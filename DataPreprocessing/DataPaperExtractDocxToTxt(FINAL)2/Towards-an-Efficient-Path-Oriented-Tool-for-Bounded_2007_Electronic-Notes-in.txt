Electronic Notes in Theoretical Computer Science 174 (2007) 57–70	
www.elsevier.com/locate/entcs

Towards an Efficient Path-Oriented Tool for Bounded Reachability Analysis of Linear Hybrid Systems using Linear Programming
Xuandong Lia,b,1 , Sumit Jha Aanandb,2 and Lei Bua,3
a State Key Laboratory of Novel Software Technology Department of Computer Science and Technology, Nanjing University
Nanjing, Jiangsu, P.R.China 210092
b Computer Science Department, Carnegie Mellon University 5000 Forbes Avenue, Pittsburgh, PA15213, USA

Abstract
The existing techniques for reachability analysis of linear hybrid automata do not scale well to problem sizes of practical interest. Instead of developing a tool to perform reachability check on all the paths of a linear hybrid automaton, a complementary approach is to develop an efficient path-oriented tool to check one path at a time where the length of the path being checked can be made very large and the size of the automaton can be made large enough to handle problems of practical interest. This approach of symbolic execution of paths can be used by design engineers to check important paths and thereby, increase the faith in the correctness of the system. Unlike simple testing, each path in our framework represents a dense set of possible trajectories of the system being analyzed. In this paper, we develop the linear programming based techniques towards an efficient path-oriented tool for the bounded reachability analysis of linear hybrid systems.
Keywords: Linear hybrid automata, bounded model checking, reachability analysis, linear programming.


Introduction
The model checking problem for hybrid systems is very difficult. Even for a relatively simple class of hybrid systems - the class of linear hybrid automata [1] - the most common problem of reachability is still undecidable [1]–[3].
Several model checking tools have been developed for linear hybrid automata, but they do not scale well to the size of practical problems. The state-of-the- art tool HYTECH [8] and its improvement PHAVer [9] need to perform expensive

1 Email: lxd@nju.edu.cn
2 Email: jha+@cs.cmu.edu
3 Email: bl@seg.nju.edu.cn

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.023

polyhedra computation, and their algorithm complexity is exponential in number of variables in the automata. In recent years, the bounded model checking has been presented as a complementary technique for BDD-based symbolic model checking, whose basic idea is to search for a counterexample in the model executions whose length is bounded by some integer k [5]. Several works [6,7] have been given to check linear hybrid systems using the bounded model checking technique. In these techniques, the model checking problems are reduced into the satisfiability problem of a boolean combination of propositional variables and mathematical constraints, but their experiment results show that the length of the checked model executions is still far from the practical problem size.
As the existing techniques cannot check all the paths for reachability analy- sis when attempting analysis of problem sizes that are of practical significance, a complementary approach is to develop an efficient path-oriented tool to check one path at a time where the length of the path being checked can be made very large and the size of the automaton can be made large enough to handle problems of practical interest. This approach of symbolic execution of paths can be used by the design engineers to check important paths and thereby, increase the faith in the correctness of the system. Unlike simple testing, each path in our framework represents a dense set of possible trajectories of the system being analyzed. In this paper, we present the linear programming based techniques towards development of an efficient path-oriented tool for the bounded reachability analysis of linear hybrid systems.
The paper is organized as follows. In next section, we define the class of linear hybrid automata considered in this paper. In section 3, we use linear programming to present our solution for the path-oriented bounded reachability analysis of linear hybrid automata. Section 4 presents some techniques to reduce the size of the linear programs corresponding to the paths that we are checking. The tool prototype and the case studies are described in section 5 . We give the conclusion in the last section.

Linear Hybrid Automata
The linear hybrid automata considered in this paper are a variation of the definition given in [1], in which the change rates of variables may be given a range of possible values. For simplicity, we suppose that in any linear hybrid automaton, considered in this paper, there is just one initial location with no initial conditions and no transitions to the initial location (we assume that each variable with an initial value is reset to the initial value by the transitions from the initial location).
Definition 2.1 A linear hybrid automaton is a tuple H = (X, V, E, vI , α, β), where
X is a finite set of real-valued variables. V is a finite set of locations.
E is transition relation whose elements are of the form (v, φ, ψ, v') where v, v' are
in V , φ is a set of variable constraints of the form a ≤ Σm cixi ≤ b, and ψ is a
set of reset actions of the form x := c where xi ∈ X (0 ≤ i ≤ m), x ∈ X, a, b, c

and ci (0 ≤ i ≤ m) are real numbers, and a and b may be ∞.
vI is an initial location.
α is a labelling function which maps each location in V − {vI } to a state invariant
which is a set of variable constraints of the form a ≤ Σm cixi ≤ b where xi ∈ X
(0 ≤ i ≤ m), a, b, and ci (0 ≤ i ≤ m) are real numbers, a and b may be ∞.
β is a labelling function which maps each location in V − {vI } toa set of change
.
rates which are of the form x= [a, b] where x ∈ X, and a, b are real numbers
(a ≤ b). For any location v, for any x ∈ X, there is one and only one change rate definition x= [a, b] ∈ β(v).	 
Notice that the class of linear hybrid automata we consider here can be used to approximate any general hybrid automata to any desired level of accuracy be- cause they are sufficiently expressive to allow asymptotically completeness of the abstraction process for a general hybrid automata [4].
We use the sequences of locations to represent the evolution of a linear hy- brid automaton from location to location. For a linear hybrid automaton H = (X, V, E, vI , α, β) , a path segment is a sequence of locations of the form

(φ1,ψ1)
v1 −→ v2
(φ2,ψ2)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn

which satisfies (vi, φi, ψi, vi+1) ∈ E for each i (1 ≤ i ≤ n − 1). A path in H is a path segment starting at vI .
The behavior of linear hybrid automata can be represented by timed sequences. Any timed sequence is of the form (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) where vi (1 ≤ i ≤ n) is a location and ti (1 ≤ i ≤ n) is a nonnegative real number. It represents a behavior of an automaton, that is, the system starts at the initial location and changes to the location v1, stays there for t1 time units, then changes to the location v2 and stays at v2 for t2 time units, and so on.
Definition 2.2 For a linear hybrid automaton H = (X, V, E, vI , α, β), a timed sequence (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) represents a behavior of H if and only if the following condition is satisfied:

there is a path in H of the form v
(φ0,ψ0)
v
(φ1,ψ1)	(φn−1,ψn−1)
...	v ;

0 −→
1 −→
−→	n

t1, t2,... , tn satisfy all the variable constraints in φi (1 ≤ i ≤ n − 1), i.e. for each variable constraint a ≤ c0x0 + c1x1 + ... + cmxm ≤ b in φi,

δk ≤ γi(xk) ≤ δ'
for any k (0 ≤ k ≤ m), and

a ≤ c0γi(x0)+ c1γi(x1)+ ... + cmγi(xm) ≤ b
where γi(xk) (0 ≤ k ≤ m) represents the value of the variable xk when the automaton stays at vi with the delay ti, and for any k (0 ≤ k ≤ m),
δk = dk + ujk +1tjk +1 + ujk +2tjk +2 + ... + uiti,

δ' = dk + u'	tj +1 + u'
tj +2 + ... + u' ti,

k	jk+1 k
jk+2 k	i
.	'

xk := dk ∈ ψjk (0 ≤ jk < i), xk := d /∈ ψl for any l (jk < l < i), and xl = [ul, ul] ∈

β(vl) for any l (jk < l ≤ i); and
t1, t2,... , tm satisfy the state invariant for each location vi (1 ≤ i ≤ n), i.e.
· for each variable constraint a ≤ c0x0 + c1x1 + ... + cmxm ≤ b in α(vi),

δk ≤ γi(xk) ≤ δ'
for any k (0 ≤ k ≤ m), and

a ≤ c0γi(x0)+ c1γi(x1)+ ... + cmγi(xm) ≤ b
where γi(xk) (0 ≤ k ≤ m) represents the value of the variable xk when the automaton stays at vi with the delay ti, and for any k (0 ≤ k ≤ m),
δk = dk + ujk+1tjk+1 + ujk+2tjk+2 + ... + uiti,
δ' = dk + u'	tj +1 + u'	tj +2 + ... + u' ti,
k	jk+1 k	jk+2 k	i
xk := dk ∈ ψjk  (0 ≤ jk < i), xk := d /∈ ψl for any l (jk < l < i), and
.	'
xl = [ul, ul] ∈ β(vl) for any l (jk < l ≤ i); and
· for each variable constraint a ≤ c0x0 + c1x1 + ... + cmxm ≤ b in α(vi+1),

δk ≤ γi(xk) ≤ δ'
for any k (0 ≤ k ≤ m), and

a ≤ c0λi(x0)+ c1λi(x1)+ ... + cmλi(xm) ≤ b
where γi(xk) (0 ≤ k ≤ m) represents the value of the variable xk when the automaton stays at vi with the delay ti, if xk := eik ∈ ψi (0 ≤ k ≤ m) then λi(xk)= eik else λi(xk)= γi(xk), and for any k (0 ≤ k ≤ m),
δk = dk + ujk+1tjk+1 + ujk+2tjk+2 + ... + uiti,
δ' = dk + u'	tj +1 + u'	tj +2 + ... + u' ti,
k	jk+1 k	jk+2 k	i
xk := dk ∈ ψjk  (0 ≤ jk < i), xk := d /∈ ψl for any l (jk < l < i), and
.	'
xl = [ul, ul] ∈ β(vl) for any l (jk < l ≤ i).	 

Path-Oriented Bounded Reachability Analysis using Linear Programming
In this section we use linear programming to present a solution for the path-oriented bounded reachability analysis of linear hybrid automata.
Path-Oriented Bounded Reachability
For a linear hybrid automaton H, a reachability specification consists of a location v in H and a set ϕ of variable constraints, denoted by R(v, ϕ). We are concerned with the problem of checking whether a path in H satisfies a given reachability specification. The formal definition is presented below.
Definition 3.1 Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, and
R(v, ϕ) be a reachability specification. A path ρ in H of the form

(φ0,ψ0)
v0 −→ v1
(φ1,ψ1)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn

satisfies R(v, ϕ) if and only if the following condition holds:
vn = v, and
there is a behavior of H of the form (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) such that any variable constraint in ϕ is satisfied when the automaton stays at vn with the delay tn, i.e. for each variable constraint a ≤ c0x0 + c1x1 + ... + cmxm ≤ b in ϕ,


δk ≤ γn(xk) ≤ δ'
for any k (0 ≤ k ≤ m), and

a ≤ c0γn(x0)+ c1γn(x1)+ ... + cmγn(xm) ≤ b
where γn(xk) (0 ≤ k ≤ m) represents the value of the variable xk when the automaton stays at vn with the delay tn, and for any k (0 ≤ k ≤ m),
δk = dk + uik +1tik +1 + uik +2tik +2 + ... + untn ,
δ' = dk + u'	ti +1 + u'	ti +2 + ... + u' tn ,
k	ik+1 k	ik+2 k	n
xk := dk ∈ ψik  (0 ≤ ik < n), xk := d /∈ ψj for any j (ik < j < n), and
.	'
xj = [uj, uj ] ∈ β(vj) for any j (ik < j ≤ n).	 


Representation of a long path
Since our tool is designed to check a path which is as long as desired and can handle linear hybrid automata of practical problem size, we first need to represent such a long path.
For a linear hybrid automaton H = (X, V, E, vI , α, β), we can represent a path segment ρ in H of the form

(φ0,ψ0)
v0 −→ v1
(φ1,ψ1)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn

by a simple form v0ˆv1ˆ ... ˆvn, which is called simple regular expression. A simple regular expression (SRE) R and the path segment L(R) it represents are defined recursively as follows:
if v ∈ V , then v is a SRE, and L(v)= v;
if R1 and R2 are SREs and there is a transition in E from the last location in
L(R1) to the first location in L(R2) , then R1ˆR2 is a SRE, and
(φ,ψ)
L(R1ˆR2)= L(R1) −→ L(R2); 
if R is a SRE and there is a transition in E from the last location in L(R) to the first location in L(R), then Rk is a SRE where k ≥ 2 is an integer, and

L(Rk)= L(R) (φ,ψ)
(φ,ψ)	(φ,ψ)
(R)	... 
(R) .

`	˛k¸	x
Using the above definition, we can represent a long path to be checked as a SRE, and the SREs can be used as a text language for the input of the tool.

Reducing the Bounded Reachability Problems into Linear Programs
Now we show how the problem of checking a path for a given reachability specifi- cation can be reduced to a linear program.
Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ) be a reacha- bility specification, and ρ be a path in H of the form

(φ0,ψ0)
v0 −→ v1
(φ1,ψ1)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn

where vn = v. For any timed sequence of the form (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn), if it is such that ρ satisfies R(v, ϕ), then the following condition must hold:
t1, t2,... , tn satisfy all the variable constraints in φi(0 ≤ i ≤ n),
t1, t2,... , tn satisfy all the variable constraints in α(vi) (1 ≤ i ≤ n), and
t1, t2,... , tn satisfy all the variable constraints in ϕ,
which form a group of linear inequalities on t1, t2,... , tn (see Definition 2.2 and 3.1), denoted by Θ(ρ, R(v, ϕ)). It follows that we can check if ρ satisfies R(v, ϕ) by checking if the group Θ(ρ, R(v, ϕ)) of linear inequalities has a solution, which can be solved by linear programming.
In addition to t1, t2,... , tn, each γi(xk) in Definition 2.2 and 3.1 also becomes a variable in the linear program corresponding to checking of a path. Notice that
.	'
if the change rate of xk is a constant (xk = [a, a]), then δk = δk in Definition 2.2
and 3.1 such that we can replace γi(xk) with δk. Thus, for a path checking, the numbers of the variables and the constraints in the corresponding linear program can be calculated as follows:
we have one variable in the linear program for each location in the path,
we have at most one variable in the linear program for each variable occurrence in a variable constraint labelled on a transition, in a location invariant, and in the reachability specification,
for each variable occurrence in a variable constraint labelled on a transition, in a location invariant, and in the reachability specification, we have at most one constraint in the linear program,
for each variable constraint labelled on a transition, we have one constraint in the linear program,
for each variable constraint in a location invariant, we have two constraints in the linear program, and
for each variable constraint in the reachability specification, we have one con- straint in the linear program.
Thanks to the advances in computing during the past decade, linear programs in a few thousand variables and constraints are nowadays viewed as“small”. Problems having tens or hundreds of thousands of continuous variables are regularly solved. Indeed, many software packages have been developed to efficiently find solutions for linear programs. Leveraging the research in efficient solution of linear programs, we can develop an efficient tool to check a path in a linear hybrid automaton, where

the length of the path and the size of the linear hybrid automaton are both closer to the practical problem sizes.

Reducing Size of Linear Programs Corresponding to Path Checking
We have reduced the bounded reachability analysis for a given path into a linear programming problem. In this section, we present several techniques for reducing the size of the resulting linear programming problem so that our tool can be used to solve problems of size as large as possible.

Decomposing Linear Programs Corresponding to Path Checking
In some cases, we can decompose the linear program corresponding to the path being checked into several smaller linear programs so that the tool can check longer paths.
Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ) be a reacha- bility specification, and ρ be a path in H of the form

(φ0,ψ0)
v0 −→ v1
(φ1,ψ1)
−→ ... 
(φi−1 ,ψi−1)
−→	vi
(φi,ψi)
−→ vi+1
(φi+1,ψi+1)
−→	... 
(φn−1 ,ψn−1)
−→	vn

where vn = v. If there is i (0 < i < n) such that
for any variable x occurring in a variable constraint in φj (i < j < n), x is reset on a transition (vk, φk, ψk, vk+1) (i ≤ k < j), i.e. x := a ∈ ψk,
for any variable x occurring in a variable constraint in α(vj) (i < j ≤ n), x is reset on a transition (vk, φk, ψk, vk+1) (i ≤ k < j), i.e. x := a ∈ ψk, and
for any variable x occurring in a variable constraint in ϕ, x is reset on a transition (vk, φk, ψk, vk+1) (i ≤ k < n), i.e. x := a ∈ ψk,
then the linear program corresponding to checking ρ for R(v, ϕ) can be decomposed.
In this case, there is a timed sequence of the form
(v1, t1)ˆ(v2, t2)ˆ ... ˆ(vi, ti)ˆ(vi+1, ti+1)ˆ(vi+2, ti+2)ˆ ... (vn, tn) such that ρ satisfies R(v, ϕ) if and only if the following condition holds:
t1, t2,... , ti satisfy all variable constraints in φk (1 ≤ k ≤ i), and all variable
constraints in α(vk) (1 ≤ k ≤ i), and
ti+1, ti+2,... , tn satisfy all variable constraints in φk (i < k ≤ n), all variable constraints in α(vk) (i < k ≤ n), and all variable constraints in ϕ,
which correspond to two separate linear programs according to Definition 2.2 and
3.1. Thus, in this case we can decompose the linear program corresponding to a path checking into two smaller linear programs. The resulting linear programs can be recursively decomposed by the same technique until the technique can no longer be applied.

Shortening Paths
For a path segment ρ in a linear hybrid automaton, its length |ρ| is the number of the locations in ρ. Since the size of the linear program corresponding to the path being checked is proportional to the length of the path, shortening the path will improve the complexity of the overall method. By shortening a path, we mean to find a shorter path in lieu of the path being checked such that both of them are equivalent with respect to the given reachability specification - if one of them satisfies the reachability specification, so does the other.
For a linear hybrid automaton H = (X, V, E, vI , α, β), a long path ρ in H, which we want to check, usually includes repetitions of path segments, which can be represented as the following form:

(φ0,ψ0)
(φi−1 ,ψi−1 )
(φi,ψi)  k (φ,ψ)
(φi+1 ,ψi+1)
(φn−1 ,ψn−1)

ρ = v0
−→ ... 
−→	vi
−→ ρ1 −→ vi+1
−→	... 
−→	vn

where ρ1 is a path segment in H, k ≥ 2 is an integer, and ρk represents the path

segment

(φ',ψ')	(φ',ψ')	(φ',ψ')

ρ1 −→ ρ1 −→ ... −→ ρ1 .
`	˛¸	x
In the following, we show that in some cases we can find k' < k such that ρ satisfies a given reachability specification if and only if ρ' satisfies the reachability specification where ρ' is of the form

ρ' = v
(φ0,ψ0)
(φi−1 ,ψi−1)
(φi,ψi)  k' (φ,ψ)
(φi+1 ,ψi+1)
(φn−1 ,ψn−1 )

0 −→ ... 
−→	vi
−→ ρ1
−→ vi+1
−→	... 
−→	vn .

Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ) be a reacha- bility specification, and ρ be a path in H of the form

(φ0,ψ0)
v0 −→ v1
(φ1,ψ1)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn

where vn = v. We say that a variable constraint is related to a location vi (0 ≤ i ≤ n) if it is in φi, α(vi), or in ϕ when i = n. We define the reference point for a variable in a variable constraint related to a location in ρ as follows:
for a variable x in a variable constraint related to a location vi (0 ≤ i ≤ n), a location vj (0 ≤ j < i) is the reference point if x is reset on the tran- sition (vj, φj, ψj, vj+1) (x := a ∈ ψj), and is not reset on any transition (vk, φk, ψk, vk+1) (j < k < i) (x := b /∈ ψk) (in this case, we say that a is the reference value of x on vi).
Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ) be a reacha-
'  '
(φ,ψ)  k (φ ,ψ )  '
bility specification, and ρ be a path in H of the form ρ = ρ1 −→ ρ2 −→ ρ1 where
k > 3, ρ1 is a path, and ρ' , ρ2 are path segments. We say that ρk is closed in ρ if
1	2
the following condition holds:

k	(φ'',ψ'')  k−2 (φ'',ψ'')  '
(φ'',ψ'')  '	'

ρ2 = ρ21 −→  ρ3
−→ ρ21 where ρ2 = ρ21
−→  ρ21 and |ρ21| ≤ |ρ21|, and

ρ3
= v1
(φ1,ψ1)
−→ v2
(φ2,ψ2)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn, and for any x occurring in a variable

constraints in φi or α(ui) (1 ≤ i ≤ n), x := a ∈ ψ'' or x := a ∈ ψj (1 ≤ j < i).

Theorem 4.1 Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ)
'  '
(φ,ψ)  k (φ ,ψ )  '
be a reachability specification, and ρ = ρ1 −→ ρ2  −→ ρ1 be a path in H where
ρk (k > 3) is closed in ρ. If any location in ρ1 is not the reference point for any
variable in a variable constraint related to a location in ρ' , then ρ satisfies R(v, ϕ)

'	'	(φ,ψ)
(φ',ψ') '

if and only if ρ
satisfies R(v, ϕ) where ρ = ρ1 −→ ρ3
−→ ρ1.

Proof. Suppose that ρk = ρ
(φ'',ψ'') k−2 (φ'',ψ'') '

2	21
−→ ρ3
−→  ρ21, and

ρ3 = v1
(φ1,ψ1)
−→ v2
(φ2,ψ2)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn .

'' (φ'',ψ'')
k−2 (φ'',ψ'')

'''
'	'' (φ'',ψ'')
(φ'',ψ'')

'''

It follows that ρ = ρ1  −→  ρ3	−→  ρ1 , and ρ = ρ1  −→  ρ3  −→  ρ1 . The
half of the claim, if ρ satisfies R(v, ϕ) then ρ' satisfies R(v, ϕ), can be proved as
follows. Since ρ satisfies R(v, ϕ), suppose that the corresponding timed sequence
σ = σ''ˆσrˆσ''' satisfies the condition given in Definition 3.1 where σr corresponds to
1	1
ρk−2. It follows that σr = σr1ˆσr2ˆ ... ˆσrk−2, and that each σri (1 ≤ i ≤ k − 2) is of the form (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) such that t1, t2,... , tn satisfies the condition in Definition 2.2. Since ρk is closed in ρ and any location in ρ1 is not the reference point for any variable in a variable constraint related to a location in ρ' , by removing σr2ˆσr3ˆ ... ˆσrk−2 from σ we get a timed sequence σ' which satisfies the condition in Definition 3.1 and corresponds ρ'. It follows that ρ' satisfies R(v, ϕ). The other half of the claim can be proved as follows. Since ρ' satisfies R(v, ϕ), suppose that
the corresponding timed sequence σ' = σ''ˆσ3ˆσ''' satisfies the condition given in
1	1
Definition 3.1 where σ3 corresponds to ρ3. Since ρk is closed in ρ and any location
in ρ1 is not the reference point for any variable in a variable constraint related to a location in ρ' , by replacing σ3 with σ3ˆσ3ˆ ... ˆσ3 in σ' we get a timed sequence σ
`	k˛−¸2	x
which satisfies the condition in Definition 3.1 and corresponds ρ. It follows that ρ
satisfies R(v, ϕ).	 
Let H = (X, V, E, vI , α, β), and ρ be a path in H of the form

(φ0,ψ0)
v0 −→ ... 
(φi−1 ,ψi−1)
−→	vi
(φi,ψi)
−→ ... 
(φj−1 ,ψj−1)
−→	vj
(φj ,ψj)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn .

m k=0
if the following condition holds:
ckxk ≤ b related to vj (1 ≤ j ≤ n) is positive in ρ

ck ≥ 0 for any k (0 ≤ k ≤ m), and
for any xk (0 ≤ x ≤ m), if the reference point is vi, then any vl (i < l ≤ j) is
.
such that if xk= [a, b] ∈ β(vl) then a ≥ 0,
and we say that b − Σk	ckdk is the bound of the variable constraint where dk
(0 ≤ k ≤ m) is the reference value of xk on vj.
Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ) be a reach-
'  '
(φ,ψ)	k  (φ ,ψ )	'

ability specification, and ρ = ρ1
−→  ρ2	−→	ρ1 be a path in H where

k	(φ'',ψ'')  k−2 (φ'',ψ'')  '
ρ2 = ρ21 −→  ρ3	−→  ρ21 (k > 3) is closed in ρ, and

ρ3 = v1
(φ1,ψ1)
−→ v2
(φ2,ψ2)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn .

If there is a positive variable constraint a ≤ Σm
cixi ≤ b related to a location in

' such that
there is a variable set ω ⊆ {x0, x1,... , xm} (ω /= ∅) such that for any x ∈ ω, its reference point is in ρ1, and
ξ > 0 where ξ is the infimum of the set
⎧⎪	if xi ∈ ω then c' = ci else c' =0 for any i (0 ≤ i ≤ m);	⎫⎪
i	i
⎪	⎪

⎪⎨ m
for any i (0 ≤ i ≤ m), δi = ui1t1 + ui2t2 + ... + uintn
⎬

Σ c' δi
'	∈ β(v ) for any j (1 ≤ j ≤ n); and

i
i=0
⎪
where xi= [uij, uij ]	j
⎪

(v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) is a timed sequence such that
⎪	⎪
⎪⎩	t1, t2,... , tn satisfy the condition in Definition 2.	⎪⎭
(notice that ξ can be calculated by linear programming),
then we say that pk is constrained by [ζ/ξ♩ +3 where ζ is the bound of the variable
constraint a ≤ Σm  cixi ≤ b.
Theorem 4.2 Let H = (X, V, E, vI , α, β) be a linear hybrid automaton, R(v, ϕ)
'  '
(φ,ψ)  k (φ ,ψ )  '
be a reachability specification, and ρ = ρ1 −→ ρ2  −→ ρ1 be a path in H where
ρk (k > 3) is closed in ρ, and constrained by k'. If k > k' then ρ does not satisfy
R(v, ϕ).

Proof. Suppose that ρk = ρ
(φ'',ψ'') k−2 (φ'',ψ'') '

2	21
−→ ρ3
−→  ρ21, and

ρ3 = v1
(φ1,ψ1)
−→ v2
(φ2,ψ2)
−→ ... 
(φn−1 ,ψn−1 )
−→	vn .

'' (φ'',ψ'') k−2 (φ'',ψ'')

'''

It follows that ρ = ρ1  −→  ρ3	−→  ρ1 . Suppose that ρ satisfies R(v, ϕ), and

the corresponding timed sequence σ = σ''ˆσrˆσ'''
satisfies the condition given in

1	1
Definition 3.1 where σr corresponds to ρk−2. It follows that
σr = σr1ˆσr2ˆ ... ˆσrk−2
where each σri (1 ≤ i ≤ k − 2) is of the form (v1, t1)ˆ(v2, t2)ˆ ... ˆ(vn, tn) such that

t1, t2,... , tn satisfies the condition in Definition 2.2. Since ρk
is closed in ρ and

constrained by k', if k > k' then there is a positive variable constraint related to a

location in ρ'
which is not satisfied, which results in a contradiction and hence, the

claim holds.	 
This theorem tells us that in some cases we just need to focus a shorter path since extending the path by repeating a path segment in it will result in that the given reachability specification is not satisfied.

Tool Prototype and Case Studies
Based on the techniques presented in this paper, we have implemented a tool pro- totype for the bounded reachability analysis of linear hybrid automata. The tool is



,  , 
, θ = 15 , 

y := 1
v1
y ≤ 10
e1 y = 10?
v2
x ≤ 2
x1 := 6
x2 := 6
v1
θ =6 
 e1 x1 ≥ 6 )
v2
θ = −4

v0◯
)		)
v0◯
) x˙1 =1 
x˙1 =1 

e0	x˙ =1 
x := 0
x˙ =1 
e0	x˙2 =1 (e2 θ =3 
x˙2 =1 

y˙ =1 
y˙ =1 
θ ≤ 15
x := 0
θ ≥ 3

 J  J
 ˆ J1	 J

ˆ
x = 2?  e4

e2 x = 2?
e3
θ = 15
e4	  e5
θ = 3  x1 < 6 ∧ x2 < 6

x2 ≥ 6
v
x2 := 0  θ = 15
 

,  ,  ,v	, 

v4 x ≤ 2
e3 y = 5?
v3 y ≥ 5
v3	v4
θ = −3

y˙ = −2
x˙ =1 
(	
x := 0
y˙ = −2
x˙ =1 
x˙1 =1 
x˙2 =1 
θ ≥ 3
shutdown

 J
(1)
 J  J	 J
(2)

Fig. 1. The automata modelling water-level monitor and temperature control system
implemented in Java, and its graphical interface allows the users to construct, edit, and analyze linear hybrid automata interactively. The linear programming soft- ware package which is integrated in the tool is from OR-Objects of DRA Systems
[11] which is a free collection of Java classes for developing operations research, scientific and engineering applications. On a HP workstation (Intel Xeon CPU 2.8GHz×2/3.78GB), we evaluated the potential of the techniques presented in this paper by several case studies.
One example depicted in Figure 1(1) is the water-level monitor in [2]. Along the path v0ˆ(v1ˆv2ˆv3ˆv4)k, we check if the location v4 is reachable, and get the positive answers from the tool with
k = 100, 200, 230, 400, 450, 500, 10000
respectively. Table 1 shows the tool performance when using the original technique (without any optimization), the optimization technique of decomposing linear pro- grams, and the optimization techniques of shortening paths respectively. When k ≥ 500, without one of the optimization techniques the tool cannot give a result because of the “Java.lang.out of memory” error occurring in the linear program- ming package integrated in the tool. Actually, with the optimization technique of shortening paths (see Theorem 4.1), for this example the tool can give a result for any k.
Another example depicted in Figure 1(2) is the temperature control system in [2]. Along the paths
v0ˆ(v1ˆv2ˆv1ˆv3)kˆv1ˆv4  and  v0ˆ(v1ˆv2)k1 ˆ(v1ˆv3)k2 ˆv1ˆv4 ,
we check if a complete shutdown is required (the location 4 is reachable), and get the negative answers with the various values of k, k1, and k2. The tool performance is shown in Table 2. For the path v0ˆ(v1ˆv2ˆv1ˆv3)kˆv1ˆv4, no optimization technique works, and the tool cannot give a result when k ≥ 450 because of the “Java.lang.out of memory” error occurring in the linear programming package integrated in the tool. For the path v0ˆ(v1ˆv2)k1 ˆ(v1ˆv3)k2 ˆv1ˆv4, the condition of Theorem 4.2 holds so that the optimization technique of shortening paths works.


Table 1
Experimental results on the water-level monitor
Table 2
Experimental results on the temperature control system

Table 3
Experimental results on the experimental automaton

We also compare our technique with PHAVer [9] which is the improvement of the state-of-the-art tool HYTECH [8]. Because of performing expensive poly- hedra computation, the capacity of PHAVer is restricted by the variable num- ber in the automata. We simply construct an experimental automaton depicted in Figure 2 in which there are seven locations and variables. Along the path v0ˆ(v1ˆv2ˆv3ˆv4)kˆv5ˆv6, we check if the location v6 is reachable by PHAVer and our tool respectively. Because PHAVer does not provide any timer, we manually record its execution time. The experimental result is shown in Table 3. When k is set to 20 and 30, PHAVer spends about 0.66 and 4 hours respectively for checking, which are much longer than the execution time of our tool with the original technique.

PHAVer can not give any result when k = 40 after running for 20 hours, but even when k = 150 our tool can give the result in a tolerable duration. Notice that for fairness, we use the unfolded path as the input of PHAVer for avoiding it doing the full reachability analysis. Because of performing expensive polyhedra computation, the algorithm complexity of PHAVer is exponential in the number of variables of an automaton, which gives an intuitional explanation for the experiment result.
The above experiments are preliminary and use freely available linear program- ming packages, but they indicate a clear potential of the techniques presented in this paper with the support of an advanced commercial linear programming package.
,	,
v1	v2

v0◯ )
x1 := 15
x2 := 6
x3 := 6
x4 := 0
x5 := 0
x6 := 0
x7 := 0
x˙1 =6 
x˙2 = [0, 2]
x˙3 = [0, 2]
x˙4 = [0, 4]
x˙5 = [0, 1]
x˙6 = [0, 20]
x˙7 = [−10, 0]
x1 ≤ 15

	J
x˙1 = −4
x˙2 = [0, 2]
x˙3 = [0, 2]
x˙4 = [0, 20]
x˙5 = [0, 20]
x˙6 = [0, 10]
x˙7 = [−20, 0]
x1 ≤ 3
3x5 − x4 − x7 ≥ 0
x6 − x7 − 3x5 ≥ 0
	J

e4 ˆx1 =3 ∧ x4 − x5 − x6 + 0.1x7 ≥ 0
,	x3 := 0
v4
e2 x1 =3 
,	vx3 := 0
v3

x˙1 = −3
x˙2 = [0, 2]
x˙3 = [0, 2]
x˙4 = [0, 12]
x˙5 = [0, 12]
x˙6 = [0, 12]
x˙7 = [−20, 0]
x1 ≥ 3
x7 + 10x6 − 10x5 ≥ 0
  4x5 − x4 ≤ 4	J
x1 =3 ∧ x4 − x5 − x6 + 0.1x7 ≥ 0
e5 x3 := 0
x˙1 =6 
x˙2 = [0, 2]
x˙3 = [0, 2]
x˙4 = [0, 8]
x˙5 = [0, 2]
x˙6 = [0, 4]
x˙7 = [−20, 0], x1 ≤ 15 x4 − 3x5 + 0.1x7 ≤ 0 x6 − 0.1x7 − 3x5 ≥ 0
  4x5 − x4 ≤ 4	J

,	v	,		 
v5	v6

x˙1 =6 
x˙2 = [0, 2]
x˙3 = [0, 2]
x˙4 = [0, 16]
x˙5 = [0, 4]
x˙6 = [0, 8]
x˙7 = [−20, 0], x1 ≥ 15
3x5 − x7 − x4 ≥ 0
x6 − x7 − x4 ≥ 0
  4x5 − x4 ≤ 4	J
x˙1 = 1, x˙2 = [0, 2]
x˙3 = [0, 2], x˙4 = [0, 4]
x˙5 = [0, 1], x˙6 = [0, 2]
x˙7 = [−10, 0], x1 ≥ 15
x4 − x5 ≥ 0
x5 − x2 ≥ 0
x4 + x6 − x5 + 0.1x7 ≥ 0 x6 + 0.1x7 − x2 − x3 ≥ 0 x6 + x5 − x4 ≤ 0
0.1x7 + x5 ≥ 0
  		J

Fig. 2. An experimental automaton

Conclusion
In this paper, based on linear programming we develop the techniques towards an efficient path-oriented tool for the bounded reachability analysis of linear hybrid au-

tomata, which checks one path at a time where the length of the path being checked can be made very large and the size of the automaton can be made large enough to handle problems of practical interest. Since the existing techniques have not resulted in an efficient tool for checking all the paths in a linear hybrid automaton for problems with sizes of practical interest, the tool derived from the techniques presented in this paper will become a design engineer’s assistant for the reachability analysis of linear hybrid automata.

Acknowledgement
We would like to thank Professor Edmund M. Clarke and the anonymous re- viewers for their valuable comments and suggestions. The first and third authors are supported by the National Natural Science Foundation of China (No.60425204, No.60233020), the National Grand Fundamental Research 973 Pro- gram of China (No.2002CB312001), and by the Jiangsu Province Research Founda- tion (No.BK2004080). The second author acknowledges the support of a graduate fellowship from the Computer Science Department at Carnegie Mellon.

References
Thomas A. Henzinger. The theory of hybrid automata. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (LICS 1996), pp. 278-292.
R. Alur, C. Courcoubetis, N. Halbwachs, T.A. Henzinger, P.-H.Ho, X. Nicollin, A. Olivero, J. Sifakis,
S. Yovine. The algorithmic analysis of hybrid systems. In Theoretical Computer Science, 138(1995), pp.3-34.
Thomas A. Henzinger, Peter W. Kopke, Anuj Puri, and Pravin Varaiya. What’s Decidable About Hybrid Automata? In Journal of Computer and System Sciences, 57:94-124, 1998.
Thomas A. Henzinger, Pei-Hsin Ho, Howard Wong-Toi. Algorithmic Analysis of Nonlinear Hybrid Systems.In IEEE Transactions on Automatic Control, 1998, pp.540-554.
Armin Biere, Alessandro Cimatti, Edmund M. Clarke, Ofer Strichman, Yunshan Zhu. Bounded Model Checking. In Advance in Computers, Vol.58, Academic Press, 2003.
Martin Franzle, Christian Herde. Eifficient Proof Engines for Bounded Model Checking of Hybrid Systems. In Electronic Notes in Theoretical Computer Science, Vol.89, No.4, 2004.
Gilles Audemard, Marco Bozzano, Alessandro Cimatti, Roberto Sebastiani. Verifying Industrial Hybrid Systems with MathSAT. In Electronic Notes in Theoretical Computer Science, Vol.89, No.4, 2004.
T.A. Henzinger, P.-H. Ho, and H. Wong-Toi. HYTECH: a model checker for hybrid systems. In Software Tools for Technology Transfer, 1:110-122, 1997.
Goran Frehse. PHAVer: Algorithmic Verification of Hybrid Systems past HyTech. In Manfred Morari and Lothar Thiele, editors, Hybrid Systems: Computation and Control (HSCC’05), Lecture Notes in Computer Science 2289, Springer-Verlag, 2005, pp.258-273.
Li Xuandong, Zhao Jianhua, Pei Yu, Li Yong, Zheng Tao, and Zheng Guoliang. Positive Loop-Closed Automata: A Decidable Class of Hybrid Systems. In Journal of Logic and Algebraic Programming, Vol.52-53(C), Elsevier Science, 2002, pp.79-108.
OR-Objects of DRA Systems. http://OpsResearch.com/OR-Objects/index.html .
