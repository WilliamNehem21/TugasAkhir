

Electronic Notes in Theoretical Computer Science 250 (2009) 85–102
www.elsevier.com/locate/entcs
Light-Weight SMT-based Model Checking
Silvio Ghilardi1
Dip. di Scienze dell’Informazione, Univ. di Milano (Italia)
Silvio Ranise2
Dip. di Informatica, Univ. di Verona (Italia)
Thomas Valsecchi3
Dip. di Scienze dell’Informazione, Univ. di Milano (Italia)

Abstract
Recently, the notion of an array-based system has been introduced as an abstraction of infinite state sys- tems (such as mutual exclusion protocols or sorting programs) which allows for model checking of invariant (safety) and recurrence (liveness) properties by Satisfiability Modulo Theories (SMT) techniques. Unfortu- nately, the use of quantified first-order formulae to describe sets of states makes fix-point checking extremely
expensive. In this paper, we show how invariant properties for a sub-class of array-based systems can be model-checked by a backward reachability algorithm where the length of quantifier prefixes is efficiently controlled by suitable heuristics. We also present various refinements of the reachability algorithm that allows it to be easily implemented in a client-server architecture, where a “light-weight” algorithm is the client generating proof obligations for safety and fix-point checks and an SMT solver plays the role of the server discharging the proof obligations. We also report on some encouraging preliminary experiments with a prototype implementation of our approach.
Keywords: Model Checking of Infinite State Systems, Satisfiability Modulo Theories, Safety


Introduction
An integration of Satisfiability Modulo Theories (SMT) solving in a backward reach- ability algorithm has been proposed in [22] for the model checking of invariant (safety) properties of a large class of infinite state systems—called, array-based sys- tems. Roughly, an array-based system is a transition system which updates one (or more) array variable a. Being parametric in the structures associated to the

1 Email: ghilardi@dsi.unimi.it
2 Email: silvio.ranise@univr.it
3 Email: thomas.valsecchi@gmail.com

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.019

indexes and the elements in a, the notion of array-based system is quite flexible and allows one to specify a large of class of infinite state systems. For example, consider parametrised systems and the task of specifying their topology: by using no struc- ture at all, indexes are simply identifiers of processes that can only be compared for equality; by using a linear order, indexes are identifiers of processes so that it is possible to distinguish between those on the left or on the right of a process with a particular identifier; by using richer and richer structures (such as trees and graphs), it is possible to specify more and more complex topologies. Similar observations hold also for elements, where it is well-known how to use algebraic structures to specify data structures. Formally, the structure on both indexes and elements is declaratively and uniformly specified by theories, i.e. pairs formed by a (first-order) language and a class of (first-order) structures.
In this framework, invariant properties of array-based systems can be verified by using a symbolic version of a backward search algorithm which repeatedly computes the pre-image of the set of states from which it is possible to reach the set of unsafe states, i.e. the states violating the desired invariant property. The algorithm halts in two cases, either when the current set of (backward) reachable states has a non-empty intersection with the set of initial states and the system is unsafe, or when such a set has reached a fix-point (i.e. further application of the transition does not enlarge the set of reachable states) and the system is safe. To mechanize this approach, the following three requirements are mandatory: (i) the class F of (possibly quantified) first-order formulae is expressive enough to represent sets of states and invariants, (ii) F is closed under pre-image computation, and (iii) the checks for safety and fix-point can be reduced to decidable logical problems (e.g., satisfiability) of formulae in F. Once requirements (i)—(iii) are satisfied, this technique can be seen as a symbolic version of the model checking techniques of [8] revisited in the declarative framework of first-order logic augmented with theories [22]. Using this declarative framework has several potential advantages; two of the most important ones are the following. First, the computation of the pre-image (cf. requirement (ii) above) becomes computationally cheap: we only need to build the formula φ representing the (iterated) pre-images of the set of unsafe states and then put the burden of using suitable data structures to represent φ on the available (efficient) solver for logical problems encoding safety and fix-point checks. This is in sharp contrast to what is usually done in almost all other approaches to symbolic model checking of infinite state systems, where the computation of the pre-image is computationally very expensive as it requires a substantial process of normalization on the data structure representing the (infinite) sets of states so as to simplify safety and fix-point checks.
The second advantage is the possibility to use state-of-the-art SMT solvers, a technology that is showing very good success in scaling up various verification tech- niques, to support both safety and fix-point checks (cf. requirement (iii) above). Unfortunately, the kind of satisfiability problems obtained in the context of the backward search algorithm requires to cope with (universal) quantifiers and this makes the off-the-shelf use of SMT solvers problematic. In fact, even when using

classes of formulae with decidable satisfiability problem, currently available SMT solvers are not yet mature enough to efficiently discharge formulae containing (uni- versal) quantifiers, despite the fact that this problem has recently attracted a lot of efforts (see, e.g., [17,21,15]). To alleviate this problem, we have designed a general decision procedure for a class of formulae satisfying requirement (i) above, based on quantifier instantiation (see [22] and Theorem 3.4 below); this allows for an easier way to integrate currently available SMT-solvers in the backward search algorithm. Unfortunately, the number of instances required by the instantiation algorithm is still very large and preliminary experiments have shown unacceptable performances. This fact together with the observation that the size of the formulae generated by the backward search algorithm grows very quickly demand a principled approach to the pragmatics of efficiently integrating SMT solvers in the backward search algorithm. In this respect, the paper makes two important contributions.
We focus on a sub-class of the (quantified) formulae in [22] (Section 3) to model a smaller but still significant class of systems analogous to the well-known guarded assignment systems (see, e.g., [29]). Our ﬁrst contribution (Section 4.1) is to find sufficient conditions under which, it is correct to reduce (and sometimes also to eliminate) the quantifiers in the formulae representing (iterated) pre-images. The second contribution (Section 4.2) is a discussion about how to adapt implementation techniques, known in the field of symbolic model checking, to the backward search algorithm so that a client-server architecture can be used, where a “light-weight” client (i.e. a program with few lines of code) generates proofs obligation for fix-point and safety checks for an SMT solver, the server. Preliminary experiments seem to confirm the viability and scalability of the approach. (For lack of space, technical details are in the extended version [23].)

Preliminaries
We assume the usual syntactic (e.g., signature, variable, term, atom, literal, and formula) and semantic (e.g., structure, sub-structure, truth, satisfiability, and va- lidity) notions of first-order logic (see, e.g., [20]). The equality symbol = is included in all signatures considered below. A signature is relational if it does not contain function symbols and it is quasi-relational if its function symbols are all (individual) constants. An expression is a term, an atom, a literal, or a formula. Let x be a finite tuple of variables and Σ a signature, a Σ(x)-expression is an expression built out of the symbols in Σ where at most the variables in x may occur free (we will write E(x) to emphasize that E is a Σ(x)-expression).

Satisfiability Modulo Theory.
According to the current practice in the SMT literature [25], a theory T is a pair (Σ, C), where Σ is a signature and C is a class of Σ-structures; the structures in C are the models of T . Below, we let T = (Σ, C). 4 A Σ-formula φ is T-satisﬁable

4 An important class of theories, ubiquitously used in verification, formalizes enumerated data types. An
enumerated data-type theory T is a theory in a quasi-relational signature whose class of models contains

if there exists a Σ-structure M in C such that φ is true in M under a suitable assignment to the free variables of φ (in symbols, M |= φ); it is T-valid (in symbols, T |= ϕ) if its negation is T -unsatisfiable. Two formulae ϕ1 and ϕ2 are T-equivalent if ϕ1 ↔ ϕ2 is T-valid. The satisﬁability modulo the theory T (SMT (T )) problem amounts to establishing the T -satisfiability of quantifier-free (i.e. not containing quantifiers) Σ-formulae. A theory solver for T (T -solver) is any procedure capable of establishing whether any given finite conjunction of Σ-literals is T -satisfiable or not. The lazy approach to solve SMT (T ) problems consists of integrating a DPLL Boolean enumerator with a T -solver (see, e.g., [30] for details).

Definitional extension of a theory.
Below, for technical reasons, it will be useful to extend theories with functions in a constrained way. A (quantifier-free) T-deﬁnable function is a quantifier-free formula φ(x, y) such that
T |= ∀x∃y φ(x, y)	and	T |= ∀x∀y1∀y2 (φ(x, y1) ∧ φ(x, y2) → y1 = y2).
A deﬁnable extension T ' = (Σ', C') of a theory T = (Σ, C) is obtained from T by applying—finitely many times—the following procedure: (i) consider a T -definable function φ(x, y); (ii) let Σ' := Σ ∪ {F}, where F is a “fresh” function symbol (i.e. F /∈ Σ) whose arity is equal to the length of x; (iii) take as C' the class of Σ'-structures M whose Σ-reduct is a model of T and such that
M |= ∀x∀y (F (x) = y ↔ φ(x, y)).
Indeed, the SMT (T ') problem for such a T ' can be solved by replacing the new function symbols with fresh constants, adding their definitions as conjuncts to the formula to be tested for satisfiability, and invoking a solver for SMT (T ).
In the following, we adopt a many-sorted version of first-order logic. All notions introduced above can be easily adapted to this setting (see again [20]).
Model-Checking of Array-based Systems
We consider the formalism of guarded assignment array-based systems, a restricted version of that defined in [22]. We focus on parametrised systems, i.e. systems con- sisting of an arbitrary (but finite) number of identical processes, since a large number of such systems can be expressed in this formalism. There exist two kinds of guards, expressing existential or universal global conditions, on the state of a parametrized system. As we will see, while existential conditions can be directly expressed in our formalism, universal conditions require us to model parametrized systems following the so-called stopping failures model for distributed algorithms [24], which is quite close to the approximate model of [9,10]. The key property of a parametrized system modelled according to the stopping failures model is that processes may fail without

only a single finite Σ-structure M = (M, I) such that for every m ∈ M there exists a constant c ∈ Σ
such that cI = m. Below, we use enumerated data-type theories to model control locations of processes in parametrized systems.

warning at any time. To formalize this, assume that a process in a parametrised system has a finite set Q = {q1, ..., qn} of control locations plus other local data variables. Then, consider an extended set Q' = Q ∪ {qcrash}, where qcrash /∈ Q, and augment the set of transitions of each process as follows: it is always possible to go from state qi to qcrash , for each i = 1, ..., n. An example of universal global condi- tion is a guard saying that a process i can execute a transition if a certain condition C is satisfied by all processes j /= i. In the stopping failures model, this can be expressed without the universal quantification as follows: the process i takes the transition without checking the global condition C and, concurrently, all processes j /= i not satisfying the condition C move to the state qcrash ; moreover, all processes j /= i satisfying C behave as originally prescribed. The stopping failures model of the system satisfies a sub-set of the class of safety (or even recurrence) properties satisfied by the original system (since the latter has fewer runs), hence establishing a safety property for the stopping failures model implies that the same property is enjoyed by the original system.
Example 3.1 Consider the simplified variant of the Bakery algorithm of [10], where a finite (but unknown) number of processes should be granted mutual exclusion to a critical section by using tickets. Processes are arranged in an array whose indexes are linearly ordered and each process can be in one of three control locations: idle, wait, critical. At the beginning, all processes are idle. There are three possible transitions involving a single process with index z (in all transitions, the processes with index different from z remain in the same location): (τo) z is in idle, all the processes to its left are idle, and z moves to wait; (τo) z is in wait, all the processes to its right are idle, and z moves to crit; and (τo) z is in crit and moves to idle. The system should satisfy the following mutual exclusion property: there are no two distinct processes in crit at the same time.
Since we adopt the stopping failures model, we introduce an additional location crash and three additional transitions: (τc) if a process with index z is in state x, then it moves to crash and all the other processes remain in the same state (for x ∈{ idle, wait, crit }). The transitions τo, τo, and τo are transformed as follows: (τ1)
1	2	3
if a process with index z is idle, then it moves to wait; furthermore, any process on its left remains in the same state and for any process on its left if the process is not idle, then it moves to crash, otherwise it remains idle; (τ2) if a process
with index z is in wait, then it moves to crit; furthermore, any process on its left remains in the same state and for any process on its right which is not idle, then it moves to crash, otherwise it remains idle; and (τ3) if a process with index z is
in crit, then it becomes idle and all other processes remains in the same state. The new system is supposed to satisfy the same mutual exclusion property of the original system above.
In the following, we use the term “running example” to indicate the stopping failures model of this system. When discussing the application of our verification techniques to the running example, we forget the transitions (τc), for x ∈ { idle,
wait, crit }, since their structure is similar to (τ3) and all observations for the
latter apply trivially to the former.	 

Theories for indexes and elements.
The state of an array-based system consists of a single array (however, it is straightforward to generalize all definitions below to the case of several arrays) indexed by a data structure I (e.g., by a finite and linearly ordered set of identifiers), storing elements of a data structure E (e.g., an enumerated data type for the control locations). To formalize this in our declarative formalism, we use two theories: TI for indexes (intuitively, the role of TI is to specify the “topology” of the system) and TE for data (the role of TE is to specify the set of values over which local data variables values range). In the rest of the paper, we fix (i) a theory TI = (ΣI, CI ) whose only sort symbol is INDEX; (ii) a theory TE = (ΣE, CE) whose only sort symbol is ELEM (the class of models CE of this theory is usually reduced to a single structure).
The theory AE = (Σ, C) of arrays with indexes I and elements E is
obtained as the combination of TI and TE as follows: INDEX, ELEM, and ARRAY are the only sort symbols of AE, the signature is Σ := ΣI ∪ ΣE ∪{ [ ]} where [ ] : ARRAY, INDEX −→ ELEM (intuitively, a[i] denotes the element stored in the array a at index i); a three-sorted structure M = (INDEXM, ELEMM, ARRAYM, I) is in C iff ARRAYM is the set of (total) functions from INDEXM to ELEMM, the function symbol [ ] is interpreted as function application, and MI = (INDEXM, I|Σ ), ME =
(ELEMM, I|Σ ) are models of TI and TE, respectively (where I|Σ	is the restriction
X
of the interpretation I to the symbols in ΣX for X ∈ {I, E}).
Example 3.2 To begin the formalization of the running example, we take TI to be the theory of finite and linearly ordered sets: the signature ΣI is relational and contains only the binary predicate <. Furthermore, let TE be the enumerated data type theory whose signature contains a constant for each of the four possible control locations: idle, wait, crit, and crash (hence ΣE is quasi-relational).	 

Array-based systems.
A (guarded assignment) array-based (transition) system (for (TI, TE)) is a triple S = (a, I, τ ) where (i) a is the state variable of sort ARRAY; (ii) I(a) is the initial (Σ ∪ ΣD)(a)-formula; and (iii) τ (a, a') is the transition (Σ ∪ ΣD)(a, a')-formula, where a' is a renamed copy of a and ΣD is the set of defined function symbols not in ΣI ∪ ΣE. Below, for the sake of simplicity, any definable extension of AE will still be denoted with AE. In making such a definitional extension, we always assume to use defining formulae φ(x, y) such that φ is a quantiﬁer-free (ΣI ∪ ΣE)-formula and the variable y is of sort ELEM.
Example 3.3 Let TI and TE be as in Example 3.2 and ΣD := {F 1,F 2,F 3}. The array-based transition system for the Bakery algorithm can be specified as follows (for simplicity, we omit sorts):
I(a) := ∀i.a[i] = idle	and

τ (a, a') :=  ∃z.φi (z, a[z]) ∧ ∀j.a'[j] = Fi(z, a[z], j, a[j]),
i=1

where φi (z, a[z]) := (a[z] = xi) for i = 1, 2, 3, x1 is idle, x2 is wait, x3 is crit,

and
⎧⎪ wait	if j = z F 1(z, a[z], j, a[j]) := ⎪⎨ a[j]	if  j < z
a[j]	if j > z Λ a[j] = idle
⎪⎪⎩ crash	otherwise
⎪ crit	if j = z F 2(z, a[z], j, a[j]) := ⎪⎨ a[j]	if  j > z
a[j]	if j < z Λ a[j] = idle
⎪⎪⎩ crash	otherwise
F 3(z, a[z], j, a[j]) := ⎨ idle if j = z
⎩ a[j]	otherwise

For the sake of clarity, the functions Fi’s are defined by cases; it is a trivial exercise to formalize them in extensions of first-order logic supporting an ‘if then else’ term constructor as it is customary in SMT solving [25]. Notice that the negation of the
mutual exclusion property can be formalized as K(a) := Ez1, z2.(z1 /= z2 Λ a[z1] = 
crit Λ a[z2] = crit).	 


Backward Reachability.
Given an array-based transition system £ = (a, I, τ ), many symbolic model- checking algorithms are based on computing the set BRn(τ, K) of backward reach- able states, starting from a formula K(a) describing a set of unsafe states. The set BRn(τ, K) can be found by iteratively computing the set of backward reachable state in one step, i.e.
Pre(τ, K) := Ea'.(τ (a, a') Λ K(a')).

Then, BRn(τ, K) :=  n
Pres(τ, K), where

Pre0(τ, K) := K	and	Pren+1(τ, K) := Pre(τ, Pren(τ, K)).

This iteration reaches a fix-point at n + 1 iff BRn+1(τ, K) → BRn(τ, K) is AE- valid. Furthermore, if BRn+1(τ, K) Λ I is AE-unsatisfiable, then £ is safe (w.r.t.
K); otherwise, it is unsafe.
In order to be able to exploit the backward reachability algorithm sketched above to check invariant properties, it is mandatory to identify a class of first-order formulae such that it should be possible to: (R1) express I, τ , and K for a large number of (abstractions of) systems; (R2) check both AE-satisfiability and AE-
I	I
validity for the safety and fix-point tests described above, respectively; and (R3)

compute a formula which is logically equivalent to Pre(τ, K) and which is of the same shape as K (this will make the fulfillment of (R2) easier).


Formulae for states and transitions.
Intuitively, the class of formulae satisfying (R1) contains those used in Exam- ple 3.3. To make this observation precise, we introduce some notational conventions: d, e range over variables of sort ELEM, a over variables of sort ARRAY, i, j, k, z, . . . over variables of sort INDEX. An underlined variable name abbreviates a tuple of variables of unspecified (but finite) length and, if i := i1,..., in, the notation a[i] abbrevi- ates the tuple of terms a[i1],..., a[in]. Possibly sub/super-scripted expressions of the form φ(i, e), ψ(i, e) denote quantiﬁer-free (ΣI ∪ ΣE ∪ ΣD)-formulae in which at most the variables i ∪ e occur (notice in particular that no array variable and no constructor [ ] can occur here). Also, φ(i, t/e) (or simply φ(i, t)) abbreviates the substitution of the terms t for the variables e (here, the constructor [ ] may appear in t). Thus, for instance, φ(i, a[i]) denotes the formula obtained by replacing e with a[i] in the quantifier-free formula φ(i, e). An EI-formula is a formula of the form Ei.φ(i, a[i]) (see, e.g., the formula K(a) in Example 3.3). A ∀I-formula is a formula of the form ∀i.φ(i, a[i]) (see, e.g., the formula I(a) in Example 3.3).
According to [22], a transition can be split into a local and a global component. In the restricted format adopted in this paper, the local component is a guard expressing a condition to be satisfied by a finite number of indexes and the global component is a deterministic update of the whole system which is represented by a definable function. Formally, let φL(i, e) be a quantifier-free formula and F (i, e, j, d) be a defined function symbol. A T-formula with guard φL and global update F is a formula of the form
Ei (φL(i, a[i]) Λ ∀j a'[j] = F (i, a[i], j, a[j])).
In the rest of the paper, we fix an array-based system £ = (a, I, τ ), in which the initial formula I is a ∀I -formula and the transition formula τ is a disjunction of T-formulae. An example of such a system is in Example 3.3: the φi ’s are local components, the Fi ’s are global updates, and the transition τ is a disjunction of three T-formulae.


Satisfiability checking.
Concerning (R2), recall the formulae that we are supposed to use for the safety and fix-points checks: I Λ BRn(τ, K) and ¬(BRn+1(τ, K) → BRn(τ, K)), where the latter is negated since we reason by refutation as we use only SMT solvers. Under the hypothesis (verified below) of closure under pre-image computation—cf. (R3)—both formulae above are of the form Ea Ei ∀j ψ(i, j, a[i], a[j]). Following [22], such formulae are called EA,I∀I-sentences.
Theorem 3.4 ([22]) The AE-satisﬁability of EA,I∀I-sentences is decidable if (i)
TI has a quasi-relational signature and it is closed under substructures; (ii) the

SMT (TI ) and SMT (TE) problems are decidable. 5
The peculiarity of the above result (when compared with similar ones available in literature, e.g., [12]) is the model-theoretic nature of the conditions on the paramet- ric input theory TI that ensure decidability. The (proof of this) Theorem (see [22]) suggests the following quantifier instantiation algorithm: first, eliminate the uni- versal quantifiers of EA,I∀I -sentences by instantiating the j’s with the constants in ΣI and the i’s, considered as (Skolem) constants, in all possible ways; then, invoke the available SMT solver for AE. The decidability of the SMT (AE) problem can
I	I
be shown by using generic combination techniques from the decidability of those
for SMT (TI ) and SMT (TE) (see [22] for details). From now on, we assume that the theories TI and TE always satisfy the hypotheses of Theorem 3.4.

Closure under pre-image.
Condition (R3) is ensured by the following result.
Proposition 3.5 Let K(a) be an EI-formula; then Pre(τ, K) is AE-equivalent to
an (effectively computable) EI-formula.
Proof. Let K(a) := Ek φ(k, a[k]) and τ (a, a') :=  s	Ei (φh (i, a[i]) Λ ∀j a'[j] = 
Fh(i, a[i], j, a[j])). Now, ∀j a'[j] = Fh(i, a[i], j, a[j]) can be equivalently rewritten as a' = λj.Fh(i, a[i], j, a[j]) using λ-abstraction. Thus, if we eliminate the quantifier Ea' and then apply β-conversion, we get that Pre(τ, K) is equivalent to
Ei Ek s	(φh (i, a[i]) Λ φ(k,Fh(i, a[i], k, a[k]))
where φ(k,Fh(i, a[i], k, a[k])] is the formula obtained from φ(k, a'[k]) by replacing
a'[km] with Fh(i, a[i], km, a[km]) for m = 1, ..., l (here k is the tuple k1,..., kl). 
As suggested by the proof of Proposition 3.5, the implementation of Pre simply amounts to build up formula (3): the task of simplifying it by eliminating redun- dancies is entirely left to the SMT solver. Even better, if the available SMT solver (e.g., Yices [7]) offers some support for λ-abstractions, the β-reduction needed to obtain (3) can be delegated to the SMT solver. To the best of our knowledge, this simplicity in the computation of the pre-image is in sharp contrast to current approaches to symbolic model checking of inﬁnite state systems available in the literature where computationally expensive operations are required to obtain some normal form that can then be exploited by safety and fix-point computations. We avoid this by directly using first-order formulae and then exploiting the flexibility and scalability of the SMT solver to internalize formulae in appropriate data struc- tures that support efficient satisfiability checks to which both safety and fix-point tests can be reduced. This is similar in spirit to what is current practice in ﬁnite state model checking, where the BDD package abstracts away the details of the efficient handling of finite sets and related operations on them.

5 The first part of (i) can be weakened to local finiteness as in [22]; while the second part is satisfied in all practical cases (when, e.g., the models of TI are all (finite) sets, linear orders, graphs, forests, etc.). Quantifier elimination for TE is assumed in [22] to show closure under pre-image computation: here we do not need it, as we adopt a more restricted notion for T-formulae.

function BReach(K)
i ←− 0; BR0(τ, K) ←− K; K0 ←− K
if BR0(τ, K) Λ I is AE-sat. then return unsafe
repeat
Ki+1 ←− Pre(τ, Ki)
BRi+1(τ, K) ←− BRi(τ, K) ∨ Ki+1
if BRi+1(τ, K) Λ I) is AE-sat. then return unsafe
else i ←− i +1 
until ¬(BRi+1(τ, K) → BRi(τ, K)) is AE-unsat.
return safe
end
Fig. 1. Backward Reachability Algorithm
Light-weight reachability
Having found suitable hypotheses under which conditions (R1), (R2), and (R3) are satisfied, it is now possible to introduce the algorithm in Figure 1 to compute BRn(τ, K) for the class of array-based systems considered in this paper. The func- tion Pre computes the pre-image of an EI -formula (according to (1)) and then applies the syntactic manipulations explained in the proof of Proposition 3.5 to find a logi- cally equivalent EI -formula. The algorithm in Figure 1 semi-decides the (invariant) model-checking problem for K(a) whenever K(a) is an EI -formula. Termination of BReach for some important classes of systems may be obtained as shown in [22].

Reducing quantiﬁer instantiation
As observed after Theorem 3.4, checking the AE-satisfiability of EA,I∀I -formulae is possible by integrating quantifier instantiation and SMT solving. Unfortunately, the instantiation is too expensive. One of the main reasons for this is the growing num- ber (at each iteration of the loop in Figure 1) of existentially quantified variables in the prefix of the EI -formulae resulting from the computation of the Pre-image: the existentially quantified prefix E k is augmented with E i in (3) (cf. proof of Propo- sition 3.5). Hence, it would be desirable to find ways to greatly limit the growing number of existentially quantified variables in the prefix of the Pre-image or, even better, to ensure it remains constant. In the rest of this Section, we develop our ideas to achieve this goal so as to obtain a light-weight (but still complete) version of the algorithm in Figure 1. To this end, for simplicity, we make a stronger assumption on the theory TI of indexes, namely that ΣI is relational.
Let τ (a, a') be the disjunction of the T-formulae
Ei (φh (i, a[i]) Λ a' = λj.Fh(i, a[i], j, a[j])),
where h ranges over a certain finite set S, say S = {1,..., s}. For the sake of simplicity, we assume that the tuple i is independent of h: the length of such a tuple is denoted by c(τ ) and it is called the complexity of τ .
A formula K(a) has degree less than n (in symbols, d(K) ≤ n) iff K is AE-

equivalent to a formula of the form Ek φ(k, a[k]) in which the length of the tuple k is less than or equal to n. When writing d(K) = n, we mean that n is the smallest natural number such that d(K) ≤ n holds. Now, the proof of Proposition 3.5 shows that the degree of Pre(τ, K) can be bounded by the sum of the complexity of τ and of the degree of K, in symbols d(Pre(τ, K)) ≤ c(τ )+ d(K). By induction, we derive d(BRn(τ, K)) ≤ d(K)+ n · c(τ ). Below, we show that, under suitable hypotheses, this estimate can be slightly improved.
An activity condition is a quantifier-free Σ-formula γ(s, a[s]) such that
AE |= φh (i, a[i]) → γ(t, a[t]) holds for each h ∈ S and each variable t ∈ i.
I	L
Discharging this obligation implies that only active processes can fire transition h. An EI -formula Ek ψ(k, a[k]) is γ-active (for the activity condition γ) iff
AE |= ψ(k, a[k]) → γ(t, a[t]) holds for each variable t in k.
At this point, it is interesting to consider our formalization of parametrised systems in the stopping failures model. Recall, from Section 2, that no transition is enabled when control reaches the additional state qcrash . This suggests a[s] /= qcrash as an obvious candidate for expressing an activity condition in such systems.
Example 4.1 To show that a[s] /= crash is an activity condition for our running example, it is necessary to prove the AE-unsatisfiability of the three formulae a[z] = x Λ a[z] = crash where x ∈ {idle, wait, crit}. This is immediate since crash /= x for x ∈ {idle, wait, crit} by the theory TI of enumerated data types. The EI - formula K(a) in Example 3.3 is γ-active. To see this, it is sufficient to prove that z1 /= z2 Λ a[z1] = crit Λ a[z2] = crit Λ a[zi] = crash are AE-unsatisfiable (for i = 1, 2), which is trivial.	 
Recall that τ is a disjunction of T-formulae of the form (4), for h ∈ S. We say that τ is γ-local iff the formula
φh (i, a[i]) Λ γ(s, Fh(i, a[i], s, a[s])) → s ∈ i V a[s] = Fh(i, a[i], s, a[s]).
						
is AE-valid for each h ∈ S, where s ∈ i abbreviates	s = u. To understand (5),
observe that, once the transition fires, the state of the system is updated according to the assignment a'[s] := Fh(i, a[i], s, a[s]); hence, (5) means that the value stored at an index s of the array a not causing the transition to fire remains the same, unless s becomes ‘inactive’ after the transition, i.e. unless γ(s, a'[s]) becomes false (just read (5) by contraposition).
Example 4.2 It is not difficult to see that the transition of the running example is γ-local, where γ is a[s] /= crash (as in Example 4.1). For the sake of conciseness, we illustrate this only for τ3 (τ1 and τ2 are similar, only more cases must be considered). It is sufficient to check for AE-unsatisfiability the two formulae obtained by case- splitting on (5), namely a[z] = crit Λ s = z Λ crash /= idle Λ s /= z Λ a[s] /= idle and a[z] = crit Λ s /= z Λ crash /= a[s] Λ s /= z Λ a[s] /= a[s]. Both checks are trivial.	 
In practice, it is possible to find activity conditions making transitions local for several protocols ensuring mutual exclusion as well as for algorithms manipulating

arrays (e.g., sorting) by guessing appropriate γ’s. Typical examples of non local transitions are those of broadcast protocols.
We are now ready to show the usefulness of local transitions to limit the growing prefix of EI -formulae computed by the algorithm in Figure 1.
Theorem 4.3 Suppose c(τ ) ≥ 1. Let K be an EI-formula and let γ be an activity condition such that K is γ-active and τ is γ-local. Then, d(BRn(τ, K)) ≤ d(K)+ n · c(τ ) — n. Hence, if c(τ ) = 1 then d(BRn(τ, K)) ≤ d(K), for all n ≥ 0.
Before applying Theorem 4.3, let us consider the task of finding a suitable ac- tivity condition γ. For parametrised systems formalized in the stopping failures model, we have seen before Example 4.1 that the obvious candidate for an activity condition is a[s] /= qcrash , because no transition is enabled in the additional crash state. In general, the search space for such γ(s, a[s]) is infinite, but it becomes ﬁnite for instance when TE has a quasi-relational signature: in that case, the hypotheses of Theorem 4.3 can be effectively checked, as the following example shows.
Example 4.4 The signature ΣE of Example 3.2 is quasi-relational, hence we can compute all possible choices for γ(s, a[s]): the latter can only be a Boolean com- binations of atoms of the form a[z] = x for x ∈ {idle, wait, crit, crash}. By enumerating such formulae (e.g., in disjunctive normal form) and checking for the conditions of γ-activity and γ-locality, we quickly find that a[s] /= crash satisfies the desired requirements.	 

Case c(τ ) = 1.
In this case, Theorem 4.3 implies that the number of existentially quanti- fied variables of the pre-image remains constant at each iteration of the loop of the backward reachability algorithm in Figure 1. So, if the input formula K of the reachability algorithm has k existentially quantified variables, BRi(τ, K) is AE-equivalent to an EI -formula of the form Ekφi(k, a[k]) and the AE-validity
I	I
of BRi+1(τ, K) → BRi(τ, K), to detect a fix-point, is equivalent to the AE-
unsatisfiability of the quantifier-free formula
φi+1(k, a[k]) Λ  чφi(kσ, a[kσ]),
σ
where σ ranges over all possible substitutions with domain k and co-domain k, according to the instantiation procedure sketched after Theorem 3.4. Although the number of instances (or, equivalently, of substitutions σ’s) to be considered at each iteration of the loop does not change, it is tempting to furtherly simplify the formula above by considering only one instance, obtained by the identical substi- tution: φi+1(k, a[k]) Λ чφi(k, a[k]). This algorithm is computationally much less expensive than that suggested by Theorem 3.4; unfortunately, it is incomplete in general. However, when, e.g., TE is an enumerated datatype theory, checking the AE-unsatisfiability of φi+1(k, a[k]) Λ чφi(k, a[k]) is precise enough, since there are only finitely many quantifier-free formulae of the form ψ(k, a[k]), up to AE- equivalence, and a fix-point can always be reached (maybe with more iterations

than those needed by the loop in Figure 1). Operationally, this observation can be implemented by preliminarily ‘grounding the whole system,’ as exemplified below.
Example 4.5 For the formulae in Example 3.3, we have c(τ ) = 1 and d(BRn(τ, K)) = d(K) = 2 by Theorem 4.3 with the activity condition in Ex- ample 4.1.  Because TE is an enumerated datatype theory (cf. Example 3.2) and the last observation above, to prove the safety of the running example, it is sufficient to consider a parametrized system consisting of only d(K) = 2 pro- cesses, i.e. it is sufficient to consider the following ground version of the system:
I^(a) := (a[z1] = idle Λ a[z2] = idle),
2	3	2

'	i
L
l=1 i=1
   a'[zm] = Fi(zl, a[zl], zm, a[zm]))),
m=1

and K(a) := z1 /= z2 Λa[z1] = crit Λa[z2] = crit, where z1, z2 are INDEX constants. It is a routine exercise to verify that the formulae for checking fix-point and safety computed with I, τ , and K are the same (modulo trivial logical manipulations) as those obtained by using I, τ , K and then performing the above instantiation. 

 Case c(τ ) = 11 .
In practice (see, e.g., the Szymanski protocol [10]), it turns out that parametrised systems with transitions of complexity 2 are formalized by disjunctions of T- formulae of the form
Ei1, i2 (φh (i1, i2, a[i1], a[i2]) Λ a' = λk.Fh(i1, a[i1], k, a[k])),
i.e. whereas both existentially quantified variables occur in the local component, just one of them occurs in the update. The degree-reducing algorithm of Theorem 4.3 prescribes that, when computing Pre(τ, Ek φ), one can insert the extra information that one of the i1, i2 is equal to one of the k’s. However, when τ is a disjunction of T-formulae of the form (6), one can improve again the procedure by imposing the condition that precisely i1 must be identified with one of the k’s. Since this reduces by one half the length of the optimized Pre(τ, Ekφ), we (informally) say that formulae (6) have complexity 11 . For the formal details, see the Appendix.

Reﬁnements of backward reachability and experiments
Theorem 4.3 and its applications suggest to implement the algorithm in Figure 1 on top of a client-server architecture, where the client is a “light-weight” program to generate formulae representing (iterated) pre-images, whose AE-unsatisfiability is checked by an off-the-shelf SMT solver, the server. Below, we discuss how to make this efficient. We assume the available SMT solver to offer the following in- terface functionalities: (I1) parsing of strings for processing symbolic expressions, (I2) supporting definable function symbols (as an alternative, one may require to support λ-abstraction), and (I3) incremental handling of a logical context, i.e. ad- dition/removal of logical facts and (incremental) satisfiability checks.

Lazy generation of proof obligations.
Although (I1) seems sufficient to mechanize our approach as SMT solvers have a standard input format [25], preliminary experiments have shown that formulae for both safety and fix-point checks quickly become quite large and parsing may become a bottleneck. To see this, consider the sequence of formulae generated by the loop of the algorithm in Figure 1: BRi+1(τ, K) := BRi(τ, K) V Pre(τ, Ki), for i ≥ 0. The formulae for safety and fix-point checks involving BRi+1(τ, K) contains a copy of the previously generated (and already parsed by the SMT solver) formula BRi(τ, K). After some iteration, parsing becomes prohibitively expensive. To avoid this, we introduce a new Boolean variable BRi to be used as an “abbreviation” for the arbitrarily complex formula BRi(τ, K) in the computation of BRi+1(τ, K) as follows: BRi ↔ BRi(τ, K), which is is added to the logical context of the SMT solver by invoking (I3), so that BRi+1(τ, K) := BRi V Pre(τ, Ki), for i ≥ 0. In this way, the size of BRi+1(τ, K) as well as of all the formulae containing it remains constant over the iterations and parsing is no more problematic.

Interleaving.
By definition, our transition formula τ is the disjunction of the T-formulae τh and Pre(τ, K) is the disjunction of the Pre(τh, K)’s. In practice, it is rarely the case that each Pre(τh, K) is AE-satisfiable as not all transitions may be taken from a given state. This suggests to check first for the AE-satisfiability of the formula Pre(τh, Ki): if the result is unsatisfiable, then we proceed to consider τh+1 (if h + 1 ≤ s). In other words, we replace the check for safety with the following sequence of (simpler) checks: (C1.h) Pre(τh, Ki) Λ I is AE-satisfiable and the fix- point check with (C2.h) ч(Pre(τh, Ki) → BRi) is AE-satisfiable, for h = 1, ..., s at the i-iteration of the loop in the algorithm of Figure 1. If one of the checks (C1.h) is satisfiable, we stop and report the unsafety of the system. Instead, if all the checks (C2.h) are unsatisfiable, we conclude that Pre(τ, Ki) → BRi is AE-valid and, hence, a fix-point has been reached. Otherwise, if some of the checks (C2.h) are satisfiable and the others are unsatisfiable, we discard the latter ones and take the disjunction of the former ones to compute BRi+1(τ, K). By interleaving in this way the generation of the proof obligations and the satisfiability checks, the hope is to generate a more compact symbolic representation of the set of reachable state.

Breadth vs. depth.
The algorithm in Figure 1 implements a breadth-first visit of the set of backward reachable states. However, thanks to the flexibility of our declarative approach, it is easy to implement a recursive algorithm implementing a depth-first visit of the state space. Consider the s-ary tree built by labelling its root with K and its s-sons with K V Pre(τh, K) for h = 1, ..., s, and recursively repeating this construction. A standard depth-first visit of this tree yields a depth-first visit of the state space. Indeed, the tree is constructed on-the-fly while it is visited by using “local” checks for fix-point and safety, similar to those of the algorithm in Figure 1. The main advantage of the depth-first algorithm is that more compact formulae are generated

for the SMT solver. Its main drawback is that it may take much longer to terminate (or even diverge). Fortunately, it is possible to alleviate this problem by storing the set of “already-visited” states, i.e. those states describing a “local” fix-point, in a global variable AV , which is then used in subsequent fix-point checks, as follows:
prove the AE-validity of BRi+1 → (BRi V AV ) for h ≥ 0, where BRi+1 and BRi
I	df	df	df	df
are the sets of states reachable in depth-first at iteration i + 1 and i, respectively, and AV is the set of “already-visited” states (at the beginning, AV is false, i.e. the empty set of states). When h = s, this enhanced depth-first algorithm performs a
“global” fix-point check similar to that of the algorithm in Figure 1. Our flexible framework allows us to experiment with “hybrid” strategies combining depth- and breadth-first searches.

The tool.
To test the practical viability of the client-server architecture designed above and to evaluate the impact of the various heuristics, we implemented smtmc, a prototype tool which uses Yices 1.0.11 as the SMT solver (in particular, its API lite that supports (I1)–(I3) above) and writing around 1390 source lines of C code.
Our benchmark set consists of problems taken from the distribution of various model-checking tools for infinite state systems, such as Babylon [3], Brain [4], Action Language Verifier [1], ARMC [2], and PFS [5]. We have considered two classes of problems: NUM (with 34 problems), where TI is an enumerated data type theory and TE is the theory of Linear Real/Integer Arithmetic; and AIE (with 19 problems), where TI is the theory of finite and linearly ordered sets and TE is the theory of an enumerated data type sometimes combined with Linear Integer Arithmetic. Array-based systems in NUM model situations where a fixed and known number of integer variables is updated by the transition systems; e.g., those obtained by counting abstraction [18]. For problems in this class, we have c(τ ) = 0, i.e. problems are quantifier-free. The class AIE features (truly parametric) systems with a fixed (either known or unknown) number of elements; e.g., those in [10]. Although smtmc has been designed for very expressive extensions (covering all problems that can be modeled by generic array-based systems), it is still under major development and its current version, due to insufficient quantifier instantiation, can only handle, in an incomplete way, most of the problems in AIE. On the other hand, actual performances are encouraging and seem comparable with dedicated state-of-the-art tools for problems in the class NUM. Incomplete runs seem to predict the possibility to obtain good results also for problems in AIE. An executable of our tool and the benchmark problems can be reached from [6].

Heuristics.
Our experiments have clearly shown that straightforward implementations of breadth- and depth-first search (even in combination with the interleaving of the generation of proof obligations and satisfiability checking) scale up poorly. The more promising results have been obtained with two extensions of depth-first search: depth-AV, where the fix-point check is enhanced by the checks with the “already-


The number of variables nv and the number nt of T-formulae for problems in NUM are such that 3 ≤ nv ≤ 44 and 3 ≤ nt ≤ 37.
Experiments were conducted on a Pentium Dual- Core 1.66 GHz with 1 Gb Sdram running Linux. All the timings are in seconds and the time-out is 3 hours.
A dot below the diagonal means a better per- formance of depth-AV.Interleave over depth-AV; viceversa for a dot above.



Fig. 2. Results of smtmc on NUM
visited” set of states, and depth-AV.Interleave, which is similar to depth-AV except for the fact that the generation of proof obligations is interleaved with satisfiability checking according to (C1.h) and (C2.h). Figure 2 shows that the two heuristics are equivalent on NUM: both are capable of solving 87% of the problems while for the remaining 13%, the search space is too large and the tool times out.

Discussion and related work
We have presented a refinement of the SMT-based model-checking of array-based systems of [22] that allows us to directly leverage existing SMT solvers by a light- weight implementation effort. The idea of using arrays to represent system states is not new in model-checking (see in particular [27,26]); what seems to be new in our approach is the fully declarative characterization of both the topology and the (local) data structures of systems by using theories. This has two advantages. First, implementations of our approach can handle a wide range of topologies without modifying the underlying data structures representing sets of states. This is in contrast with recently available techniques [10,9] for the uniform verification of parametrized systems, which consist of exploring the state space of a system by using a finitary representation of (infinite) sets of states and require substantial modifications in the computation of the pre-image to adapt to different topologies. Second, since SMT solvers are capable of handling several theories in combinations, we can avoid encoding everything in one theory, which has already been proved detrimental to performances in [14,13,1]. SMT techniques were already employed in model-checking [16,11], but only in the bounded case (whose aim is mostly limited at finding bugs, not at full verification).
Babylon [3] is a tool for the verification of counting abstractions of parametrized systems (e.g., multithreaded Java programs [19]). It uses a graph-based data struc- ture to encode disjunctive normal forms of integer arithmetic constraints. Com- puting pre-images requires computationally expensive normalization, which is not needed for us as SMT solvers efficiently handle arbitrary integer constraints.
Brain [4] is a model-checker for transition systems with finitely many integer variables which uses an incremental version of Hilbert’s bases to efficiently perform entailment/satisfiability checking of integer constraints (the results reported in [28] shows that it scales very well). Taking TI to be an enumerated datatype theory, the array-based systems considered in this paper reduce to those used by Brain.

A recent interesting proposal to uniform verification of parametrized systems is [12], where a decidability result for Σ0-formulae is derived (these are E∀-formulae roughly corresponding to those covered by Theorem 3.4 above, for the special case in which the models of the theory TI are all the finite linear orders). While the rep- resentation of states in [12] is (fully) declarative, transitions are not, as a rewriting semantics (with constraints) is employed. Since transitions are not declaratively handled, the task of proving pre-image closure becomes non trivial; e.g., in [12], pre-image closure of Σ0-formulae under transitions encoded by Σ0-formulae ensures
2	2
the effectiveness of the tests for inductive invariant and bounded reachability anal- ysis, but not for fix-point checks. In our approach, an easy (but orthogonal) pre-
image closure result for existential state descriptions (under certain Σ0-formulae
representing transitions) gives the effectiveness of fix-point checks, thus allowing implementation of backward search.
Acknowledgement
The 2nd author was supported by FP7-ICT-2007-1 Project no. 216471, “AVANTSSAR: Automated Validation of Trust and Security of Service-oriented Ar- chitectures” (www.avantssar.eu). We thank an anonymous reviewer for his careful criticisms that helped improving the quality of the paper.

References
Action Language Verifier. http://www.cs.ucsb.edu/~bultan/composite.
ARMC. http://www.mpi-sws.mpg.de/~rybal/armc.
Babylon. http://www.ulb.ac.be/di/ssd/lvbegin/CST.
Brain. http://www.cs.man.ac.uk/~voronkov/BRAIN.
PFS. http://www.it.uu.se/research/docs/fm/apv/tools/pfs.
smtmc. http://www.dsi.unimi.it/~ghilardi/mcmt.
Yices. http://yices.csl.sri.com.
P. A. Abdulla, K. Cerans, B. Jonsson, and Y.-K. Tsay. General decidability theorems for infinite state systems. In Proc. of LICS ’96, pages 313–321, 1996.
P. A. Abdulla, G. Delzanno, and A. Rezine. Parameterized verification of infinite-state processes with global conditions. In CAV, number 4590 in LNCS, 2007.
P. A. Abdulla, N. B. Henda, G. Delzanno, and A. Rezine. Regular model checking without transducers. In TACAS, number 4424 in LNCS, 2007.
A. Armando, J. Mantovani, and L. Platania. Bounded Model Checking of Software using SMT Solvers instead of SAT Solvers. In Proc. of SPIN’06, number 3925 in LNCS, pages 146–162, 2006.
A. Bouajjani, P. Habermehl, Y. Yurski, and M. Sighireanu. Rewriting systems with data. In Proc. of Symp. on Fund. of Comp. Th. (FCT 07), pages 1–22, 2007.
T. Bultan, R. Gerber, and C. League. Composite model-checking: verification with type-specific symbolic representations. ACM Trans. on Soft. Eng. an Meth., 9(1):3–50, 2000.
T. Bultan, R. Gerber, and W. Pugh. Model-checking concurrent systems with unbounded integer variables: symbolic representations, approximations, and experimental results. ACM Trans. on Progr. Lang. and Sys., 21(4):747–789, 1999.

L. de Moura and N. Bjørner. Efficient e-matching for smt solvers. In Proc. of CADE, LNCS, 2007.
L. de Moura, H. Rueß, and M. Sorea. Lazy theorem proving for bounded model checking over infinite domains. In Proc. CADE, volume 2392 of LNCS, 2002.
D. D´eharbe and S. Ranise. Satisfiability solving for software verification. Int. Journal on STTT, 2008. To appear.
G. Delzanno. Automatic verification of parameterized cache coherence protocols. In Proc. of CAV, number 1855 in LNCS, 2000.
G. Delzanno, J.-F. Raskin, and L. Van Begin. Towards the automated verification of multi-threaded java programs. In 8th Int. Conf. on TACAS, number 2280 in LNCS, 2002.
Herbert B. Enderton. A Mathematical Introduction to Logic. Academic Press, New York-London, 1972.
Y. Ge, C. Barrett, and C. Tinelli. Solving quantified verification conditions using satisfiability modulo theories. In Proc. of CADE-21, LNCS, 2007.
S. Ghilardi, E. Nicolini, S. Ranise, and D. Zucchelli. Towards SMT Model-Checking of Array-based Systems. In Proc. of IJCAR, LNCS, 2008. Extended version available at http://homes.dsi.unimi. it/~ghilardi/allegati/GhiNiRaZu-RI318-08.pdf.
S. Ghilardi, S. Ranise, and T. Valsecchi. Light-Weight SMT-based Model Checking (Extended version). Available at http://homes.dsi.unimi.it/~ghilardi/allegati/GhRaVa_avocs.pdf, 2008.
Nancy A. Lynch. Distributed Algorithms. Morgan Kauffman Publishers, Inc., 2000.
S. Ranise and C. Tinelli. The SMT-LIB Standard: Version 1.2. Technical report, Dep. of Comp. Science, Iowa, 2006. Available at http://www.SMT-LIB.org/papers.
A. W. Roscoe, R. S. Lazic, and T. C. Newcomb. On model checking data-independent systems with arrays without reset. Theory and Practice of Logic Programming, pages 659–693, 2004.
A. W. Roscoe, R. S. Lazic, and Tom Newcomb. On model checking data-independent systems with arrays with whole-array operations. In Communicating Sequential Processes. Springer LNCS, 2005.
T. Rybina and A. Voronkov. Using canonical representations of solutions to speed up infinite-state model checking. In Proc. of CAV, number 2404 in LNCS, 2002.
T. Rybina and A. Voronkov. A logical reconstruction of reachability. In Proc. of PSI, pages 222–237. LNCS 2890, 2003.
R. Sebastiani. Lazy satisfiability modulo theories. Jour. on Sat., Boolean Modeling and Comp., 3:141– 224, 2007.
