Electronic Notes in Theoretical Computer Science 53 (2004)
URL: http://www.elsevier.nl/locate/entcs/volume53.html 23 pages



A Model-Theoretic Description of Tree Adjoining Grammars 1

Frank Morawietz and Uwe Mo¨nnich 2,3
Seminar fu¨r Sprachwissenschaft Universit¨at Tu¨bingen Tu¨bingen, Germany


Abstract
In this paper we show that non-context-free phenomena can be captured using only limited logical means. In particular, we show how to encode a Tree Adjoining Gram- mar [16] into a weakly equivalent monadic context-free tree grammar (MCFTG). By viewing MCFTG-rules as terms in a free Lawvere theory, we can translate a given MCFTG into a regular tree grammar. The latter is characterizable by both a tree automaton and a corresponding formula in monadic second-order (MSO) logic. The trees of the resulting regular tree language are then unpacked into the intended “linguistic” trees through a model-theoretic interpretation in the form of an MSO transduction based upon tree-walking automata. This two-step approach gives a logical as well as an operational description of the tree sets involved.


Introduction
Algebraic, logical and regular characterizations of (tree) languages provide a natural framework for the denotational and operational semantics of grammar formalisms relying on the use of trees for their intended models.
In the present context the combination of algebraic, logical and regular techniques does not only add another description of mildly context-sensitive languages to an already long list of weak equivalences between grammar for- malisms. It also makes available the whole body of techniques that have been developed in the tradition of algebraic language theory, logic and automata theory.

1 The research presented in this paper was supported by the Deutsche Forschungsgemein- schaft within the Sonderforschungsbereich 441, TP A2. The authors wish to thank Jens Michaelis and Stephan Kepser for helpful comments.
2 Email: frank@sfs.uni-tuebingen.de
3 Email: um@sfs.uni-tuebingen.de
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

For regular string and tree languages, classical results in the descriptive theory of recognizability have established a tight connection between logical formalisms and language classes. They provide translation procedures that transform logical specifications into finite automata equivalent to the language classes and vice versa. Bu¨chi [3] and Elgot [7] have shown that regular string languages represented through finite (string) automata can be expressed by sentences in the weak MSO logic with one successor. For tree languages an analogous result is well known: a tree language is definable in weak MSO logic with multiple successors if and only if it is recognizable by a finite tree automaton [6,32].
It is these earlier characterizations that provide the reason for a renewed interest in logical approaches to grammar specifications. The main open ques- tion in this area of research is whether an appropriate extension of the MSO language can be found which is expressive enough to define significant proper- ties of natural languages without becoming too unwieldy from the perspective of complexity theory.
We believe, similarly to the claims in Pullum and Scholz [28], that model- theoretic approaches to syntax represent an important aspect of the formal analysis of natural language formalisms. In the present context we try to circumvent the problems posed by the limited expressive power of MSO by developing the model-theoretic description in terms of a two-step approach. We choose Tree Adjoining Grammar (TAG) [13,14,15] as maybe the prototyp- ical mildly context-sensitive formalism 4 for natural languages to illustrate our proposal for a denotational approach towards a generative, non-context-free formalism.
The first step in the approach proposed in this paper consists in the use of a type of tree grammars which can be “lifted”, i.e., a certain amount of control information is explicitly coded in the trees, such that the resulting tree sets are amenable to formalizations in terms of tree automata and MSO logic. In par- ticular, we will use a restricted form of context-free tree grammars (CFTGs), namely monadic CFTGs which have an adequate descriptive complexity (see Section 2.3 below). Since the weak equivalence between TAGs and monadic
CFTGs has independently been proven by M¨onnich [24] and Fujiyoshi and Kasai [12], CFTGs form an adequate basis for the following work. Finally, a second step is necessary to remove the explicit control information from the trees to recover the linguistically intended structures.
Recently, Jim Rogers has shown that tree-adjoining languages can be characterized in terms of a monadic second-order definition on the three- dimensional tree manifolds [30]. We plan to work out in a future paper the exact relationship between the introduction of a further tree dimension and the device of higher types in the specification of lifted vocabularies.

4 In fact, the desiderata Joshi enumerates for any formalism dealing with natural languages coined this terminology.

Preliminaries
Universal Algebra
Recall that for a given set of sorts S, a many-sorted alphabet Σ (over S) is an indexed family ⟨Σw,s | w ∈ S∗,s ∈ S⟩ of disjoint sets. A symbol σ ∈ Σw,s is an operator of type ⟨w, s⟩, arity w, sort s and rank |w|. The elements of Σε,s are also called constants (of sort s).
In case S is a singleton set {s}, i.e., in case Σ is a single-sorted or ranked alphabet (over sort s), we usually write Σn to denote the (unique) set of operators of rank n ∈ N. 5
In later sections of the paper we will mainly use the single-sorted case of alphabets. We will indicate the need for many-sorted alphabets where necessary.
For such a ranked alphabet Σ, we denote by T (Σ) the set of trees over Σ. T (Σ) is inductively defined with base case Σ0 ⊆ T (Σ) and recursive step f (t1,..., tn) ∈ T (Σ) if f ∈ Σn and ti ∈ T (Σ) for i = 1,..., n.
Furthermore, we fix an indexed set X = {x1, x2,.. .} of variables and de- note by Xn the subset {x1,..., xn}. Variables are considered to be constants, i.e., operators of rank 0. For a ranked alphabet Σ the family T (Σ, X) is defined to be T (Σ(X)), where Σ(X) is the ranked alphabet with Σ(X)0 = Σ0 ∪X and Σ(X)n = Σn for every n /= 0. A subset L of T (Σ) is called a tree language
over Σ.
Having described the tree terms, it remains to specify the central notion of an algebra and to give a precise definition of the way in which the operator symbols induce operations on an algebra.
Suppose that Σ is a ranked alphabet. A Σ-algebra A is a pair A = (A, (fA)f∈Σ) where the set A is the carrier of the algebra and for each op- erator f ∈ Σn, fA : An → A is an operation of arity n on A.
Different algebras, defined over the same operator domain, are related to each other if there exists a mapping between their carriers that is compatible with the basic structural operations.
A Σ-homomorphism of Σ-algebras h : A −→ B is a function h : A −→ B, such that h(fA(a1,..., an)) = fB(h(a1),..., h(an)) for every operator f of rank n and for every n-tuple (a1,..., an) ∈ An.
The set of trees T (Σ, X) can be made into a Σ-algebra T(Σ, X) by defining the operations in the following way. For every f in Σn, for every (t1,..., tn) in T (Σ, X)n: fT(Σ,X)(t1,..., tn) = f (t1,..., tn).
Every variable-free tree t ∈ T (Σ) has a value in every Σ-algebra A. It is the value at t of the unique homomorphism h : T(Σ) → A.
The existence of a unique homomorphism from the Σ-algebra of trees into an arbitrary Σ-algebra A provides also the basis for the view that regards the

5 Note that for S = {s} each ⟨w, s⟩∈ S∗ ×S is of the form ⟨sn, s⟩ for some n ∈ N.

elements of T (Σ, Xn) as derived operations. Each tree t ∈ T (Σ, Xn) induces an n-ary function tA : An → A.
The meaning of this function tA is defined in the following way. For every (a1,..., an) ∈ An: tA(a1,..., an) = aˆ(t), where aˆ : T(Σ, Xn) → A is the unique homomorphism with aˆ(xi) = ai.
In the particular case where A is the Σ-algebra T(Σ, Xm) of trees over Σ that contain at most variables from Xm = {x1,..., xm} at their leaves the unique homomorphism extending the assignment of a tree ti ∈ T (Σ, Xm) to the variable xi in Xn acts as a substitution tT(Σ,Xm)(t1,..., tn) = t[t1,..., tn] where the right hand side indicates the result of substituting ti for xi in t.

Tree Adjoining Grammar
The main obstacle for the simple and direct use of MSO logic stems from the fact that linguistic theories allow non-context-free structures and therefore cannot be accommodated within the classical approach outlined in Rogers’ monograph [29]. In this section we will sketch a definition of tree adjoin- ing grammars following Vijay-Shanker and Weir [34] and Joshi and Schabes [16]. This formalism has a descriptive complexity which is higher than that of context-free grammars. Additionally, TAGs are a derivational formalism and, hence, a logical approach towards describing the resulting tree sets presents a further problem.
Definition 2.1 (Tree Adjoining Grammar) A Tree Adjoining Grammar (TAG) isa quintuple ⟨VN , VT , S, I, A⟩ where VN is a ﬁnite set of nonterminals, VT a ﬁnite set of terminals, S ∈ VN the start symbol, I a ﬁnite set of initial trees and A a ﬁnite set of auxiliary trees.
Initial trees are such that all interior nodes (including the root node) are labeled with nonterminals and all nodes on the frontier are labeled with termi- nal or nonterminal symbols; the nonterminals being marked for substitution. The same holds for the auxiliary trees with one exception. There exists one distinguished leaf-node which is labeled with the same nonterminal as the root node, which is called the foot node. Furthermore, the nodes can be marked to allow or forbid adjunction. For simplicity, we only indicate nodes where no adjunction is allowed by putting a bar on top of them.
New trees are built from the sets I and A via adjunction or substitution. Adjunction is defined such that an auxiliary tree is spliced into an existing tree such that it basically “expands” a nonterminal. A subtree rooted in the node labeled with a nonterminal A is taken out of the a tree. A new auxiliary tree is inserted in its place (if the root and foot are also labeled with the identical nonterminal A) and the original subtree is appended at the foot node. There also exists a simpler operation in TAGs, called substitution, to generate new
trees. Intuitively, in substitution, a nonterminal is replaced by a tree with a matching nonterminal at its root. Since we do not need the formal definitions in this paper, the reader is referred to the literature cited above for details.

The corresponding tree and string languages are defined in the obvious way. An example for a TAG generating the non-CF language anbncndn is given below:
Example 2.2 Let GT AG = ⟨{S}, {a, b, c, d}, S, {α}, {β}⟩ be a TAG. The only initial tree α and the only auxiliary tree β are given as follows:
S 

S	a	d
 =		 =	S "
b	c
S 
A derivation yielding aabbccdd has only two steps, both adjoin the auxiliary tree in the only possible position, see Figure 1.
S 

a	d
S	S 

a	d	a	d
S	S	S
=)	=)
"	b		c	b		c S			S 
"	b	c
S 

"
Fig. 1. An example derivation of the TAG GT AG given in Example 2.2

It can be shown that TAGs can only generate string languages with de- pendencies up to four, i.e., anbncndn can be generated, but there is no TAG which generates anbncndnen [16].

Context-Free Tree Grammars
The algebraic perspective allows the uniform and natural extension from strings to trees by the simple technique of generalizing from unary to multi- ary operators. In this section, grammars working on strings are generalized to grammars working on trees. Thus we have a natural counterpart to the Chomsky hierarchy: regular tree grammars correspond to the known regular grammars and context-free tree grammars to the context-free grammars.
We now formally introduce the notion of a context-free tree grammar (CFTG). This type of grammar is related to a type of grammars which were defined by Fisher [10] and which were called macro grammars. In his setting, the use of macro-like productions served the purpose of making simultaneous

string copying a primitive operation. CFTGs constitute an algebraic general- ization of macro grammars (cf. Rounds [31]).
Let us view grammars as a mechanism in which local transformations on trees can be performed. The central ingredient of a grammar is a finite set of productions, where each production is a pair of trees. Such a set of productions determines a binary relation on trees such that two trees t and t' stand in that relation if t' is the result of removing in t an occurrence of a first component in a production pair and replacing it by the second component of the same pair. The simplest type of such a replacement is defined by a production that specifies the substitution of a single-node tree t0 by another tree t1. Two trees t and t' satisfy the relation determined by this simple production if the tree t' differs from the tree t in having a subtree t1 that is rooted at an occurrence of a leaf node t0 in t. In slightly different terminology, productions of this kind incorporate instructions to rewrite auxiliary variables as a complex symbol that, autonomously, stands for an element of a tree algebra. Recall that in context-free string grammars a nonterminal auxiliary symbol is rewritten as a string of terminal and nonterminal symbols, independently of the context in which it occurs. As long as the carrier of a tree algebra is made of constant tree terms the process of replacing null-ary variables by trees is analogous.
As we will see, the situation changes dramatically if the carrier of the algebra
is made of symbolic counterparts of derived operations and the variables in production rules range over these second-level entities.
Definition 2.3 (Context-Free Tree Grammar) Let £ be a singleton set of sorts. Then a context-free tree grammar (CFTG) for £ is a 5-tuple Γ = 
⟨Σ, F, S, X, P⟩, where Σ and F are ranked alphabets of inoperatives and op- eratives over £, respectively. S ∈ F is the start symbol, X is a countable set of variables, and P is a set of productions. Each p ∈ P is of the form F (x1, ··· , xn) —→ t for some n ∈ N, where F ∈ Fn, x1, ··· , xn ∈ X, and t ∈ T (Σ ∪ F, {x1, ··· , xn}).
Intuitively, an application of a rule F (x1,..., xn) → t “rewrites” a tree rooted in F as the tree t with its respective variables substituted by F ’s daughters.
A CFTG Γ = ⟨Σ, F, S, X, P⟩ with Fn = ∅ for n /= 0 is called a regular tree grammar (RTG). Since RTGs always just substitute some tree for a leaf- node, it is easy to see that they can only generate recognizable sets of trees, a forteriori context-free string languages [22]. If Fn is non-empty for some n /= 0 , that is, if we allow the operatives to be parameterized by variables, however, the situation changes. CFTGs in general are capable of generating sets of structures, the yields of which belong to the subclass of context-sensitive languages known as the indexed languages. In fact, CFTGs characterize the class of indexed languages modulo the inside-out derivation mode [31].
For reasons having to do with the impossibility of mirroring the process of copying in a grammar with a completely uncontrolled derivation regime, we restrict ourselves to this particular mode of derivation. Accordingly, a function

symbol may be replaced only if all its arguments are trees over the terminal alphabet. In the conventional case this form of replacement mechanism would correspond to a “rightmost” derivation where “rightmost” is to be understood with respect to the tree order.
The definition of a CFTG given above could be canonically generalized to the case of many-sorted signatures Σ and F over some set of sorts £. Since we will be concerned with such generalized versions of CFTGs only in their regular form, we will not give a new definition but rely on the definition of a many-sorted alphabet in Section 2.1 and reader’s intuition.
Finally, since we need to show how to handle TAGs within the framework of CFTGs, we also define monadic context-free tree grammars (MCFTGs). Since they are only a simplification of Definition 2.3, we outline only the differences here.
Definition 2.4 (Monadic Context-Free Tree Grammar) Given a set of sorts £, a monadic context-free tree grammar (MCFTG) for a set of sorts £ is a 5-tuple Γ = ⟨Σ, F0 ∪ F1, S, X, P⟩, i.e., a CFTG, where all the rules in P are of one of the following “unary” types (A, B, C, Bi ∈ F1 ∪ F0, 1 ≤ i ≤ n, a ∈ Σ, x ∈ X):
A —→ a
A —→ B(C)
A(x) —→ a(B1,..., Bi−1, xi, Bi+1,..., Bn)
A(x) —→ B1(B2(... Bn(x) ... ))

Interestingly, it has been shown by M¨onnich [24] and Fujiyoshi and Kasai
[12] that TAGs are weakly equivalent to this restricted form of CFTGs. To a large extend, the intuition behind the proof is fairly simple. Since CFTGs can insert multiple subtrees in a single step, but TAGs only a single one, all we have to do is limit the operative nonterminals of the CFTG to unary or monadic ones.
Since the proof is constructive, i.e., there exists an algorithm to transform any given TAG into an equivalent monadic CFTG, we will silently assume in the following sections that it is enough to deal with (M)CFTGs.
As an example, we present an MCFTG ΓT AG for anbncndn generating the same language as the TAG grammar GT AG given in Example 2.2.

Example 2.5 Consider the MCFTG ΓT AG = ⟨{a, b, c, d, ε, St, S0}, {S, S', S1, S2, a, b, c, d}, S', {x}, P⟩ resulting from a translation of the TAG GT AG with P given as follows
S' —→ S(ε)	a —→ a S(x) —→ S1(S(S2(x)))	b	—→ b
S(x) —→ S0(x)	c	—→ c

S1(x) —→ St(a, x, d)	d	—→ d
S2(x) —→ St(b, x, c)

A corresponding derivation of the string abbccdd is shown in Figure 2. The example derivation is somewhat longer than the one given for the almost identical TAG grammar generating the same language. This is due to the fact that we need nonterminals to introduce each branching of the resulting tree separately. In the first step, we simply rewrite the start symbol. In the second one, the symbol S with the term S1(S(S2(x))) where the (degenerate) tree ε is
simply appended to the only argument position x of S2. This step is repeated
before we terminate with an application of the rule rewriting S as S0. We simplified the presentation in the sense that in this last step we also applied the rules for the “barred” operatives, i.e., we replaced each Si, i ∈ {1, 2} with the corresponding term and each s ∈ {a, b, c, d} with s.
 
1	t

 	 
1	1


S	S	S
S0 =)	=)	=)	=)
 	 
2	2

  2

"





b

t

St

c

b	"	c

Fig. 2. An example derivation of the MCFTG ΓT AG from Example 2.5

Lifting
We designate the process which makes the control information inherent in term based grammar formalisms explicit by the term lifting. The intuition here is that the basic assumptions about the operations of tree substitution and argument insertion are made explicit. We make them visible by inserting the “control” information which allows us to code the resulting structures with regular means, i.e., regular tree grammars or finite-state tree automata and therefore with MSO logic.

lifting CFTGs
The intuition behind the lifting process is that each term compactly encodes information such as composition and concatenation.
Any context-free tree grammar Γ for a singleton set of sorts £ can be transformed into a regular tree grammar ΓL for the set of sorts £∗, which
characterizes a (necessarily recognizable) set of trees encoding the instruc- tions necessary to convert them by means of a unique homomorphism h into the ones the original grammar generates [21]. This “lifting” is achieved by

constructing for a given single-sorted signature Σ a new, derived alphabet (an N-sorted signature) ΣL, and by translating the terms over the original signature into terms of the derived one via a primitive recursive procedure. The lift-operation takes a term in T (Σ, Xk) and transforms it into one in T (ΣL, k). 6 Intuitively, the lifting eliminates variables and composes func- tions with their arguments explicitly, e.g., a term f (a, b) = f (x1, x2) ◦ (a, b) is
lifted to the term c(c(f, π1, π2), a, b). The old function symbol f now becomes a constant, the variables are replaced with appropriate projection symbols and the only remaining non-nullary alphabet symbols are the explicit composition symbols c.
Definition 3.1 (lift) Let Σ be a ranked alphabet and Xk = {x1,..., xk}, k ∈
N, a ﬁnite set of variables. The derived N-sorted alphabet ΣL is deﬁned as
follows: For each n ≥ 0, Σ'	= {f' | f ∈ Σn} is a new set of symbols of type

⟨ε, n⟩; for each n ≥ 1 and each i, 1 ≤ i ≤ n, πn
is a new symbol, the ith

projection symbol of type ⟨ε, n⟩; for each n, k ≥ 0 the new symbol c(n,k) is the (n, k)th composition symbol of type ⟨nk1 ··· kn, k⟩ with k1 = ··· = kn = k. The set of all c(n,k) will be denoted by C, the set of all πn by Π.


L
ε,0
L
ε,n
'
ε,0
'
ε,n


∪ {πn | 1 ≤ i ≤ n} for n ≥ 1



L
nk1···kn,k

L
w,s
= {c(n,k)} for n, k ≥ 0 and ki = k for 1 ≤ i ≤ k
= ∅ otherwise

For k ≥ 0, liftΣ : T (Σ, Xk) → T (ΣL, k) is deﬁned as follows:
liftΣ(xi) = πk
k	i
liftΣ(f ) = c(0,k)(f')  for f ∈ Σ0
liftΣ(f (t1,..., tn)) = c(n,k)(f', liftΣ(t1),..., liftΣ(tn))
k	k	k
for n ≥ 1,f ∈ Σn and t1,..., tn ∈ T (Σ, Xk)

Note that this very general procedure allows the translation of any term over the original signature. The left hand side as well as the right hand side (RHS) of a rule of a CFTG Γ = ⟨Σ, F, X, S, P⟩ is just a term belonging to T (Σ ∪ F, X), but so is, e.g., any structure generated by Γ.
Further remarks on the observation that the result of lifting a CFTG is always an RTG can be found in Mo¨nnich [25].

6 Since £ is a singleton, we can identify S∗ with N. By T (ΣL, k) we denote the set of all trees over ΣL which are of sort k.

Lifting MCFTGs uses the same definitions for lifting as is used for gen- eral CFTGs. The translation process for grammars has at its heart the lift- morphism for the translation of the alphabets of the operatives and inopera- tives and the RHSs of the production rules. Since the rest of the translation follows trivially from this, we dispense with a formal definition. Note that for better readability, we omit all the 0- and 1-place composition symbols. To further illustrate the techniques, we present the continuation of Example 2.5.

 		

Example 3.2 Let ΓL
with P given as follows
= ⟨{a, b, c, d, ε, St, S0}, {S, S', S1, S2, a, b, c, d}, S', P⟩

S' —→ c(1,0)(S, ε)
S —→ c(1,1)(S1, c(1,1)(S, c(1,1)(S2, π1)))
S —→ c(1,1)(S0, π1)
t	1
S1 —→ c(3,1)(St, a, π1, d)
S2 —→ c(3,1)(St, b, π1, c)


Note that we now have only null-ary operatives but extra composition and projection symbols.
We parallel the derivation given in Figure 2 with the new grammar as given in Figure 3. Note that nonterminals are now simply replaced by entire subtrees and no extra insertions take place.

Coding the lifted Structures
In the previous section we have shown how to code the non-CF structures with regular tree grammars via lifting. In the next section, we will show how to code RTGs themselves with finite-state tree automata (FSTAs) and MSO logic.

Tree Automata

Since ΓL
in (3.2) generates a regular set of trees, we can construct a tree

automaton A L
TAG
= ⟨Q, Σ, δ, q0, Qf ⟩ to recognize this set.

Recall that a (deterministic) bottom-up tree automaton (FSTA) A is a 5-
tuple ⟨A, Σ, δ, a0,F⟩ with A the (finite) set of states, Σ a ranked alphabet,
a0 ∈ A the initial state, F ⊆ A the final states and δ :	n(An × Σn) → A the transition function.
We can extend the transition function inductively to trees by defining hδ(ε) = a0 and hδ(σ(t1,..., tn)) = δ(hδ(t1),..., hδ(tn), σ), ti ∈ TΣ, 1 ≤ i ≤ n, σ ∈ Σn. An automaton A accepts a tree t ∈ TΣ iff hδ(t) ∈ F . The language recognized by A is denoted by T (A) = {t | hδ(t) ∈ F}.

c(1;0)

c(1;0)	"




S =)

c(1;0)
=)
S	"
c(1;1)

  1


c(1;1)


"	1

=)


(1;1)


(1;1)	=)


S	c(1;1)
1	c(1;1)	2	1

2	1	c(1;1)
c(1;1)

S0   1		1
t	1	1
c(1;0)
c(1;1)	"


c(3;1)

S	a  1 d 1


St




c(3;1)


c(1;1)


d	c(1;1)




c(1;1)

c(1;1)




c(1;1)




c(3;1)

St


c(1;1)
 1
1

c

1

S0   1
t	1
St
1
c(3;1)	 1

1  c

Fig. 3. An example derivation of the lifted MCFTG ΓL	given in Example 3.2

Intuitively, such a tree automaton starts on the leaves of a tree in an initial state and then moves toward the root by making transitions according to the states “labeling” the daughters and the alphabet symbol labeling the mother. Construction of a tree automaton from a given lifted context-free tree grammar ΓL = ⟨ΣL, FL, S', PL⟩, i.e., an RTG, is straightforward. Since tree automata recognize only local trees in each transition, we have to use auxiliary 
transitions for RHSs of lifted macro productions consisting of trees of depth
greater than one in order to recognize the correct trees incrementally. So, what we are doing is to decompose the RHSs into trees of depth one which then can be recognized by a transition, i.e., in a preliminary step we have to transform ΓL into a normal form ΓNF = ⟨ΣL, FNF , S', PNF ⟩ via the introduction of aux- iliary rules and new nonterminals. In our example, the lifted tree grammar is not in the desired normal form, but it is easy to see how to change this. The resulting rules and nonterminals are reflected both in the new transitions and
in the states we need. In the following, we assume without loss of generality, that the trees on the RHSs of the lifted macro productions are of depth one. Recall furthermore that, according to the definition above, a tree automa-
ton operates on a ranked alphabet Σ = ⟨Σn | n ∈ N⟩. Therefore, in our case, we use the inoperative symbols of the lifted grammar to construct Σ, but we reduce the explicit many-sorted type information by defining Σn as
{σ ∈ ΣL | rank(σ) = n}.  For the set of states Q, we need distinguishable

states for each of the terminals, nonterminals and projection symbols appear-
ing in RHSs of the rules, i.e., Q = {qσ | σ ∈ ΣL ∪ FNF }∪ {q0}. 7 Furthermore,
we need a new initial state q0. In the automaton, the state which corresponds
to the start symbol S' of the grammar becomes the single final state, i.e.,
Qf = {qS'}.
Since our tree automata work bottom up, we have to start the processing at the bottom by having transitions from the new initial state to a new state encoding the fact that we read a particular symbol on the frontier of the tree. Accordingly, together with the transitions encoding the productions, we have to construct two kinds of transitions in δ:
transitions from the initial state on all subtrees reading a terminal σ, i.e., elements of all the Σi from Γ, to the corresponding state; i.e., q0 × σ → qσ;
transitions recognizing the internal structure of the local trees appearing in RHSs, i.e., from the states corresponding to the leaves of a tree on a RHS to the nonterminal D of the left hand side, i.e., for each lifted tree grammar production of depth one D —→ c(d1,..., dn) we have to construct a transition in the automaton as follows: qd1 × ··· × qdn × c → qD.

MSO Logic
Alternatively, we can also code RTGs with MSO logic. The standard way of doing this requires that we first construct the corresponding tree automaton.
In Thomas [33] tree automata are converted to formulas in MSO logic by basically encoding their behaviour.	Under the assumption that Q =

{0,..., m} with q0 = 0, the (closed) Σ1-formula ϕA
given there adapted to

1	ΓL
TAG
our signature and for maximally 4-ary tree automata reads as given below. 8
Intuitively, the sets Xi label the tree where the automaton assumes state
i. The first two lines of the formula say that we cannot have a node which is in two states and that X0 is our “initial” set; the third one licenses the distribution of the sets according to the transitions and the last one says that we need a root node which is in a “final” set.



ϕAΓL
TAG
def
⇐⇒ (∃X0,..., Xm)[
i/=j
(¬∃y)[y ∈ Xi ∧ y ∈ Xj] ∧
(∀x)[leaf(x) → x ∈ X0]

(∀x1,..., xl, y)[ 
xk ∈ Xik ∧ y ✁ xk ∧ y ∈ Xj ∧ y ∈ Pσ]

1≤l≤4
(i1,...,il,σ,j)∈δ 1≤k≤l

 
i∈Qf
(∃x∀y)[x ✁∗ y ∧ x ∈ Xi]

7 We do not need states for the composition symbols since each composition corresponds to a nonterminal due to the normal form.

8	stands for the predicate labeling a node with the symbol a and leaf(x) def
(¬∃y)[x✁y].

In Kolb et al. [19] we also propose a way of directly coding the behaviour of the RTG with logical formulas. Since this does not contribute anynew insights the interested reader is referred to the earlier paper for further information.

Reconstructing lifted (M)CFTGs
Unfortunately, the terminal trees in Figure 3 generated/recognized by the

grammar ΓL
given in the Example 3.2, don’t seem to have much in common

with the structures linguists want to talk about, i.e., the ones in Figure 2.
However, in some sense to be made operational, the lifted structures contain the intended structures. As mentioned before, there is a mapping h from these explicit structures onto structures interpreting the compositions (the c’s) and the projections (the π’s) the way the names we have given them suggest, viz. as compositions and projections, respectively, which are, in fact, exactly the intended structures.
On the denotational side, we can implement the mapping h with an MSO definable tree transduction (as defined in Courcelle [5]) and on the opera- tional side with both tree-walking automata (FSTWA, see [2]) and Macro Tree Transducer (MTT, see [8]) to transform the lifted structures into the intended ones. In this paper, we will focus on the logical transduction.
Let us restate our goal then: Rogers [29] has shown the suitability of an

MSO description language L2
for linguistics which is based upon the prim-

itive relations of immediate (✁), proper (✁+) and reflexive (✁∗) dominance
and proper precedence (≺). We will show how to define these relations with an MSO transduction built upon finite-state tree-walking automata (FSTWA) thereby implementing the unique homomorphism mapping the terms into ele- ments of the corresponding context-free tree language, i.e., the trees linguists want to talk about.
Put differently, it should be possible to define a set of relations RI =
{(, (+, (∗ (dominance), c-command, q (precedence),.. .} holding between the nodes n ∈ NL of the explicit or lifted tree TL which carry a “linguistic” label L in such a way, that when interpreting (∗ ∈ RI as a tree order on the set of “linguistic” nodes and q ∈ RI as the precedence relation on the resulting structure, we have a “new” description language on the intended structures.
As mentioned before, we will use an MSO definable tree transduction to transform the lifted structures into the intended ones. The core of this trans- duction will be the definition of the new relations via tree-walking automata.
To do so, it is helpful to note a few general facts (illustrated in Figure 4 with another rendering of the last tree of the derivation given in Figure 3, [17]):
Our trees—that contain no substitutable elements from F0 any more— feature three families of labels: the “linguistic” symbols, i.e., the lifted
in-operatives of the underlying macro-grammar, L = lift(	Σn); the

c(1;0)













Fig. 4. Intended relations on a lifted structure: MCFTGs

“composition” symbols C = {c(n,k)}, n,k ≥ 0; and the “projection” sym- bols Π.
All non-terminal nodes in TL are labeled by some c(n,k) ∈ C. This is due to the fact that the “composition” symbols are the only non-terminals of a lifted grammar. No terminal node is labeled by some c(n,k).
The terminal nodes in TL are either labeled by some “linguistic” symbol or by some “projection” symbol πi ∈ Π.
Any “linguistic” node dominating anything in the intended tree is on some left branch in TL, i.e., it is the left-most daughter of some c(n,k) ∈ C. This lies in the nature of composition: c(n,k)(x0, x1,..., xn) evaluates to x0(x1,..., xn).
For any node p labeled with some “projection” symbol πi ∈ Π in TL there is a unique node µ (labeled with some c(n,k) ∈ C by (ii.)) which properly dominates p and whose i-th sister will eventually evaluate to the value of π. Moreover, µ will be the first node properly dominating p which is on a left branch. This crucial fact is arrived at by an easy induction on the construction of ΓL from Γ.
By (iv.) it is not hard to find possible dominants in any TL. It is the problem of determining the actual “filler” of a candidate-dominee which is at the origin of the complexity of the definition of (. There are three cases to account for:
If the node considered carries a “linguistic” label, it evaluates to itself;
if it has a “composition” label c(n,k), it evaluates to whatever its function symbol—by (iv.) its leftmost daughter—evaluates to;
if it carries a “projection” label πi, it evaluates to whatever the node it

“points to”—by (v.) the ith sister of the first C-node on a left branch dominating it—evaluates to.
Note that cases (vii.) and (viii.) are inherently recursive such that a simple MSO definition will not do.

Reconstruction with FSTWAs
In general, recursive definitions in MSO may lead to undecidability and are therefore properly extending the expressive power of our logic. Fortunately, there are certain techniques to ensure that some relation R which would most naturally be defined recursively has a valid MSO definition. Still, special care has to be taken to establish that the relations defined are well-behaved in this respect. In our case this caveat applies to ( as well as to its reflexive transitive closure (∗.
Following Bloem and Engelfriet [2], we will use a (basic) tree-walking au- tomaton with node-label tests to specify the intended (immediate) dominance relation on lifted trees (indicated in Figure 4 with solid green lines), thus
showing in passing that it is a regular tree node relation which is indeed MSO definable.
Intuitively, those automata—which are a variation of the tree-walking au- tomata introduced in Aho and Ullman [1]—make transitions from nodes in a tree to other nodes along its branches. Each single transition can either test a label of a node, move up in the tree or down to a specific daughter.
A tree-walking automaton (with tests) over some ranked alphabet Σ is a finite automaton A = (Q, ∆, δ, I,F ) with states Q, directives ∆, transitions δ : Q × ∆ → Q and the initial and final states I ⊆ Q and F ⊆ Q which
traverses a tree along connected edges using three kinds of directives: ↑i— “move up to the mother of the current node (if it has one and it is its i-th daughter)”, ↓i—“move to the i-th daughter of the current node (if it exists)”, and ϕ(x)—“verify that ϕ holds at the current node”.
For any tree t, such an automaton A computes a node relation

Rt(A) = {(x, y) | (x, qi) =⇒ (y, qf ) for some qi ∈ I and qf ∈ F}

where for all states qi, qj ∈ Q and nodes x, y in t (x, qi) =⇒ (y, qj) iff ∃d ∈ ∆ : (qi, d, qj) ∈ δ and y is reachable from x in t via d. Note that x is reachable from itself if the directive was a (successful) test.
It is important not to confuse this relation with the walking language rec- ognized by the automaton, i.e., the string of directives needed to come from the initial to the final node in a path.
If all the tests ϕ(x) of A are definable in MSO logic, A specifies a regular tree-node relation. Bloem and Engelfriet [2], who should be consulted for details, prove that any regular tree-node relation is itself MSO definable and provide a general translation of A into an MSO formula. We, however, will

not exploit the full power of the definition: a basic tree-walking automaton restricting ϕ to simple tests of node labels (which are trivially MSO definable via the membership relation) is sufficient for our purposes.
We define A{ = (Q, ∆, δ, I,F ) with states Q, directives ∆, transitions δ and the initial and final states I ⊆ Q and F ⊆ Q, respectively, as given graphically in Figure 5. Construction of the automaton is based upon the careful analysis of the trees involved as given above. Basically, we have to “undo” the lifting process by associating the old function symbols, i.e., the intended interior nodes, via the composition symbols with their respective daughters. So it basically implements the facts we presented in (vi.) to (viii.) above.

Fig. 5. The FSTWA for dominance on intended structures: MCFTGs

The automaton works as follows: First of all, if it can read a “linguistic” label on the node it started in and if that node is the first (leftmost) daughter, it goes to one of its sisters. Then depending on the case it is in, it “reads” a linguistic label and halts, or reads a composition symbol and finds the leftmost daughter, or it reads a projection symbol and finds the corresponding node by walking upward until it is on a leftmost daughter and then goes on to finding the second sister. This automaton is universal for MCFTGs. 9
However, there is another interpretation of such a tree-walking automaton. Viewed as an ordinary FSA over the alphabet of directives ∆, A recognizes
a regular (string-) language, the walking language W . In our case it is the
walking-language W{ = L(x) · ↑1 · (↓2 ∪ ↓3 ∪ ↓4) · (	WΠ ∪ WC)∗ · L(x)
i

9 The automaton is also universal for CFTGs in the sense that the only variable part it contains is the number of projection functions we have to deal with, i.e., the number of the needed “triangles” in the lower part of the automaton.

with
WC = C(x) · ↓1
WΠ = Πi(x) · (↑2 ∪ ↑3 ∪ ↑4)∗ · ↑1 · ↓i+1
which is finally translated into an MSO-formula transW{ (x, y). For an example of such a translation, see [27].
For the case of the recursion inherent in reflexive dominance a standard solution exists in MSO logic on finite trees. It is a well-known fact [4] that the reflexive transitive closure R∗ of a binary relation R on nodes is (weakly) MSO-definable, if R itself is. This is done via a second-order property which holds of the sets of nodes which are closed under R:
def
R-closed(X) ⇐⇒ (∀x, y)[x ∈ X ∧ R(x, y) → y ∈ X]
Now, for any node n, the intersection of all such sets which contain n is exactly the set of m, such that R∗(n, m). Since we are dealing with the (necessarily finite) trees generated by a context-free grammar, this construction can be safely exploited for our purposes;
Similarly to the tree-walking automaton for dominance, we also have to construct a tree-walking automaton for the intended precedence relation. Since the RTGs in all the examples we have given are linear RTGs, i.e, they do not use a variable more than once on any RHS, we can present the definition for precedence in two steps as follows.
The first step is defined with an FSTWA which encodes the immediate precedence relations. Then we define precedence following the same reasoning as before, namely as proper precedence, based upon the definition of immedi- ate precedence.
Looking at the example in Figure 4, what can we observe concerning prece- dence? The linguistically labeled terminals seem to appear in the right order such that precedence reduces to sisterhood. But what happens to the in- tended interior nodes? And how do we have to treat the projection nodes? The answer appears to be simple: the nonterminals have to be inserted for the “right” projection symbols and then precedence is reducible to sisterhood. But finding the correct projection symbol for a filler is non-trivial.
The FSTWA given in Figure 6 basically consists of two parts: the first part deals with those cases where the nodes which are labeled with a linguistic label are already sisters, i.e., the intended terminal nodes, or have a node labeled with a projection node as sister, i.e., they precede a nonterminal. Between them we simply have an immediate precedence relation which, in the case of a projection node, has to be found via a further traversal of the tree. In Figure 6 those nodes are identified bygoing up a non-leftmost branch, and then by descending to the non-leftmost sisters. If the node found bears a linguistic label, we are done. If it bears a projection symbol, we proceed analogously to the definitions for dominance, i.e., go up until we find a leftmost node and



Fig. 6. The FSTWA for precedence on intended structures: MCFTGs

then go to down the right branch.
The situation is complicated by the fact that every node with a linguistic label at the same time is a potential filler for a projection node. 10 Basically, we have to reverse the process which finds a filler for a projection node. But since a projection line can consist of several projection nodes, how do we know when to stop? The FSTWA ensures that the relevant projection nodes for a filler are found by recursively looking up and then down a tree. The nodes bearing a linguistic label which are on a leftmost branch have to look upwards on leftmost branches until they find the first right branch. At this point they have to descend again into the subtree to find the projection node. This is achieved by repeatedly going down non-leftmost branches as long as there are composition nodes on the way and testing for a projection node. If we find one, we can start computing its sisters. If it doesn’t have any, it starts the entire process recursively. The resulting relation will be indicated by qimm and the corresponding formula generated by the procedure outlined previously 
trans	.
imm
We are now in a position to complete the definition of precedence by using
the definition of immediate precedence. As usual, two nodes stand in the precedence relation if they either stand in the immediate precedence relation or if they are dominated by nodes which stand in the immediate precedence

10 In this particular example, where we have only one projection node, the only potential fillers will either be a second daughter, or the leftmost daughter of a composition node which is a right daughter.

relation:


⇐⇒ (∃u, v)[u (∗
x ∧ v (∗
y ∧ transWq


imm
(u, v)]



Reconstruction with MSO Transductions
Now we can turn to the definition of the transduction via MSO logic. Since we did the necessary preparatory work with the presentation of the needed tree-walking automata, we are almost done.
Let R be a finite set of relation symbols with the corresponding arity for each r ∈ R given by ρ(r). A relational structure R = ⟨DR, (rR)r∈R⟩ consists of the domain DR and the ρ(r)-ary relations rR ⊆ Dρ(r). We can code trees as relational structures by taking a tree domain as the domain DRw,A of the structure and defining suc as the corresponding tree order.
The classical technique of interpreting a relational structure within another one forms the basis for MSO transductions. Intuitively, the output tree is interpreted on the input tree. E.g., suppose that we want to transduce the input tree t1 into the output tree t2. The nodes of the output tree t2 will be a subset of the nodes from t1 specified with a unary MSO relation ranging over the nodes of t1. The daughter relation will be specified with a binary MSO relation with free variables x and y ranging over the nodes from t1.
Definition 5.1 [MSO transduction] Let R and Q be two finite sets of ranked relation symbols. A (non-copying) MSO transduction of a relational structure R (with set of relation symbols R) into another one Q (with set of relation symbols Q) is defined to be a tuple (ϕ, ψ, (θq)q∈Q) consisting of an MSO for- mula ϕ defining the domain of the transduction in R, an MSO formula ψ defining the resulting domain of Q, and a family of MSO formulas θq defining the new relations Q using only definable formulas from the “old” structure R, i.e., for α a variable assignment,

DQ = {d ∈ DR | (R, d) |= ψ[α]}

and for each q ∈ Q


qQ = {(d1,..., dn) ∈ Dn
| (R, d1,..., dn) |= θq[α]} where n = ρ(q)


Note that the transduction is only defined if ϕ holds.
Using the defined formulas for ( and q, the specific MSO transduction we need to transform the lifted structures into the intended ones simply looks as follows:


(ϕ, ψ, (θq)q∈Q)

Q = {(, (∗, (+, q,... }

ϕ ≡ ϕA L
TAG
ψ ≡ L(x)
θ{(x, y) ≡ transW{ (x, y)
θ{∗ (x, y) ≡ (∀X)[(-closed(X) ∧ x ∈ X → y ∈ X] θ{+ (x, y) ≡ x ( y ∨ x /≈ y
θq(x, y) ≡ x q y
θlabels ≡ taken over from R
As desired, the domain of the transduction is characterized by the MSO for- mula for the lifted trees (see Section 4). The domain, i.e., the set of nodes, of the intended tree is characterized by the formula ψ which identifies the nodes via the “linguistic” labels. Building on it, we define the other primitives of

our description language analogous to L2
with the given FSTWAs.

Note that while standard “linguistic” relations like c-command or gov- ernment would be defined in terms of dominance, our approach allows the alternative route of taking, in the spirit of Frank and Vijay-Shanker [11], c- command as the primitive relation of linguistic structure by defining, in a similar fashion, an FSTWA which computes the intended c-command relation directly, without recourse to dominance.

Conclusion
All the constructions that have been cited as evidence for the need of assuming context-sensitive grammatical devices for the description of natural languages seem to be amenable to an analysis within the framework of context-free tree grammars or multiple context-free grammars [18,20,23,26,27]. Based on the Mezei-Wright result [22] according to which structural accounts of the context-free tree level can be lifted to the regular tree level where composition and projection occur as explicit node labels, the paper has focused on a fine- grained analysis of the process connecting the initial level of explicit trees with the intended level of context-free or macro trees. In accordance with the three types of classical approaches in formal language theory we have provided logical, grammatical and automata-theoretic characterizations of the homomorphism relating the initial tree algebra of terms to the substitution algebra of macro terms. Along the way first steps were taken in the direction of “reverse” linguistics. For the contemporary natural language formalism of

Tree Adjoining Grammar it has been shown how to accommodate the main ideas within the algebraic framework outlined above.
Comparing this statement of the result of the paper with the characteri- zation of context-free graph languages by Engelfriet and van Oostrom [9], we want to stress the point that our logical description of (M)CFTG languages does not provide a characterization of this language family in the technical understanding of an equivalence between MCFTG languages and languages defined by a regular tree language/closed MSO formula and a macro tree transducer/MSO transduction. For a recent result on the equivalence between regular tree languages followed by an MSO definable tree transduction and the tree languages generated by context-free graph grammars see Engelfriet and Maneth [8].

References
Aho, A. V. and J. D. Ullman, Translations on a context-free grammar, Information and Control 19 (1971), pp. 439–475.
Bloem, R. and J. Engelfriet, Characterization of properties and relations deﬁned in Monadic Second Order logic on the nodes of trees, Technical Report 97-03, Dept. of Computer Science, Leiden University (1997).
Bu¨chi, J. R., Weak second-order arithmetic and ﬁnite automata, Z. Math. Logik Grundlag. Math. 6 (1960), pp. 66–92.
Courcelle, B., Graph rewriting: An algebraic and logic approach, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Handbook of Theoretical Computer Science B, Elsevier, 1990 pp. 193–242.
Courcelle, B., The expression of graph properties and graph transformations in monadic second-order logic, in: G. Rozenberg, editor, Handbook of Graph Grammars and Computing by Graph Transformation. Vol. I: Foundations, World Scientific, 1997 pp. 313–400.
Doner, J. E., Tree acceptors and some of their applications, J. Comput. System Sci. 4 (1970), pp. 406–451.
Elgot, C. C., Decision problems of ﬁnite automata design and related arithmetics, Trans. Amer. Math. Soc. 98 (1961), pp. 21–51.
Engelfriet, J. and S. Maneth, Macro tree transducers, attribute grammars, and MSO deﬁnable tree translations, Information and Computation 154 (1999),
pp. 34–91.
Engelfriet, J. and V. van Oostrom, Regular description of context-free graph languages, Journal Comp. & Syst. Sci. 53 (1996), pp. 556–574.
Fischer, M. J., Grammars with macro-like productions, in: Proceedings of the 9th Annual Symposium on Switching and Automata Theory, IEEE, 1968, pp. 131–142.

Frank, R. and K. Vijay-Shanker, Primitive c-command (1998), ms., Johns Hopkins University & Universtiy of Delaware.
Fujiyoshi	and	Kasai,	Spinal-formed context-free tree grammars,	MST: Mathematical Systems Theory 33 (2000).
Joshi, A. K., Tree adjoining grammars: How much context-sensitivity is required to provide reasonable structural description, in: D. Dowty, L. Karttunen and
A. Zwicky, editors, Natural Language Parsing, Cambridge University Press, Cambridge, UK, 1985 pp. 206–250.
Joshi, A. K., An introduction to tree adjoining grammars, in: Manaster-Ramer, editor, Mathematics of Language, John Benjamins, Amsterdam, 1987 .
Joshi, A. K., L. S. Levy and M. Takahashi, Tree adjunct grammars, Journal of Computer and System Sciences 10 (1975), pp. 136–63.
Joshi, A. K. and Y. Schabes, Tree adjoining grammars, in: G. Rozenberg and
A. Salomaa, editors, Handbook of Formal Languages, Handbook of Formal Languages 3: Beyond Words, Springer, Berlin, 1997 pp. 69–123.
Kolb, H.-P., Macros for minimalism? Towards weak descriptions of strong structures, in: H.-P. Kolb and U. Mo¨nnich, editors, Mathematics of Syntactic Structure: Trees and Their Logics, Studies in Generative Grammar 44, Mouton- de Gruyter, 1999 .
Kolb, H.-P., J. Michaelis, U. Mo¨nnich and F. Morawietz, An operational and denotational approach to non-context-freeness (2000), to appear in: Theoretical Computer Science, Elesevier Science. Draft available under http://tcl.sfs. uni-tuebingen.de/~frank/.
[19] Kolb, H.-P., U. Mo¨nnich and F. Morawietz, Logical description of cross-serial dependencies, in: Proceedings of the Workshop Finite Model Theory and its Applications at FloC ’99, Trento, Italy, 1999.
Kolb, H.-P., U. Mo¨nnich and F. Morawietz, Descriptions of cross-serial dependencies, Grammars 3 (2000), pp. 189–216.
Maibaum, T. S. E., A generalized approach to formal languages, J. Comput. System Sci. 88 (1974), pp. 409–439.
Mezei, J. and J. B. Wright, Algebraic automata and contextfree sets, Information and Control 11 (1967), pp. 3–29.
Michaelis, J., U. M¨onnich and F. Morawietz, On minimalist attribute grammars and macro tree transducers (2000), to appear in: Linguistic Form and its Computation, Ch. Rohrer, A. Rossdeutscher, H. Kamp (eds), CSLI. Draft available under http://tcl.sfs.uni-tuebingen.de/~frank/.
Monnich, U., Adjunction as substitution, in: G.-J. M. Kruijff, G. Morill and
R. Oehrle, editors, Formal Grammar ’97, Aix-en-Provence, 1997, pp. 169–178.

M¨onnich, U., On cloning contextfreeness, in: H.-P. Kolb and U. Mo¨nnich, editors, The Mathematics of Syntactic Structure, number 44 in Studies in Generative Grammar, Mouton de Gruyter, 1999 pp. 195–229.
M¨onnich, U., Regular Description of HPSG (2001), ms, Universita¨t Tu¨bingen.
Morawietz, F., “Two-Step Approches to Natural Language Formalisms,” Ph.D. thesis, Universit¨at Tu¨bingen (2001).
Pullum, G. K. and B. C. Scholz, On the Distinction between Model-Theoretic and Generative-Enumerative syntactic Frameworks, in: P. de Groote, G. Morill and C. Retor´e, editors, Logical Aspects of Computational Linguistics (2001),
pp. 17–43, LNAI 2099.
Rogers, J., “A Descriptive Approach to Language-Theoretic Complexity,” Studies in Logic, Language, and Information, CSLI Publications and FoLLI, 1998.
Rogers, J., A descriptive characterization of tree-adjoining languages, in:
Proceedings of COLING-ACL 98, 1998.
Rounds, W. C., Tree-oriented proofs of some theorems on context-free and indexed languages, in: Proceedings of the 2nd Annual ACM Symposium on Theory of Computing, 1970, pp. 109–116.
Thatcher, J. W. and J. B. Wright, Generalized ﬁnite automata theory with an application to a decision problem of second-order logic, Math. Systems Theory 2 (1968), pp. 57–81.
Thomas, W., Automata on inﬁnite objects, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Elsevier Science Publishers B. V., 1990 pp. 133–191.
Vijay-Shanker, K. and D. J. Weir, The equivalence of four extensions of context- free grammars, Mathematical Systems Theory 27 (1994), pp. 511–546.
