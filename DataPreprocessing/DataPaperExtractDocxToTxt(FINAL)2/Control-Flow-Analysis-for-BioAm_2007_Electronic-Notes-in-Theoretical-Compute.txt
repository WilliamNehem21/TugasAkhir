Electronic Notes in Theoretical Computer Science 180 (2007) 65–79	
www.elsevier.com/locate/entcs
Control Flow Analysis for BioAmbients1
Flemming Nielson and Hanne Riis Nielson2
Technical University of Denmark
Corrado Priami and Debora Rosa3
University of Trento

Abstract
This paper presents a static analysis for investigating properties of biological systems specified in BioAm- bients. We exploit the control flow analysis to decode the bindings of variables induced by communications and to build a relation of the ambients that can interact with each other. We eventually apply our analysis to an example of gene regulation by positive feedback taken from the literature.
Keywords: Control flow analysis, BioAmbients, gene regulation


Introduction and Motivation
Modelling of biological systems is a challenge for computer science [27]. In fact the complexity of these systems is some order of magnitude larger than the computer systems ever built. Furthermore, the modelling of dynamical behaviour of biological systems is becoming an urgent need for biologists who are trying to coherently organize the huge amount of data available in the post-genomic era. This paper is a step towards the definition of modelling environments for biologists that can assist them in the definition and analysis of complex systems.
Promising approaches based on process algebras allow to model and simulate the dynamic behaviour of molecular systems. The pioneering work on modeling biochemical systems with a calculus is [10] where a version of the λ-calculus is used. A better account of pathways descriptions is proposed by [28] via a calculus

1 This research has been funded in part by the DEGAS project (number IST-2001-32072) funded by the European Union and by the LoST project (number 21-02-0507) funded by the Danish Natural Science Research Council.
2 Email: nielson@imm.dtu.dk, riis@imm.dtu.dk
3 Email: priami@dit.unitn.it, schuch@dit.unitn.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.041

for mobility where processes represent compounds and communications represent interactions. Then, [24] enriched this model with quantitative aspects. Along the same line, we mention also the Bio-calculus proposed in [16]. A process algebra called Core Formal Molecular Biology has been recently proposed in [7]. The new calculus builds on the basic primitives of the π-calculus. As in the other language- based models mentioned above, processes represent compounds, sets of processes represent solutions, and their behaviour is given by a set of rewrite rules, driven by suitable side-conditions. The proposed rules are related to the biological realm and mimic typical reactions that occur in biochemical networks, e. g., activation, synthesis, complexation etc. Recently, Regev proposed BioAmbients [25], a variant of the Ambient Calculus [6] in which compartments are described as a hierarchy of boundary ambients. This hierarchy can be modified by suitable operations that have an immediate biological interpretation. For example, the enter primitive, that moves an ambient into a (sibling) ambient, models a compartment entry. Ambients contain compounds that interact via communications. A communication is only possible if the involved processes obey certain constraints, e. g. either they are in the same compartment (local communications), or they belong to two parallel compartments (sibling communication), or they belong to two ambients one within the other (parent-child communication). The original presentation of BioAmbients has been refined in [26,5].
All the work mentioned above describe the behaviour of molecular systems by relying on a transition system representation that can be explored to investigate the properties of interest. The main limitation of this approach is the huge size of the representation. In fact the size of the transition system is exponential in the size of the program representing the behaviour. In other words all the proposals above implement a dynamic analysis of systems. The classical alternative to dynamic analysis, when the size of the representations is too large, is static analysis [17]. It only needs the text of the program and can infer suitable properties of the behaviour of the system modelled. The technique is much more efficient, but one has to pay a loss in the precision of the properties checked. Historically, static analysis techniques have been developed in the context of optimising compilers and only within the last few years they have been successfully used for validating programs in process calculi. In the classical application domains it is customary that the complete program is available for analysis and hence the techniques have focused on closed programs. Previous work has shown that static analysis approaches can handle a variety of the necessary constructs including mobility and communication primitives as in the π-calculus [3], Mobile Ambients [20,18] and Boxed Ambients [20].
We introduce here a static approach for analysing molecular processes specified in BioAmbients. To the best of our knowledge this is the first attempt at exploiting static analysis in the biological application domain. The aim of the analysis is to keep track of the contents of the ambients and the bindings of the names that may vary when communications occur. In BioAmbients, the ambients are nameless and in order to talk about the contents of an ambient we need a way of referring to it; we shall therefore annotate the program so that we can distinguish between the various

syntactic occurrences of ambients. Using this information we build two relations describing the bindings of names and the contents of ambients. The relations are up- dated while scanning the specification and analysing the potential communications that may alter the bindings of names and the potential execution of capabilities that may change the contents of ambients. We show how the analysis works by modelling in BioAmbients an example already published in [24] and specified there in the π-calculus. The exploitation of the results of our analysis in the biological setting is immediate. For instance, we can use our analysis to establish whether two ambients may interact (e. g., a protein with a degradation factor or with another protein) or whether there exists a flow of information from one molecule to another. Due to the efficiency of the solver of the constraints of the analysis we are able to handle larger molecular networks than dynamic analysis, although our approach only suggests potential interaction. This could be a breakthrough in the analysis of complex pathways: we can build models describing the dynamic behaviour of biological systems and using our analysis technique we may (1) get faith in the models by validating their properties in relation to those already recorded in pub- lic databases and (2) provide further biological insights by establishing relations between elements that are not directly related in the available representations on public databases (e. g., EcoCyc[12], WIT [30], KEGG [22],CSNDB [11], aMAZE
[31],GeNet [13], Transfac [32],INTERACT [9], DIP [33], BIND [2],SPAD [1], and
Flynets [29]).
The paper is organized as follows. In the next section we recall the basics of BioAmbients. Section 3 introduces the analysis technique and Section 4then applies it to an example taken from the literature. We eventually draw some conclusions.

BioAmbients
BioAmbients [25,26,5] differ from Mobile Ambients [6] in two main respects:
The ambients are nameless entities although their roles may be indicated by comments. To distinguish between the various syntactic occurrences of ambients we shall annotate the ambients as in [P ]μ and we shall say that μ is the identity of the ambient [P ].
The capabilities are based on pure names n with no internal structure. Reactions are synchronous and both the object and the subject must agree on the reaction in order for it to happen; the latter is accomplished by having pairs of capabilities react with each other.
Furthermore, the set of control structures for processes is slightly larger than what is traditionally studied for Mobile Ambients in that it includes non-deterministic choice as well as a general recursion construct in the manner of CCS [15]. The syntax of the processes P and the capabilities M is given in Table 1. The move- ment capabilities of BioAmbients are based on the subject and object containing capabilities that share the same name; this is in contrast to Mobile Ambients where movement capabilities are based on identities (called ambient names) and is actually

P ::= 0	inactive process
M ::= enter n | accept n	enter movement
Table 1
Syntax of BioAmbients.


▶p P
▶s P
▶s P	▶s P '
▶s P

▶s 0
	wf	
	wf	
  wf	wf	
	wf	
▶s X

wf	s
wf
M.P
s (n)P
s P + P '
s rec X. P	wf

▶s P
▶p P
▶p P	▶p P '
▶p P

  wf 
	wf	
  wf	wf	
	wf	

p	p
wf	wf
(n)P
p
wf
Table 2
P | P '

p
p [P ]μ

s

Well-formedness predicates: ▶wf P and ▶wf P .

closer to the treatment of communication. Ignoring this difference, the enter/accept and exit/expel capabilities are analogous to the in/in and out/out capabilities of Mo- bile Ambients and its variants, Safe Ambients [14] and Discretionary Ambients [20]. There is no analogue to the open/open capabilities, rather there is a merge+/merge– construct that dissolves the boundary of one ambient and includes its contents in a sibling ambient.
The communication primitives of BioAmbients are somewhat different from those of Mobile Ambients in that they use names as channels and furthermore only names can be exchanged as a result of the communication. As with Mobile Ambi- ents, two processes can communicate if they run in parallel within the same ambient; this is called local communication. However, two processes may also communicate if they belong to ambients that are siblings. Yet another kind of communication can happen when one ambient is the child of another: a process in the child ambient may communicate with a process in the parent ambient. As with Boxed Ambients [4], this really gives rise to two kinds of communication depending on whether in- formation flows from the child to the parent or the other way. Compared to the π-calculus [15], the names of channels are used in a localised manner. The syntax is subject to a well-formedness condition that ensures that a top-level process has no free process variables and that it basically is a parallel composition of a number of processes that each is a sum of processes.  The latter condition is formalised
by the predicate ▶p  P defined in Table 2; it makes use of the auxiliary predicate
s  P holding on sums of guarded processes. The well-formedness conditions are

α-renaming of bound names and bound variables:

(n)P ≡ (m)P [m/n]
n?{p}.P ≡ n?{q}.P [q/p]
n ?{p}.P ≡ n ?{q}.P [q/p]
nˆ?{p}.P ≡ nˆ?{q}.P [q/p]
n#?{p}.P  ≡ n#?{q}.P [q/p]
rec X. P ≡ rec Y. P [Y/X]
if m ∈/ fn(P ) if q ∈/ fn(P ) if q ∈/ fn(P ) if q ∈/ fn(P ) if q ∈/ fn(P )
if Y ∈/ fv(P )

Reordering of parallel processes:	Reordering of sum processes:

P | P ' ≡ P ' | P
(P | P ') | P '' ≡ P | (P ' | P '')
P | 0 ≡ P
Scope rules for name bindings: (n)0 ≡ 0
(n1)(n2)P ≡ (n2)(n1)P
P + P ' ≡ P ' + P
(P + P ')+ P '' ≡ P + (P ' + P '')
P + 0 ≡ P

(n)(P | P ') ≡ ((n)P ) | P ' if n ∈/ fn(P ')
(n)([P ]μ) ≡ [(n)P ]μ

Table 3
Structural congruence relation: P ≡ P '.

Movement of ambients:
[(enter n. P + P ') | P '']μ1 | [(accept n. Q + Q') | Q'']μ2 → [ [P | P '']μ1 | Q | Q'']μ2
[ [(exit n. P + P ') | P '']μ1 | (expel n. Q + Q') | Q'']μ2 → [P | P '']μ1 | [Q | Q'']μ2
[(merge+ n. P + P ') | P '']μ1 | [(merge– n. Q + Q') | Q'']μ2 → [P | P '' | Q | Q'']μ1
Communication between ambients:
(n!{m}.P + P ') | (n?{p}.Q + Q') → P | Q[m/p]
(n !{m}.P + P ') | [(nˆ?{p}.Q + Q') | Q'']μ → P | [Q[m/p] | Q'']μ
[(nˆ!{m}.P + P ') | P '']μ | (n ?{p}.Q + Q') → [P | P '']μ | Q[m/p]
[(n#!{m}.P + P ') | P '']μ1 | [(n#?{p}.Q + Q') | Q'']μ2 → [P | P '']μ1 | [Q[m/p] | Q'']μ2
Execution in context:

P → Q


(n)P → (n)Q
P → Q


[P ]μ → [Q]μ
P → Q


P | R → Q | R
P [rec X. P/X] → Q


rec X. P → Q

P ≡ P ' P ' → Q' Q' ≡ Q
P → Q

Table 4 Transition relation: P → P '.

somewhat more liberal than the syntactic rules for sum and prefixing put forward in [26].
The semantics is given in the classical way using a congruence relation ≡ and a transition relation →. The congruence relation is defined in Table 3; here we write fn(P ), resp. fn(M ), for the set of free names in P , resp. M , and we write P [m/n]
for the process that is as P except that all free occurrences of n are replaced by m (subject to α-renaming of bound names). A similar notation is used for free process variables, fv(P ), and substitutions of free process variables, P [Y/X]. The transition
relation → is defined in Table 4. The following result shows that well-formedness is preserved by the transition relation (up to structural congruence):

Proposition 2.1 If ▶p
P and P → Q then there exists Q' such that ▶p
Q' and

Q' ≡ Q.	 

Analysis
The aim of the analysis is to keep track of the contents of ambients and the bindings of names; it amounts to an adaptation of ideas presented in [20]. We shall refer to the ambients by their identities as specified by the syntactic annotations of the process. In the examples we shall be careful and introduce unique identities but this is not crucial for our approach: if two syntactically distinct ambients get the same identity it only means that the analysis will not be able to distinguish between them and hence will not be as precise as it could have been. In the rather simple analysis developed here we shall write Ambient for the set of ambient identities and assume that it is finite. As the names are subject to α-renaming they cannot be used to carry information in the analysis. The usual way to circumvent this problem is to assume that each name n has a canonical name written [n♩,and then assume that canonical names are preserved under α-renaming, i. e. that [n♩ = [m♩. resp. [p♩ = [q♩, holds for the α-renaming clauses of Table 3. We shall write Name for the set of canonical names and once more assume that it is finite. Canonical capabilities are then capabilities using canonical names rather than names; we write Cap for those. The analysis keeps track of the following information:
An approximation of the contents of ambients:
I ⊆ Ambient × (Ambient ∪ Cap)
So u ∈ I(μ) (standing for (μ, u) ∈ I) means that μmay contain u. An ambient may contain other ambients as well as capabilities. This part of the analysis is affected by the movement capabilities.
An approximation to the relevant name bindings:
R⊆ Name × Name
So ν' ∈ R(ν) (standing for (ν, ν') ∈ R) means that νmay take on the value ν'. Here ν' will typically be the canonical name of the name being transmitted in the communication. This part of the analysis is affected by the communication capabilities.
The judgements of the analysis have the form
(I, R) |=٨ P

and express that when P is enclosed within an ambient with the identity ∈ Ambient then I and R correctly capture the behaviour of P , this means that if P evolves into P' in a number of steps, i. e. P → · · · → P', then also (I, R) |=٨ P'.
The analysis is specified in two stages. First we make sure that I and R describe the initial process; this is done for processes in Table 5 and for capabilities in Table 6. The clauses of Table 5 simply amount to a straightforward structural traversal of the processes; whenever a name is introduced it must be reflected in the R-component as expressed by the condition [n♩∈ R([n♩) and whenever an ambient is introduced



Table 5
Analysis of processes: (I, R) |=s P .


(I, R) |=s enter n	iff ∀νn : νn ∈ R([n♩) ⇒ enter νn ∈ I(٨) (I, R) |=s accept n	iff ∀νn : νn ∈ R([n♩) ⇒ accept νn ∈ I(٨) (I, R) |=s exit n	 iff ∀νn : νn ∈ R([n♩) ⇒ exit νn ∈ I(٨) (I, R) |=s expel n	iff ∀νn : νn ∈ R([n♩) ⇒ expel νn ∈ I(٨)
(I, R) |=s merge+ n iff ∀νn : νn ∈ R([n♩) ⇒ merge+ νn ∈ I(٨) (I, R) |=s merge– n iff ∀νn : νn ∈ R([n♩) ⇒ merge– νn ∈ I(٨)
(I, R) |=s n!{m}	iff ∀νn, νm : νn ∈ R([n♩) ∧ νm ∈ R([m♩) ⇒ νn!{νm}∈ I(٨)
(I, R) |=s n?{p}	iff ∀νn : νn ∈ R([n♩) ⇒ νn?{[p♩} ∈ I(٨)
(I, R) |=s n !{m}	iff ∀νn, νm : νn ∈ R([n♩) ∧ νm ∈ R([m♩) ⇒ νn !{νm}∈ I(٨)
(I, R) |=s nˆ?{p}	iff ∀νn : νn ∈ R([n♩) ⇒ νnˆ?{[p♩} ∈ I(٨)
(I, R) |=s nˆ!{m}	iff ∀νn, νm : νn ∈ R([n♩) ∧ νm ∈ R([m♩) ⇒ νnˆ!{νm}∈ I(٨)
(I, R) |=s n ?{p}	iff ∀νn : νn ∈ R([n♩) ⇒ νn ?{[p♩} ∈ I(٨)
(I, R) |=s n#!{m}	iff ∀νn, νm : νn ∈ R([n♩) ∧ νm ∈ R([m♩) ⇒ νn#!{νm}∈ I(٨)
(I, R) |=s n#?{p}	iff ∀νn : νn ∈ R([n♩) ⇒ νn#?{[p♩} ∈ I(٨)
Table 6
Analysis of capabilities: (I, R) |=s M.


it must be reflected in the I-component as expressed by μ ∈ I( ) —note that when we inspect the contents of the ambient we make sure to record that the enclosing ambient is μ as reflected by the clause (I, R) |=μ P . For capabilities we use the judgement (I, R) |=٨ M defined in Table 6 and explained below. The clauses for parallel processes and sums of processes are equal thereby witnessing the simplicity of the analysis; the same trend is followed in the analysis of recursion.
To understand the analysis of capabilities it is important to observe that the names introduced by (n)P are constants, whereas the names introduced in input capabilities (called p above) are variables that may be bound to other names (i. e. constants) as a result of communications. The clauses for processes already ensure that constants stand for themselves in R; initially there will be no requirements on the bindings of the variables of input capabilities, they will be imposed when we study how to mimick the dynamics of the processes. The clauses of Table 6 merely demand that for each possible binding of the names occurring free in the capability (called n and m above), there is a record of the corresponding instantiated capability in the I component of the analysis.


Enter/accept:	∀μ, μ1, μ2, νn : enter νn ∈ I(μ1) ∧ μ1 ∈ I(μ)∧
accept νn ∈ I(μ2) ∧ μ2 ∈ I(μ)
⇒ μ1 ∈ I(μ2)
Exit/expel :	∀μ, μ1, μ2, νn : exit νn ∈ I(μ1) ∧ μ1 ∈ I(μ2)∧
expel νn ∈ I(μ2) ∧ μ2 ∈ I(μ)
⇒ μ1 ∈ I(μ)
Merge:	∀μ, μ1, μ2, νn : merge+ νn ∈ I(μ1) ∧ μ1 ∈ I(μ)∧
merge– νn ∈ I(μ2) ∧ μ2 ∈ I(μ)
⇒ ∀μ' : μ' ∈ I(μ2) ⇒ μ' ∈ I(μ1)
To local:	∀μ, νm, νp, νn : νn!{νm}∈ I(μ)∧
νn?{νp}∈ I(μ)
⇒ νm ∈ R(νp)
To child:	∀μ, μc, νm, νp, νn : νn !{νm}∈ I(μ)∧
νnˆ?{νp}∈ I(μc) ∧ μc ∈ I(μ)
⇒ νm ∈ R(νp)
To parent:	∀μ, μc, νm, νp, νn : νnˆ!{νm}∈ I(μc) ∧ μc ∈ I(μ)∧
νn ?{νp}∈ I(μ)
⇒ νm ∈ R(νp)
To sibling:	∀μ, μ1, μ2, νm, νp, νn : νn#!{νm}∈ I(μ1) ∧ μ1 ∈ I(μ)∧
νn#?{νp}∈ I(μ2) ∧ μ2 ∈ I(μ)
⇒ νm ∈ R(νp)
Table 7
Closure condition on I and R.

Finally we make sure that I and R also take the dynamics of the process into account; this is formulated by the closure conditions in Table 7. The first three clauses take care of the movement capabilities and the last four of the communica- tion capabilities. In each case the precondition expresses in terms of I the potential presence of a redex in the semantics and the conclusion then imposes the additional requirements on I and R necessary to mimick the semantics.
Let us explain the clause for enter/accept; the clauses for the other movement capabilities follow the same pattern. From Table 4, it is clear that in order for the transition to take place it must be the case that the enter and accept capabilities are inside ambients that are siblings and this is exactly what is expressed by the precondition of the clause of Table 7: enter νn is inside μ1, accept νn is inside μ2 and μ1 and μ2 are siblings since they both are inside μ. From the semantics, we see that as a result of the transition the ambient with the enter capability will move into the ambient with the accept capability; in our analysis this is expressed by the conclusion of the clause that says that μ1 is inside μ2.
Turning to the clauses for communication capabilities we shall explain the one for local communication; the others follow the same overall pattern. The precondition expresses that νn!{νm} and νn?{νp} must be within the same ambient (μ) exactly as is required in the semantics of Table 4. The effect of the communication is to perform a binding in the continuation of the input capability; this is captured by including μm in R(νp). The information of R is global so it is available everywhere and in particular in the continuation of the input capability.
The semantic correctness of the analysis is expressed by:
Theorem 3.1 Assume P → Q, (I, R) |=٨ P and∀n ∈ fn(P ) : [n♩∈ R([n♩). Then

(I, R) |=٨ Q.	 
This says that the analysis result describes an over-approximation to the actual behaviour of the process: it takes all the actual transition steps ofthe process into account. However, due to the simplicity of the analysis there will also be situations where the analysis information indicates that a transition may take place but where it actually never will be so. The proof of the theorem is by induction on P → Q and it uses the following standard lemma that can be proved by induction on P ≡ Q:
Lemma 3.2 If P ≡ Q then (I, R) |=٨ P if and only if (I, R) |=٨ Q.	 
The analysis is implemented using the Succinct Solver [19]. This solver works over finite (but not necessarily bounded) universes and accepts as input a static analysis specified as clauses in ALFP (Alternation-Free Least Fixed Point Logic) and it will then compute their least solution. Actually, the clauses of Tables 5, 6 and 7 are already written in ALFP so the implementation is straightforward. The Succinct Solver is implemented in Standard ML and exploits a number of clever algorithms and data structures in order to obtain not only a good performance but also a formally predictable time complexity. Compared with other solvers, the Succinct Solver is optimised for handling sparse relations as we believe they frequently appear in context dependent static analysis. In the specification of the analysis above we have not been concerned with these issues at all and our practical experiments have not indicated a need for doing so; as an example when analysing the process to be presented in the next section, the solver will operate over a universe with just 89 atoms and it will construct an I relation with 75 elements and a R relation with 33 elements; the computation of these relations takes less than a second. However, for more complex examples it may be worthwhile to rewrite the analysis to better exploit the representation of relations.
As an illustration of what can be done consider for example the analysis of the capability enter n in Table 6: it will give rise to a pair (enter νn, ) in I for each possible value νn of [n♩ in R. An alternative specification would just include (enter [n♩, ) in I and then inspect R as part of checking for the presence of a redex in the closure condition of Table 7.

Example:	Transcriptional Regulation by Positive Feedback
We shall now use BioAmbients to model the same example specified in [24] relying on a variant of the stochastic π-calculus [23]. The system, illustrated in Figure 1 and presented in Table 8, regulates gene expression by positive feedback. It in- cludes two genes (ambients GeneA and GeneTF ), their transcribed mRNAs (ambi- ents RNAA andRNATF ), the corresponding translated proteins (ambients ProteinA andProteinTF ) and the degradation of both RNA and protein molecules. The events are mediated by interaction with cellular machineries for DNA transcription (ambi- ent Transcr ), RNA translation (ambient Transl ) and RNA and protein degradation




Fig. 1. Graphical presentation of Transcriptional Regulation by Positive Feedback [24].
(ambients RNAdeg and Proteindeg ). Each of these interactions involves different molecular motifs (names basal , utr , degm, anddegp).
The main idea that drives the coding of the biological process in bioambients is to use capabilities to move interacting molecules in position where communications can occur. Furthermore, since we mimick the π-calculus specification of the same system, we trigger capabilities execution by communications. After two sibling communications on the name basal between Transcr and both GeneA and GeneTF , and after the movement of ambients originated by the capabilities expel a/exit a and expel c/exit c, the ambients RNAA and RNATF are both at the top level. Now the translation mechanism moves ProteinA and ProteinTF to the top level through two sibling communications on the channel utr between Transl and both RNAA and RNATF , followed by the movements generated by the capabilities expel b/exit b and expel e/exit e.
In the resulting configuration, ProteinA binds ProteinTF by accepting ActiveTF inside itself using the accept tf /enter tf capabilities. Then ProteinTF becomes active by expelling the ambient BoundTF with the capabilities expel atf /exit atf . For BoundTF there are now three alternatives:
Using a sibling communication on the channel bb2 it first synchronises with the Kinase of ProteinA, then it synchronises with the parent ProteinA on the channel bb1 , and eventually it expels the ambient ActiveTF with the capa- bilities expel f /exit f . The ambient ActiveTF is now expelled from ProteinA by the capabilities expel g/exit g. Then ActiveTF can interact either with the

(a)(b)(c)(d )(e)(f )(g )(bb1 )(bb2 )(bb3 )(basal )(pa )(utr )(degm)(degp)(tf )(atf )(ptail ) [ rec X1. (basal #?{x2 }. expel a. X1 + pa#?{x1 }. expel a. X1 )
| [ rec X2. exit a. (utr #?{x4 }. expel b. X2 + degm#?{x3 }. 0)
| [ exit b. rec X3. accept tf . (bb1 !{d}. (expel g. X3 + X3)
+degp#?{x6 }. bb3 !{d}. bb3 !{d}. 0
+degp#?{x7 }. bb3 !{d}. 0)
| [ rec X4. (bb2 #!{d}. X4 + bb3ˆ?{x5 }. 0) ]Kinase ]ProteinA ]RNAA ]GeneA
| [ rec X5. (basal #?{y2 }. expel c. X5 + pa#?{y1 }. expel c. X5 )
| [ rec X6. exit c. (utr #?{y4 }. expel e. X6 + degm#?{y3 }. 0)
| [ exit e. enter tf . expel atf . accept atf . 0
| [ exit atf . (bb1ˆ?{y9 }. enter atf . 0
+bb3ˆ?{y8 }. 0
+bb2 #?{y7 }. (bb1ˆ?{y6 }. expel f . 0 + bb3ˆ?{y5 }. 0))
| [ exit f. exit g. rec X7. (ptail #!{d}. X7
+degp#?{y10 }. 0) ]ActiveTF ]BoundTF ]ProteinTF ]RNATF ]GeneTF
| [ rec X8. basal #!{d}. X8 + ptail #?{z1 }. pa#!{d }. X8 ]Transcr
| [ rec X9. utr #!{d}. X9 ]Transl
| [ rec X10. degm#!{d }. X10 ]RNAdeg
| [ rec X11. degp#!{d }. X11 ]Proteindeg
Table 8
BioAmbient representation of Transcriptional Regulation by Positive Feedback.

transcription factor Transcr by a sibling communication on the channel ptail or with the degradation factor Proteindeg by a sibling communication on the channel degp. Note that BoundTF can be dissolved at any time if ProteinA starts a degradation through a sibling interaction along the channel degp with Proteindeg .
It can be dissolved after a communication from the parent ProteinA on the channel bb3 because ProteinA has started a degradation step with asibling communication on the channel degp.
It can enter again ProteinTF after a communication from the parent along the channel bb1 .
The specification of the system is reported in Table 8. Note that to avoida heavy use of parentheses, we write the summation as well as the parallel composition operator immediately under the beginning of the first summand. To aid the analysis we have α-renamed the bound variables apart and we have made sure that the identities of the ambients are distinct.
The result of analysing the system is displayed in Table 9. Most of the entries of the I component account for the syntactic structure of the process; the dynamics of the system causes the underlined pairs to be added. These entries clearly confirm the behaviour of the system as described above:
The pairs (GeneA, ProteinA), ( , ProteinA), ( , RNAA), (GeneTF , ProteinTF ), ( , ProteinTF ) and ( , RNATF ) reflect the movement of the ambients ProteinA, ProteinTF , RNAA and RNATF to the top level.
The pair (ProteinA, ProteinTF ) witnesses that ProteinTF enters ProteinA and the activation of BoundTF inside ProteinA is then reflected by the presence of the pair

I : (Proteindeg , degp#!{d}),
(RNAdeg , degm#!{d}),
(Transl , utr #!{d}),
(Transcr , pa#!{d }), (Transcr , ptail #?{z1 }), (Transcr , basal #!{d}),
(ActiveTF , degp#?{y10 }), (ActiveTF , ptail #!{d}), (ActiveTF , exit g ), (ActiveTF , exit f ), (BoundTF , ActiveTF ), (BoundTF , bb3ˆ?{y5 }), (BoundTF , expel f ), (BoundTF , bb1ˆ?{y6 }),
(BoundTF , bb2 #?{y7 }), (BoundTF , bb3ˆ?{y8 }), (BoundTF , expel atf ),
(BoundTF , bb1ˆ?{y9 }), (BoundTF , exit atf ),
(ProteinTF , ActiveTF ), (ProteinTF , BoundTF ), (ProteinTF , accept atf ), (ProteinTF , expel atf ), (ProteinTF , enter tf ), (ProteinTF , exit e),
(RNATF , ActiveTF ), (RNATF , BoundTF ), (RNATF , ProteinTF ),
(RNATF , degm#?{y3 }), (RNATF , expel e), (RNATF , utr #?{y4 }), (RNATF , exit c),
(GeneTF , ActiveTF ), (GeneTF , BoundTF ), (GeneTF , ProteinTF ), (GeneTF , RNATF ), (GeneTF , pa#?{y1 }), (GeneTF , expel c), (GeneTF , basal #?{y2 }),
(Kinase, bb3ˆ?{x5 }), (Kinase, bb2 #!{d}),
(ProteinA, ActiveTF ), (ProteinA, BoundTF ), (ProteinA, ProteinTF ), (ProteinA, Kinase),
(ProteinA, bb3 !{d}), (ProteinA, degp#?{x7 }), (ProteinA, degp#?{x6 }),
(ProteinA, expel g ), (ProteinA, bb1 !{d}), (ProteinA, accept tf ), (ProteinA, exit b),
(RNAA, ActiveTF ), (RNAA, ProteinA), (RNAA, degm#?{x3 }), (RNAA, expel b),
(RNAA, utr #?{x4 }), (RNAA, exit a),
(GeneA, ActiveTF ), (GeneA, ProteinA), (GeneA, RNAA), (GeneA, pa#?{x1 }),
(GeneA, expel a), (GeneA, basal #?{x2 }),
(٨, ProteinA), (٨, RNAA), (٨, ActiveTF ), (٨, BoundTF ), (٨, ProteinTF ), (٨, RNATF ),
(٨, Proteindeg ), (٨, RNAdeg ), (٨, Transl ), (٨, Transcr ), (٨, GeneTF ), (٨, GeneA)
R : (x1, d), (x2, d), (x3, d), (x4, d), (x5, d), (x6, d), (x7, d),
(y1, d), (y2, d), (y3, d), (y4, d), (y5, d), (y6, d), (y7, d), (y8, d), (y9, d), (y10, d),
(z1, d),
(ptail , ptail ), (atf , atf ), (tf , tf ), (degp, degp), (degm, degm), (utr , utr ), (pa, pa), (basal , basal ),
(bb3 , bb3 ), (bb2 , bb2 ), (bb1 , bb1 ), (g , g ), (f , f ), (e, e), (d , d ), (c, c), (b, b), (a, a)

Table 9 Analysis result.






(ProteinA, BoundTF ).
The expelling of ActiveTF from ProteinA is reflected by the presence of the pair ( , ActiveTF ).
As the analysis specifies an over-approximation to the precise contents of the am- bients, it is actually more interesting to observe the information that is not included in I, as this confirms what is definitely not happening. As an example we can see that the ambient Kinase does not move at all — only the pair (ProteinA, Kinase) is present in I — and hence even though there may be several copies of ProteinA in the system, they are guaranteed not to get their Kinase components mixed up; the full arguments involve checking that there are no (ProteinA, ProteinA), (ProteinA, merge+ ·· ·) or (ProteinA, merge– ·· ·) in I. The R-component approx- imates the bindings of the names and, since all communications in the example amount to nothing but synchronisation, we observe that all variables may end up being bound to the dummy name d. Also we see that all variables may eventually get bound to a value.

Conclusion and Further Work
The paper presented a new control flow analysis for BioAmbients, a calculus based on Mobile Ambients and specifically tuned to model biological systems. Our pro- posal is the first attempt to adapt static analysis techniques to analysing molecular interactions. We established the feasibility of the approach with a case study taken from [24], where a gene regulation by positive feedback is modelled in π-calculus.
The analysis introduced here is a very simple one because it is both context insensitive and flow insensitive. Nevertheless, it has proved very useful for debug- ging the preliminary versions of our specification. In fact, the basic mechanisms of ambient calculi and π-like calculi are quite different in modelling dimers. In the BioAmbients we can simply decide that one component enters another in the same ambient or that two ambients merge to generate a new single ambient, including the content of both the merging ones. In the π-calculus we model this situation by letting the constituent of the dimer share a new private channel through a scope ex- trusion and subsequent closing of the enlarged scope. This difference prevents each π-calculus process in the specification in [24] from being matched by a corresponding ambient, and hence the overall behaviour of the two systems is not easily checked to be equivalent. We used our analysis to check that the interacting entities are the same in both specifications and that the flow of information represented by new bindings is the same in both specifications. We iterated the process of specifying the system and analysing it several times before reaching a BioAmbient specification with the same behaviour as the π-calculus specification.
This practical experiment shows how important static analysis is in the mod- elling phase of biological systems, when we have to write a specification that matches the experimental knowledge available from biological data. We are currently inves- tigating a methodology to code biological systems in BioAmbients to facilitate the usage of our machinery. Actually there are classifications of the kind of biological reactions that can occur within cells that could be compiled into ambients macros. Then the system specification would be the composition of these macros.
Furthermore, a major problem in modelling biological systems is the selection of parameters that can vary a lot from one publication to another and even from one database to another for the same experiment. To be more accurate in this direction, we are working to extend the semantics as well as the analysis to take stochastic information into account. A suitable approach could be to rely on the enhanced operational semantics [8] where stochastic information is derived by a relabelling function and it is a parameter of the semantic model [21]. This separation of concerns should allow an easy extension of the analysis presented here and it should also allow to run the analysis solver on the same specification many time with different quantitative parameters thus comparing different experiments.


References
Spad signaling pathway database. 2000.

G. D. Bader, I. Donaldson, C. Wolting, B. F. Ouellette, T. Pawson, and C. W. Hogue. Bind-the biomolecular interaction network database. Nucleic Acids Research, 29(1):242–245, 2001.
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static analysis for the π-calculus with applications to security. Information and Computation, 168:68–92, 2001.
M. Bugliesi, G. Castagna, and S. Crafa. Boxed Ambients. In Theoretical Aspects in Computer Science (TACS 2001), volume 2215 of Lecture Notes in Computer Science, pages 37–63. Springer, 2001.
L. Cardelli. Bioware languages. In Computer Systems - Papers for Roger Needham. 2003.
L. Cardelli and A. D. Gordon. Mobile Ambients. In Foundations of Software Science and Computation Structures (FoSSaCS 1998), volume 1378 of Lecture Notes in Computer Science, pages 140–155. Springer, 1998.
V. Danos and C. Laneve. Core formal molecular biology. In European Symposium on Programming (ESOP03), to appear, 2003.
P. Degano and C. Priami. Enhanced operational semantics: A tool for describing and analysing concurrent systems. ACM Computing Surveys, 33,2:135–176, 2001.
K. Eilbeck, A. Brass, N. Paton, and C. Hodgman. Interact: an object oriented protein-protein interaction database. In Intelligent Systems for Molecular Biology, volume 7, pages 87–94, Palo Alto, 1999. AAAI Press.
W. Fontana and L. W. Buss. The arrival of the fittest: Toward a theory of biological organization.
Bull. Math. Biol., 56:1–64, 1994.
T. Igarashi and T. Kaminuma. Development of a cell signalling networks database. In R. B. Altman, A. K. Dunker, L. Hunter, and T. E. Klein, editors, Proccedings of the Pacific Symposium of Biocomputing ’97, pages 187–197, Singapore, 1997. World Scientific Press.
P. D. Karp, M. Krummenacker, S. Paley, and J. Wagg. Integrated pathway/genome databases and their role in drug discovery. Trends in Biotechnology, 17(7):275–281, 1999.
F. A. Kolpakov, E. A. Ananko, G. B. Kolesov, and N. A. Kolchanov. Genenet: a gene network database and its automated visualization. Bioinformatics, 14(8):529–537, 1998.
F. Levi and D. Sangiorgi. Controlling interference in ambients. In Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 2000), pages 352–
364. ACM Press, 2000.
R. Milner. Communicating and Mobile Systems: The pi-Calculus. Cambridge University Press, 1999.
M. Nagasaki, S. Onami, S. Miyano, and Kitano H. Bio-calculus: Its concept and molecular interaction.
Genome Informatics, 10:133–143, 1999.
F. Nielson, H. Riis Nielson, and C. Hankin. Principles of Program Analysis. 1999.
F. Nielson, H. Riis Nielson, and R. R. Hansen. Validating firewalls using flow logics. Theoretical Computer Science, 283(2):381–418, 2002.
F. Nielson, H. Riis Nielson, and H. Seidl. A succinct solver for ALFP. Nordic Journal of Computing, 9:335–372, 2002.
H. Riis Nielson, F. Nielson, and M. Buchholtz. Security for mobility. Technical Report WP6-IMM-I01- Int-001, DEGAS, 2002.
C. Nottegar, C. Priami, and P. Degano. Performance evaluation of mobile processes via abstract machines. IEEE Transactions on Software Engineering, 27(10), 2001.
H. Ogata, S. Goto, K. Sato, W. Fujibuchi, H. Bono, and M. Kanehisa. Kegg: Kyoto encyclopedia of genes and genomes. Nucleic Acids Research, 27(1):29–34, 2000.
C. Priami. Language-based performance prediction for distributed and mobile systems. INFCTRL: Information and Computation (formerly Information and Control), 175, 2002.
C. Priami, A. Regev, W. Silverman, and E. Shapiro. Application of a stochastic passing-name calculus to representation and simulation of molecular processes. Information Processing Letters, 80:25–31, 2001.
A. Regev. Computational system biology: A calculus for biomolecular knowledge. PhD thesis, Tel Aviv University, 2003.

A. Regev, E. M. Panina, W. Silverman, L. Cardelli, and E. Shapiro. BioAmbients: An abstraction for biological compartments. 2003. Manuscript available from http://www.luca.demon.co.uk/.
A. Regev and E. Shapiro. Cells as computations. Nature, 419:343, 2002.
A. Regev, W. Silverman, and E. Shapiro. Representation and simulation of biochemical processes using the π-calculus process algebra. In Pacific Symposium of Biocomputing (PSB2001), pages 459–470, 2001.
C. Sanchez, C. Lachaize, F. Janody, B. Bellon, L. Roder, J. Euzenat, F. Rechenmann F, and B. Jacq. Grasping at molecular interactions and genetic networks in drosophila melanogaster using flynets, an internet database. Nucleic Acids Research, 27(1):89–94, 1999.
E. Selkov, Y. Grechkin, N. Mikhailova, and E. Selkov. Mpw: the metabolic pathways database. Nucleic Acids Research, 26(1):43–45, 1998.
J. van Helden, A. Naim, R. Mancuso, M. Eldridge, L. Wernisch, D. Gilbert D, and S. J. Wodak. Representing and analysing molecular and cellular function using the computer. Biological Chemistry, 381(9–10):921–935, 2000.
E. Wingender, X. Chen, E. Fricke, R. Geffers, R. Hehl, I. Liebich, M. Krull M, V. Matys, H. Michael,
R. Ohnhauser, M. Pruss, F. Schacherer, S. Thiele, and S. Urbach. The transfac system on gene expression regulation. Nucleic Acids Research, 29(1):281–283, 2001.
I. Xenarios, E. Fernandez E, L. Salwinski, X. J. Duan, M. J. Thompson, E. M. Marcotte, and
D. Eisenberg. Dip: the database of interacting proteins: 2001 update. Nucleic Acids Research, 29(1):239–241, 2001.
