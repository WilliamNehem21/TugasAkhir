Electronic Notes in Theoretical Computer Science 44 No. 1 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 21 pages


Generalised Coinduction

F. Bartels 1
CWI, P.O. Box 94079, 1090 GB Amsterdam, The Netherlands
http://www.cwi.nl/~bartels


Abstract
We introduce the λ-coiteration schema for a distributive law λ of a functor T over a functor F. Under certain conditions it can be shown to uniquely characterise functions into the carrier of a final F-coalgebra, generalising the basic coiteration schema as given by finality. The duals of primitive recursion and course-of-value iteration, which are known extensions of coiteration, arise as instances of our frame- work. One can furthermore obtain schemata justifying recursive specifications that involve operators such as addition of power series, regular operators on languages, or parallel and sequential composition of processes.
Next, the same type of distributive law λ is used to generalise coinductive proof techniques. To this end, we introduce the notion of a λ-bisimulation relation. It specialises to what could be called bisimulation up-to-equality or bisimulation up- to-context for contexts built from operators of the type mentioned above. We state that every such relation is contained in some larger conventional bisimulation and demonstrate that this principle leads to simpler bisimilarity proofs using less complex relations.


Introduction
Around the early nineties, the categorical notion of a final F-coalgebra for a functor F on some category C was found useful for the abstract description of possibly infinite objects in computer science. Examples are datatypes such as infinite streams or dynamical systems like processes or automata (see e.g. the introductions by Jacobs and Rutten [JR96,Rut00b]). Treating these dif- ferent entities uniformly as behavioural systems of some type F allowed for an abstract formulation of definition and proof principles that have been studied separately for various applications before.
States of a final coalgebra can be characterised using a principle which is given directly by finality. We call it coiteration here to distinguish it from

1 The research reported here was part of the NWO project ProMACS.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


derived variants. The main tool for proving states equal is that of an F- bisimulation [AM89], a categorical generalisation of notions of bisimulation used for different concrete systems. But these basic principles are often too rigid to nicely cover given examples. Many functions into the carrier of a final coalgebra can be shown not to be coiterative and many statements about be- havioural equivalence require bisimulations which are difficult to exhibit and check. Therefore several extensions for particular settings are studied. Ex- amples of a more general type are the definition principles that arise as the duals of primitive recursion and course-of-value iteration. The specification of processes by systems of recursive equations forms another one. For proof purposes one often uses relations which instead of being bisimulations them- selves satisfy sufficient conditions for being contained in some bisimulation. These are often called bisimulations up-to (see e.g. Milner [Mil89]). Sangiorgi [San98] has introduced a framework for deriving such principles in the context of labelled transition systems.
Categorical formulations of the schemata that form the duals of primitive recursion and course-of-value iteration are known, see e.g. Vene and Uustalu [UV99]. Following common practice, we will call the first one primitive core- cursion.
A step towards a more general description of extended principles on this level has been made by Lenisa in the course of her comparison of set-theoretic and coalgebraic (categorical) formulations of coinduction [Len99a]. She has demonstrated that her framework captures the arrows obtainable by primitive corecursion and the same can be shown for the dual of course-of-value iteration, but in neither case does her theory directly yield the universal characterisation for these morphisms mentioned above. By modifying Lenisa’s approach we arrived at a categorical description of generalised coinductive definition and proof principles based on such a universal characterisation which specialises directly to both principles from above.
Simply speaking, the conventional coiteration schema assigns infinite be- haviours to the states of a set X by specifying for each element a direct obser- vation and successor states. Since these successors are taken from X again, the same specification applied to them reveals the second layer of the behaviour, and so on. A different approach is taken by the λ-coiteration schema that we introduce, which is parameterised by another functor T and a distributive law λ of T over F: it allows the successor states to be taken from TX instead of X, which may increase the expressiveness of the format in case the former can be regarded as being “richer” than the latter. For the observations to be continued with these successors, the distributive law λ lifts the specification for X to T X. In the main theorems of this paper we show for two additional assumptions that each of them is sufficient for the λ-coiteration schema to uniquely define arrows into the final F-coalgebra.
Making similar use of T and λ, we define the notion of a λ-bisimulation and show that the same conditions as for the validity of the λ-coiteration schema

are sufficient to show that all states in such a relation are bisimilar. A small example demonstrates that the technique enables simpler proofs involving less complex relations.
The categorical formulation of primitive corecursion and the dual of course- of-value iteration mentioned above can be obtained from the λ-coiteration schema for suitable instantiations of T and λ, although we do not explain the details here. Instead, we briefly sketch how it can be used to justify specifications involving operators of a certain type. These are the operators that Turi and Plotkin [TP97] have shown to be closely related to those de- finable by structured transition rules in GSOS format [BIM95]. Presenting these schemata as instances of our framework at the same time produces the corresponding variants of the λ-bisimulation proof technique. For the case of definitions via operators one obtains a notion of bisimulation up-to-context [San98] for multivariate contexts (i.e. context with several “holes”) built from operators of the type mentioned above. This provides an abstract justification for the usability of these operators for this purpose.
The theory presented is stated for some category C, but for easy reading our explanations and examples all refer to the category of sets and total func- tions, Set. This paper is a short version of a CWI technical report under the same name [Bar00]. The long version contains detailed proofs for most of the statements given here and further examples.
(Co)Algebras and (Co)Iteration
In this section we will briefly present a categorical view on algebras and coalge- bras. More detailed expositions can be found e.g. among the papers of Jacobs and Rutten [JR96,Rut00b]. We take C and T, F: C → C to denote a category and two functors on it.
Definition 2.1 [T-algebra, F-coalgebra] A T-algebra is a pair ⟨X, β⟩ where X is an object of C and β : TX → X is an arrow in C. We will sometimes call X and β the carrier and operation of the algebra. Dually, an F-coalgebra is a pair ⟨X, α⟩ where the operation α : X → F X is an arrow going into the reversed direction.
Generally, algebra operations can be seen as a means for constructing ele- ments of their carrier. The operation of a coalgebra – also called destruction or unfolding elsewhere – gives us information about its states, either in terms of attributes or (potential) successor states. In the first case we will talk about the observation a state allows, in the second about its dynamics.
Definition 2.2 [homomorphism] An arrow h : X → Y is a T-algebra ho- momorphism from one T-algebra ⟨X, βX⟩ to another T-algebra ⟨Y, βY ⟩ if it makes the left diagram below commute. Similarly, an F-coalgebra homomor- phism from one F-coalgebra ⟨X, αX⟩ to another F-coalgebra ⟨Y, αY ⟩ is an arrow h : X → Y making the right diagram commute:



T X  Th  T Y βX	βY
J	 J 
X 	h	 Y αX			αY
J	 J 

X	h	Y	F X  F h  F Y
We will often just talk about homomorphisms when their type is clear from the context. Algebras and coalgebras together with the corresponding homomorphisms form the categories AlgT and Coalg respectively.
Definition 2.3 [final F-coalgebra] A final F-coalgebra is a final object in the category of F-coalgebras CoalgF, i.e. a coalgebra – usually denote here by
⟨ΩF, ωF⟩ – such that there exists exactly one homomorphism from every other
F-coalgebra to it.
Example 2.4 Some of our later examples will involve infinite streams of real numbers σ ∈ IRω. These arise as states of the final coalgebra of the functor S: Set → Set where S X := IR ×X. Coalgebras of this functor have the shape
⟨X, ⟨o, s⟩⟩ for a set X and two functions o : X → IR and s : X → X. That is, for each state we can observe a real number and move to a successor state. The infinite streams of real numbers form the final S-coalgebra ⟨IRω, ⟨head, tail⟩⟩, where for each stream σ = ⟨σ0, σ1,.. .⟩ ∈ IRω the observation is given by its first element head(σ) := σ0 and the successor by the stream that remains after removing it, tail(σ) := σ' := ⟨σ1, σ2,.. .⟩. We will call S-coalgebras stream systems in the following.
The finality of an F-coalgebra ⟨ΩF, ωF⟩ yields an arrow h : X → ΩF for every F-coalgebra operation α on X by assuming it to be the unique homo- morphism from ⟨X, α⟩ to ⟨ΩF, ωF⟩. Such an arrow is then called the coiterative arrow defined (or induced) by α:
X _ _∃!h_ _ Ω F
∀α	ωF
J	J 
F X	F h F ΩF
Example 2.5 [Coiteration for Streams] The coiteration schema for stream systems from Example 2.4 states that for every pair of functions o : X → IR and s : X → X there is a unique function f : X → IRω satisfying
head(f (x)) = o(x),
tail(f (x)) = f (s(x)).
As an example we take a look at the element-wise addition of two streams. By the coiteration schema there is a unique function ⊕ : IRω × IRω → IRω satisfying the following two equations:
head(σ ⊕ τ )= head(σ)+ head(τ )
tail(σ ⊕ τ )= tail(σ) ⊕ tail(τ )

As a proof principle, one can show that for a final F-coalgebra ⟨ΩF, ωF⟩ two arrows h1, h2 : X → ΩF are equal by providing an F-coalgebra operation on X for which both arrows are homomorphisms. Most of the time one exploits this property for proving that two states show the same behaviour, i.e. that they are mapped onto the same state of the final coalgebra by the coiterative morphisms. Technically one uses a derived principle based on the notion of bisimulation. We work with a definition in terms of spans:
Definition 2.6 [span] In a category C, a span R = ⟨R, r1, r2⟩ between two C objects X and Y consists of an object R and two arrows r1 : R → X and r2 : R → Y . A span between X and itself is called a span on X.
There is a preorder ≤ of spans between the objects X and Y defined as
⟨R, r1, r2⟩ ≤ ⟨S, s1, s2⟩ if and only if there is an arrow f : R → S such that both triangles in the following diagram commute:
r,1,,, R ¸¸¸r¸2¸¸

, , s
X ¸¸¸¸¸¸
 ∃f
 
z˛
,,, ¸

s1 ¸¸
J,, ,s2

Definition 2.7 [Bisimulation] For a functor F : C → C, an F-bisimulation between two F-coalgebras ⟨X, αX⟩ and ⟨Y, αY ⟩ is a span B = ⟨B, b1, b2⟩ be- tween their carriers X and Y , such that there is an F-coalgebra operation γ : B → F B turning b1 and b2 into homomorphisms:

X ¸,b1
B 	b2	 Y 

αX	 ∃γ	αY
J ¸, 	 J 	  J 
F X F b1 F B F b2 F Y
A bisimulation between a coalgebra ⟨X, α⟩ and itself is called a bisimulation
on ⟨X, α⟩.
In Set one often only considers bisimulations which are relations, i.e. spans
⟨B, π1, π2⟩ for a relation B ⊆ X × Y (see e.g. Rutten [Rut00b]). We use the formulation based on spans because it generalises to other categories and is sometimes easier to work with. We will still often talk about bisimulation relations. This is justified by the observation that every span ⟨R, r1, r2⟩ in Set can be regarded as representing the image ⟨r1, r2⟩[R] ⊆ X × Y . The order ≤ of spans corresponds to relation inclusion of images. Furthermore the image of a (span) bisimulation is again a (relational) bisimulation.
One usually calls two states bisimilar if they are related by some bisimula- tion relation and takes bisimilarity to be the notion of behavioural equivalence. This is justified by the fact that in case a final F-coalgebra exists bisimilar states are identified by the coiterative morphisms. This can easily be seen as follows:
Let B ⊆ X × Y be a bisimulation between the F-coalgebras ⟨X, αX⟩ and
⟨Y, αY ⟩ containing the pair ⟨x, y⟩, where the bisimulation property is witnessed by γ : B → F B. Let hX and hY denote the coiterative arrows from ⟨X, αX⟩


and ⟨Y, αY ⟩ to the final coalgebra ⟨ΩF, ωF⟩, then one gets the diagram be- low in CoalgF, commuting by finality. This yields hX(x) = hX(π1(⟨x, y⟩)) = hY (π2(⟨x, y⟩)) = hY (y) as wanted.
⟨R, γ⟩

π1 
 j 
⟨X, αX,,⟩
,,,
,,,π2
,vz
⟨Y, αY ⟩
    

hX	vz jhY 
⟨ΩF, ωF⟩

Definition by λ-Coiteration
The states of a final F-coalgebra ⟨ΩF, ωF⟩ can be taken to represent abstract behaviours of the type F, as we did already in the explanations above. An arrow f : X → ΩF assigns such behaviours to the elements of X. The coitera- tion schema allows us to define this function such that it maps every element of X to the behaviour it exhibits as a state in a given F-coalgebra ⟨X, α⟩. Un- fortunately, for many functions f : X → ΩF that one wants to specify there is no F-coalgebra operation α on X itself making f the coiterative morphism or it may not be obvious from the given specification of f .
In this section we are first going to present a specification of this kind. Then we will formulate the encountered pattern more abstractly and – as the main theorems of this paper – state sufficient conditions for it to uniquely characterise arrows into the carrier of a final coalgebra. This yields a definition schema that we call λ-coiteration.

Example: Multiplication of Formal Power Series
Like Rutten [Rut00a], we will consider infinite streams of real numbers σ =
⟨σ0, σ1,.. .⟩ ∈ IRω as representations of formal power series Σ∞ σiXi. The
operation ⊕ from Example 2.5 turns out to be such that σ ⊕ τ represents the sum of the two series represented by σ and τ . Similarly, we would like to define a binary operation ⊗ on IRω such that σ ⊗ τ represents the convolution product of the two series represented by σ and τ . After some computation (c.f. [Rut00a]) one arrives at the following specification, where the constant series r ∈ IR is represented by [r]= ⟨r, 0, 0,.. .⟩∈ IRω: 2
head(σ ⊗ τ )= head(σ) · head(τ ),
tail(σ ⊗ τ )= ([head(σ)] ⊗ tail(τ )) ⊕ (tail(σ) ⊗ τ ).
These two equations do not form a coiterative definition as in Example 2.5 because of the use of ⊕ in the expression for the tail. To get a better picture of the type of definition we have here, we set X := IRω × IRω and o : X → IR, s1, s2 : X → X with

2 Coiteratively: head([r]) = r and tail([r]) = [0].

o(σ, τ ) := head(σ) · head(τ ),
s1(σ, τ ) := ⟨[head(σ)], tail(τ )⟩, s2(σ, τ ) := ⟨tail(σ),τ⟩.
Using this, the equations above can be stated alternatively by asking ⊗ to fit into the diagram below:

X _ _
⟨o,⟨s1,s2⟩⟩
_ _ _
_ ⊗_ _ _
_ _ _ IR ω
⟨head,tail⟩

J 
IR × (
_	  J ω

X × X)
IR
×(⊕◦ (⊗×⊗)) IR × IR

In the following the question to be addressed more generally amounts here to asking whether this condition uniquely defines the arrow ⊗.

The general Pattern
To describe the format of the specification from above more abstractly, we make the following two definitions:
Definition 3.1 [T-extension] Let β : TY → Y be a T-algebra. For a given arrow f : X → Y , we call f|β := β ◦ T f : TX → Y the T-extension of f along β:
T X T f  T Y
¸ ¸
f|β  ¸ ¸  β
X 	z J 
f	Y
Definition 3.2 [homomorphism up-to-β] Let ⟨X, φ⟩ be an FT-coalgebra and
⟨Y, α⟩ be an F-coalgebra with a T-algebra operation β : T Y → Y on its carrier. An arrow f : X → Y is called a homomorphism up-to-β from ⟨X, φ⟩ to ⟨Y, α⟩, if it makes the following diagram commute (note that in the picture we added an arrow for β to visualise its typing, though it does not contribute to the commutativity expressed):
T Y
f	Jβ 
X 	 Y 
φ	α
J 	 J 
FTX	F Y
F f|β
By taking the functor T := Id × Id, ⊗ becomes a homomorphism up- to-⊕ from the S T-coalgebra ⟨X, ⟨o, ⟨s1, s2⟩⟩⟩ to ⟨IRω, ⟨head, tail⟩⟩, the final S-coalgebra, since we can rewrite the arrow at the bottom of the diagram intended to specify ⊗ as follows:
IdIR × (⊕ ◦ (⊗× ⊗)) = S (⊕ ◦ (⊗× ⊗)) = S (⊕ ◦ T ⊗)= S ⊗|⊕.


Distributive Laws
We are looking for a framework in which a homomorphism up-to-β into a final F-coalgebra ⟨ΩF, ωF⟩ uniquely exists for a given T-algebra operation β on its carrier. Since it is easy to see that this is not the case for all β, one needs to restrict the class of operations allowed. The unique existence of a homomorphism up-to-β means that an FT-operation on an object X specifies an arrow h : X → ΩF, i.e. an assignment of abstract F-behaviours to the elements in X.
This suggest that the way β evaluates elements of TΩF can be described more globally via a specification of the interaction of T and F. In our approach we assume this to be given by a distributive law λ of T over F defined below, which uniquely determines the T-algebra operation on the final F-coalgebra. In the case of our example, the operation ⊗ can be seen to arise from such a distributive law λ.
Definition 3.3 [distributive law] Let T, F: C → C be two functors. A natural transformation λ : TF ⇒ FT is called a distributive law of T over F. We will sometimes alternatively use the phrase that T distributes over F via λ.
A major application of the notion of a distributive law in computer sci- ence has been given by Turi and Plotkin [TP97] where the two functors were coming as a monad and a comonad respectively and additional coherence ax- ions involving the extra structure were considered (see the work by Power and Watanabe [PW99] for a structured account of this setting). Subsequently, dis- tributive laws were also used in situations where less structure was assumed for the functors and the corresponding coherence axioms were dropped (see [LPW00]). For now we only treat plain functors and no coherence axioms, but we will later encounter a case requiring more structure.
Regarding the elements from TX as structured entities containing elements from X as arguments, a distributive law tells us how to assign an F-step to such an entity given the steps the arguments can do. With this information, we can derive an F-coalgebra operation for TX from the F-coalgebra ⟨X, α⟩:
Definition 3.4 [λ-lifting] Given a distributive law λ of a functor T over a functor F, we can lift T : C → C to the functor Tλ : CoalgF → CoalgF on the F-coalgebras by setting
Tλ ⟨X, α⟩ := ⟨T X, liftλ⟩	and	Tλ h := T h,
for an F-coalgebra ⟨X, α⟩ and an F-coalgebra homomorphism h, where
liftλ := λX ◦ T α : TX → FTX.
For this definition to make sense we need the following lemma which is easily proved using the assumption on λ being natural:
Lemma 3.5 (see also [Rut00b, Theorem 15.3]) Let h be an F-coalgebra homomorphism from ⟨X, αX⟩ to ⟨Y, αY ⟩, then T h is a homomorphism from Tλ ⟨X, αX⟩ to Tλ ⟨Y, αY ⟩.

In the case of our example the distributive law λ of T := Id × Id over S should give a global description of the addition of two states. For a set X we define λX : (IR × X) × (IR × X) → IR × (X × X) as
λX(⟨ox, sx⟩, ⟨oy, sy⟩) := ⟨ox + oy, ⟨sx, sy⟩⟩.
It is easy to verify that we get a natural transformation indeed. Given a stream system ⟨X, ⟨o, s⟩⟩, the resulting system Tλ ⟨X, ⟨o, s⟩⟩ has pairs of states from X as states. Unfolding such a pair ⟨x, y⟩ yields the sum of the two observations o(x)+ o(y) and the pair of the successors ⟨s(x), s(y)⟩, that is the behaviour of ⟨x, y⟩ in Tλ ⟨X, ⟨o, s⟩⟩ is the (stream) sum of the behaviours of x and y in
⟨X, ⟨o, s⟩⟩ as wanted.
With the lifting from above, a distributive law λ assigns F-behaviours to the set TX, given the behaviours of the elements from X. The generalised coinduction schema we are about to state and justify involves T-algebra op- erations β which preserve these behaviours. More precisely, for a given F- coalgebra ⟨X, α⟩ we consider homomorphisms β from Tλ ⟨X, α⟩ to ⟨X, α⟩. It turns out that this situation is captured by the notion of a λ-bialgebra occur- ring in the literature, thus we recall its definition here:
Definition 3.6 [T,F-bialgebra, T,F-bialgebra homomorphism, λ-bialgebra] A T,F-bialgebra is a triple ⟨X, β, α⟩ of an object X and two arrows β : T X → X and α : X → F X, i.e. a T-algebra and an F-coalgebra operation on a common carrier. Given two T,F-bialgebras ⟨X, βX, αX⟩ and ⟨Y, βY , αY ⟩, a T,F-bialgebra homomorphism from ⟨X, βX, αX⟩ to ⟨Y, βY , αY ⟩ is an arrow h : X → Y which is both, a T-algebra homomorphism from ⟨X, βX⟩ to ⟨Y, βY ⟩ and an F-coalgebra homomorphism from ⟨X, αX⟩ to ⟨Y, αY ⟩. Like with T- algebras and F-coalgebras, T,F-bialgebras and their homomorphisms form a category, denoted by BialgT.
Given a distributive law λ of T over F, a λ-bialgebra is a T,F-bialgebra
⟨X, β, α⟩ such that the following diagram commutes:
,T,,α,,, T X
TFX	β
J 
λX  λ-bialg. X
J 
FTX ¸¸¸¸¸	α
F β ¸zF˛J 
The full subcategory of BialgT containing all λ-bialgebras is denoted by λ-Bialg.
Note that indeed the definition of ⟨X, β, α⟩ being a λ-bialgebra is equiv- alent to saying that β is an F-coalgebra homomorphism from Tλ ⟨X, α⟩ to
⟨X, α⟩ as wanted above. With this remark, for a final F-coalgebra ⟨ΩF, ωF⟩
there is exactly one choice for a T-algebra operation βλ : TΩF → ΩF such that
⟨ΩF, βλ, ωF⟩ is a λ-bialgebra, namely the coiterative morphism from Tλ ⟨ΩF, ωF⟩
to ⟨ΩF, ωF⟩.
Bialgebras for a distributive law play an important role in the paper by

Turi and Plotkin [TP97] as well. As with the definition of the distributive law, our notion of a λ-bialgebra differs from theirs due to the fact that we do not assume T and F to come as a monad and a comonad: in their setting ⟨X, β⟩ and ⟨X, α⟩ are assumed to be an algebra for the monad and a coalgebra for the comonad respectively.
In our example the bialgebra under consideration was ⟨IRω, ⊕, ⟨head, tail⟩⟩.
It is easily verified to be a λ-bialgebra for λ as in (1).
The λ-Coiteration Definition Schema
We are now ready to define our new schema called λ-coiteration for a distribu- tive law λ of a functor T over F:
Definition 3.7 [λ-Coiterative Arrow] Assume we are given a functor F with a final coalgebra ⟨ΩF, ωF⟩ and a distributive law λ of another functor T over
F. For an FT-coalgebra ⟨X, φ⟩ we call an arrow f : X → ΩF a λ-coiterative arrow induced by φ if it is a homomorphism up-to-βλ from ⟨X, φ⟩ to ⟨ΩF, ωF⟩ for the unique arrow βλ such that ⟨ΩF, βλ, ωF⟩ is a λ-bialgebra (c.f. remark following Definition 3.6):



X _ _ f_
φ
TΩF
Jβλ 
_ Ω F
ωF

J	J 

FTX
F f|βλ
 F ΩF

We want to use the above diagram as a definition for f , calling it the λ- coiteration schema. To be able to do so, we need to prove the unique existence of a λ-coiterative arrow for any given FT-coalgebra ⟨X, φ⟩. The two answers we are going to present work by establishing a one-to-one correspondence be- tween the λ-coiterative arrows and the coiterative arrows from an F-coalgebra
⟨LX, αφ⟩ constructed from ⟨X, φ⟩. The unique existence of the former then fol- lows from that of the latter. The constructions require additional assumptions on C or T and λ respectively:
Theorem 3.8 (λ-Coiteration (1)) Assume the category C has countable co- products and we are given a functor F: C → C with a final coalgebra ⟨ΩF, ωF⟩ and another functor T: C → C that distributes over F via λ. Then, for every FT-coalgebra ⟨X, φ⟩ there exists a unique λ-coiterative arrow induced by φ.
For this approach, one constructs an F-coalgebra on the countable coprod-
uct Σ∞  Ti X. The operation is a case analysis involving φi : Ti X → FTi+1 X
and appropriate coproduct injections where the φi are obtained as liftings of
φ via λ. The correspondence of homomorphisms up-to-βλ f : X → ΩF and
homomorphisms h : Σ∞ Ti X → ΩF is given by f '→ [fi]∞ and h '→ h ◦ in0
where f0 := f , fi+1 := fi|βλ , ini is the ith coproduct injection, and [.]∞	is

the countable case analysis. A detailed proof can be found in [Bar00].
Using this theorem we can finally answer the question whether the specifi- cation in Section 3.1 uniquely defined the function ⊗ positively: The example was living in the category Set, which of course has countable coproducts.
Theorem 3.9 (λ-Coiteration (2)) Assume we are given a functor F: C → C with a final coalgebra ⟨ΩF, ωF⟩, a monad ⟨T, η, µ⟩ in C and a distributive law λ of this monad over F, i.e. a distributive law of T over F such that the follow- ing diagrams commute, which we will refer to as the unit and multiplication law of λ:


ηF cccc
F,,,
,,,Fη
T F.
µF ıııııı
λ	zF T.¸
,
,,Fµ

cccc
unitλ
,,,
ıııııı
mult.
,,,,

,c	 zz 
T2 F ¸
λ
FT2

TF	λ	FT
¸¸¸¸¸ z  ,,,,, ˛,

Tλ	, λT
TFT
Then, for every FT-coalgebra ⟨X, φ⟩ there exists a unique λ-coiterative arrow induced by φ.
In case T is coming as a monad, for every i ∈ IN the elements from Ti X can be represented within T X, either using η or (possibly several times) µ. The additional assumptions on λ ensure that these mappings “preserve be- haviours”, such that it suffices to take TX as the carrier of the F-coalgebra to
be constructed instead of Σ∞ Ti X as above. The correspondence of homo-
morphisms up-to-βλ f : X → ΩF and homomorphisms h : TX → ΩF is given
by f '→ f|βλ and h '→ h ◦ ηX.
As a remark, the above argument marks the λ-coiterative arrows obtained by Theorem 3.9 as being coiterative up-to-⟨T, η⟩ in the framework of Lenisa [Len99a]. Actually the setting she uses to reason about these morphisms corresponds to yet another variation of the assumptions which lies in between those of the two theorems given here: it assumes the category C to have colimits of ω-chains and the functor T is supposed to come as a pointed functor for which λ satisfies the unit law.
Properties and an Extension
As an interesting though trivial observation note that the coiteration schema itself arises as the λ-coiteration schema for the identity functor distributing over F via the natural transformation FId : Id F ⇒ FId.
Another observation in this direction is that when there is a unit natural transformation η : Id ⇒ T for which λ satisfies the unit law (which is assumed in Theorem 3.9 anyway), then the corresponding instance of the λ-coiteration schema individually generalises the coiteration schema: one can obtain a coit- erative arrow induced by any F-coalgebra operation α : X → F X as the λ-coiterative arrow induced by FηX ◦ α : X → FTX (the crucial observation

is that the assumption on λ makes βλ an algebra operation for the pointed functor ⟨T, η⟩, which yields f|βλ ◦ ηX = f ).
One simple extension of the coiteration schema arises as the dual of prim- itive recursion and is therefore sometimes called primitive corecursion (see e.g. [UV99]). It states that in a category with binary coproducts every arrow φ : X → F(X + ΩF) uniquely determines a morphism f : X → ΩF making the diagram below commute.

X _ _
∀φ
_ _∃!h_
_ _ _ Ω F
ωF

J	J 
F(X + ΩF)	F [h,Id]	 F ΩF
This characterisation can be obtained as the λ-coiteration schema for the functor T X := X + ΩF and the distributive law λ : TF ⇒ FT defined as λX := [Finl, Finr ◦ ωF]: FX + ΩF → F(X + ΩF). In loc. cit. the schema that arises as the dual of course-of-value iteration is also given categorically. It can be obtained as an instance of λ-coiteration too. We do not state it here since this requires quite some technicalities. We still would like to mention that for this second example λ-coiteration simplifies the justification of the schema considerably, compared to a proof “by hand”.
Finally, we would like to mention that in case the category C has bi- nary products the results from above can be extended to a setting where the distributive law λ is replaced by a natural transformation of the type λ : T(Id × F) ⇒ FT. This increases the expressiveness in that one can use both, the F-step that some x ∈ X appearing inside t ∈ T X can do and x itself, for the specification of the behaviour of t. The Theorems 3.8 and 3.9 can be generalised to this new setting with minor modifications: In the first case the construction further requires the existence of binary coproducts in the category C, in the second the unit and multiplication laws for λ have to be adapted as follows: 3


Id × F  π2	 zF 
T(Id × F) 	λ	 zF T,¸


ηId×F
unit λ	F η
µ(Id×F)  ,
  
,,,,,F,µ

cz 		cz	2	,	2

T(Id × F) λ	zF T
T (Id × F)
¸¸¸¸¸¸¸¸
mult. λ
˛F,T
,,,,

T⟨Tπ1,λ⟩ ¸¸ z	,,,,λT
T(T × FT)





3 Following a suggestion by Lenisa, Power, and Watanabe [LPW00], one can elegantly show this by moving from the functor F to the cofree copointed functor generated by F, namely
⟨Id × F, π1⟩.

Proof by λ-Coinduction
In this Section we will consider generalised proof principles for bisimilarity. We give an example of a statement for which the straightforward relation fails to be a bisimulation. But it satisfies a condition sufficient to conclude that it is contained in some larger bisimulation. Again the condition is expressed via the existence of an FT-coalgebra operation on the relation instead of an F-coalgebra structure and we will call such relations λ-bisimulations. The corresponding proof principle allows for simpler bisimilarity proofs involving less complex relations.

Example: Distributivity of ⊕ over ⊗
We would like to prove that the addition of streams of real numbers defined in the Example 2.5 distributes over the multiplication considered in Section 3.1:
∀σ, τ, ρ ∈ IRω :	σ ⊗ (τ ⊕ ρ)= (σ ⊗ τ ) ⊕ (σ ⊗ ρ)
Since on the final coalgebra bisimilarity is contained in equality, it suffices to prove that both terms denote bisimilar streams. The bisimulation to be found needs to contain
B := {⟨σ ⊗ (τ ⊕ ρ), (σ ⊗ τ ) ⊕ (σ ⊗ ρ)⟩| σ, τ, ρ ∈ IRω}⊆ IRω × IRω
One can easily check that all pairs related by B have equal heads. Further- more, the bisimulation to be found has to relate the tails of every two streams related by B. A computation yields 4
tail(σ ⊗ (τ ⊕ ρ)) = ([σ0] ⊗ (τ ' ⊕ ρ')) ⊕ (σ' ⊗ (τ ⊕ ρ))

`	=˛:¸x1
x	`	=˛:¸x2	x

tail((σ ⊗ τ ) ⊕ (σ ⊗ ρ)) = (([σ0] ⊗ τ ') ⊕ ([σ0] ⊗ ρ')) ⊕ ((σ' ⊗ τ ) ⊕ (σ' ⊗ ρ)) .

`	=˛:¸y1
x	`	=˛:¸y2	x

We obtain sums of streams related by B, namely ⟨x1, y1⟩ and ⟨x2, y2⟩. Thus, the bisimulation should also contain
T (B) := {⟨x1 ⊕ x2, y1 ⊕ y2⟩| ⟨x1, y1⟩, ⟨x2, y2⟩∈ B}⊆ IRω × IRω.
But then we need to check on the pairs contained in T (B) as well.	The continuation of this procedure would lead to the relation

B˜ :=  T i(B).
i=0
To show that it is a bisimulation one could prove by induction on i ∈ IN that for ⟨x, y⟩∈ T i(B) one finds
head(x)= head(y)	and	⟨tail(x), tail(y)⟩∈ T i+1(B).

4 The second one involves commutativity and associativity of ⊕. Both can easily be proved using standard bisimulations.


The calculations above constitutes the base case of this induction, the induc- tion step is easy and independent of B. 5 It proves the following principle:
Given a relation B ⊆ IRω × IRω such that for ⟨x, y⟩∈ B one has
head(x)= head(y)	and	⟨tail(x), tail(y)⟩∈ T (B)
then B˜ :=  ∞ T i(B) is a bisimulation containing B.
With this principle, one can work directly with the relation B as in (2) which only contained the pairs used in the statement itself. There is no need to find a description covering all the tails encountered while walking down the streams, as it is done e.g. by Rutten [Rut00a], who uses all pairs
n	n
⟨Σ(σi ⊗ (τi ⊕ ρi)), Σ((σi ⊗ τi) ⊕ (σi ⊗ ρi))⟩
i=0	i=0
for n ∈ IN, σi, τi, ρi ∈ IRω (0 ≤ i ≤ n).
λ-Coinduction
We are now going to capture the situation from above categorically. For a functor T that distributes over F via λ, it corresponds to asking for an FT- coalgebra operation χ on the relation B ⊆ X ×Y which makes the projections homomorphisms up-to-β for suitable T-algebra operations on the F-coalgebras under consideration. We introduce the following notion:
Definition 4.1 [λ-bisimulation] Let F, T : C → C be functors. A span B =
⟨B, b1, b2⟩ is a λ-bisimulation between the F-coalgebras ⟨X, αX⟩ and ⟨Y, αY ⟩, if there exist an FT-operation χ on B and T-algebra operations βX and βY on X and Y , such that ⟨X, βX, αX⟩ and ⟨Y, βY , αY ⟩ are λ-bialgebras and b1 and b2 are homomorphisms up-to-βX and -βY respectively:
T X  	T  Y
∃βX J   b		b	 J∃β Y

X ¸, 1
αX
B 
 ∃χ
2	 Y 
αY

J ¸,	
 J 	 J 

F X F b1|βX
FTB	F Y
F b2|βY

If we want to make the T-algebra operations βX and βY explicit, we talk about a λ-bisimulation with respect to βX and βY . A λ-bisimulation between ⟨X, α⟩ and itself will be called a λ-bisimulation on ⟨X, α⟩.
It turns out that under the assumptions made in Theorem 3.8 (3.9) about C (T and λ), λ-bisimulations only relate bisimilar states. This can be proved by giving a construction that enlarges a λ-bisimulation such that a conventional bisimulation is encountered, similar to what we have done in the example. The

5 The induction step basically states that T is a respectful function in the terminology of Sangiorgi [San98] (with a translation of this notion from labelled transition systems to stream systems).


argument does not assume a final F-coalgebra to exist, hence it can be used in any context where behavioural equivalence is defined via bisimulations.
Theorem 4.2 (λ-coinduction) Let two functors T, F: C → C be given such that T distributes over F via λ and assume that
the category C has countable coproducts or
T is taken from a monad ⟨T, η, µ⟩ such that λ satisfies the unit and mul- tiplication law from Theorem 3.9.
If B is a λ-bisimulation between two given F-coalgebras ⟨X, αX⟩ and ⟨Y, αY ⟩
then there exists a (conventional) bisimulation B˜ between them with B ≤ B˜.
The proof uses an F-coalgebra ⟨LB, αχ⟩ constructed from ⟨B, χ⟩ as in the proof of Theorem 3.8 or 3.9 respectively. In the same way the homomorphisms up-to-βX and -βY give rise to F-coalgebra homomorphisms from ⟨LB, αχ⟩ to
⟨X, αX⟩ and ⟨Y, αY ⟩, say b1 '→ ˜b1 and b2 '→ ˜b2. (Note that this direction only
needs the assumption that the bialgebras involved are λ-bialgebras, finality is not needed.) This yields a bisimulation ⟨⟨LB, αχ⟩, ˜b1, ˜b2⟩. The order of spans claimed is witnessed by in0 in (i) and by ηB in (ii).
The Example revisited
Consider again the example from Section 4.1 where we had T := Id × Id and λ as given in equation (1) on page 9. In this setting the definition of a λ-bisimulation can be spelled out as follows:
Let ⟨X, ⟨oX, sX⟩⟩ and ⟨Y, ⟨oY , sY ⟩⟩ be two stream systems, both coming with binary operations ⊕X and ⊕Y on their carrier turning them into λ- bialgebras. The condition for a relation B ⊆ X × Y to be a λ-bisimulation between ⟨X, ⟨oX, sX⟩⟩ and ⟨Y, ⟨oY , sY ⟩⟩ with respect to ⊕X and ⊕Y can easily be seen to be equivalent to the following one: For all ⟨x, y⟩∈ B we have that oX(x)= oY (y) and ⟨sX(x), sY (y)⟩∈ T (B) where
T (B) := {⟨x1 ⊗X x2, y1 ⊗Y y2⟩| ⟨xi, yi⟩∈ B; i = 1, 2}.
By taking ⟨X, ⟨oX, sX⟩⟩ = ⟨Y, ⟨oY , sY ⟩⟩ = ⟨IRω, ⟨head, tail⟩⟩ and ⊗X =
⊗Y = ⊗ we find that the assumption on the relation B in the principle given in Section 4.1 is just to be a λ-bisimulation on the final stream system. Theorem 4.2 tells us that this is enough to conclude that there is a bisimulation B˜ ⊆ IRω × IRω with B ⊆ B˜. The span constructed in the proof of Theorem
4.2 corresponds to B˜ from Section 4.1.
λ-Coiteration and Operators
In this section we will again consider specifications involving operators in the definition of the dynamics of a state, but this time in a more flexible manner. The definition of the convolution product of formal power series treated in the previous sections could only be handled by the simple functor T := Id × Id because of the very regular occurrence of the auxiliary operation inside the

specification: the tail of σ ⊗ τ could always be characterised as the sum of two products of streams. Here we will give a schema that allows for arbitrary terms build of possibly several operators belonging to a certain class. Again we start with a concrete example.
The Stream of Hamming Numbers
Taking up an example from Dijkstra’s [Dij81] (also treated e.g. by Sijtsma [Sij89]), we consider the stream ham ∈ IN ω containing exactly those natural numbers in increasing order whose only prime factors are 2 and 3. These numbers are usually referred to as the Hamming Numbers (admittedly we dropped the prime factor 5 for simplicity). Similar to the previous examples the carrier of the final SNI -coalgebra, where SNI X := IN × X, is taken to model infinite streams of natural numbers. We will concentrate on the following specification using the auxiliary operators merge (binary) and mapg (unary) for g : IN → IN :
⟨head, tail⟩(ham)= ⟨1, merge(map∗2(ham), map∗3(ham))⟩
 ⟨σ0, merge(σ',τ )⟩	if σ0 < τ0

⟨head, tail⟩(merge(σ, τ )) =
⟨σ0, merge(σ',τ')⟩	if σ0 = τ0
 ⟨τ0, merge(σ, τ ')⟩	if σ0 > τ0

⟨head, tail⟩(map (σ)) = ⟨g(σ0), map (σ')⟩
g	g
for σ = ⟨σ0 : σ'⟩,τ = ⟨τ0 : τ '⟩ ∈ IN ω and the functions ∗2, ∗3: IN → IN that double and triple their arguments.
Viewing the stream ham as a function ham : 1 → IN ω, where 1 = {∗} is a one element set, one could try to define it by λ-coiteration. The idea is to employ a functor T mapping a set X to the set of terms freely generated by corresponding operator symbols merge and map (g : IN → IN ) over X and a
g
distributive law λ that equips these terms with a behaviour according to the definition of merge and mapg from above. The stream of Hamming Numbers should then arise as the λ-coiterative arrow induced by
φ := ∗ '→ ⟨1, merge(map (∗), map (∗))⟩ :1 → S T1.
∗2	∗3
We are going to study this schema in a more general setting in the remainder of this section.
The λ-Coiteration Schema on Terms
Assume we are given a signature ⟨Σ, ar⟩, i.e. a set Σ of operator symbols coming with an arity assignment ar : Σ → IN . Let ⟨T, η, µ⟩ denote the term monad generated by this signature. That is, TX is the set of terms freely generated by ⟨Σ, ar⟩ over X (we will sometimes call the set X a set of variables in this context), Tf renames all variables inside a term by applying f , ηX converts a variable x ∈ X into a term (we will usually leave its application implicit), and µX : T2 X → T X flattens two-level terms.

To use the functor T within λ-coiteration, we need to specify its interaction with F, i.e. a distributive law λ : TF ⇒ FT or, using the generalisation mentioned at the end of Section 3.4, λ : T(Id × F) ⇒ FT. We will concentrate on the latter type, since many examples for this approach require the greater expressiveness it offers.
Assume we are given such a distributive law λ. Let ⟨ΩF, ωF⟩ be a final F-coalgebra and let [. ] denote the coiterative morphism from Tλ ⟨ΩF, ωF⟩ to
⟨ΩF, ωF⟩. By applying Theorem 3.8 we get that for every operation φ : X →
FTX there is a unique arrow f : X → ΩF satisfying ωF ◦ f = F f|[[.]] ◦
φ. In the above example this means that ham is a unique arrow satisfying

head(ham)=1 and tail(ham)= [[merge(map
∗2
(∗), map
∗3
(∗))]]. For this to be a

solution for the above specification we need that [. ] evaluates terms according
to the (semantic) operators merge and mapg .	In particular, [. ] should be compositional, i.e. for all σ ∈ ΩF, ti ∈ TΩF we ask
[[σ]] = σ	and	[op(t1,..., tn)]] = [op([[t1]],..., [[tn]]) ].
It can be shown that we obtain a compositional T-algebra operation in case λ is compositional itself, which means it satisfies the modified unit and multiplication laws shown in Section 3.5. This is equivalent to saying that λ is constructed inductively from natural transformations
ρop : (Id × F)n ⇒ FT,
for each operator symbol op ∈ Σ, ar(op) = n. Then [. ] can be uniquely characterised as being compositional and satisfying
ωF([[op(σ1,..., σn)]]) = (F [.]])(ρop(⟨σ1, ωF(σ1)⟩,..., ⟨σn, ωF(σn)⟩)).
In our concrete example it is straightforward to come up with transfor- mations ρmerge and ρmapg such that the evaluation of terms using merge and mapg satisfies this characterisation. Using this we can easily compute that the λ-coiterative arrow above is the unique one satisfying the original specification.
Generally, the approach yields unique solutions for specifications involving a set of auxiliary operators that can be captured by natural transformations as in (3). This boils down to saying that for every operator op the first F-step of op(σ1,..., σn) can be determined by only looking at the direct observations for σi ∈ ΩF and the successor states contained are among the σi, their imme- diate successors, or any state that can be reached from those by applying the operators themselves (these restrictions are due to the naturality condition in
(3)). Turi and Plotkin [TP97] show that this type of operator specification is closely related to transition rules in GSOS format [BIM95].
The fact that [. ] evaluates terms by applying corresponding semantic op- erators can also be used to simplify the definition of λ-bisimulations on the

final F-coalgebra: Let B˜
denote the congruence closure of a given relation

B ⊆ ΩF × ΩF under all operators, i.e. the smallest relation containing B such
that for all operators op we have that ⟨op(σ1,..., σn), op(τ1,..., τn)⟩ ∈ B˜ if
⟨σi, τi⟩∈ B˜ for 1 ≤ i ≤ n. We get that B is a λ-bisimulation on ⟨ΩF, ωF⟩ if and

only if there is an operation χ : B → F B˜ making the diagram below commute (note that the projections πi in the upper and lower part of the diagram are taken w.r.t. different relations):

Ω ¸,π1
B 	π2	 Ω 

F		F
ωF	 ∃χ	ωF
J 	 J 	J 
FΩF ¸,  F B˜ 	 F ΩF
F π1	F π2
A relation satisfying this condition is sometimes called a bisimulation up-to- context [San98]. Our treatment abstractly justifies that all states related by a bisimulation up-to-context are bisimilar, if the contexts are built from oper- ators of the type mentioned above. As an example, the operators on formal power series Rutten considers for his stream calculus [Rut00a], of which we have seen the sum and convolution product already, all fit into this framework. The resulting proof principle up-to-context yields simpler proofs for many of the equations involving these operators he states in Theorem 4.1 in loc. cit.

Related and Future Work
As mentioned in the introduction, we developed our framework as an ad- vancement of Lenisa’s schemata [Len99a]. She defines the definition princi- ple of coiteration up-to-T for a pointed functor T = ⟨T, η⟩ – i.e. a functor T: C → C with a natural transformation η : Id ⇒ T – and a proof principle based on the notion of bisimulation up-to-T , which additionally assumes that the pointed functor distributes over the behaviour functor F via some λ and that it is actually taken from a monad ⟨T, η, µ⟩. In this case one can argue that there is a close relationship between our λ-coiterative arrows and her arrows coiterative up-to-T .
Our definition principle improves Lenisa’s in that it comes as a direct char- acterisation of the arrows to be defined instead of a construction. For the proof principles, λ-coiteration generalises the one based on bisimulations up-to-T in that it is no longer limited to bialgebras of the shape ⟨T X, µX, α⟩. These are central in Lenisa’s setting since the coalgebras involved appear within coiter- ation up-to-T . The main impact of this generalisation is presumably the fact that it allows one to work directly on the final coalgebra, as we have demon- strated in our example. This is particularly helpful since it obviates the need to reason up-to-bisimilarity, which arises in many examples but is possible with neither of the two principles yet. Generally, in relation to Lenisa’s the- ory we have emphasised and clarified the role of the distributive law, paying less attention to the monad structure.
Lenisa has used bisimulations up-to-T to derive a sound principle for prov- ing equivalences induced by arrows coiterative up-to-T . In our case of a λ- coiterative arrow f for φ : X → FTX her statement simplifies to the immedi- ate observation that all FT-bisimilar states in ⟨X, φ⟩ are equated by f . There

are clearly stronger statements to be found about the equivalence induced by
λ-coiterative arrows, which we leave for future work.
Another paper that our work on bisimilarity proofs is related to is that by Sangiorgi [San98]. It is about relational bisimulations for labelled transition systems in Set, but a reformulation in terms of spans between arbitrary F- coalgebras in an abstract category C should be possible (certainly requiring extra assumptions to be made for particular aspects of the theory to carry over). We expect that our notion of λ-bisimulation can be made to fit into such a framework (as argued in [Bar00]). This may open our technique for further examples covered by Sangiorgi’s method, like bisimulation up-to-bisimilarity (see e.g. [Mil89]).
Our use of a distributive law λ and λ-bialgebras follows that of Turi and Plotkin [TP97]. Starting from a signature functor Σ and a behavioural functor F, they describe program syntax using the term monad ⟨T, η, µ⟩ generated by Σ and global program behaviour by means of the behavioural comonad
⟨D, ε, δ⟩ generated by F. The specification of the semantics takes the shape of a distributive law λ of the monad over the comonad and its models are the λ-bialgebras.
In the example of corecursive definitions using operators from Section 5 our theory gets related to their setting, in that the functor T is taken from the term monad as well and that the class of well behaved operators here coincides with the main class considered by Turi and Plotkin. We add to their approach a separate treatment of specifications of the type φ : X → FTX, which are similar to what is sometimes called guarded recursive definitions. One of the advantages of treating the operators and solutions of the recursive specifications separately is that we obtain a notion of bisimulation up-to- context to reason about these solutions.
The setting of Turi and Plotkin is more general in the sense that they consider distributive laws of the term monad over the behavioural comonad
⟨D, ε, δ⟩ generated by F instead of F alone. This allows them to also treat a second major class of operators corresponding to tree rules. We cannot handle this class in our setting, which is in agreement with the fact that its operators may not safely be used for bisimulation up-to-context. Sangiorgi has already pointed out that this condition is stronger than only asking that bisimulation be a congruence for the operators under consideration (see the example at the end of Section 2 in [San98]). The latter condition is the decisive one for Turi and Plotkin’s approach.
We left for future work the quest for further interesting instances of our framework. Since we found sufficient conditions for our schema to work that do not assume the functor T to come as a pointed functor or monad, it would be particularly nice to come up with examples exploiting this generality. In all the examples we have so far this structure can be added immediately or at least after a straightforward reformulation of the problem.
Another interesting aspect to study would be the interplay of λ-coiterative

arrows and invariant properties.
Acknowledgements
I would like to thank my colleagues, in particular Jan Rutten, Alexandru Bal- tag, and Alexander Kurz, for discussions and guidance. I am further grateful to Dirk Pattinson for suggestions and to the anonymous referees for helpful hints. Special thanks go to Matteo Coccia, who raised my interest in Category Theory during his stay at the CWI.

References
[AM89] Peter Aczel and Nax Mendler. A final coalgebra theorem. In D.H. Pitt, D.E. Rydeheard, P. Dybjer, A.M. Pitts, and A. Poign´e, editors, Proceedings 3rd Conf. on Category Theory and Computer Science, CTCS’89, Manchester, UK, 5–8 Sept 1989, volume 389 of Lecture Notes in Computer Science, pages 357–365. Springer-Verlag, Berlin, 1989.
[Bar00] F. Bartels. Generalised coinduction. Technical Report SEN-R0043, CWI
- Centrum voor Wiskunde en Informatica, December 2000.
[BIM95] Bard Bloom, Sorin Istrail, and Albert R. Meyer. Bisimulation can’t be traced. Journal of the ACM, 42(1):232–268, January 1995.
[Dij81] E.W. Dijkstra. Hamming’s exercise in sasl. Personal Note EWD792, see
http://www.cs.utexas.edu/users/EWD/, 1981.
[JR96] Bart Jacobs and Jan Rutten. A tutorial on (co)algebras and (co)induction.
Bulletin of the EATCS, 62:222–259, 1996.
[JR99] B. Jacobs and J. Rutten, editors. Proc. Coalgebraic Methods in Computer Science (CMCS 1999), volume 19 of Electronic Notes in Theoretical Computer Science, 1999.
[Len99a] M. Lenisa. From set-theoretic coinduction to coalgebraic coinduction: Some results, some problems. Unpublished extension of [Len99b] (available through the author’s homepage at http://www.dimi.uniud. it/~lenisa/), December 1999.
[Len99b] M. Lenisa. From set-theoretic coinduction to coalgebraic coinduction: some results, some problems. In Jacobs and Rutten [JR99], pages 1–21.
[LPW00] M. Lenisa, J. Power, and H. Watanabe. Distributivity for endofunctors, pointed and co-pointed endofunctors, monads and comonads.	In
H. Reichel, editor, Proc. Coalgebraic Methods in Computer Science (CMCS 2000), volume 33 of Electronic Notes in Theoretical Computer Science, pages 233–263, 2000.
[Mil89] R. Milner. Communication and Concurrency. International Series in Computer Science. Prentice Hall, 1989.


[PW99] J. Power and H. Watanabe. Distributivity for a monad and a comonad.
In Jacobs and Rutten [JR99], pages 119–132.
[Rut00a] J.J.M.M. Rutten. Behavioural differential equations: a coinductive calculus of streams, automata, and power series. Technical Report SEN- R0023, CWI - Centrum voor Wiskunde en Informatica, 2000.
[Rut00b] J.J.M.M. Rutten. Universal coalgebra: A theory of systems. Theoretical Computer Science, 249(1):3–80, October 2000.
[San98] D. Sangiorgi. On the bisimulation proof method. Journal of Mathematical Structures in Computer Science, 8:447–479, 1998.
[Sij89] Ben A. Sijtsma. On the Productivity of Recursive List Definitions. ACM Transactions on Programming Languages and Systems, 11(4):633–649, October 1989.
[TP97] D. Turi and G.D. Plotkin. Towards a mathematical operational semantics. In Proc. 12th LICS Conf., pages 280–291. IEEE, Computer Society Press, 1997.
[UV99] Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course- of-value (co)iteration, categorically. INFORMATICA (IMI, Lithuania), 10(1):5–26, 1999.
