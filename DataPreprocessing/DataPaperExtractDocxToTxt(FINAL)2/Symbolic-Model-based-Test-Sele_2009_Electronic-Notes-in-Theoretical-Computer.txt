

Electronic Notes in Theoretical Computer Science 240 (2009) 167–184
www.elsevier.com/locate/entcs
Symbolic Model-based Test Selection
Thierry J´eron1,2
IRISA / INRIA Rennes - Bretagne Atlantique Campus de Beaulieu, 35042 Rennes – France

Abstract
This paper addresses the problem of model-based off-line selection of test cases for testing the conformance of a black-box implementation with respect to a specification, in the context of reactive systems. Efficient solutions to this problem have been proposed for LTS finite-state models, based on the ioco conformance testing theory. In this paper, the approach is extended for infinite-state specifications, modelled as automata extended with variables. When considering the selection of test cases according to test purposes (abstract
scenarii focused by test cases), the selection of test cases relies on approximate co-reachability analyses using abstract interpretation and syntactical transformations guided by this analysis, while test execution uses constraint solving.
Keywords: Model-based testing, conformance, test selection, model, reactive systems


Introduction
Many aspects of software can be tested to assess its correctness e.g., functionality, performance, timing, robustness, etc. Among these, the focus of this paper is on conformance testing of reactive systems. This consists in checking that a black-box implementation of a system, only known by its interactions with the environment through an interface, behaves correctly with respect to its specification. This relies on experimenting the system with test cases, with the objective of detecting some faults, or to improve the confidence one may have in the implementation.
Automatization of some parts of the testing activity, using models of software and formal methods is a way to improve the quality and cost of testing. For more than a decade, model-based testing (see e.g., [5]) advocates the use of formal models and methods to formalize this activity. The formalization relies on models of testing artifacts, relations between them including conformance, and properties they satisfy. For reactive systems, behavioral models are used for specifications, and serve both

1 Email: Thierry.Jeron@irisa.fr, Web: www.irisa.fr/prive/jeron
2 We would like to thank colleagues who participated in this research work, and the SBMF ’08 committee for their invitation to present this work.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.051

as a basis for test generation, and as an oracle for the assignment of verdicts in test cases. Testing theories based on finite-state models such as automata (see e.g., the survey [19]), or labelled transition systems (see e.g., [25]) are now well understood, and gave rise to automatic test generation algorithms and tools like TorX [2], TGV [14], Gotcha [3] among others, have been developed and successfully used on industrial-size systems.
Some developments are still necessary to improve the automation of test gen- eration. In particular more powerful models taking into account some aspects of complex software must be considered such as data, time, etc. In this paper we fo- cus on data, and models called Input/Output Symbolic Transition Systems (ioSTS) are considered. These are automata extended with variables, with distinguished input and output actions, and corresponding to reactive programs without recur-
sion. As their semantics can be defined in terms of infinite-state Input/Output Labelled Transition Systems (ioLTS), the ioco testing theory [25], which defines conformance as a partial inclusion of external behaviours (suspension traces) of the
implementation in those of the specification, can be reused. The difficulty is in the selection of test cases. Test cases are programs with variables, directly built from the ioSTS model rather than from the enumerated ioLTS semantic model. This construction relies on syntactical transformations of the specification model, guided by an approximate analysis. The models and principles of the test selection algo- rithms are illustrated by a simple example of a lift controller. The test selection algorithms described in this paper are implemented in the STG tool [16] (see http:
//www.irisa.fr/vertecs/software.html#STG). The approximate co-reachability and reachability analyses are provided by an interface with the NBac tool [15] (see http://pop-art.inrialpes.fr/people/bjeannet/nbac/index.html) using abstract interpretation [8]. This work builds on previous work by our team such as [24,17].

Related work
Several other works, done in the context of conformance testing or white bow testing can be related to our work.
Some are based on symbolic execution [4,13] and/or constraint resolution: the DART tool [11] combines symbolic execution with random testing and constraint solving, the PET tool [12] uses constraint solving to produce test cases as solu- tions to path conditions produced from a specification and a property, the Agatha tool [10] uses symbolic execution on a variation of the ioSTS model, the Gatel [23] and BZ-TT [20] tools rely on constraint solving. In [21] the authors use selection hypotheses combined with unfolding for algebraic data types and predicate resolu- tion to produce test cases. Compared to our approach, these approaches are limited to deterministic systems, and consider finite unfoldings of systems by limiting the search depth in order to cope with loops, but they may produce precise test cases. Nevertheless, these are complementary methods: test selection with test purposes using approximate analyses can be seen as a front-end used to select an abstract test case, where information on non-conformance is preserved.  Then constraint

solving techniques can be used to search for instantiated test cases, by limiting the unfolding of remaining loops.
Other approaches are funded on abstractions: [6] uses TGV on an abstraction before concretization of test cases using constraint solving, and Ball [1] uses a combi- nation of predicate abstraction, reachability analysis and symbolic execution. Very recently, abstract interpretation has also been proposed in the context of white box structural testing in combination with constraint solving [9].

Modeling reactive systems with ioSTS
In this section, a model of reactive systems, called ioSTS for Input/Output Sym- bolic Transition Systems, is proposed which will serve for specifications, test cases and test purposes. This model is a kind of extended automata model, inspired by I/O automata [22]. It is made of a set of variables (including one encoding control locations) which encode the state of the system, and transitions with guards, input and output actions with communication parameters and assignments of variables to expressions.
Definition 2.1 [ioSTS ] An Input/Output Symbolic Transition System M is de- fined by a tuple (V, Θ, Σ,T ) where:
V = Vi ∪ Vx is the set of variables, partitioned into a set Vi of internal variables and a set Vx of external variables. Dv denotes the domain in which v takes its values,
Θ is the initial condition. It is a predicate Θ ⊆ DVi defined on internal variables. It is assumed that Θ has a unique solution in DVi .
Σ = Σ? ∪ Σ! is the finite alphabet of actions. Each action a has a signature sig(a), which is a tuple of types sig(a) = ⟨t1,..., tk⟩ specifying the types of the communication parameters carried by the action.
T is a finite set of symbolic transitions. A symbolic transition t = (a, p, G, A), also written [ a(p) : G(v, p)? v' := A(v, p) ], is defined by
an action a ∈ Σ and a tuple of (formal) communication parameters p =
⟨p1,..., pk⟩, which are local to a transition; without loss of generality, it is assumed that each action a always carries the same vector p, which is supposed to be well-typed w.r.t.  the signature sig(a) = ⟨t1,..., tk⟩; Dp is denoted by
Dsig(a);
a guard G ⊆ DV × Dsig(a), is a predicate on variables (internal and external)
and communication parameters.
an assignment A : DV × Dsig(a) → DVi , which defines the evolution of the internal variables. Av : DV × Dsig(a) → Dv denotes the function in A defining the evolution of the variable v ∈ Vi.
This model does not explicitly define control locations, but these can be encoded (as in the examples) by a variable pc with finite domain. One particularity of the model is the distinction made between internal and external variables.  Internal

variables are standard variables defining the state of the system itself, while external variables are used to observe the state of another system (thus modified by this other system). As will be seen, this allows to use the same model for specifications and test purposes. It is assumed that guards are expressed in a theory in which satisfiability is decidable. We will come back later to the hypothesis of satisfiability of guards, which will be important during test execution.

Example 2.2 Fig. 1 describes an example of ioSTS specifying a simple lift con- troller (the dashed edges labelled with δ are not part of the specification and will be explained later). The integer constant h specifies the height of the building, the integer variables c and g are initialized to 0 and respectively specify the current level, and the target level. Wait, Move and End are control locations (values of the pc variable). In location Wait, an input Target? is read and a level is chosen by providing a value between 0 and h to the parameter p, then stored in g, and the lift controller reaches Move. In location Move, if the current level c equals the target level g, a Stop!(p) is sent with p = c. If c < g, an output Up!(p) is sent with p = c, and c is increased. If c > g, the output Down!(p) is sent with parameter p = c, and c is decreased. In case of breakdown, the controller may non-dterministically send an output Break! and go to state End.







0 ≤ p ≤ h T arget?(p) g := p

c < g ∧ p = c Up!(p)


c = g =0 


c = g ∧ p = c Stop!(p)
c > g ∧ p = c Down!(p) c := c − 1


Fig. 1. ioSTS specification S of a simple lift controller example



The semantics of an ioSTS M = (V, Θ, Σ,T ) is an input/output labelled tran- sition system (ioLTS) M) = (Q, Q0, Λ, →) where:
Q = DV is the set of states;
Q0 = {ν = ⟨νi, νx⟩ | νi ∈ Θ ∧ νx ∈ DVx } is the subset of initial states;
Λ = {⟨a, π⟩ | a ∈ Σ ∧ π ∈ Dsig(a)} is the set of valued actions partitioned into
valued inputs Λ?, and valued outputs Λ!;

the transition relation → is defined by

(a, p, G, A) ∈ T	ν = ⟨νi, νx⟩∈ DV	π ∈ Dsig(a)	ν' = ⟨ν' , ν' ⟩∈ DV


G(ν, π)	ν' = A(ν, π)
i	x


(Sem)

⟨a,π⟩
ν  → ν'
Intuitively a state is composed of the values of internal and external variables. The set of initial states is composed of states where the internal part is uniquely determined by Θ, while the external part is arbitrary. Transitions are labelled by valued actions and the set of transitions is determined by the rule (Sem): in a state ν = ⟨νi, νx⟩, a transition (a, p, G, A) can be fired if there exists a valuation π of the communication parameters p such that ⟨ν, π⟩ satisfies the guard G; the valued action ⟨a, π⟩ is then taken, resulting in a state ν' where the new values of the internal variables are defined by the assignment A, while external variables take arbitrary values, which reflects the fact that their value is defined by another ioSTS. As variables may have infinite domains, the semantics of an ioSTS may be an infinite-state ioLTS.
Example 2.3 The lift-controller example having no external variable, states are composed of values of the variables pc (locations), c (current level) and g (target level).

Notations on ioLTS
In the sequel we will use standard notations of LTS. As usual q →α  q' is used
for (q, a, q') ∈→ and q →α  for ∃q',q →α  q'. For a sub-alphabet Λ' ⊆ Λ, a state q
of M is said Λ'-complete if ∀α ∈ Λ' : q →α . It is complete if it is Λ-complete. The ioLTS M) is Λ'-complete (resp. complete) if all its states are Λ'-complete (resp. complete). Note that these completeness conditions can be defined on ioSTS: an ioSTS M is Σ'-complete for Σ' ⊆ Σ, if for any a ∈ Σ', the predicate	¬G is unsatisfiable (otherwise said ∀a ∈ Σ', (a,p,G,A)∈T G = true).

Runs and traces.
The behavior of an ioSTS is defined by its ioLTS semantics. A run of an ioSTS
M is an alternate sequence of states and valued actions ρ = q0α0q1 ... αn−1qn ∈

Q0.(Λ.Q)∗ s.t.	∀i, qi
→αi
qi+1
.	The run ρ is accepted in	F  ⊆ Q if qn
∈ F .

Runs(M) denotes the set of runs of M and RunsF (M) is the set of accepted
runs in F . When modelling the testing activity, we consider abstractions of runs where states are abstracted away, as variables and locations cannot be observed by the environment. A trace of a run ρ ∈ Runs(M) is the projection proj Λ(ρ) of
ρ on actions. Traces(M)  proj Λ(Runs(M)) denotes the set of traces of M and
TracesF (M)   proj Λ(RunsF (M)) is the set of traces of runs accepted in F .
For the sake of simplicity, we restrict to deterministic ioSTS, where an ioSTS M = (V, Θ, Σ,T ) is deterministic if for any action a ∈ Σ, and any pair of transitions t1 = (a, p, G1, A1) and t2 = (a, p, G2, A2) carrying the same action, the conjunction

of the guards G1 ∧ G2 is unsatisfiable. In fact, it is not always possible to transform an ioSTS into a deterministic one having the same set of traces. However, a class of ioSTS as been identified which can be determinized effectively [18].
When testing for conformance, one is interested in comparing the observable behavior, thus traces of the implementation with the ones of the specification. Ad- ditionally, one can also observe quiescences of the implementation, and check that they are allowed by the specification. A quiescence occurs when no output is fire- able: the system is blocked unless the environment provides an input. A particular case is a deadlock, i.e., when additionally no input is fireable. As quiescence is not preserved by determinization (the same trace can lead to a quiescent and a non-
quiescent state), this information has to be computed before determinization. The corresponding transformation called suspension was originally defined for ioLTS [25], and here denoted Δ. It consists in adding a self loop labelled with a new output
δ in every quiescent state. Suspension is here defined directly for ioSTS with the expected effect on the ioLTS semantics (i.e.  Δ(M)) = Δ( M))):
Definition 2.4 [ioSTS suspension] For an ioSTS M = (V, Θ, Σ,T ) with alphabet Σ = Σ! ∪ Σ?, the suspension of M is the ioSTS Δ(M) = (V, Θ, Σδ, Tδ) where:
the alphabet is increased by a new output: Σδ = Σδ ∪ Σ? with Σδ = Σ! ∪ {δ},
!	!
new loop transitions labelled by δ are added: Tδ = T ∪ {⟨δ, Gδ,IdV ⟩} with

Gδ = ¬	∃π ∈ Dsig(a) : G(ν, π)
⎝(a,p,G,A)∈T, a∈Σ!	⎠
The guard Gδ associated to δ evaluates to true exactly when there is no valuation of variables and communication parameters such that an output can be fired.
The definition of suspension leads to the the observable behavior considered for testing of an ioSTS M can be defined as the traces of its suspension Δ(M). The set Traces(Δ(M)) will be denoted by STraces(M). These suspension traces are the
reference for conformance testing and will thus be central in the definition of the conformance relation.
Example 2.5 For the lift-controller example, Fig. 1 describes the suspension au- tomaton, with δ actions with guards true in states Wait (no output is firebale) and End (deadlock).

Conformance testing theory
Conformance testing consists in checking that an implementation exhibits an ob- servable behavior consistent with its specification. In order to formalize this, one has to fix models for specifications, implementations and test cases:
The specification is a deterministic ioSTS S = (V S , ΘS, Σ,TS ), with Σ = Σ! ∪ Σ? and V S = ∅ (S has only internal variables). Its ioLTS semantics is S) = S = (Q, Q0, Λ, →) with Λ = Λ! ∪ Λ?.

Implementations are unknown, except for their interfaces and are not models but real systems. However, in order to reason about conformance, implementations are assumed to behave as models. The implementation is modelled by a (possibly non-deterministic) ioLTS I = (QI, Q0, Λ! ∪ Λ?, →I ) having the same interface as
S. I is assumed to be Λ?-complete 3 . Δ(I) denotes its suspension ioLTS.
A test case for the specification ioSTS S is a deterministic ioSTS TC =

(V TC , ΘTC , ΣTC ,TTC ), where ΣTC
= Σ! and ΣTC
= Σ? (actions are mir-

rored w.r.t.  S), equipped with a variable Verdict ∈ V TC of the enumerated
type {none, fail, pass, inconc}. Intuitively, fail means rejection, pass means that some targeted behaviour has been reached (this will be clarified later) and inconc means that targeted behaviours cannot been reached anymore. TC is
assumed to be ΣTC -complete in all states where Verdict = none. This means that
TC is ready to react to any output of the implementation, except when a ver- dict is reached and the execution stops. TC = T C) = (QTC , qTC , ΛTC , →TC ) denotes the ioLTS semantics of T C. The predicates Fail = (Verdict = fail), Pass = (Verdict = pass), and Inconc = (Verdict = inconc) denote the subsets of QTC where verdicts are emitted.
We are now ready to formalize conformance. We consider the ioco conformance relation [25] which says that after any suspension trace of the specification, outputs (or quiescences) of the implementation must be specified. We here adopt a definition where non-conformant suspension traces are explicit:
Definition 3.1 [Conformance] Let S be a specification, and I be an implementa- tion of S. The ioco conformance relation is defined as:
I ioco S  STraces(I) ∩ NC STraces(S) = ∅
where NC STraces(S) = STraces(S) · (Λ! ∪ {δ}) \ STraces(S) is the set of minimal (with respect to the prefix order) non-conformant suspension traces.
Example 3.2 For the lift-controller with constant h	=	10, the suspen- sion trace δ!.T arget?(5).Up!(0).Up!(1).Up!(2).Up!(3).Up!(4).Stop!(5) is conformant,
while Target?(5).Up!(0).Up(1).Up(2).Down!(3).Up!(2).Up(3).Up(4).Stop!(5) is not as the lift is not supposed to go down if the lift is lower than the target level.
The definition of conformance exhibits the fact that conformance is a safety property: it can be violated by a finite trace. As usual, the negation of this safety property can be defined by an observer which recognizes the non-confomant sus- pension traces NC STraces(S), giving rise to the definition of the canonical tester:
Definition 3.3 [Canonical Tester] Let S = (V S , ΘS, Σ,TS ) be a deterministic ioSTS and Δ(S) = (V S , ΘS, Σδ,TS ) its suspension.  The canonical tester for S is the (deterministic) ioSTS Can(S) = (V Can , ΘCan , ΣCan ,TCan ) such that:
V Can = V S ∪ {Verdict} where Verdict is of the enumerated type {none, fail}

3 This ensures that the composition of I with a test case TC never blocks because of non-implemented inputs.

ΘCan = Θ£ ∧ Verdict = none;
ΣCan = Σδ and ΣCan = Σ? (the alphabet is mirrored w.r.t. Δ(S))
?	!	!

TCan is defined by the rules:


t ∈ T Δ(£)


t ∈ TCan


(Keep


T£ )

a ∈ Σδ = ΣCan
Ga =  (a,p,G,A)∈T Δ(S) ¬G

 a(p) : G (v, p)? Verdict' := fail ∈ TCan	(Input-completion)
Example 3.4 The canonical tester of the lift-controller is described in Fig. 2. First the inputs and outputs are reversed compared to S and new transitions to a Fail location have been added, labelled with actions with negations of the guards of transitions in S, e.g., from the Move location, the transition carrying Up!(p) is guarded by c < g ∧ p = c in S, and a new transition to Fail carrying Up!(p) and guarded by c ≥ g ∨ p /= c is added in Can(S).


0 ≤ p ≤ h T arget!(p)
δ?	g := p
c < g Λ p = c Up?(p)
c := c +1	δ?


c = g =0 









Down?(p)	Down?(p)
Fig. 2. Canonical tester


Can(S) is a test case by itself: it is deterministic and ΣCan -complete in all states where Verdict = none. Moreover Can(S) exactly recognizes non-conformant behaviours in its Fail states, as TracesFail(Can(S)) = NC STraces(S). Conformance can then be expressed using the canonical tester:
I ioco S ⇐⇒ STraces(I) ∩ TracesFail(Can(S)) = ∅
If I was known, checking non-conformance would be simple. However, as I is unknown, complete verification is impossible and one has to experiment the im- plementation with selected test cases. The canonical tester will play a central roˆle in this selection. Test cases will have to satisfy some properties. In order to de- fine these, the execution of a test case on an (model of) implementation must be formalized first.

Let I be an implementation with Δ(I) = (QI, QI, Λ! ∪ {δ} ∪ Λ?, →Δ(I)) its suspension, and TC = (QTC , qTC , Λ? ∪ Λ! ∪ {δ}, →TC ) the ioLTS semantics of an ioSTS test case T C. The test execution of TC on I is modelled by the parallel composition of Δ(I) and TC , an ioLTS Δ(I)  TC = (QI × QTC , QI × {qTC }, Λ! ∪
0	0
{δ}∪ Λ?, →Δ(I) TC ) where →Δ(I) TC , is defined by the rule:
α ∈ Λ! ∪ {δ}∪ Λ?	q1 →α	q2	q' →α TC q'
Δ(I)	1	2
(q1, q' ) →α	(q2, q' )

It then follows that
1	Δ(I)  TC	2

Traces(Δ(I)  TC ) = STraces(I) ∩ Traces(TC ) = STraces(I) ∩ Traces(T C) For P ∈ {Fail, Pass, Inconc}, one also gets
TracesQI×P (Δ(I)  TC ) = STraces(I) ∩ TracesP (TC )
The main result of the execution of a test case on an implementation is the verdict that it emits. As this execution is not fully determined due to non-controlable choices made by the implementation, this execution may result in several traces. We then formalize the potential failure of a test case on an implementation as the fact that one of these executions may lead to a Fail verdict:
TC mayfail I  TracesQI×Fail(Δ(I)  TC ) /= ∅
which is equivalent to STraces(I) ∩ TracesFail(TC ) /= ∅.

Test case properties:
Basic properties are essential to guarantee that selected test cases are related to the conformance relation. A set of test cases TS is said complete if it is both sound and exhaustive where:
TS is sound  ∀I : (I ioco S =⇒ ∀TC ∈ TS : ¬(TC mayfail I)), i.e., only non-conformant implementations may be rejected by a test case in TS .
TS is exhaustive  ∀I : (¬(I ioco S) =⇒ ∃TC ∈ TS : TC mayfail I), i.e., any non-conformant implementation may be rejected by a test case in TS .
As TC mayfail I ⇐⇒ STraces(I) ∩ TracesFail(TC ) /= ∅ and I ioco S ⇐⇒ STraces(I) ∩TracesFail(Can(S)) = ∅ these properties can be related to the canonical tester as follows:
TS is sound	iff  TC ∈TS TracesFail(TC ) ⊆ TracesFail(Can(S)), TS is exhaustive iff  TC ∈TS TracesFail(TC ) ⊇ TracesFail(Can(S)).
This means that sound test cases are sub-observers of the canonical tester, and that an exhaustive test suite should capture exactly the same non-conformant be- haviors as the canonical tester. Clearly, the canonical tester is by itself a complete

test case. In some sense, this is the idea used in the TorX tool [2] for on-line test- ing for ioLTS models: the tool either non-deterministically chooses an input of the canonical tester to feed the implementation or checks that the outputs produced by the implementation does not reach Fail in the canonical tester, or stops by giving a Pass verdict. Traces of these executions form sound test cases, but exhaustiveness is in general lost when considering finite executions.
In off-line test selection, one renounces to exhaustiveness and selects test cases among all possible sound ones. The non-deterministic algorithm of [25] can then be understood as the production of a test case by an unfolding of the canonical tester. As will be seen later, one can also use test purposes to select test cases that focus on some particular behaviors. In both cases, even if exhaustiveness is lost by any finite set of test cases, one can still prove that the (inifnite) set of all test cases that could be produced is exhaustive. which guarantees that for any non-conformant implementation, there is a possibility to detect it by one test case produced by the algorithm.

Test selection
The test selection algorithm proposed in this paper is based on the notion of test purpose. In practice, a test purpose attached to a test case specifies the intention of the test case. The formalization of a test purpose by an ioSTS observer allows to specify abstract behaviors one is interested to test.
Definition 4.1 [Test purpose] For a specification £ = (V, Θ, Σ = Σ! ∪ Σ?,T ), a
Test Purpose is a deterministic ioSTS 7У = (V TP , ΘTP , Σδ,TTP ) such that:
V TP = V S: test purposes are allowed to observe the internal state of £;
x	i
V TP ∩V S = ∅ and V TP contains a program counter variable pcTP with accept ∈
i	i	i
ÐpcTP . Its set of accepting states is Accept = (pcTP = accept).
7У should be complete except when pcTP = accept, which means that for any action a ∈ Σδ, pcTP /= accept ⇒ (a,p,G,A)∈T TP G = true. This ensures that 7У does not restrict the runs of £ before they are accepted (if ever).
Example 4.2 A test purpose for the lift-controller is described by Fig. 3. The dashed transitions are those that are automatically added by the STG tool, e.g., loops in locations labelled by actions that do not appear as outgoing transitions, and transitions to a Sink location guarded by the negation of the union of guards of the same action in outgoing transitions. The intention of this test purpose is to select behaviors where a first Stop(p) occurs at a certain level l storing the value of p, and a second Stop(p) occurs at a level p which is exactly the half of l (2p = l), and less than the third of h (3p ≥ h). One immediately notice that l should be even.
A test purpose, with its set of accepting states allows to recognize behaviors of the specification. More precisely, it allows to recognize runs. In the case of automata or ioLTS, a synchronous product is used to capture this idea. Similarly,


Σδ \ Stop!(p)	Σδ \ Stop!(p)


l =0 






Fig. 3. A test purpose
a synchronous product for ioSTS can be defined. This synchronous product is here specialized for the canonical tester Can(£) = (V Can , ΘCan , Σδ,TCan ) and a test purpose 7У = (V TP , ΘTP , Σδ,TTP ) with V TP = V Can :
x	i
The synchronous product of Can(£) and 7У is the ioSTS У = Can(£) ×7 У = (V P , ΘP , ΣCan ,TP ) where:
V P = V P ∪ V P , with V P = V Can ∪ V TP and V P = ∅;
i	x	i	i	i	x
ΘP (⟨vCan , vTP ⟩) = ΘCan (vCan ) ∧ ΘTP (vTP );
TP is defined by the following inference rule:

[ a(p) : Gc(vc, p)? (vc)' := Ac(vc, p)] ∈ TCan
 a(p) : Gt(vt, p)? (vt)' := At(vt, p)  ∈ TTP

 a(p) : Gc(vc, p) ∧ Gt(vt, p)? 
(vc)' := Ac(vc, p), (vt)' := At(vt, p) ∈ TP

We denote У' the ioSTS obtained by adding the assignment Verdict := pass to all transitions with assignment pc' := accept.
Example 4.3 The synchronous product £×7 У for the lift controller is represented in Fig. 4. For simplicity, we did not represent the ioSTS for У' = Can(£) ×7 У. У' would have the same structure, plus transitions to a Fail location labelled with actions with negations of guards of outgoing transitions in £×7 У as in the canonical tester.
As 7У is non-intrusive (it observes but does not modify variables of £), one gets
Traces(У') ⊆ Traces(Can(£)) and TracesFail(У') = Traces(У')∩TracesFail(Can(£))

This means that У' detects every non-conformance along its traces. It is thus a sound test case. One also gets
TracesPass(У') = TracesAccept(У) ⊆ STraces(£) ∩ TracesAccept(7 У) The inclusion becomes an equality if 7У does not observe variables of £.





δ?

c = g =0 
l =0 







Fig. 4. Synchronous product £ × T P


Note that У' has two distinguished roˆles: it is both an observer of non- conformant suspension traces with its Fail states, and an observer of the abstract behaviors one wants to test with its Pass states. But no test selection has been performed yet. An ideal selection would mean to select TracesPass(У'), and, along these traces, unspecified outputs leading to Fail. However, systems are not fully controllable: outputs are not fully determined by inputs because of choices made by the system. This entails that all specified outputs have to be considered after a trace: outputs from which Pass is reachable or Fail is reached, but also outputs after which Pass is not reachable anymore, which is denoted by the Inconc verdict And in this last case, one would like to detect the divergence as soon as possible, i.e., on the first output where this occurs.
This amounts to computing the set of states from which Pass is reachable, denoted coreach(Pass), which is the least fix-point of an monotonic function in the lattice 2Q of subsets of Q:  coreach(Pass) = lfp(λX.Pass ∪ pre(X)) where
pre(X) = {q | ∃q' ∈ X, ∃α ∈ Λ : q →α  q'} is the set of states from which X
can be reached in one transition.
In the case of finite ioLTS, coreach(Pass) is easily computed with graph algo- rithms (computation of strongly connected components), as implemented in the TGV tool [14]. However the set coreach(Pass) is not computable for ioSTS. A solution then consists in computing an over-approximation. This is the idea used in the STG tool, with the help of the NBAC tool, a verification tool based on abstract interpretation. How this computation is performed by NBAC is not detailled (other techniques and tools could compute such an approximation) but we assume that an over-approximation has been computed, and explain how this approximation is used in the selection of test cases. The main idea of test selection is to trans- form У' = (V P ' , ΘP' , ΣCan ,TP ' ) together with its set of Fail and Pass states into a test case 7 C, by reinforcing the guards of transitions of У' in order to try to stay in coreach(Pass). As this set is not computable, this set and thus the guards are over-approximated.
Given a set of states X ∈ Ðv represented by a formula X(v), let pre(A)(X)(v, p) denote the precondition of X by an assignment A : Ðv × Ðp → Ðv:

pre(A)(X)(v, p)  =  ∃vs : X(vs) ∧ vs = A(v, p)  =  X(A(v, p))
In other words, pre(A)(X)(v, p) represents the set of values of variables v and parameters p from which X is reached after the assignment A. Note that the operator pre(A) is monotone. Assume that one can compute a monotone over- approximationpreα(A)(X) ⊇ pre(A)(X) of pre(A)(X).
Assume now that an over-approximation coreachα of coreach(Pass) has been computed. This computation typicaly uses the operation preα(A)(X), together with a widening operator which guarantees the termination of fix-point iterations. We assume that coreachα is represented by a predicate.
The predicate preα(A)(coreachα) is then an over-approximation of the set of values for variables and parameters which allow to stay in coreach(Pass) when tak- ing a transition (a, p, G, A). In other words it is a necessary condition to stay in coreach(Pass). Its negation is thus a sufficient condition to leave coreach(Pass). We use this to reinforce the guards and compute a test case from У'.
The test case for £ and 7У is the ioSTS 7C = (V P ' , ΘP' , ΣCan ,TF C ) where
TFC is defined from У' by the three rules:


(a, p, G, A) ∈ T P ' a ∈ ΣCan G' = preα(A)(coreachα) (a, p,G Λ G', A) ∈ T TC 

(Select)

(a, p, G, A) ∈ T P '  a ∈ ΣCan A
= Verdict' := fail

	?	Verdict	
(a, p, G, A) ∈ T TC 
(Fail)

(a, p, G, A) ∈ T P '  a ∈ ΣCan
AVerdict
/= Verdict' := fail

G' = preα(A)(coreachα)
(a, p,G Λ G', A), (a, p,G Λ чG', A') ∈ T TC 

(Split)

where A'
is defined by
'
Verdict
= Verdict' := inconc,

A' = Av for v /= Verdict,

The transformation treats inputs and outputs differently, because the tester controls its outputs, but only observes its inputs. The first rule (Select) is for outputs. It consists in reinforcing the guard with G' = preα(A)(coreachα) in order to keep a chance to stay in coreach(Pass) after the transition. Implicitly this rule forbids all outputs that would certainly leave coreach(Pass). The two other rules are concerned with non-controlable inputs. The first one (Fail) keeps all transitions with Fail verdict. The second splits transitions labelled with inputs into two new transitions: one by which we may stay in coreach(Pass) by reinforcing the guard with G', the other one by which we are sure to leave coreach(Pass) by reinforcing the guard with the negation of G'. In this second case an Inconc verdict is set.
The test case can be further simplified with an over-approximation reachα(ΘP' ) of its reachable states reach(ΘP' ) where reach(ΘP' ) = lfp(λX.ΘP' ∪ post (X)) with
post (X) = {q' | ∃q ∈ X, ∃α ∈ Λ : q →α q'} being the set of states reachable from
X in one transition. The simplification consists in removing transitions of which the guards are unsatisfiable in the over-approximation reachα(ΘP' ) of the set of reachable states i.e., transitions (a, p, G, A) where G ∧ reachα(ΘP' ) simplifies to
false. Note that, this transformation is purely syntactic: it does not modify the

semantics of TC as it only removes infeasible transitions.
Example 4.4 The results of the backward and forward analysis computed by the NBAC tool are described in the following table:



Notice that the analysis is not exact as the fact that the first target level should be even is lost: NBAC is not able to infer this as it restricts its analysis to polyhedra, and parity is not a linear constraint.
As a consequence of these analyses, the resulting test case is computed, as shown in Fig. 5 (for clarity, transitions to Fail are not represented but can be obtained by complementation of guards). The coreachability analysis allows to constraint the guards of transitions. In particular for outputs, the first transition carrying Target(p) is enforced by 3p ≤ 2h as preα(g := p)(3g ≤ 2h) = 3p ≤ 2h, and the second one by 3p ≤ h ∧ 2p = l as preα(g := p)(g ≤ c ≤ 2g = l ∧ 3g ≤ h∧) = 3p ≤ h ∧ 2p = l.
The reachability analysis then allows to cut non-fireable transitions. In location Move, S1 (resp. Move, S2) the transition carrying Down?(p) (resp. Up?(p)) is not fireable as its guard c > g∧p = c (resp. c < g∧p = c) is unsatisfiable when 0 ≤ c ≤ g (resp. g ≤ c ≤ 2g). Similarly the guard c = g ∧ p = c ∧ 2p /= l ∨ 3p > h of the transition from Move, S2 to Wait, Sink is unsatisfiable when g ≤ c ≤ 2g ∧ 3g ≤ h.

Properties of selected test cases
As expected, it can be proved that the (infinite) set of test cases that can be produced by the test selection algorithm is sound and exhaustive. Soundness directly comes from the soundness of Can(S), which is preserved by synchronous product and selection (these transformation do not add any trace leading to Fail). For exhaustiveness, the idea is, for any non-conformant trace σ.a ∈ NC STraces(()S) = TracesFail(Can(S)), to identify a test purpose 7У for which the selection produces

c < g Λ p = c

0 ≤ p ≤ h Up?(p) c = g Λ p = c δ?	Λ3p ≤ 2h c := c +1 Λ 3c ≤ 2h
0 ≤ p ≤ hΛ δ? 3p ≤ h Λ 2p = l
c = g Λ p = cΛ
2p = l Λ 3p ≤ h


c = g =0 
l =0 








Fig. 5. Selected test case

a test case 7C such that σ.a ∈ TracesFail(7 C). One chooses an output b such that σ.b ∈/ TracesFail(Can(S)) (the existence of b is ensured as Can(S) has no quiescence), and builds an test purpose accepting σ.b. By construction the test case 7C built from 7У then reaches Fail for the trace σ.a.
Apart soundness and exhaustiveness which relate Fail verdicts to conformance, other properties related to verdicts Pass and Inconc are also of importance as they relate test cases to the selection means, namely test purposes. It can be proved that Pass verdicts are always exact: a Pass is always emitted when the current trace is accepted by the test purpose. The only verdict where the over-approximation may cause a lost in precision is Inconc. In fact, it may be the case that some traces of 7C are not anymore a prefix of an accepted trace, but is not detected as such. It will either be detected by continuation of the trace, or will loop. It is easy to see that the precision of the approximation directly influences the ability of test cases to emit Inconc verdicts accurately. For the reader familiar with structural testing, the problem of detecting Inconc verdicts is similar to the classical problem of the undecidability of the feasability of a path in structural testing, which is known to be undecidable.

Test execution
In most test generation techniques, generated test cases are completely instanciated test cases in the form of sequences (in the deterministic case), trees or graphs where actions carry some valued parameters. In our case, generated test cases are kinds of programs described as ioSTS, thus have variables, guards, actions and assignments. During test execution, the test harness will start the test case with its unique initial state. Then the system will progress with transitions carrying either inputs or outputs. The tester can choose a transition carrying an output if one is fireable. In this case, as values of variables are known, it should choose a value of parameters such that the guard is satisfiable. This is where satisfiability of guards should be decidable. If there is none, an input (or quiescence should be observed). The choice

of parameters values should be done by constraint solving. An input is fireable only if it is sent by the implementation under test. The tester then has to check, according to the current value of variables and the value of the input parameters, which guard is satisfiable among transitions carrying this input. As the test case is input-complete in any state with no verdict, exactly one transition is fireable.

Example 5.1 In the lift-controller example, the execution proceeds as follows. Let us fix the constant h = 10. The tester chooses a value for p for Target such that 0 ≤ p ≤ 10 ∧ 3p ≤ 20. Assume that 4 is chosen, then the tester will observe the trace Up?(0).Up?(1).Up?(2).Up?(3).Stop?(4) if the implementation conforms to £ but does not emit Break. The tester will then choose 2 as the unique solution of the guard 0 ≤ p ≤ 10 ∧ 2p = 4 ∧ 3p ≤ 20. The lift will then go down and the tester is supposed to observe Down?(4).Down?(3).Stop?(2).
If 3 was chosen as a solution to 0 ≤ p ≤ 10 ∧ 3p ≤ 20 for the first level to reach, the tester would observe Up?(0).Up?(1).Up?(2).Stop?(3). After that, there is no solution to 0 ≤ p ≤ 10 ∧ 2p = 5 ∧ 3p ≤ 20 and the tester can only observe a quiescence ?δ. This situation is due to the approximation, as the constraint on the first Target does not ensure that p is even.


Conclusion and perspectives
This paper proposes an approach to the off-line selection of test cases from speci- fication models with control and data (ioSTS) using test purposes. This technique avoids the state explosion problem due to the enumeration of data values and pro- duces test cases on the form of programs. Test selection reduces to syntactical opera- tions on these models and relies on an over-approximate analysis of the co-reachable states to a target location. During execution of test cases on the implementation, constraint solving is used to choose output data values. For simplicity, the theory exposed in this paper is restricted to deterministic specifications. However, non- determnistic specifications can be taken into account with some restrictions [18].
In our perspectives of this work, more powerful models of systems with features such as time, recursion and concurrency should be considered. A similar approach has been developed for stack automata modeling recursive programs and test pur- poses specified as automata [7]. In this case, the analyses are exact, but cannot be fully used if test cases cannot observe their own stack, thus also inducing an approximation. For test generation, one problem to address in these models is par- tial observability, which, as for ioSTS, entails the identification of determinizable sub-classes corresponding to applications.
Other challenges are the combination of these techniques with coverage-based test selection. One direction should be to use the dynamic partitioning facility provided by the tool Nbac used by STG as an aid for test selection with respect to coverage criteria with a deeper semantic meaning. More generally, conformance testing appeals for more semantic based coverage criteria.

References
T. Ball. A theory of predicate-complete test coverage and generation. In Frank S. de Boer, Marcello M. Bonsangue, Susanne Graf, and Willem P. de Roever, editors, Third International Symposium on Formal Methods for Components and Objects (FMCO’04), Leiden, The Netherlands, November 2 - 5, 2004, Revised Lectures, volume 3657 of LNCS. Springer, 2005.
A. Belinfante, J. Feenstra, R.G. de Vries, J. Tretmans, N. Goga, L. Feijs, S. Mauw, and L. Heerink.
Formal test automation: A simple experiment. In 12th Int. Workshop on Testing of Communicating Systems. Kluwer Academic Publishers, 1999.
M. Benjamin, D. Geist, A. Hartman, G. Mas, R. Smeets, and Y. Wolfsthal. A study in coverage-driven test generation. In Proceedings of the 36th ACM/IEEE Conference on Design Automation (DAC’99), 1999.
R. S. Boyer, B. Elspas, and K. N. Levitt. SELECT: a formal system for testing and debugging programs by symbolic execution. In Proceedings of the International Conference on Reliable Software, pages 234– 245, New York, NY, USA, 1975. ACM Press.
M. Broy, B. Jonsson, J.-P. Katoen, M. Leucker, and A. Pretschner, editors. Model-Based Testing of Reactive Systems: Advanced Lectures, volume 3472 of LNCS. Springer, 2005.
J.R. Calam´e, N. Ioustinova, J. van de Pol, and N. Sidorova. Data abstraction and constraint solving for conformance testing. In Proc. of 12th Asia-Pacific Software Engineering Conference (APSEC’05), Taipei, Taiwan, pages 541–548, 2005.
C. Constant, B. Jeannet, and T. J´eron. Automatic test generation from interprocedural specifications. In TestCom/Fates07, number 4581 in LNCS, pages 41–57, Tallinn, Estonia, June 2007.
P. Cousot and R. Cousot. Abstract intrepretation: a unified lattice model for static analysis of programs
by construction or approximation of fixpoints. In 4th ACM Symposium on Principles of Programming Languages (POPL’77), Los Angeles, CA, pages 238–252, 1977.
T. Denmat. Contraintes et abstractions pour la g´en´eration automatique de donn´ees de test. PhD thesis, INSA Rennes, June 2008.
C. Gaston, P. Le Gall, N. Rapin, and A. Touil. Symbolic execution techniques for test purpose definition. In The 18th IFIP International Conference on Testing Communicating Systems (TestCom’06), 2006.
P. Godefroid, N. Klarlund, and K. Sen. Dart: directed automated random testing. In PLDI’05: Proceedings of the 2005 ACM SIGPLAN conference on Programming Language Design and Implementation, pages 213–223, New York, NY, USA, 2005. ACM Press.
E. Gunter and D. Peled. Model checking, testing and verification working together. Formal Aspects of Computing, 17(2):201–221, August 2005.
W. E. Howden. Theoretical and empirical studies of program testing. In Proceedings of the 3rd international conference on Software engineering (ICSE ’78), pages 305–311, Piscataway, NJ, USA, 1978. IEEE Press.
C. Jard and T. J´eron. TGV: theory, principles and algorithms, a tool for the automatic synthesis of conformance test cases for non-deterministic reactive systems. Software Tools for Technology Transfer (STTT), 6, octobre 2004.
B. Jeannet. Dynamic partitioning in linear relation analysis. Formal Methods in System Design, 23(1):5–37, 2003.
B. Jeannet, T. J´eron, and F. Ployette. STG: a symbolic test generation tool for reactive systems. In
TestCom/Fates07, Tool paper, Tallinn, Estonia, June 2007.
B. Jeannet, T. J´eron, V. Rusu, and E. Zinovieva. Symbolic test selection based on approximate
analysis. In 11th Int. Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’05), Edinburgh, Scottland, volume 3440 of LNCS. Springer, april 2005.
T. J´eron, H. Marchand, and V. Rusu. Symbolic determinisation of extended automata. In 4th IFIP International Conference on Theoretical Computer Science, 2006, Santiago, Chile. SSBM (Springer Science and Business Media), August 2006.
D. Lee and M. Yannakakis. Principles and Methods of Testing Finite State Machines - A Survey.
Proceedings of the IEEE, 84(8), 1996.
B. Legeard, F. Peureux, and M. Utting. Automated boundary testing from Z and B. In Proc. of Formal Methods Europe (FME’02), volume 2391 of LNCS, July 2002.


G. Lestiennes and M.-C. Gaudel. Testing processes from formal specifications with inputs, outputs and data types. In 13th International Symposium on Software Reliability Engineering (ISSRE’02), Annapolis, Maryland. IEEE Computer Society Press, 2002.
N. Lynch and M. Tuttle. Introduction to IO automata. CWI Quarterly, 3(2), 1999.
B. Marre and A. Arnould. Test sequences generation from LUSTRE descriptions: GATEL. In 15th IEEE International Conference on Automated Software Engineering (ASE’00), Los Alamitos, CA, USA, page 229. IEEE Computer Society, 2000.
V. Rusu, L. du Bousquet, and T. J´eron. An approach to symbolic test generation. In Integrated Formal Methods (IFM’00), Dagstuhl, Allemagne, LNCS 1945, volume 1945 of LNCS, pages 338–357. Springer Verlag, Novembre 2000.
J. Tretmans. Test generation with inputs, outputs and repetitive quiescence. Software—Concepts and Tools, 17(3):103–120, 1996.
