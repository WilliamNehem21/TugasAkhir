Array 8 (2020) 100047

		




Tabu search-based fleet scheduling of air ambulances for disaster response
Joseph Tassone *, Salimur Choudhury
Lakehead University, 955 Oliver Road, Thunder Bay, ON, P7B 5E1, Canada



A R T I C L E I N F O

Keywords:
Air transportation CUDA
Fleet scheduling
Integer linear programming Local search
Tabu search
A B S T R A C T

Proper scheduling of air assets can be the difference between life and death for a patient. While poor scheduling can be incredibly problematic during hospital transfers, it can be potentially catastrophic in the case of a disaster. These issues are amplified in the case of an air emergency medical service (EMS) system where populations are dispersed, and resources are limited. There are exact methodologies existing for scheduling missions, although actual calculation times can be quite significant given a large enough problem space. For this research, known coordinates of air and health facilities were used in conjunction with a formulated integer linear programming model. This was the programmed through Gurobi so that performance could be compared against custom algo- rithmic solutions. Two methods were developed, one based on neighbourhood search and the other on Tabu search. While both were able to achieve results quite close to the Gurobi solution, the Tabu search outperformed the former algorithm. Additionally, it was able to do so in a greatly decreased time, with Gurobi being unable to resolve to optimal in larger examples. Parallel variations were also developed with the compute unified device architecture (CUDA), though did not improve the timing given the smaller sample size.





Introduction

Disasters can strike at any time and in these scenarios, it can be devastating if there is not an efficient emergency medical service (EMS) system. While this can be problematic in a city-based environment, it is catastrophic when considering a larger air ambulance system. These vehicles travel over much longer distances, through regions with very dispersed populations. While patient transfers may occur between populous areas, this is not guaranteed during a disaster. Additionally, many air ambulances have a rather small contingency [1] which must cover all missions within a certain time frame to be effective. It is critical to accurately schedule vehicles in such a way that these potentially vast distances can be managed, and patient lives can be secured.
This work is a continuation of prior research which sought to opti- mize the staging and positioning of air assets [2]. Therefore, despite it being an independent methodology, it is also part of a greater problem directed towards air ambulance management. This is not necessarily new, as there have been several exact methodologies suggested previ- ously [3]. Though solving for optimal is not always unreasonable, since scheduling is NP-hard, it becomes much more time consuming with an increase in the solution space. The issue with this is compounded in a critical system like EMS where time can mean the difference between life and death. Near-optimal metaheuristics provide an effective alternative
as they achieve acceptable solutions in a much more manageable win- dow. In this research, known coordinates of air and health facilities were utilized and aided in simulating an actual scheduling scenario. A mission in this case always began at a vehicle occupied base and returned to the same base. Subsets of missions could be performed by each vehicle with a respective mission performing a pickup and delivery before continuing to the next point. Two algorithmic solutions were developed for this problem and each was structured using a sequential and parallel meth- odology. For the latter, the Compute Unified Device Architecture (CUDA) platform was employed and timed against the former for each algorithm. Overall, the goal was to develop a model with integer linear program- ming and then formulate algorithms which could attain a similar solution to the optimal.
This paper is arranged as follows. Section 2 describes the related work with a description of past techniques and solutions. Section 3 outlines the modelling of the problem, emphasizing constraints and the objective. Section 4 displays the algorithmic solutions, describing the neighbour- hood and tabu search, as well as the initialization technique. Sections 5 and 6 respectively show the results and conclude the paper.

Related work

For scheduling problems, neighbourhood searches have been well-



* Corresponding author..
E-mail address: jtasson2@lakeheadu.ca (J. Tassone).

https://doi.org/10.1016/j.array.2020.100047
Received 21 July 2020; Received in revised form 15 October 2020; Accepted 27 October 2020
Available online 11 November 2020
2590-0056/© 2020 The Author(s). Published by Elsevier Inc. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).



documented in achieving successful results. Dag˘layan and Karakaya suggested a solution for scheduling ambulances following a disaster and formulated it as a capacitated vehicle routing problem (CVRP) [4]. In their research, they minimized the routes and then reduced the average travel time to health facilities. For this process they developed both a genetic algorithm and nearest-neighbour heuristic. Both operated inde- pendently and were compared in three different test cases. These were based on capacity where light damage had 1 victim, medium damage could have 1 to 8 victims, and heavy damage had beyond 8. While the authors claimed that further study was required, when compared against CVRP benchmarks the genetic algorithm achieved shorter distances. This work does require additional testing, as there is a limitation in utilizing a single facility and ambulance.
Tabu search is another successful algorithm in scheduling, being an extension of the neighbourhood-based algorithms. In this type of solution recently explored neighbourhoods which improved the result are ignored, preventing the risk of achieving only a local optimum [5]. Oberscheider and Hirsch utilized this methodology in conjunction with real-patient data to ensure the efficient transport of patients for lower Austria’s Red Cross [6]. They developed an algorithm based on the static multi-depot heterogeneous dial-a-ride problem and generated all possible combinations of patient deliveries considering a set of con- straints to solve it. For each prior generation, set partitioning was per- formed to achieve an initial solution and then these were inputted into a Tabu search metaheuristic for optimization. The authors claim that the work is an improvement upon previous variations as it considers non-static service times that depended on the combination of patients, their transport mode, the vehicle type, and the pickup or delivery locations.
Another research presented by Repoussis et al. formulated a mixed integer linear programming model for the scheduling and routing of large casualty disasters [7]. They sought to use a minimized amount of re- sources while also being able to achieve a reduced response time. Their solution was developed as a hybrid multi-start local search, involving an exact construction heuristic followed by an optimization by iterated Tabu search. Initialization utilized a greedy technique for assignments and then the problem in its reduced state was optimized. A high-quality upper bound was achieved and these were inputted into the Tabu search, repeating until the stopping condition was met.
Most solutions involve sequential designs where a solution must iteratively solve until reaching an optimal. While not a new trend, par- allelization has been utilized to achieve higher calculation speeds through the graphics processing unit [8]. The algorithms must be rede- veloped to take advantage of the multiple simultaneous threads and loops are replaced by these to perform calculations. Additionally, threads are divided into blocks which can be an issue in larger problems. In this case thread communication occurs within blocks, but synchronization cannot happen between them. For these scenarios block level design must be considered along with thread design. Regardless, the primary bottleneck is related to the kernel call to GPU when the problem space is small enough. Race conditions are another potential issue, though CUDA pro- vides both shared memory and locks to deal with this problem [9].
While prior parallel research has been performed, it is limited in terms of optimization problems of this type. Schulz et al. performed a survey revealing a small amount of literature on applying GPU paralle- lization to local or Tabu search [10]. The same can be said when applied to regional or air ambulance problems. Hussai et al. redeveloped the particle swarm optimization algorithm by using CUDA to perform partially coalescing memory accesses [11]. When compared against benchmarks the new algorithm was able to gain a significant improve- ment in time compared to a similar sequential variation. Similarly, Fabris and Krholing used benchmarks and applied CUDA to a co-evolutionary differential evolution algorithm for solving min-max optimization prob- lems [12]. Their research showed that the algorithm was able to
converge to a near optimal result, although in a much better time when scaled up.

Model

Scheduling of air ambulances follows predetermined positions, where ambulances are already placed at bases. Time is also a factor as sched- uling relies on patients arriving at certain periods. This may be due to urgency from an incident or transfers for more specialized care. While there are potentially many bases in an EMS system, this scheduling problem only deals with the subset of bases that have vehicles assigned to them. In general, unless otherwise specified, the scheduling problem treats the terms vehicles and bases as synonymous.
In this case a mission starts at a base and can be made up of at least a single pickup and delivery. However, rather than a simple return to base, another mission may be assigned to that vehicle, where it will continue from the previous delivery to next pickup. Therefore, the schedule will consist of each base being assigned a set of missions, followed by a return to the original base. An example of this problem and all possible setups can be seen in Fig. 1. There are three bases, with four missions. So long as the constraints are met, each base can have either as many missions as possible assigned or none. Essentially, this means a base can be assigned one or more missions up to the maximum which require assignment.
The potential bases consist of the following two sets:

P: the set of all fixed-wing plane occupied bases with each being a 4- tuple of form
ak =< k s ϕk ψ k >,ak ∈ P 6 k = 1, …,4
k Ξ base ID
s Ξ vehicle speed
ϕk Ξ row coordinate of base k
ψ k Ξ column coordinate of base k

H: the set of rotary-wing helicopter occupied bases with each being a 4-tuple of form.
hk =< k s ϕk ψk >,hk ∈ H 6 k = 5, …,12 k Ξ base ID
s Ξ vehicle speed
ϕk Ξ row coordinate of base k
ψk Ξ column coordinate of base k

The set of all missions consists of:
M: the set of all missions, with each being a 6-tuple of form.

mn =< n ϕp ψp ϕd ψd ρ >,mn ∈ M 6 n n Ξ mission ID
ϕp Ξ row coordinate of patient pick-up location
ψp Ξ column coordinate of patient pick-up location
ϕd Ξ row coordinate of patient delivery location
ψd Ξ column coordinate of patient delivery location
1 if mission requires rotary — wing helicopter
0 otherwise

Sets H and P are vehicle occupied bases, where both are constant and locked to their specific coordinates. No other bases can be utilized and following a set of missions there must be a return to the original base. Both sets are parts of the full set of bases which can be utilized, stated as P
∪ H = K. Additionally, rather than total distance, the travel time from one position to another is considered. Helicopters and planes travel at different speeds, meaning that regardless of distances they will arrive at different times. Therefore, speed must be considered for each set to perform accurate scheduling. Missions have specific requirements where only a helicopter occupied base may perform certain missions.




Fig. 1. Basic scheduling setup for missions and bases.



Table 1
Summary of scheduling model variables.


Variable	Description


xijk	A binary decision variable determining whether a mission i to j are connected, while starting and ending at base k
dijl	Time matrix where the distance from i to j is divided by the speed of the


the vehicle. The respective result is then placed into l where l0 is for helicopters and l1 is for planes. The distance is determined for a base as the sum of each mission’s patient pick-up and delivery locations. Since this is not simulated data, Haversine distance is considered. The full calculation can be completed with the following:
D = 2rsin—1 rsﬃﬃiﬃﬃnﬃﬃ2ﬃﬃ ﬃﬃﬃφﬃﬃﬃﬃ—ﬃﬃﬃﬃﬃφﬃﬃﬃpﬃ ﬃﬃﬃﬃ+ﬃﬃﬃﬃﬃcﬃﬃoﬃﬃﬃsﬃ(ﬃﬃφﬃﬃﬃ)ﬃﬃcﬃﬃoﬃﬃﬃsﬃ ﬃﬃﬃφﬃﬃﬃﬃ ﬃﬃsﬃﬃiﬃﬃnﬃﬃ2ﬃﬃ ﬃﬃﬃψﬃﬃﬃﬃ—ﬃﬃﬃﬃﬃψﬃﬃﬃpﬃﬃ ﬃﬃﬃ	(1)

wn	Constant stating the time by which a vehicle must arrive at mission n by
fn	Constant stating the vehicle requirement for a mission n (0 for helicopter- only and 1 for any vehicle)
bk	Constant stating the vehicle situated at a base k (0 for helicopter and 1 for airplane)
ui	Integer decision variable for the exclusion of subtours, the value is a ranked order where a value i = {1, …,n} for each base k


In the above formula ϕ represents row locations, while ψ applies to column location values. Ks is used to indicate a specific speed of a vehicle at a base, which is divided by the Haversine distance calculated. The resulting matrix is of dimension (n + k) × (n + k) × 2 and referenced for achieving total travel time for each mission. The optimization model takes the following form:
minimize

There are a set of variables for the problem with a summary show in
XXXx
d ; l = b

(2)

Table 1. xijk is binary, where an instance will be 1 if a mission i to j are connected and starting from base k. Additionally, the variable ui is uti-

i  j k
ijk ijl	k

lized for subtour elimination based on the Miller-Tucker-Zemlin constraint [13]. For the exclusion of subtours the value can be i = {1,
…,n} for each base k. The model also considers a set of constants p, wn, bk,
subject to
XXxijk =; 6 j	(3)

and fn. Both p and wn contribute to time constraints where p is the	i  k
maximum flight time allowed by a vehicle in a day (10 h for the purposes

of this research) and wn is the time by which a vehicle must arrive at a
XXxijk =; 6i	(4)

base by. In the scheduling problem they are independent as once a	j  k

vehicle arrives for a mission it must wait until its respective wn to
Xx  = Xx
; 6 k; n	(5)

continue to the next point. The constant p only considers actual time in flight and does not recognize waiting. Both bk and fn are utilized for limiting certain bases to certain missions. bk states the type of vehicle that
ink
i
njk
j

is at an individual base (0 for helicopter and 1 for plane), while fn de- scribes the vehicle requirement that must be used for a mission (0 for helicopter-only and 1 for any vehicle).
In addition to distance calculations, the respective travel time is considered as determined by the speed of the vehicle. Based on known statistics about air ambulance vehicles, rotary-wing helicopters are assigned a speed of 300 km/h [14] and fixed-wing planes are assigned a
xijk ≤ 1; 6 j; k	(6)
i


xijk ≤ 1; 6 i; k	(7)
j

XXxijkdijl ≤ p; 6 k; l = bk	(8)

speed of 500 km/h [15]. The matrix d is the result of the calculation,	i  j
where the distance from i to j is determined and divided by the speed of


xijkdijl ≤ xijkwj; 6 j; k; l = bk; i ≤ n	(9)

xijk dijlwi ≤ xijkwj; 6 j; k; l = bk; i > n	(10)

xijk(bk — fi)≤ 0 ; 6 i; j; k	(11)

ui — uj + n xijk ≤ n — 1 ; 1 ≤ i /= j ≤ n; ; 6 k	(12)

xijk = 0 ; (i /= j; k)∈ K	(13)

xijk ∈ {1; 0}; 6 i; j; k	(14)

ui ∈ {i = 1; …; n}	(15)
Equation (2) describes the objective function, where the total time flown by each vehicle to its assigned missions are minimized. Each set’s dijl is summed based on its corresponding xijk variables which have a 1. The actual distance is determined by the constant bk, where the index of l equals the respective value. The objective function is also constrained based on the rules set by Equations (3)–(15).
Each mission can only be completed once, constrained by Equations
(3) and (4). Equation (5) guarantees route continuity, where each mission must continue from one to the other along their assigned route. To ensure that missions leave and return to the same base, the model considers Equations (6) and (7). As previously stated, vehicles can only fly so long which determined by p. The constraint for this is upheld by Equation (8) for each base k set of missions. The remaining time con- straints are determined by Equations (9) and (10). The first is for when a vehicle is travelling from a base to a mission. In this case the base does not have a time limit and begins at 0. The second considers either a mission to a mission, or a mission returning to a base. In the latter case the limit is usually assumed to be correspond to the number of hours in a day. Regardless of travel time the vehicle must wait until that mission’s time limit to travel to the next one. The distance summed with the pre- vious time limit must be less than the next mission’s time limit.
To force each mission to be correctly assigned to a valid base, the model uses Equation (11). There is only one invalid permutation for this assignment, where a plane is assigned to a helicopter-only mission. This is prevented as all other possibilities are forced to be less than or equal to
0. The subtour elimination constraint is outlined by Equation (12) and uses the Miller-Tucker-Zemlin formulation. For this constraint, ui is a variable associated with each mission and is used to eliminate sets that do not begin and end at a base. The variable is equal to the order in which each mission occurs for each base k, where the base begins at the first index [16]. To further limit the formulation, Equation (12) prevents bases from travelling to other bases other than themselves. Lastly, Equations (13) and (14) limit the values which can be assigned to each variable.

Algorithm

All the solutions within this section were designed with consideration of the constraints and variables in the scheduling model above. The al- gorithms each had a sequential and parallel CUDA implementation. As there were only minor changes within the algorithms, Algorithm 2 and 3 are outlined as the sequential versions. Any other alterations are given following a description of each one.

Scheduling initialization algorithm

Due to the constraints, there is no guarantee that a randomized initialization will be able to generate a valid solution. Since vehicles must fly under a certain period and within a particular limit there is an increased difficulty in discovering a starting state. Therefore, Algorithm 1 was developed to find an initialized organization for optimization. To

clarify, the algorithm is not designed to find a near-optimal solution, only to determine the existence of any solution. Essentially, the method will attempt to assign missions to bases and upon failure will perform swaps. This will improve the current result and may increase the chances of finding a valid permutation. If after so many attempts, it does not find a solution it will report an error.
The algorithm accepts a set of occupied bases and a set of mission data as its input. Lines 1–4 show the constant data that must be abided by including the distance matrices for each respective vehicle type, the mission times determining when a vehicle must arrive by, and the daily flight limit for a vehicle. The Solution matrix declared at line 5 will hold each mission with a row starting and ending with a base, and compatible missions will then fill in between these indices. The remainder of the algorithm is broken up into a section for helicopter-only mission as- signments (lines 6–42) and then a section for the remaining missions (lines 43–77). For both, the outer loops will only terminate once all are assigned.
The first step at line 8 is to determine the unassigned mission with the smallest time limit. There is an urgency for this to be completed first as the time limit constraint cannot be broken. As per line 9, every base will be checked, and the current best fit will be held in CurrentMin. The next set of lines follow the constraints set by the model, limiting which bases can accept a mission. If a base breaks any of the requirements, then the algorithm continues to the next possible base. Lines 10–12 ensure that only a helicopter occupied base may accept a helicopter-only mission. Lines 13–34 are the time limit constraints, ensuring that vehicle does not pass the arrival time set for a respective mission. This part is broken into two parts based on whether a base already has missions or has yet to have one assigned to it. As the mission is being placed between two indices it must consider the vehicle arriving at the new mission and the travel new mission to the next one. Additionally, once a vehicle arrives at a mission it must wait until that time limit to move on to the following. If it is starting at a base the limit is 0 and not considered, while if it from another mission it must utilize the distance to the next plus the previous time limit. If the vehicle is returning to a base then the time cannot pass a predetermined maximum limit, currently expressed as the number of hours in the day. Lines 29–31 performs a check on the current flight time of each set of missions. This constraint only considers actual flight time and not the waiting enforced by the previous constraints. Once these restrictions have been met, lines 32–34 check if the new assignment is an improvement over the prior. The result is saved if there has yet to be an update to CurrentMin or if the new value is smaller than the previous.
If CurrentMin has a solution, then it is added to the Solution matrix at
line 40. There is the possibility that following the loop there will be no available positions to place the mission. If this occurs, then lines 36–37 attempt a reorganization to find a new valid permutation. These swaps are performed by Algorithm 2 and discussed below. The algorithm returns an error if no reorganization is possible, no missions have been assigned, or following reorganization the assignment fails.
Lines 43–77 perform nearly the exact same process, with the excep- tion that there is no mission compatibility requirement. To validate the correct matrix to choose from, the algorithm includes a flag called VehicleType (line 47). Each remaining check performs almost identically to the last section; however, the flag is used to ensure the corresponding distance matrix matches the vehicle at each base.
The addition of parallelism to this algorithm was simplistic, as race conditions were only an issue for CurrentMin. CUDA operates through concurrent thread organization, so the loops at lines 7 and 44 could instead be replaced with their own threads. The continues are also replaced as each thread controls its own base. This allowed the MinIndex to be checked simultaneously for each base. A mutex check was per- formed at line 32 to add to CurrentMin along with the thread ID. At line 40, if the thread ID matched the CurrentMin, then it updated it with its solution. If there was currently no updated solution, a thread would be allocated to performing the swaps.



Neighbourhood search fleet scheduling optimization

Algorithm 2 accepts either the initialized or the partially complete data from Algorithm 1. The goal of the algorithm is to find an organi- zation of missions and bases which minimizes the total travel time. As already discussed, the design of the previous algorithm was not to find an optimal solution, only a valid one. Conversely, Algorithm 2 was formu- lated to be performed through multiple instances to minimize the total time to near optimal. Though the initialization method uses this algo- rithm, it only performs a single iteration to attempt a new result. To ensure that Algorithm 2 has a diverse set of possibilities, the loops at lines 6 and 7 may be exchanged with random index permutation vectors.
The algorithm functions by moving missions to new bases, essentially having another vehicle take responsibility for that mission. It will only end once no further improvement is found. If utilizing a set of permu- tation vectors, this means no better result is found in the current per- mutation and provides the opportunity for another iteration. A similar set of constraints from the previous algorithm are used and updates are performed to the Solution matrix. There are four sets of loops with line 6 allowing for looping through the bases and line 7 for looping through the respective missions assigned to a base. The loops at lines 9 and 17 perform a similar function, though they are the corresponding positions being move to.











. (continued).


Like Algorithm 1, it includes a CurrentMin variable for keeping track of the best current position for swapping. Once every valid combination
is checked, the CurrentMin updates the Solution at line 43. Swapping within a base is restricted by lines 10–12, as the current order is already




Fig. 2. The movement of one mission to another base.



constrained by the time. Additionally, certain planes cannot accept helicopter-only missions as stated in lines 13–15. There is a VehicleType flag for determining which matrix to select from for the remainder of the algorithm. This is based on the specific vehicle that is assigned.
An example of the process can be seen in Fig. 2, where the first mission connected to base 1 is moved to base 2. Once a swap occurs base 1 connects directly to mission 2, while the base 2 setup adds two new links between the new position of mission 1. During the movement, the new position of the mission cannot force the vehicle’s flight limit to be exceed, expressed by lines 18–20.
Similarly, the new links must not exceed any of the time limits set by the lines 21–36. This function is identical to the design of the previous
algorithm where the check depends on where the mission is being moved to. Again, a vehicle must wait until the current mission’s time limit before proceeding, meaning each proceeding time limit must be considered in the check. If the movement passes these requirements and is the current best option, then it is added to CurrentMin at line 38.
Like the previous algorithm, this one can be made easily parallel by the removal of the loop at line 9. This allows every base to be simulta- neously checked and for the CurrentMin to be updated with the best result quicker. The outer loop at line 6 could have instead been replaced, though this would have given a different value than the original, making accurate comparison difficult. Either design can be run multiple times and so long as an index ordering is done the solution may be improved.







Tabu search fleet scheduling optimization

This algorithm functions as a modification of Algorithm 2, with a near identical design. The primary differences are the variables included at lines 5 and 6. The TabuList prevents recently explored neighbourhoods from being explored again. There is a chance that the algorithm may become locked into a local minimum, preventing optimum exploration of the space. Therefore, the TabuList helps to prevent this, keeping certain regions restricted for several iterations based on the TabuCounter.
During the iterative process if a region which has recently been explored is already in the list, then it is skipped as per lines 20–27. The respective counter for each value is then reduced at the end of the current
iteration with line 56. Additionally, a value is added to TabuList only if improves the value determined by lines 52–55. If permutation vectors are used for the outter loops, then improvement may be discovered through multiple runs. In this case the TabuList variable is maintained through proceeding iterations.
The parallel implementation is identical to Algorithm 2. The inner loop at line 11 is replaced and continues are removed as each base re- ceives its own thread. Also like the previous, Algorithm 3 will result in the exact same answer as the sequential variation. The updates are still handled by a single thread, which is determined by the best result in CurrentMin.







Results

Eight datasets were employed for testing the algorithms, all being based on known coordinates of air and health facilities. The Numba li- brary [17] was applied to speed up the programs through the JIT compiler. All programs, including Gurobi scripts, were tested with a system containing 128 GBs of RAM with a 24 core Intel Core i9-7920X X-series processor. CUDA versions made use of a GeForce GTX 1080 Ti graphics card as well as the prior technologies mentioned.
Each algorithm ran 10 times, with all results being summarized in Figs. 3 and 4 and Tables 2 and 3. A subset of each set of missions were chosen and divided from 12 to 33. 12 vehicles were used consisting of 8 rotary-wing helicopters and 4 fixed-wing planes. The vehicle’s locations were locked to the bases and at the end of a set of missions each vehicle needed to return to the same base. Time limits were randomly generated






















Fig. 3. Comparison of scheduling algorithms against the optimized solution.


Fig. 4. Comparison of scheduling runtimes.
for each, needing to be completed within a 24-h period. This factor in addition, to a 10-h flight limit, prevented sets from going over 33 mis- sions. While under the right circumstances it is possible for vehicles to complete beyond 33 missions in a day, it is highly unlikely and difficult to generate a valid test scenario. Each method had a parallel and sequential variation, and both Algorithm 2 and 3 used Algorithm 1 for building a starting solution. For accurate comparison with the optimal, Gurobi was employed and tested upon the same data.
Based on the values shown in Fig. 3, the two optimization algorithms had similar results. All were consistently under 8% of the optimal, with some becoming quite close for the higher mission sets. The Tabu search did perform better than the Neighbourhood search in a very comparable time. The difference may not seem to be much based on the results in Table 3, though it should be noted that not a single case showed a better result for Neighbourhood search. Fig. 2 does display that it is technically faster, though at these speeds this is a negligible difference. Despite similar values, the consistency in the results show that the Tabu search is a better option. Admittedly, Fig. 2 does give the impression that upper and lower bounds are quite spread; however, the y-axis utilizes a very small incrementation. They are tight when further compared using Table 3. Additionally, total travel time is being compared instead of distance. This means the summed values are much smaller, explaining why it is easier to get within a better percentage of the optimal.
The Gurobi optimizer almost always managed to achieve an optimal solution in a much slower time compared to the custom algorithms. The problem with scheduling is that it does not scale well, with larger mis- sions counts making the space exponentially more difficult. While it was able to solve it in an acceptable time for missions below 24, anything above this became stuck. At points beyond 27 the gap between the upper and lower bounds stopped shrinking and the optimal was no longer improving. The optimizer was set to stop running after 20,000 s which is why Fig. 4 shows the last three values as being the same. This problem shows the issue with Gurobi in a case where the optimal needs to be determined quickly, as there is not a guarantee it will find it. This is not an unusal case in a disaster where timing can mean the difference be- tween life and death. In this scenario these custom algorithms may be more reasonable, since in the case of 33 missions the Tabu search ach- ieved a better lower bound than the value Gurobi had solved at that point in time. While in some cases it may be more useful to utilize the optimizer for a smaller count, the difficulty of this problem and the fact that the custom algorithms have a much faster runtime, does at least offer some advantages to alternatives.
Base on the results in both Fig. 4 and Table 2, the CUDA variations does not offer a better option at this scale. Both sequential versions are significantly faster in all cases. The problem with CUDA at this level is that the kernel call itself takes a lot of time to perform. It is possible to bundle everything into a single call, though it still will not be as fast as the other algorithms with these mission sizes. The CUDA implementation is about the same for both algorithms and still significantly faster than Gurobi. It is possible that at a higher mission count the parallel imple- mentation may begin to outperform the sequential algorithms. Although, as previously mentioned it is unlikely to have more than 33 missions in a day for this set of data, meaning the only option would be if it was for scheduling a much longer period. In any case, while not an unreasonable


Table 2
Summary of total missions times.



Table 3
Summary of total runtimes.


Number of Missions	Optimal Distance	Neighbourhood Search	Tabu Search
Declaration of competing interest

The authors declare that they have no known competing financial


12	23.521	U: 25.495
L: 24.903
A: 25.199
15	24.348	U: 25.771
L: 25.119
A: 25.445
18	34.027	U: 36.834
L: 35.526
A: 36.008
21	46.853	U: 49.801
L: 48.029
A: 48.915
24	59.977	U: 62.365
L: 61.924
A: 62.144
27	57.841	U: 62.393
L: 58.950
A: 60.672
30	60.428	U: 63.904
L: 61.226
A: 62.565
33	66.564	U: 68.221
L: 66.956
A: 67.868

U: 25.374
L: 24.640
A: 25.007
U: 25.623
L: 24.858
A: 25.240
U: 36.138
L: 34.984
A: 35.611
U: 49.047
L: 47.380
A: 48.214
U: 61.793
L: 60.434
A: 61.164
U: 61.310
L: 58.859
A: 59.934
U: 62.379
L: 60.532
A: 61.456
U: 67.947
L: 66.425
A: 67.638
interests or personal relationships that could have appeared to influence the work reported in this paper.

Acknowledgements

This research is supported by the respective NSERC Discovery Grants from Dr.
Salimur Choudhury. Additionally, the work was funded by a Vector Institute Scholarships in AI from Joseph Tassone. Lastly, funding was also provided by a NSERC CGSM award through Joseph Tassone.

References

Ornge. Online, https://www.ornge.ca/home. [Accessed 10 November 2019].
Tassone J, Pond G, Choudhury S. Algorithms for optimize. fleet staging of air ambulances, Array 2020;7:100031. http://www.sciencedirect.com/science/article/ pii/S2590005620300163ing.
Carnes TA, Henderson SG, Shmoys DB, Ahghari M, MacDonald RD. Mathematical programming guides air-ambulance routing at ornge. Interfaces 2013;43(3):232–9.
Dag˘layan H, Karakaya M. An optimized ambulance dispatching solution for
rescuing injures after disaster. Univ J Eng Sci 2016;4(3):50–7.
Edelkamp S, Schro€dl S. Chapter 14 - selective search. In: Edelkamp S, Schro€dl S, editors. Heuristic search. San Francisco: Morgan Kaufmann; 2012. p. 633–69. https://doi.org/10.1016/B978-0-12-372512-7.00014-6.
M. Oberscheider, P. Hirsch, Analysis of the impact of different service levels on the

result, at this scale the sequential Tabu search is still the best option.

Conclusion

The results demonstrate the convenience of these custom algorithmic solutions. In all cases, Gurobi achieved an optimal in an increased time. Though not the universal, this is not acceptable in a disaster situation where time is not a luxury and fleet reorganization is required. In these scenarios, algorithms approaching the optimal become more valuable. Both algorithms were quite close to the Gurobi solution, though the Tabu slightly outperformed in all cases. In the latter simulations the Tabu even outperformed the Gurobi which could not calculate an effective permu- tation before the time termination expired. While parallel optimization may be an option in a larger scheduling scenario, it was not an improvement in this case. The kernel call resulted in a bottleneck which hindered any speedup gain. This should not eliminate the possibility of using this technique, though the situation should be considered. Overall, these algorithms can achieve acceptable results in an excellent time. They are adaptable to quick changes and can be run for multiple instances, displaying the effectiveness of this for the domain.

Credit author statement

Joseph Tassone: Conceptualization, Software, Methodology, Writing - Original Draft. Salimur Choudhury: Validation, Writing - Review & Editing, Funding acquisition, Supervision, Resources.
workload of an ambulance service provider, BMC Health Serv Res 16:487. doi: 10.1186/s12913-016-1727-5.
Repoussis PP, Paraskevopoulos DC, Vazacopoulos A, Hupert N. Optimizing emergency preparedness and resource utilization in mass-casualty incidents. Eur J Oper Res 2016;255(2):531–44. https://doi.org/10.1016/j.ejor.2016.05.047.
Lee D, Dinov I, Dong B, Gutman B, Yanovsky I, Toga AW. Cuda optimization strategies for compute- and memory-bound neuroimaging algorithms. Comput Methods Progr Biomed 2012;106(3):175–87. https://doi.org/10.1016/ j.cmpb.2010.10.013.
Cuda toolkit documentation v10.2.89. Nov 2019. https://docs.nvidia.com/cuda/.
Schulz C, Hasle G, Brodtkorb AR, Hagen TR. Gpu computing in discrete optimization. part ii: survey focused on routing problems. EURO J Transp Logist 2013;2(1):159–86. https://doi.org/10.1007/s13676-013-0026-0.
Hussain MM, Hattori H, Fujimoto N. A cuda implementation of the standard particle swarm optimization. In: 2016 18th international symposium on symbolic and numeric algorithms for scientific computing (SYNASC); 2016. p. 219–26. https:// doi.org/10.1109/SYNASC.2016.043.
Fabris F, Krohling RA. A co-evolutionary differential evolution algorithm for solving min–max optimization problems implemented on gpu using ccuda. Expert Syst Appl 2012;39(12):10324–33. https://doi.org/10.1016/j.eswa.2011.10.015.
Desrochers M, Laporte G. Improvements and extensions to the miller-tucker-zemlin subtour elimination constraints. Oper Res Lett 1991;10(1):27–36. https://doi.org/ 10.1016/0167-6377(91)90083-2.
The world’s best turboprop better than ever: pilatus reveals the pc-12 ngx, Pilatus Aircraft Ltd.
Aw139. https://www.leonardocompany.com/en/products/aw139.
Ramos TRP, Gomes MI, Po´voa APB. Multi-depot vehicle routing problem: a comparative study of alternative formulations. Int J Logist Res Appl 2019:1–18. https://doi.org/10.1080/13675567.2019.1630374. 0 (0).
A high performance python compiler. http://numba.pydata.org/; 2018.
