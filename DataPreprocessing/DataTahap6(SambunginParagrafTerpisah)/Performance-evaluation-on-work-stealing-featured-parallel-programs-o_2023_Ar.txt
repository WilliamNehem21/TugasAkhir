The emersion of the Intel asymmetric performance multicore prod- ucts will further enliven the use of AMPs architectures for broader applications. For better application and the best practices in software development, it is necessary to understand their performance behavior well. For simple writing purposes in this paper, we rewrite the CPU of P-Core as P-CPU and CPU of E-Core as E-CPU.

The memory-bounded speedup in [4] can initially explain the phe- nomenon of how superlinear speedup can occur in cases involving problems with large sizes on a computer cluster. With a large problem size, a single node may run slowly due to memory limitations. By adding a number of nodes, the program speed per node becomes faster. Memory-bounded speedup can also explain how superlinear speedup can occur on symmetric multicore processors [5,6]. If the memory capacity increases with the increase in the number of nodes on a computer cluster, whereas in a symmetric multicore, the capacity of cache memory increases with the increase in the number of CPU cores used. From here, investigating whether compute-bounded workloads can encounter superlinear speedup events is an interesting question to investigate.

The normal form heterogeneity model is presented in [10]. It ap- pears that the normal heterogeneity model can accurately model su- perlinear speedups, but it may not be effective in modeling cases of sublinear speedups. Sublinear speedups are bound to occur if the fastest CPU is used for the serial execution, which serves as the baseline.

In general, the existing speedup law cannot accurately describe the performance behavior of AMPs. Specifically to the AMPs, superlinear speedup can occur if code that was previously executed by a slow processor core is then enhanced by one or more faster processor cores. Conversely, sublinear speedup can occur in cases where serial execution time is obtained from serial execution using the fastest CPU. This research gap is the basis for this research.

Although work-stealing has been proposed as a solution to overcome the problem of unfair workload distribution in dynamic heterogeneous distributed computers, shared memory work-stealing on AMPs has not been investigated to the best of our knowledge. Distributed work- stealing in distributed computers has different characteristics than work-stealing in shared memory multicore architectures such as AMPs. Specifically, work-stealing operations that use communication channels contribute to overhead. On the other hand, there is no communication for work-stealing on AMPs, which means that it does not contribute to overhead. Therefore, investigating the performance of work-stealing on AMPs is still an interesting topic to discuss.

The authors of [14] presented research on the performance evalu- ation of heterogeneous multicore processors on multi-threaded work- loads. In the paper, they demonstrated that heterogeneous multicore is more efficient than homogeneous multicore when handling a multi- threaded workload. The authors deduced efficiency from the weighted speedup, which is calculated by dividing the total IPC of all running threads by the total IPC of the single slowest core. In this case, the authors conducted IPC measurements in a constant time window.

All the works mentioned above focused on the OS-level fairly scheduling for the multi-programmed environment. However, our work tested the fair work distribution among the E-CPUs and P-CPUs in a multi-threaded program. Our point of view regarding fairness is that we argue that the faster CPUs should endure more works of parallel fraction than the slower ones as other works presented Speedup and Power Scaling Models in [10] and AID in [18]. As authors indicated in [19], unbalanced task distribution causes poor performance.

The OS-level mechanism ensures that each kernel-level thread re- ceives a fair share of CPU time while working in the multiprocessing domain. On the other hand, the user-level mechanism allows a mul- tithreaded application to efficiently utilize multiple CPU/core time and improve parallelism. To achieve this, programming for multicore systems uses multithreaded programming with a one-to-one mapping approach, where each user-level thread maps to a kernel-level thread. However, if a user-level thread becomes idle (for instance, while wait- ing for other threads due to load imbalance during computation), the CPU time it receives is wasted. In this case, idle threads do not contribute to the performance of multithreaded programs. Unfortu- nately, the kernel does not support the management of user-level threads [20]. Thus we need a user-level load-balancing mechanism such as work-stealing for multithreaded applications on AMPs.

A heterogeneous asymmetric multicore chip has the potential to offer more efficient performance than symmetric multicore, as pre- sented by the authors in [7]. Although the authors wrote a retrospective paper in [27] regarding their previous model, they made a relevant recommendation that researchers should continue investigating this asymmetric multicore chip, including dealing with scheduling and overheads. Our work in this paper presents performance evaluation results where we assigned threads to the efficient core CPUs first and enhanced execution with the higher performance core.

In our experiment, we collected performance data from the Intel Core i5 1240P. The processor has four P-CPUs and two E-CPU clusters, each cluster consisting of 4 cores. Both P-CPU clusters are implemented with the Golden Cove microarchitecture, while the E-CPUs are im- plemented with the Gracemont microarchitecture. Therefore, the Intel Core i5 1240P is an asymmetric performance multicore processor.

In this work, experiments were conducted in a number of scenarios. The scenarios indicate the order of adding CPUs in such a way as to see the difference in scalability between E-CPU first and P-CPU first. E-CPU first means that threads occupy E-CPU first until none are left and then P-CPU. Conversely, P-CPU first means that threads occupy P-CPU first until none are left and then E-CPU. To achieve that goal, the benchmark program utilized the Linux CPU affinity library [39] to determine which CPU to use.

also has the second parameter to specify the number of threads involved in execution. The mode option determines the CPU mask and indirectly determines the order of the assigned CPUs when the program increases the number of threads. For example, two options, which select the CPU mask [8:15,0,2,4,6] and nine threads, will make eight threads occupy E-CPUs first and then one thread occupy a P-CPU. Then increasing the number of threads to ten will make eight threads occupy E-CPUs first, and two threads occupy two P-CPUs with ID 0 and 2. In addition, our experiments collect performance data repeatedly with Python script. Python script also sets an environment variable CILK_NWORKERS.

Our works provide evidence that work-stealing strategy performs well on AMPs. We propose to apply work-stealing to solve the problem of asymmetric performance. If work stealing were unable to overcome the problem, then applied work stealing should result in the P-Cores being more idle and experiencing a decrease in the nominal IPC value when operating in asymmetric mode rather than operating exclusively. However, this is not the case, as the evidence suggests otherwise. To state it more clearly, we found that there is no performance loss due to asymmetric performance on the Intel Core i5 1240P, and there is no decrease in nominal IPC on the P-Cores.

