Secure coders often examine various aspects of a programing code: syntax, semantics, program flow, and overall program execution. They typically focus on finding security weaknesses and then determine the appropriate mitigation techniques. With diverse skills, secure coders may approach discovering and fixing vulnerabilities very differently and inefficiently. While secure coding becomes increasingly important, secure coding behavior is not well understood. Understanding secure coding behavior and where challenges occur during coding can help us understand where to improve learning content and therefore improve secure coders abilities.

The fundamental challenge stems from user-controlled eye tracking stimuli. Secure coders may read paragraphs of documentation and guidelines; they may read and write source code; and they may utilize security scanning tools. Often secure coders perform several of these tasks concurrently with an application visually adjacent to other appli- cations and rapidly switch focus between applications. Furthermore, the

Our study provides a realistic software development environment. Participants can scroll in documents and source code files, switch among multiple source code files, use a static analysis tool, and conduct web searches. Our design allows each participant to control the flow of fixing vulnerabilities. This dynamic design setup is essential for the objective of providing a natural software coding environment that is needed for evaluating the value of eye gaze visualization techniques for secure coders and their coding behavior.

The rest of this paper is organized as follows. Section 2 introduces general information about secure coding and educational material concerning secure coding, general information about eye tracking, and a summary of existing visualization approaches and their limitations. Section 3 reviews the type of stimuli presented in our hands-on secure coding learning modules. Section 4 contains information about our eye

Software vulnerabilities can exist in several aspects of source code: the lack of focus on security threats when an application is developed, using open source or third-party components, being more inter- connected, and sharing user data over network devices and accounts [3]. Security vulnerabilities damage integrity, confidentiality, and avail- ability. Secure coding is a major aspect to software assurance and vulnerability management [4,5]. It is better to develop source code that is secure during the software development lifecycle before publication as the cost to mitigate after software is published is typically higher.

the secure coding resources. These methods could potentially be improved by an understanding of secure coding behavior and how coders approach secure coding problems [18]. Our research is focused on systematically studying the behavior of secure coders in order to bring improvements to the secure coding process.

hands-on approach involved using a photo and video web sharing application. We used vulnerabilities from the Common Weakness Enumeration (CWE) repository to facilitate participants learning about weaknesses and vulnerabilities that are determined by industry to have a high importance [8]. The CWE repository provides a list of common weaknesses and vulnerability types as well as example code and exploits that could apply to several programming languages [32]. We also introduced specific CWEs from the OWASP Top 10 list and the National Vulnerability Database (NVD) [33,34]. Our learning modules illustrated coding instances of specific CWEs and showed exploitation methods and

visualize the viewing behavior of participants (e.g., read text and browse the Internet). Our eyes are comprised of various structures such as our pupil, retina, fovea, and various other components to help us visualize objects and colors [37]. Studying changes of pupil sizes, gaze location, pattern of eye movements allows researchers to examine participants

directly determine the amount of cognitive load on individuals. How- ever, research is ongoing in using eye tracking in combination with questionnaire and various stimuli to examine behavior and patterns of participants [46]. Our research study uses eye tracking technology to study the behavior of secure coders. In our study, students were pre- sented with questions and secure coding exercises while their eye gazes were recorded. This paper focuses on how to visualize the eye gaze of secure coders.

We investigate secure coders eye fixations and transitions with vi- sualizations. A fixation occurs when a participant eye is relatively fixed at one point and their eye has no movement. When viewed on a com- puter monitor, then a fixation is recorded as a X-point and a Y-point for a 2-dimensional viewing scene along with a timestamp. This allows for researchers to study the eye gaze of participants and determine when in time and where in the scene the eye gaze occurred. This can allow re- searchers to observe the viewing pattern of participants which is useful to determine the attention that participants have given to specific parts of a reading or visualization stimuli [47]. Transitions and order of stimuli visited can give insight into the behavior and methods that participants used when reading and watching stimuli. When the eyes are rapidly moving between two fixations, a saccade occurs [48]. The length for each saccade is noticeably short and is in the order of a few milli- seconds. Fixations typically last for milliseconds to seconds [46]. Sac- cades are often utilized to help determine the amount of attention or changes in attention [49]. Raw eye tracking data that is collected during

time-consuming to process and complex to understand. A commonly adopted technique includes creating Areas of Interest (AOIs) on pre- sented stimuli. This allows a research analyst to add specific regions of interest to the stimuli that was presented to participants [45]. The transitions between AOIs are important to analyze as well as the fixa- tions that occur inside of an AOI. An AOI is generally created manually

An important phase after the data collection is the data analysis. The methodologies applied to transform the raw eye fixations and saccades into meaningful insight is lacking with certain stimuli content [48]. Common techniques are appropriate for reading paragraphs of natural reading text; however, these approaches do not work well for stimuli that is more dynamic media-based in nature such as source code reading or scrolling through web-pages [50]. When the order of stimuli is not the same for all participants in the eye tracking recording sessions due to the unique individual behavior of the participant, then existing approaches of data analysis do not work well [51] because the eye movement pat- terns are much more complex than simpler stimuli content. Further- more, it is often necessary to determine the visual scan path that participants take to solve a problem in the chronological order in which participants viewed the stimuli [45]. This can be especially beneficial to determining patterns between participants.

Switches in attention between and within stimuli or AOIs can help researchers understand the visual strategies over a period that partici- pants used when inspecting the stimuli presented. Visualization methods are needed to fully understand the behaviors and patterns in the tran- sitions between and within stimuli or AOIs. Several common eye tracking data visualization techniques are Heat Maps, Scan Paths and Clustering.

when they read natural language text [73]. Recent publications demonstrate that allowing participants to scroll in source code while their eye gaze is recorded is beneficial. However, their tool is limited to specific software development toolkits such as initially the Eclipse in- tegrated development environment [74,75]. The iTrace tool is continuing to receive development support as it has now been extended to work with the Google Chrome web browser [67,76]. Current pub- lished literature indicates that additional work is needed for the iTrace

Our focus, in this paper, is researching visualization methods for multiple types of stimuli content including static eye tracking stimuli as well as non-linear dynamic stimuli. This can allow a software developer not only to scroll in long source code files but also to modify the source code that is presented as stimuli elements. Furthermore, we do not want to limit the design to only a specific software development integrated development environment. This provides a more natural environment for a software developer than limiting the stimuli to only lines of code that fit on a single monitor [63]. The current literature is lacking with visualization and analysis methods for activities involved in secure coding particularly for non-linear dynamic stimuli. Many existing eye tracking publications limit participants ability to scroll in the eye tracking stimuli which also includes limiting the ability of a participant to actually modify the eye tracking stimuli that is presented [56,68,79, 80]. Our primary focus is directly observing secure coding and learning activities, and then we can determine the potential to analyze secure coder patterns and behavior.

Writing source code and performing secure coding tasks should not mandate a specific step-by-step order of stimuli element content that eye tracking participants must follow, if the desire is to capture the unique self-motivated behavior that each secure coder uses to find and mitigate security flaws. Thus, a need exists to improve the methodologies used to investigate and analyze eye tracking data for software development and secure coding. A potential pitfall with some methods is that it can allow for the unique individual differences in secure coders to be obscured from view. For example, this can occur if the data is simplified as an arithmetic mean for several participants over an extended timeframe [47]. Therefore, the visualization approach may depend upon the type of stimuli content and the task given to coders.

In secure coding tasks, distinct types of source code files, security vulnerabilities, questions and tools are presented in several stages. The programming problems presented in the eye tracking study and in this paper increase in complexity and difficulty. In our experiment, students progressed through our hands-on learning exercises, in which the se- curity weaknesses were easier to find and mitigate was presented first and presented as multiple choice or true/false questions. More chal- lenging security weaknesses was presented afterwards, and participants had to modify actual source code as part of the task. It was beneficial to conduct an actual study to truly elevate visualization methods for eye gaze in secure coding.

Both of our learning modules start with a description of the CWE repository and the benefits it provides to secure coders. Both of our learning modules provided a brief introduction of several CWEs and then provided example source code of several weaknesses and finally provided several demonstration source code snippets that could allow for exploiting a weakness in our application. This content is presented as short paragraphs that are similar to standard reading of a book or research article. Our eye tracking technology recorded the eye gaze of each secure coder while they looked through our learning content. As part of our analysis phase, we explored each coder eye gaze with various visualization methods and common eye tracking metrics to gain an understanding of their reading behavior and patterns of the ordinary documentation paragraphs of text.

An important aspect of our research is to study the behavior and methodologies of secure coders while they perform secure coding tasks. Therefore, we presented each student several CWEs that allowed them to read existing source code functions and determine if a vulnerability existed and how to mitigate the vulnerability. This approach allowed us to introduce coding examples to the participants and present multiple choice or true/false questions to introduce secure coding problems to our participants.

For our first learning module, after reviewing the learning content for CWE-311 [94] and CWE-434 [95], then each student was presented several static screenshot images of snippets of source code and asked which code snippet correctly mitigated the security weaknesses. No scrolling of the source code was allowed for these tasks. This was designed to allow participants that may not be familiar with coding to get a general understanding of reading source code. Additionally, this allowed us to analyze the eye gaze of source code in a similar fashion as the reading of standard document text. Participants provided their an- swers from two or three multiple choice snippets.

ability to create a mitigation strategy and modify the source code to reduce or eliminate the vulnerability. Therefore, our research also examined participants eye gaze as they write source code to secure our software application. This user interactive stimuli content not only al- lows participants to control the flow of events by scrolling or switching between files and applications, but additionally it actually allows a participant to modify the stimuli content that is presented. We believe this is a critical aspect to truly capture the behavior of secure coders performing secure coding exercises.

For our second learning module, students had to write programming solutions for CWE-79 [101] in addition to using the RIPS tool to analyze the vulnerability report. Students also had the option to use the local web-based photo and video sharing website to determine if weaknesses existed and allows participants to attempt a security exploit. Students were permitted the ability to utilize a search engine or additional websites as needed to further research the CWE or potential solutions. In our analysis phase, we utilized existing eye tracking visualization methods but discovered limitations with existing approaches as the number of AOIs and participants increased for user interactive and user modifiable stimuli content. Therefore, we researched and designed additional visualizations approaches to handle user interactive stimuli content for when each secure coder had the tasks of modifying the stimuli content real-time as it was presented.

We start this section with the simplest stimuli content, tasks and analysis approaches and then progress to the approaches used in the dynamic and interactive tasks. First, we present a basic analysis of reading documentation and how to compare multiple students. Then, our analysis progresses to the programming content and the visualiza- tions at a more detailed level of the source code. Afterwards, we present our analysis of user interactive content and split screen applications between AOIs; however, this output provide an initial high-level over- view of the AOIs to determine what secure coders viewed. One can ascertain if some participants have a higher fixation count or fixation duration in some AOIs while ignoring other AOIs. Furthermore, our script uses the AOIs and fixation data to generate various plotting vi- sualizations using the Python package Matplotlib to generate PNG chart images [106]. Our script includes the ability to use Python Multipro- cessing capability to allow each participant data processing to operate in a different Python interpreter process. This significantly improved the processing time as the script scales out to the number of threads avail- able on a system and allows for the processing of multiple secure coders at once.

For CWE-434, the programming solution that contained the security flaw was located in programming option A. This approach to analyzing the AOI transitions allows researchers to establish a transition pattern and revisit pattern of participants working a problem. We also examined the fixation duration and number of fixations for these same participants working problem for CWE-434. This view allows for examining which AOIs the participants focused more in but also when those fixations occurred over a timeline. This is not possible with the fixation matrix that simply provides an overall summary of fixation count or fixation duration per each stimuli content or AOI. This demonstrates that some secure coders have more fixations in the same programming option before switching to a different programming option while other secure coders have fixations stretched throughout the programming options restriction that researchers have faced with eye tracking research [48, 79]. However, we believe that this also restricts the ability of the participant to follow a natural flow of problem solving that is typical for reading and writing software program code [105]. Therefore, our ex- periments also included dynamic interactive stimuli in both of our learning modules. The post-processing data analysis is more compli- cated and time consuming for dynamic user interactive stimuli content than compared to static stimuli; however, our belief is that it is necessary

The eye tracking software application that we utilized allows for re- watching of the dynamic interactive stimuli as a video recording for each secure coder. Each secure coder raw datapoints are saved with a video recorded file that contains the stimuli content and furthermore metadata for the eye gazes in relationship to the video frames. We used the Tobii Studio application to create, move, transform, and disable AOIs as needed for each coder for the dynamic content. This was accomplished by advancing the video recording at an interval of 0.2 s for each coder and annotating AOIs for each timestep. Depending upon where the participant scrolled and which source files or websites the coder viewed, then that altered which AOIs were active and the location of the AOIs. The AOIs for the dynamic interactive content for then exported from Tobii Studio for further data analysis. For our dynamic stimuli content, particularly the source code containing multiple code files with several programming functions per each file, our AOI creation

This allowed us to group AOIs together into categories that have com- mon source files or usages. For example, we grouped AOIs associated with instructions together and AOIs associated with using the static code analysis tool. Then, AOIs for each source code function contained in the same source file was also grouped together. The swimlane diagram approach allows us to clearly recognize the differences in the multiple stimuli and applications that each secure coder utilized when working the secure coding learning module. The transitions between the multiple stimuli content can also be easily visualized with swimlane diagrams. Additionally, this diagramming technique allows for comparison of multiple participants and visually ascertain their behavior.

HTML and PHP programming languages, participants were allowed the option to provide just pseudocode or a comment if they could not develop the actual source code to mitigate the vulnerability. Each participant was encouraged to attempt to develop the source code if possible and only as an alternative option write the source code or comments. The benefit of at least allowing participants to provide some feedback is the ability to examine if the participant found the location in the source code that the software security flaws exist. This is useful even as identified by the RIPS static code analysis tool; or 2) False, if the vulnerability did not exist in the source that was identified by the RIPS tool as a potential security flaw. For the coding problem in the second learning module, we focused on CWE-79. Overall, most participants got this programming problem partially correct; very few completely miti- gated the vulnerability or completely incorrectly answered the problem. Our verification of what solutions each participant provided was not directly performed using eye tracking technologies for every question

Our research study utilized heat maps, scan paths, and clusters which are commonly utilized techniques to investigate eye gazes of partici- pants. Then, we explored visual plotting of transitions and AOIs to compare the transition patterns between AOIs. Our approach allowed us to study the reading patterns of participants as they reviewed source code and utilized the security analysis tools. These additional visuali- zation methods allowed another viewpoint to overcome some of the limitations of the simpler techniques to manage several AOIs as well as the transitions between several AOIs. This allowed for exploring the dynamic nature of scrolling and jumping in and out of source code that typically limits the ability to use common eye tracking visualization methods. Our techniques allowed for investigating participants eye gaze at the application level, source code level and then visualize their techniques and strategies that was used to learn and work secure coding exercises.

We determined that applying a grouping to several of the AOIs could be beneficial to visually examine when participants switch between major applications or subtask such as reading instructions, reading source code, using static code analysis tools, and searching the web for assistance. We created a swim lane representation of the major com- ponents using PlantUML. This allowed us to automate the diagram drawing process using Python scripting. We also created a state repre- sentation of the major components and created another diagramming method using PlantUML as well. This technique is designed to give a high-level overview of the transitions between major components.

Additionally, we examined the left and right pupil data that was recorded during our eye recording sessions. Following a similar approach to visualize the pupil data, our work focused on creating custom script to examine the minimum, maximum and average pupil diameter changes over a timeline and for our AOIs. We also created the ability to sample the eye pupil size at specific intervals in time to keep from losing data points when participants do not transition out of an AOI for an extended period of time. To our knowledge, the literature is lacking in research that examines the pupil changes in regard to secure coding. Our future research is to ascertain if insight can be determined as to when participants discover a vulnerability by using their pupil diameter size.

Kagdi H, Yusuf S, Maletic JI. On using eye tracking in empirical assessment of software visualizations. In: Proc - 1st ACM int workshop on empirical assessment of software engineering languages and technologies, WEASELTech 2007, held with the 22nd IEEE/ACM int Conf automated software eng, ASE 2007; 2007.

