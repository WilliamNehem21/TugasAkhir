PAGODA (Policy And GOal Based Distributed Autonomy) is a modular architecture for specifying and prototyping autonomous systems. A PAGODA node (agent) interacts with its environment by sensing and affecting, driven by goals to achieve and constrained by policies. A PAGODA system is a collection of PAGODA nodes cooperating to achieve some mutual goal.

The long term objective of the PAGODA project is to develop techniques for specification and analysis that take advantage of the modularity and the declarative nature of policy- and goal-based systems. Our approach is based on the Reflective Russian Dolls (RRD) model of distributed object reflection [23,34] which in turn is founded on the rewriting logic formal modeling framework [22,24]. In [34] a general approach to modeling policy-based coordination using RRD was presented. The contribution of the present paper is presentation of a substantial case study illustrating the benefits of policy-based coordination for modularity of design and reasoning.

Policies that constrain the allowed actions / interactions of a node or system. A policy might reduce the number of choices for setting parameters, for example based on importance of different competing effects. Another policy might de- termine trade-offs between speed and power usage. Other policies might control aggregation and abstraction of information used locally or communicated to other agents.

This architecture provides a simple means of plugging in different component instances. PAGODA node components interact with other node components based on component type not on component instance identity. Thus it is easy to have multiple reasoners, knowledge bases, learners, etc., by simply modifying the coordi- nator policy to choose appropriate component instances. Different reasoners might be appropriate for different situations or goals, knowledge might be split into cat- egories and stored in separate KB instances, or two KB instances might contain knowledge at different levels of abstraction appropriate for different situations.

Additional components types could be easily incorporated. For example a com- ponent capable of knowledge abstraction or aggregation could be invoked from time to time by the coordinator to infer higher-level information from sensor data or information received from peers. Such a component could be used to raise the level of abstraction at which the reasoner or learner operates.

of a radio to test the ideas. Goals are treated as soft constraints on subsets of sen- sor readings. The relationships between effectors (knobs) and sensor readings and between sensor readings and goals are formalized as constraint semi-rings, which provides a clean mathematical basis for solving soft-constraints [5,26,35]. In addi- tion, initial experiments adding learner functionality have been carried out using both simple hill-climbing and a logic based learning algorithm. An additional com- ponent, MadRad, that simulates actual radio hardware/software including random, unusual and faulty behavior, and test scenarios have been developed to explore possible system behaviors by executing the composition of PAGODA and MadRad. The PAGODA specification and related documents are available form the PAGODA website http://pagoda.csl.sri.com.

where deliver(conf,msgs) puts each message in the set msgs into the input queue of its target object. Given a coordinator object instantiating the rule premise (left-hand side), the rule can fire just if the rule condition can be satisfied, i.e just if there is an enabled message in q so that firstEnabled returns a message-queue pair rather than a failure indication. In this case the attributes of the coordinator object are updated according to the right-hand side of the rule.

target, from is the sender (or blank) and MB is the message body (sort MsgBody). We introduce the following sorts to classify PAGODA message bodies. For each sort, Sort, ?sort is a variable ranging over Sort and ?Sort is a pattern variable that matches any term of the corresponding sort.

Policy for Goal messages. A goal message is enabled if there is no pending acknowledgement for some other goal (?Goal). The expected acknowledment is added to the wait4s. The expression external(x) is true if x is the identifier of an external node (goals may come from outside the node, or inside). The added wait4 specifies that the acknowledgment is sent out if the sender of the goal message is external, and delivered internally otherwise. The goal message is delivered to the reasoner, R, it is logged, and a notice is delivered to L.

Policy for Set* messages. An annotated set message is enabled if there are no pending set acknowledgments. The expected acknowledgment is added to the wait4s, specifying that the acknowledgment is to be delivered. The actions part is delivered to HAL, the monitoring tasks are delivered to M, the message is logged, and a notice delivered to L.

Policy for Sense messages. The axioms for sense messages are similar to those for set messages. A reply is expected, but the exact reply is not known, so a pattern is placed in the wait4 entry. When the expected message pattern is matched, occurrences of the pattern variable ?SenseReply in the message delivery descriptions are instantiated.

Using Wait4s. Some messages can only be processed if they are expected, namely replies and acknowledgments. A message M is expected if it matches a pattern ?M of one of the wait4s. A successful match produces a substitution S for the pattern variables in ?M. This substitution is used to instantiate the messages to be delivered (iMs[S]) and the messages to be sent out (xMs[S]).

In an ongoing project concerning ad hoc wireless radio networks, methods for specifying distributed coordinators are being developed based on a logical approach to distributed monitoring [33] and a distributed AI approach to distributed prob- lem solving [20,21]. In this application, a key coordinator responsibility is controlled dissemination of information. Here policy determines what information to propa- gate, when and to which nodes. Another coordination responsibility is distributed management of resources (bandwidth, energy, data storage). Here we have an in- teresting situation in which any realization of the coordinator must rely on the

The Mobile Unity language provides coordination primitives as well as a logic for reasoning about Mobile Unity specifications. Refinement from a high-level logical specification to mobile unity code is illustrated in [32]. Coordination properties are based on system state rather than interaction events.

