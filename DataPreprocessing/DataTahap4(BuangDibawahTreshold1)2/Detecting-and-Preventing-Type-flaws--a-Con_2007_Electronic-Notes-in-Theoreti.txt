A type flaw attack on a security protocol is an attack where an honest principal is cheated on interpreting a field in a message as the one with a type other than the intended one. In this paper, we shall present an extension of the LySa calculus with tags attached to each field, indicating the intended types. We developed a control flow analysis for analysing the extended LySa, which over-approximates all the possible behaviour of a protocol and hence is able to capture any type confusion that may happen during the protocol execution. The control flow analysis has been applied to a number of security protocols, either subject to type flaw attacks or not. The results show that it is able to capture type flaw attacks on those security protocols.

The paper is organised as follows. In Section 2, we present the LySa calculus with tags for type flaw attacks, both the syntax and semantics are defined. We intro- duce the Control Flow Analysis in Section 3, which captures any type-mismatching that may happen. In Section 4, we show how the Control Flow Analysis works on two example protocols that are subject to type flaw attacks. In Section 5, we conclude with an assessment of our approach and a comparison with related work.

The distinction is obtained by means of syntax: the definition occurrence of a variable x is denoted by qx, while in the scope of the declaration, the variable appears as x. Furthermore, this notation distinguishes variables from occurrences of standard terms in tuples of matching terms, by implicitly partitioning them into standard terms or variables. In pattern matching, the first are checked for matching, while the others are bound in case of successful matching (see below).

Type Tagging We extend the syntax of standard LySa to cope with types, by using tags to represent the types of terms. Following [11], we assume to have a tag for each base type, such as nonce, key, etc. Moreover, we assume that the attacker is able to change only the types of terms that he can access. In fact, by making the assumption of perfect cryptography, we have that only cleartext can be altered. Attackers can only forge an encryption when possessing the key used to cipher it. Actually, we can tag whatever we want, but we only check inside encryptions and decryptions, as shall be shown in Section 3.

There are type variables, that are to standard variables such as tags are to closed terms (i.e. terms without variables). Similarly to the q-notation, we syntactically distinguish the defining occurrences of type variables (in the form t), from the corresponding use occurrences (in the form t). Syntactically, we have the following two new categories, where XT denote sets of applied occurrences of type variables.

i.e. each variable composing each one of the Ei has been bound in the previous computations. Instead, matching terms Mi can be partitioned in closed terms and variables to be bound. Intuitively, the matching succeeds when the closed terms, say Mi, pairwise match to the corresponding terms Ei, and its effect is to bind the remaining terms Ej to the remaining variables qxj. To exemplify, consider the following two processes, where only standard terms are present.

A type flaw attack happens when a field in a message is interpreted as having a type other than the originally intended one. In this paper, we extended the syntax of the process calculus, LYSA, with tags, which represent the intended types of terms. The semantics of the tagged LYSA makes use of a reference monitor to capture type-mismatching at run time.

our analysis can then correspond to a sort of approximate type checking. More specifically, our control flow analysis can be used to 1) detect type flaw attacks: it can be applied in the protocol design stage: once a tagged protocol process is analyzed to be free of type flaw attacks, it can be used untagged while still ensures security; or 2) prevent type flaw attacks: the tags work in a way such that fields with different types cannot be mixed up. Therefore, it offers flexibility in satisfying different needs.

LYSA has been developed to be decorated by several kinds of annotations and successfully applied for checking different security properties, e.g. confidentiality [9] and freshness [8]. It is very easy to combine tags with those techniques, thus ob- taining a more general form of analysis. The core analysis can remain the same: different inspections of a solution permit to check different security properties of a protocol, with no need of re-analysing it several times.

The control flow analysis presented here is designed to capture simple type flaw attacks, i.e. one field is confused with another single field. Future work will extends the analysis to deal with more complex ones [18], as considered in [13], e.g. when a single field in a message is confused with a concatenation of fields. Furthermore, we can think about more complex kinds of tags.

