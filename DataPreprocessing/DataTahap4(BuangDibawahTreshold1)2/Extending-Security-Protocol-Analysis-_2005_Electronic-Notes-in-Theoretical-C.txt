We argue that formal analysis tools for security protocols are not achieving their full potential, and give only limited aid to designers of more complex modern protocols, protocols in constrained environments, and security APIs. We believe that typical assumptions such as perfect encryption can and must be relaxed, while other threats, including the partial leakage of information, must be considered if formal tools are to continue to be useful and gain widespread, real world utilisation. Using simple example protocols, we illustrate a number of attacks that are vital to avoid in security API design, but that have yet to be modelled using a formal analysis tool. We seek to extract the basic ideas behind these attacks and package them into a wish list of functionality for future research and tool development.

Theorem provers, in contrast, search at a higher level of abstraction for chains of logic that constitute a compelling proof that a particular property always holds. Alternatively, they may find a counter-example in the process. Various proof search strategies are used, often based on the basic resolution strategy proposed by Robinson [19].

Finally, there are reasoning logics such as the BAN logic [12]. Though instrumental in the understanding and development of formal analysis of se- curity protocols, the BAN logic itself has not been widely used to identify flaws; its main role has been in retrospective analysis. Individual researchers regularly use custom extensions and improved logics [13,1,20] in the protocol design process.

Security API analysis closely resembles the analysis of protocols. Consider a cryptographic processor (imagine a PC in a safe) that is network-attached and is used as a service by one or more users, quite similar in concept to a trusted third-party in a security protocol. The device makes its functionality available through an Application Programming Interface (API). Users can thus offload their sensitive, and often computationally expensive security operations to a dedicated, optimised device. This device may have additional benefits and responsibilities not found in a normal PC, e.g. a cut-down operating system hardened against attack, and special storage for cryptographic keys, possibly in tamper protected memory. Indeed, international funds-transfer and credit card infrastructures are based around devices such as these.

nificantly easier. The ability to identify such issues through automated anal- ysis of security APIs would be desirable. Extending existing tools to reason about 3DES as 3 individual crypto operations would appear to be easy. It seems that the challenge here is not to merely be able to reason but rather to

In practice, common sources of leaked information are error conditions and codes. These can be explicitly revealed through a message or indirectly re- vealed through timing patterns indicating the premature halting or abnormal execution of an operation. Bleichenbacher [25] and Manger [24] have both proposed attacks on the various RSA padding schemes: in these protocols an error response, or the timing of an error response leaks information about the plaintext, allowing a chosen ciphertext attack on RSA. Often such a leak is not visible or not explicitly stated during design process but becomes visible during coding or development. The attacker is often faced with the challenge that sometimes it may be the case that we can readily determine that there exists some form of information leakage but not be able to clearly identify what information is being leaked nor how it can be exploited.

