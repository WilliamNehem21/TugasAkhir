Using audit logging along with preventive mechanisms has two major applica- tions: 1) Post-execution analysis of audit logs provides a platform to detect security violations based on the logged evidence [60,5]. This class of logging policies rely on the notions of user accountability and deterrence. 2) Audit logging is used to detect existing vulnerabilities in the preventive security mechanisms and ameliorate those mechanisms [7,44].

In both of the aforementioned applications, effectiveness of in-depth security relies on the correctness and efficiency of the generated audit log and its after-the- fact analysis. Audit log correctness and efficiency reflect on some challenges in the generation of audit logs. Correct audit logging must record factual information about the runtime behavior, which may be ensured by the verification of auditing policies and their runtime enforcement mechanisms. Moreover, a correct audit log must include sufficient information according to what the auditing policy specifies. In addition, efficiency of audit logging must be emphasized in in-depth security in order to improve system performance regarding the collection and analysis of audit logs. Efficient audit logging entails to only record necessary information about the computation, rather than naively collecting all events in the log. These issues have been challenging in the wild, for instance resulting in failure to safeguard against data breaches, and are considered as one of the top ten most critical security risks by Open Web Application Security Project [50].

The aforementioned line of work relies on the proposed semantic framework for audit log generation whose implementation model is constrained to linear process executions. This limitation, in practice, restricts the application of the framework to systems where a single thread of execution is involved in the generation of audit logs. For instance, in the case study of a medical records system [6], audit logging capability is considered as an extension to the web server program, and all precondi- tions for logging depend on the events that transpire in the same program execution thread. As an example consider breaking the glass event [32]. Breaking the glass is used in critical situations to bypass access control. By breaking the glass, system

policies access to particular patient information is logged as long as the glass is already broken. In order to implement such specifications, we need to apply a timing mechanism that is shared among all processes of the system. Each step of concurrent execution of processes updates this universal time.

Many applications have been shifting their architecture from a traditional mono- lithic structure toward service-oriented architecture (SOA) in order to boost main- tainability, continuous deployment and testing, adaptation to new technologies, system security, fault tolerance, etc. One popular deployment approach to SOA is where an application is decomposed to a set of highly collaborative processes, called microservices. A microservice must be minimal, independent, and fine-grained. Minimality constrains a microservice to access and manipulate certain data types within an application, ideally a single database per each service. Microservice in- stances run independently in their own containers, virtual machines, or hosts. To accomplish its own goals, a microservice communicates with other microservices of the application through message passing, or remote procedure calls (RPCs). Jolie

These assumptions help us to purposefully focus on the essence of logging, i.e., whether logs are generated correctly in the first place and independent of exter- nal concerns including reliability of the underlying execution and communication system, latency, etc. which are explored in related work (Section 4).

In order to provide a standalone formal presentation, in this section we review the information-algebraic semantics of audit logging and the instantiation of the semantic framework with first-order logic, which is originally proposed by Amir- Mohammadian et al. [6]. We have applied minor modifications to the model to better suit concurrency and nondeterministic runtime behavior, inherent to concur- rent systems.

The notion of correct audit logging can be defined based on an execution trace and a logging specification. To this end, the information content of the audit log is compared to the information that the logging specification dictates to be recorded in the log, given the execution trace. The following definition captures this relation.

Another related property of the instrumentation algorithm is to ensure that it is deadlock-free, meaning that instrumenting a system does not introduce new states being stuck. One approach to define an independent notion of deadlock-freeness is to consider bisimilar source and target traces. Indeed, additional formal constructs must be introduced to translate target traces to source traces for this purpose. Our

Lastly, Definition 2.10 instantiates the combination and focusing operators for the FOL-based information algebra. Combination is the closure of the union of two sets of formulas. Focusing is the closure of the intersection of an information element and a query domain.

In Section 3.1, the syntax and semantics of the source system model is intro- duced. Section 3.2 proposes a class of logging specifications that can specify tem- poral relations among computational events in concurrent systems. Section 3.3 describes the syntax and semantics of the systems enhanced with audit logging ca- pabilities. Lastly, in Section 3.4, we discuss the instrumentation algorithm and the properties it satisfies.

gorithm changes the systems as follows.  A new link cPA is established be- tween Patient and Auth agents.  The definition of brkGlass is updated as Cj (Auth)(brkGlass) = [brkGlassAuth(u)  callEvent(Auth, brkGlass, [u]).P ], and the definition of getMedHist is updated as

Another line of work employs logs to record proof of legitimate access to system resources. Vaughn et al. [48] propose an architecture based on trusted kernels that rely on such logged proofs. Another related work is the a posteriori compliance control system [19] that verifies legitimacy of access after the fact, using a trust- based logical framework that focuses on a limited set of operations. However, our logical framework is used to specify invocation of any arbitrary operation as a precondition to log, or the logging event.

Audit logs can be considered a form of provenance [41]. CamFlow [39] is an auditing and provenance capture utility in Linux that can easily integrate with distributed systems. Pasquier et al. [40] make strong case for accountability, data provenance and audit in the IoT. AccessProv [12] is proposed as an instrumentation tool that rewrites legacy Java applications for provenance and finds bugs in autho-

Microservices-based approach [17,20] to software deployment is an application of our implementation model, that we aim to study in future in a greater detail. Accountability plays a significant role as part of the access control framework in microservices-based systems [33], including platform-specific monitoring techniques, e.g., in Azure Kubernetes Service [52]. Smith et al. [45] have proposed a provenance management system, including provenance logger, for microservices-based applica- tions. Camilli et al. [11] have proposed a semantics for microservices based on Petri nets. Our approach is, however, language-based and relies on process calculi. Jolie

proven that our algorithm guarantees correct audit logs. This ensures that the in- strumented system avoids missing any logging event, as well as logging unnecessary events. Correctness of audit logs are defined according to an information-algebraic semantic framework. In this semantic framework, information containment is used to compare the runtime behavior vs. the generated audit log.

Another area of interest is to extend the class of logging specifications, and hence implementation models. Our current class focuses on function invocations within each agent of the system, and it is limited to Horn clauses. While a great percentage of system events can be specified in this class, we need other classes of logging specifications for certain purposes. For example, consider the effect of revoking break-the-glass status for a user on the specification of audit logging re- quirements. Moreover, auditing usually includes the log of message transmissions between specific agents, which is not supported by what we have introduced in this paper.

Since our model of concurrency is based on a process calculi, message-passing is used for IPC. This necessitates the exploration of models that study the specification and enforcement of correct audit logging in concurrent environments which handle IPC through alternative approaches, e.g., shared memory and/or files.

