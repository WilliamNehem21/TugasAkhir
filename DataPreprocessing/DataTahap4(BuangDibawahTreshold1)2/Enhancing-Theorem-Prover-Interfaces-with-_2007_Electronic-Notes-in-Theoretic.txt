This paper proposes an extension to theorem proving interfaces for use with proof-directed debugging and other disproof-based applications. The extension is based around tracking a user-identified set of rules to create an informative program slice. Information is collected based on the involvement of these rules in both successful and unsuccessful proof branches. This provides a heuristic score for making judgements about the correctness of any rule.

The extension is based on the assumption that the debugging process involves locating a program statement or, in the case of functional programs, function case which is incorrect. This incorrect statement will appear in a program slice which can be identified during verification. Other program slices leading to correct de- ductions may also be identified during proof. This information can then be used to create appropriate syntax highlighting of function cases in an interface. A po- tential highlighting scheme is put forward and a simple case study based around Isabelle/HOL [12] and ProofGeneral [1] is performed to show how this would work.

Program Slicing was first suggested by Weiser [17]. The key idea was to identify a variable of interest at some point in a program (called the slicing criterion) and then extract a fragment of the program (a program slice) either containing all those statements upon which the value of the variable at that point depended or that fragment whose values were effected by the value of that variable at that point. Program Slicing techniques for imperative languages have generally followed this work [16] using control flow graphs, data flow graphs or other graph-based repre- sentations of programs with statements represented as nodes in the graph and a program slice as a set of nodes from the graph. In functional programs function application takes the place of program statements. The notion of a slicing criterion can also be generalised (e.g. to a projection as in [14]).

is a real example submitted by a student as the solution to an exercise to provide a function, onceOnly, that when applied to a list, l, returned a new list containing only one copy of each element in l. There are three errors in this program. Firstly the basis case of the insert function is incorrect. Secondly a case is missing in the definition of the Once function (the case for lists of length one) and lastly in the else branch of the recursive case the expression should be x1 :: Once (x2 :: xs).

It becomes clear, while attempting the above proof, that some independent lemmas need to be established about the sort function. This provides a good example of how the system behaves when a goal evaluates to False. Let us consider a simple lemma to show that all members of a list, l, are also members of sort l.

Assuming that insert_nil has been fixed, the last example we will consider picks up the main verification at a later stage. We will now assume that insert and sort have been removed from the suspect list. Two new functions and a new lemma have been introduced. minl returns the minimum element of a list of naturals and -minl returns a list with one occurrence of its minimum element removed. Among other things the following lemma has been established:

Out intention is to provide an implementation in Isabelle/Isar using the Proof General interface. This allows there to be a clean separation between the informa- tion used by the interface and that used by the underlying theorem prover. Such an approach also creates some challenges however, since the necessary properties of goals and proof states will have to be inferred. On the whole it should be relatively straightforward to identify goals and key constants within goals although it there will be some challenges involved in keeping track of proof states, in particular the relationships between parent and child goals needed to make updates correctly. In Isabelle successfully discharged goals are dropped from the proof state presented to the interface which again is likely to raise some challenges in the tracking of information.

Although no examples have been shown here where a rule is used directly with a tactic (e.g. the rule method in Isar) this also needs to trigger updates of tracking information. In general this should be relatively straightforward based on simple analysis of tactic calls.

