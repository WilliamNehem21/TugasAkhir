a proof in its foundational dialect. What is neglected by this traditional ap- proach is the interactive nature of the tool. The user has no feeling of what is going on, why the automatic procedure has possibly failed and how he can possibly improve the situation. Moreover, when used in a didactical environ- ment where untrained users are put in front of an interactive theorem prover, it is desirable to let them use automation facilities freely, but providing them the possibility to understand the work done by the automatic procedure or the reasons of its failure.

To get this result, we develop a SLD engine that performs backtracking without relying on the call stack (i.e. not using stack frames as choice points). This characteristic, together with a carefully chosen selection function, allow us to effectively present to the user a view of the ongoing computation.

The SLD resolution rule is implemented in Matita as the apply tactic. Since it is meant for interactive usage, both the selection and computation rule are left to the user: in the following presentation the goal i and the clause (lemma) c are user provided. The outcome of the tactic is a proof status or an exception if the unification step fails.

Since we want to present the user only good alternatives, the computational rule has not only to find good candidates, but also to attempt to apply them, directly pruning false positives. Moreover, suddenly applying all found lemmas allows to sort these alternatives looking for example to the number of newly opened goals. The cands function performs this search and returns a list of alternative proof statuses.

the rightmost column lists all lemmas that can be applied to the conjecture. This column displays the so called choice stack [7], colouring in grey the applied lemma. Some additional information on these lemmas are displayed using tool tips. If a lemma is unknown to the user, its type can be shown holding the mouse on its name.

The next step performed by the automatic procedure is to find relevant lemmas for the conjecture displayed in the second line, place them in the rightmost column, grey the former and display the result of its application. In case one application fails, the next alternative is attempted. In case there are no alternatives left, the next alternative of the previous line it considered. Thus, if no lemmas can be applied to conjecture 52, both line one and two are removed together with the witness lemma that generated them and the lemma div mod spec to divides is applied.

When a subgoal is solved, two possible scenario arise, depending if some metavariables are occurring in its statement or not. If some metavariables occur, the solution found may instantiate them in such a way that other goals in which such metavariables occur result false. In that case, the line corresponding to that goal is not removed, and the list of candidates associated to it remains visible and the user can interact with it. If the goal statement

To present the user such a window, the search procedure has to be stack- less. All informations have to be accessible by the graphical user interface at any time. That means the procedure has to be a for-program (or a tail recursive function) keeping the computation tree (and informations needed for backtracking) into a first order object and possibly pass it to the GUI.

The D constructor will decorate goals that still have to be processed (toDo), while S will decorate goals that have been successfully solved, and whose proof may be cached. The last component of an element is a failure list, containing all goals that have to be considered failed when the element itself fails (i.e. when the op list contains some D items that fail).

On such a status the step function applies rule (vi). calling the cands function to get a list of alternative proof statuses. All new goals are decorated with a D constructor, and sorted using the R function. They are positioned in front of the tl list, separated with an S item for the processed goal g. This item, when processed, will cache the proof found for g, and this will happen only after all newly created D items are solved.

with an empty failure ( fl ) list. In that way, if they fail, the cache will not be updated with a failure for g, since there are still valid alternatives for that goal. On the contrary, the last element inherits the failure list and adds to it g.

To limit the search tree explored by the procedure to a certain depth, or even a number of nodes, some additional fields have to be added to the element structure. To efficiently keep track of the depth or size of the tree, the element structure is enriched with two integers representing the depth left and the actual size of tree: every time a D item is processed, the depth limit (as well as the size) is decreased. When an S item is processed the depth is increased again. The additional following rule is then added to the operational description:

The GUI and the automatic procedure run in different threads. Rule (vi) checks a condition variable 4 , associated with the pause button of the GUI, before proceeding. The computation status (the el list) is purely functional and every loop sets a global reference to that variable, allowing the GUI thread to render it.

