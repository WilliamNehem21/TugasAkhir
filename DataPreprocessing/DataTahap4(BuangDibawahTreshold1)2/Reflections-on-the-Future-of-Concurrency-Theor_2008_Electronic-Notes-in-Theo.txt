In this article we review the current state of concurrency theory with respect to its industrial impact. This review is both retrospective and prospective, and naturally encompasses process calculi, which are a major vector for spreading concurrency theory concepts. Considering the achievements, but also the failures, we try to identify the causes that, so far, prevented a larger dissemination of process calculi. This suggests a new generation of formal specification languages that would combine the concurrent features of process calculi with the standard concepts present in algorithmic languages. Finally, we underline two major evolutions in the software and hardware industries that open new application domains for the concurrency theory community.

It is organized as follows. Section 2 recalls some important, yet partial, achieve- ments of concurrency theory in general, and process calculi in particular. Section 3 discusses three main issues that often prevent process calculi from being widely used in industry. Section 4 mentions two important evolutions affecting the software and hardware industries, and discusses how these evolutions provide new opportunities to concurrency theory. Finally, Section 5 gives a few concluding remarks.

In this respect, the two questions quoted in the introduction sound like a remi- niscence of the recurrent debate pure mathematics vs applied mathematics. Same as for pure mathematics (illustrated by the Bourbaki group), it exists a pure concur- rency theory school, sometimes driven more by the abstract beauty of theoretical results than by their practical usefulness. But, as for applied mathematics (illus- trated by J.J. Lions and colleagues), it also exists an applied concurrency theory community, that takes its inspiration from real-world problems.

Find a company that designs concurrent systems with a strong need for relia- bility. This step is rather easy, as there are more such companies than research teams in concurrency theory. Typical application areas are communication protocols, distributed systems, hardware architectures, embedded systems, se- curity protocols, etc.

In the United Kingdom, for instance, the Ccs and Csp communities continued working with their favourite calculi. It is worth noticing, however, that (according to the publications) the definition of Csp gradually evolved to become quite similar to Lotos, at least for the untimed aspects (see e.g. [12]), still with slightly different notations. Additionally, the principles of Csp gave birth to new languages such as Fdr2 and Occam [33] supported by compilers and verification tools.

The lack of user-friendliness, which greatly hampers the dissemination of process calculi, is the result of unappropriate technical decisions. Although process calculi were a scientific breakthrough, their design was not free from mistakes. We briefly evoke two main mistakes, which are directly related to the two questions raised in the introduction of the present article.

From the beginning, concurrency theory has been based on models, i.e., descriptions of real-world systems, which are simplified 5 to retain only those aspects pertinent to the study of concurrency. Quite early, these models have been made formal, especially with the advent of process calculi.

Although the concept of model is widely used in many branches of science and engineering (e.g., physics, biology, civil engineering, etc.), formal models of concur- rency have been so far confined to specific topics (formal methods, model-checking) with little impact on computer science in general.

linear algebra is the same for, e.g., both automotive and aerospace industries. Similarly, behind each process calculus (except a few calculi, such Circal and Chp [40,50], which explicitly target at hardware circuits), there was an implicit motivation that this calculus should be general-purpose and expressive enough to model concurrent systems of various domains.

ded systems. As the silicon surface of circuits increases, the electric consumption increases too, and it is common that 50% or more of the energy is used only to propagate the global clock in every part of the circuit. Also, the regularity of synchronous designs makes them vulnerable to spying (e.g., by observation of their electromagnetic emissions), which is a drawback for secure applications such as cryptography. For these reasons, the synchronous design paradigm is being questioned, and there is a growing interest in asynchronous logic for circuit design [27,13,56]. However, asynchronous logic is more error-prone than syn- chronous logic (with a higher risk of deadlocks for instance), thus giving a crucial role to functional verification. In this respect, process calculi and model check- ing tools can greatly contribute to the design of correct asynchronous circuits,

At a higher level, computer architectures are evolving to allow reductions in silicon surface and cost. Many circuits (such as arithmetic co-processors, digital signal processors, etc.) that used to be external to the microprocessor (i.e., on the motherboard) are now internal. The hardware buses themselves are moving from the outside to the inside of the microprocessor. Therefore, it is no longer efficient, nor even feasible, to have a unique clock to synchronize all these various hardware subsystems produced separately by different companies. Given that these subsystems are still designed under the sychronous paradigm, the least that must be done is to allow them to work asynchronously according to the Gals (Globally Asynchronous, Locally Synchronous) paradigm [7]. Again, languages and tools derived from concurrency theory can help to study such architectures,

