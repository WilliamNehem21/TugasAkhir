Therefore, in this work we propose a distributed signature-based Markov-AP bisimulation algorithm. In contrast to [21] we apply a signature-based algorithm [5] which is more memory-efficient than the algorithm from [9] used in [21]. In some cases, our algorithm is also faster than the algorithm applied in [21]. Furthermore, we are not aware of any approach that computes the quotient of any notion of a stochastic bisimulation relation in a distributed way.

The paper is further organised as follows. In Section 2 we introduce the syn- tax and semantics of CSL, the notion of Markov-AP bisimulation, as well as a signature-based definition of Markov-AP bisimulation. In Section 3 a distributed implementation for the signature-based computation of the Markov-AP bisimula- tion quotient is presented. In Section 4 we present a few widely used case studies in the realm of stochastic verification. These case studies are used in Sec. 5 and Sec. 6

For the computation of the bisimulation quotient it is crucial to choose an initial partition. For Markov-AP bisimulation we choose to initially group those states together that bear the same state labelling. Starting from this initial partition, the partitioning is refined during the computation, until no further refinement can be found, i.e. a fixed-point is reached.

This case study is based on [23]. Here, a simple peer-to-peer protocol based on BitTorrent is described. N + 1 clients try to download a file, that is divided into K blocks. In the initial state, there is one client that is in possession of the entire file, i.e., all K blocks, and N clients have no block at all. Each client can download a block from each other client. Here, we investigate a system with K =5 blocks and N = 2, 3, 4 additional clients. A typical CSL property for the Peer-to-Peer Protocol is:

This case study is based on [13]. The system consists of two sub-clusters, where each sub-cluster possesses N workstations. The workstations in the respective sub- clusters are connected according to a star-topology with a central switch. The sub-cluster central switches communicate via a central backbone. All components are subject to failures and can be repaired. For all components a single repair unit is available. The employed repair strategy is random, i.e., if more than one component awaits repair, the repair unit chooses the component which is to be repaired next according to a typically uniform probability distribution.

Here, a cyclic server-polling system with N stations is analysed. The model was introduced in [19]. The server polls the N stations in a cyclic way. After polling station i, station i is served. If station i is idle, it is skipped.

This case study was originally described in [6]. We model a Kanban system with four cells, a single type of Kanban cards, and the possibility that some workpiece may need to be reworked. We use N to denote the number of cards in the system. For the Kanban system we have not specified CSL formulae.

In this section we show the feasibility of our signature-based reduction algorithm by means of the case studies from Sec. 4. That is, we compare both the time and memory efficiency of a serial version of our algorithm, as implemented in ltsmin with that of mrmc [22,21]. The next section is devoted to the evaluation of the distributed version of our algorithm.

The reason for the big difference in time is that for n states and m transitions the complexity of mrmc is O(m log n), whereas the complexity of ltsmin is O(mI), where I is the number of iterations needed. Worst case I can be n, but in practice we have never encountered an example where I was worse than O(N ). Because the cluster example does not grow as fast with N as the other examples this means that ltsmin is not as effective. For strong bisimulation it is known that in similar cases it is very effective to use incremental signature computation. It is future work to see if that carries over to Markov(-AP) bisimulation.

We have also computed the Markov-AP bisimulation quotient for all formulae from Section 4.3 in isolation. We observed that neither of the sets of state labels, that is induced by these formulae led to any reduction of the state space size.

Not very surprising, when not taking different rates into account, i.e. if we compute a simple strong bisimulation quotient, the state space of the Kanban system is reducible. For example for N = 3 the state space can be reduced from 58,400 to 33,200 states.

