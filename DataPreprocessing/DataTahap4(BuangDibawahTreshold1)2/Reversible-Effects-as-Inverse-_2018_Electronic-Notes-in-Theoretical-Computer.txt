We are interested in models of reversibility suited to functional programming languages. Functional languages are interesting in a reversible setting for two rea- sons. First, they are easier to reason and prove properties about, which is a boon if we want to understand the logic behind reversible programming. Second, they are not stateful by definition, which eases reversing programs. It is fair to say that existing reversible functional programming languages [20,34] still lack various desirable constructs familiar from the irreversible setting.

Irreversible functional programming languages like Haskell naturally take se- mantics in categories. The objects interpret types, and the morphisms interpret functions. Functional languages are by definition not stateful, and their categori- cal semantics only models pure functions. However, sometimes it is useful to have non-functional side-effects, such as exceptions, input/output, or indeed even state. Irreversible functional languages can handle this elegantly using monads [25] or more generally arrows [17].

This paper aims to inform design principles of sound reversible programming languages. The main contribution is to match desirable programming concepts to precise category theoretic constructions. As such, it is written from a theoretical perspective. To make examples more concrete for readers with a more practical background, we adopt the syntax of a typed first-order reversible functional pro- gramming language with type classes. We begin with preliminaries on reversible base categories (in Section 2).

This is analogous to how variable assignment works in the reversible programming language Janus [35]: Since destructive updating is not permitted, state is updated by means of built-in reversible update operators, e.g., updating a variable by adding a constant or the contents of another variable to it, etc.

A similar approach to invertibility using arrows is given by bidirectional ar- rows [2]. However, while the goal of inverse arrows is to add effects to already invertible languages, bidirectional arrows arise as a means to add invertibility to an otherwise uninvertible language. As such, bidirectional arrows have different con- cerns than inverse arrows, and notably do not guarantee invertibility in the general case.

