This paper describes a few of the strategies used in Plover, an automatic property verification tool for Haskell programs developed in connection with the Programatica project. Its objective is to demonstrate the feasibility of automatic verification of formally specified properties of computer programs. Plover can provide assurance of many useful properties based upon the soundness of automated reasoning in a formal logic. Plover specifically im- plements reasoning in P-logic, which is the verification logic of Haskell98,

Other examples of language-specific verification logics are ACL2 [3], a veri- fication logic for Common Lisp, and Sparkle [2], a verifier for Clean 2.0. When assertions are formulated in a language-specific verification logic it is unneces- sary to translate expressions and their asserted properties into another logical formalism, which may have a different type system, and with the attendant risk that errors may be introduced in the translation.

Every predicate form definable in P-logic is subject to a typing discipline: a predicate is the refinement of a Haskell type. P-logic provides basic con- structions for unary predicates analogous to the constructors of Haskell types. Predicate constructions are formed with the arrow constructor (->), finite tu- pling, predicate constructor application and predicate disjunction, which is analogous to the sum-of-constructions by which data types are defined. Ad- ditional predicate constructions go beyond the constructions of Haskell types. These include predicate disjunction 2 , predicate negation 3 , predicate abstrac- tion, least and greatest fixed-point constructions, and comprehensions that utilize formulas with quantified object variables in the specification of a pred- icate.

over two alternatives. Notice the use of the data constructors as strategy con- structors. A data constructor, when lifted to become a strategy constructor, is satisfied by a term built with the same data constructor and whose argument terms satisfy the respective strategy arguments given to the strategy construc- tor. Note also the use of the id strategy as an argument to a lifted strategy constructor. id is a library strategy that always succeeds, leaving the current term and bindings unchanged. It is analogous to a wildcard designator in a pattern.

The first alternative of the whnf strategy is satisfied by an Abs construction with any well-sorted subterms as arguments. The recursively defined alterna- tive is satisfied by any Var term and also by an App term whose rator is either a Var term or an App term in weak head normal form. Thus the recognition strategy excludes any App term that has an Abs term as rator. There is no restriction on the rand subterm of an App construction.

The second definition is similar to the first, but adds the restriction that the rand of an App term must be in head normal form. Since the allowed forms of the rator and rand subterms differ, an additional level of recursive definition is needed to accommodate both forms. Finally, the third definition adds the restriction that the body of an Abs term must have the specified normal form, as well.

Notice that the last alternative listed in the definition of Replace is sep- arated by the operator symbol (<+) rather than the symbol (+). The symbol (<+) designates left-biased choice rather than nondeterministic choice of al- ternative strategies. Since the pattern of the final alternative would match an arbitrary pair of terms, it overlaps the patterns of each of the rules that precede it, and is programmed to fire only as a default alternative.

Some types uniquely determine the top-level structure of normal-form terms of the type. Product types (finite tuples) and data types with only a single constructor have this property. Structure-determining types see greater use in Haskell programs than would be the case in many other languages.

A let expression constitutes a list of local definitions that scope over a sin- gle object expression. The order in which definitions are listed is semantically unimportant in Haskell, as they scope over one another, as well. Thus a set of definitions may be mutually recursive.

We have given a brief overview of strategies used in Plover, an automatic verification tool for properties of Haskell98 programs. The power of strate- gies for controlling rewriting is illustrated by the example of normalization strategies to achieve three, different normal forms for a simple lambda calcu- lus. However, Plover employs far more than normalization to verify Haskell programs.

