benefits of a fully automatic, highly optimized, yet exhaustive state space explo- ration should be brought to bear on programs written in standard, high-level lan- guages such as Java, C/C++, or C#. Second, the pitfalls of an error prone manual translation of the programs into the input language of established model checkers such as Spin [6] and SMV [2] should be avoided. With the growing trend towards more concurrency in everyday software (e.g., to reap performance benefits [17] or to implement embedded systems) this research seems particularly timely. Exist- ing software model checkers either translate the program into the input language of an existing model checker (e.g., Bandera [3], or Feaver [7]), or augment the ex- ecution environment of the language to carry out the model checking (e.g., Java Pathfinder [18], Verisoft [5], or Zing [1]).

In this paper, we investigate the development of a software model checker for .NET. More precisely, we show how a common representation like MSIL can be leveraged for analysis purposes in general, and model checking in particular. In principle, MSIL allows the analysis of multiple languages with only a single transfor- mation: the transformation of MSIL to the input language of the analysis tool. The contribution of this work is a framework (MSILCAD) for the automatic transforma- tion of a subset of MSIL to Bandera Intermediate Representation (BIR), the input language of the Bogor model checker [15]. At the core of our framework is the Mi- crosoft Intermediate Language-to-Java Bytecode transformation (MSIL2JBC). The MSIL2JBC transformation has been designed to support a subset of MSIL that is the result of a reasonably sized subset of both C# and J# programming languages. The framework also contains tools that support assertion violation checking as well as deadlock detection. To the best of our knowledge, the only other model checker for MSIL is Zing [1]. In contrast to Zing, our framework is translation-based, and leverages the capabilities of the Bandera toolset.

We have chosen to implement the MSIL2JBC translation with TXL [4], a pro- gramming language specifically designed to support structural source transforma- tion. The TXL program responsible for the MSIL2JBC translation applies a number of transformation rules to the MSIL input, which are separated into rule-sets, each with its own specific transformational purpose. For instance, one rule-set handles the creation of threads, while another rule-set provides the ability to support method invocation, and so on.

In the remainder of this paper, we provide background on MSIL, the Java assem- bler format JASMIN [11], TXL and Bandera in Section 2, and a complete overview of MSILCAD in Section 3. Section 4 explains the evaluation of MSILCAD and example experiments, and Section 5 discusses related work. Finally, in Section 6 conclusions are given followed by future work.

more complex due to the fact that it is designed specifically to be the target of many languages. Source code is compiled to this intermediate language before it is just- in-time compiled to native code for some target platform. The work presented in this paper is concerned with a restricted subset of this language and the remainder of this section will focus only on that subset.

MSIL is a stack-based language. The subset of MSIL that we have focused on has instructions to load literal values onto the stack (ldc), to create arrays (newarr), to load and store values between fields (ldfld, ldsfld, stfld, stsfld), to load method arguments (ldarg), as well as some others. Instructions handling standard arithmetic and boolean comparisons are supported. Moreover, instructions to do nothing (nop), to branch conditionally (br), or unconditionally (brfalse, brtrue), and to return from a method (ret) are handled. Finally, limited support has been included for concurrency and object synchronization by allowing thread and monitor objects.

JASMIN [11] is a Java Assembler Interface that takes ASCII descriptions for Java classes, written in a simple assembler-like syntax using the Java Virtual Machine [10] instruction set, and converts them into binary Java classfiles. Since its creation, JASMIN has become the de-facto standard assembly format for Java. Our work uses the JASMIN syntax as the target language of our transformation so that we can leverage the JASMIN Assembler to produce Java binaries.

Bandera is a component-based model extractor and model checker for Java pro- grams. Its current implementation handles all of Java, including object synchroniza- tion, multi-threading, and assertions. Its component-based architecture for model extraction is designed for scalability, flexibility and extensibility. Our framework utilizes Bandera for extracting optimized models from Java code, and model check- ing these models for assertion violations and deadlock.

then disassembled to MSIL code and is passed directly to the MSIL2JBC translator. The MSIL2JBC translator produces Java bytecode and Java source code, both cor- responding to the MSIL code the translator was passed. Finally, the Java bytecode and source code are passed to the Post-Transformation Processor where Bandera is prepared for analysis, assertion code is finalized, a BIR model is extracted from the Java source, and Bandera is used to check for assertion violations and deadlock. Details for all steps of MSILCAD are given in the remainder of this section.

The MSIL2JBC translator does not handle the use of assertions at the bytecode level due to the complicated nature of producing assertions in the Java source during the assembly from bytecode. The Assertion Pre-Processor replaces assertions in the source code with something that the MSIL2JBC is able to translate such that it is flagged for later discovery. Afterwards, during the Post-Transformation Processing stage, these replacements are located and assertions are realized. This step is achieved with a simple Visual Basic Script.

The Java source code and bytecode have already been produced at this point, but the session file needs to be created. We have implemented a script in Visual Basic Script that updates a template Bandera session file with the locations of the Java source code and bytecode, as well as which class contains the main method. The session file contains commands to invoke Bogor for deadlock detection and assertion violation checking, as well as a tool to output the BIR model of the program to a file. When the Bandera Pre-Processor completes, the result is a fully functional Bandera session file, and a verifiable BIR model of the program.

The Assertion Post-Processor scans the Java source files for any indication of user defined assertions created by the Assertion Pre-Processor (as discuessed in Sec- tion 3.1.1). If the use of assertions is detected, what has been located is replaced by valid Java assertion statements. This step is achieved by a simple Visual Basic Script.

ation involved programming the algorithms in C# and J# languages and verifying (by hand) that our transformation to Java was performed correctly. We demon- strated that semantics were well preserved across all of the transformations by checking that the execution and model checking behavior of the target matched the original semantics of the source. Finally, we applied model checking for deadlock detection and inserted assertion statements to test for assertion violations.

At the time of writing a new approach to model checking is in development for Java bytecode. The authors of Bogor and Bandera have introduced an early prototype of BogorVM [14], a model checker aimed directly at model checking Java bytecode, and not source code. BogorVM is in the early stages of development and has limitations, thus we used Bandera for our purposes.

bytecode. The Bandera toolset is then used to optimize and analyze the resulting bytecode. We have implemented the approach in a prototype and evaluated it with promising results on several small examples. TXL proved to be a convenient vehicle to realize the translation. While there are a few language features currently not handled by our prototype, we do not see a reason why it cannot be extended to not only support the entire safe subset of MSIL, but also other .NET languages such as Visual Basic.

