Notwithstanding all these advantages, using JNI in its most primitive form is tedious and error prone. Using raw JNI is like assembly programming on the JVM. Our mission is to make interoperation between Java and Haskell via JNI as convenient as programming in Java directly.

In general, each native method implementation gets an additional JNIEnv argument, and a jobject object reference (or a jclass class object for static methods). The JNIEnv argument is an interface pointer through which the native method can communicate with Java, for instance to access fields of the object, or to call back into the JVM. The jobject (or jclass) reference corresponds to the this pointer (or class object) in Java.

Haskell interpreters, such as for example Hugs, do not naturally support stati- cally exported functions. Fortunately, we can also dynamically export Haskell functions as if they are C function pointers 3 . Dynamically exported Haskell functions are extremely powerful and make programming with callbacks very easy, as the following example demonstrates.

The DietHEP component [11] leverages on the foreign function interface we defined for Haskell in previous papers [3] and allows us to view any Haskell module as an ordinary DLL.Clients of DietHEP see no difference (except for the extra flexibility of specifying the calling convention at runtime when using GetProcAddressEx) between using an ordinary DLL via the kernel32.dll or using the DietHEP primitives. Going through the extra level of indirection of DietHEP allows us to abstract from the underlying Haskell implementation (provided of course that it supports the DietHEP interface).

At this stage, we have shown the bare bones of the integration between Haskell and Java. We will make the binding more user friendly in a number of steps. First we will abstract away commonly occurring patterns. Second, we hide the explicit threading of the JNIEnv argument through all JNI related code. Next, we will use overloading to hide the encoding of result-types in JNI methods.

The JNIEnv pointer is only valid in its associated thread, so we cannot put it in a global variable just like that. The JavaVM pointer however does remain valid across different threads and we can safely put that in a global variable. To do that, we need to get hold of the JavaVM pointer in which the current thread is running, and we postulate that (current and future) JNI implementations provide some way of doing this. We will follow one of the suggestions 4 of Liang ([8], section 8.1.4) that relies on the fact that the current JVM releases do not support the creation of more than one JVM instance inside a single process ([8], page 254).

Before we start using overloading to simplify JNI, we have to make a short digression on marshalling. In section 3.1, we assumed that we had a function marshallString :: String -> IO CString that takes a Haskell string and returns a pointer to a null terminated array of characters.

There are several things to note about the above code. First of all, it inti- mately relies on lazy evaluation, function methodDescriptor only depends on the types of its arguments and not on their values. Secondly, the call to unsafePerformIO is there solely to strip the IO from the result type of the callMethod function, which is completely safe.

The above situation is the only case where we have to explicitly up an upcast in Haskell; the question remains how to deal with the occasional need for downcasting. In Java, it is possible to unsafely cast between arbitrary classes, which might raise a dynamic ClassCastException. Using the Haskell cast to do an illegal arbitrary cast will either result in a ClassCastException or other exception being thrown in Java (which is checked using the JNI entry ExceptionOccured), or a call to one of underlying the JNI entry calls will signal an error (usually by returning NULL). The Haskell wrapper will catch these and propagate the errors to the Haskell level by raising a userError when returning. In other words, using cast to simulate arbitrary Java casting in Haskell is no more safe or unsafe than arbitrary casting in Java.

Lambada provides tool support in concert with HDirect[3]. HDirect is IDL based, so provided we can derive an IDL specification from a Java class or interface, HDirect will take care of generating valid Haskell stubs. We do this by providing a tool that uses the Java Reflection API to generate IDL interfaces (annotated with a couple of custom attributes) corresponding to Java classes or interfaces. Provided with that information, HDirect is then able to automatically generate the Haskell callable stubs we have described in this paper. HDirect is also capable of generating Java callable stubs to Haskell implemented classes/methods.

