Operational semantics for programming languages usually come in two flavours: big-step and small-step. Both are defined using deduction rules with a congruence rule allowing reduction in certain contexts. For a description based on rewrite rules, known approaches consist in deriving an abstract machine, which is very close to implementation. In this paper, we describe the operational semantics of an imperative language in a rule-based style, arguably as abstract as the other kinds of semantics. Moreover, we combine the approach with the store-based semantics, which puts the focus on memory states rather than values, which is more appropriate for imperative languages.

Structural operational semantics (SOS) [9] has become the standard way of defining the operational meaning (or semantics) of programming languages. Still, SOS allows two different styles of specification: the big-step style defining a relation between programs and return values; and the small-step style defining a relation between program states. The big-step style is often preferred in the definition of the seman- tics of a programming language, but the small-step formulation is sometimes more convenient for certain applications (e.g., the proof of language properties [5,2]).

practice, small-step presentations of programming languages are indeed done in this way: the truly atomic steps are described as axioms, and a deduction rule allows reduction in a certain class of contexts. In general, this rule may effectively be applied an arbitrary number of times. Moreover, the class of contexts in which reduction should be allowed may be very tricky to define; this is the main difficulty that arises when one tries to derive the small-step semantics from the big-step one. Thereafter, we call contextual semantics this kind of presentation that heavily relies on contexts.

Another defect of conventional descriptions of semantics is the emphasis on values, which may prove cumbersome when the object of study is instead a memory state. This is the case in imperative languages, but also for instance in proof languages where the state is the proof-tree under development. In this situation, the framework is usually adapted to deal with pairs of a program and a memory state: the programs no longer compute a value but a final memory state, so the definition of normal forms needs to be adapted. The use of pairs also creates an artificial asymmetry in the deduction rules, reflecting the fact that subterms of pairs are not pairs themselves.

We show that the two approaches can be combined in Section 5, resulting in a truly rule-based semantics of an imperative language, where evaluation flow (reduc- tion order) is made explicit at the syntactic level, and with emphasis on memory states. This could prove particularly useful to express the semantics of languages centred on state manipulation and for which the evaluation order is tricky to define in terms of contexts. It could also be useful to derive in a more or less automatic way small-step semantics and abstract machines from big-step specifications. More- over, this allows to borrow from well-known rewriting theory results, technologies and tools.

The traditional approach to express the semantics of a language in more atomic steps is called small-step semantics [7], but we prefer the term contextual semantics here, as the formalisms we introduce can arguably also be called small-step semantics. It will even be argued that the steps are somewhat smaller. In this section, we expose the traditional approach, adapted from [7].

where the state is unchanged and v is a value. In this note, the focus is on the evaluation of commands. Hence from now on we assume expressions are correctly evaluated without giving more details; the interested reader may refer to [7].

The contextual rule has been put in the reduction relation, in an explicit way. All steps are thus truly atomic, and the number of steps gives a more reasonable account of the cost of evaluation. For instance, a compiled program will most probably not need to perform any context steps.

As in the conventional approach, there is only one reduction possible at a time. But now, this does not rely on a fine tuning of a class of contexts. This is rather enforced syntactically at the level of terms, in an explicit and extensible way.

We can now get rid of the context rule by restricting rewrite rules to atomic stores, which imposes a reduction strategy at the level of the rewrite system, so that only one reduction is possible at a time. Intermediate notations, such as := and if ... then ... else, are introduced to mark that evaluation of an expression has already been triggered, and the next step should happen after we get a value. This trick contributes to getting rid of the context rule. Finally, we use the [ , ]

Note that this way of dealing with expressions, i.e. as commands, is not as far- fetched as it may seem: the contextual semantics of Section 2.4 has a dual approach, in that it considered commands as a special kind of expressions (functions returning skip).

We have presented three original semantical frameworks for a minimalistic imper- ative language. While being at a higher level than abstract machines, they have many desirable properties compared to conventional approaches. These formalisms rely on a simpler model (term rewriting instead of deduction system), one of them gives an explicit status to the evaluation flow, another one improves the balance between memory state and values and the last one combines these benefits.

The approach has many other potential applications, still to be perceived. Among others, results and tools from rewriting theory may be easier to apply to semantics. It is also a better candidate than regular approaches to bridge the gap between big-step specifications and implementations.

