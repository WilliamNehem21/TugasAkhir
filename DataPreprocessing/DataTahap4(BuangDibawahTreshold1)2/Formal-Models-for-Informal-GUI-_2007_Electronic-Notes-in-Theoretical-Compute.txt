Many different methods exist for the design and implementation of software systems. These methods may be fully formal, such as the use of formal specification languages and refinement processes, or they may be totally informal, such as jotting design ideas down on paper prior to coding, or they may be somewhere in between these two extremes. Formal methods are naturally suited to underlying system behaviour while user-centred approaches to user interface design fit comfortably with more informal approaches. The challenge is to find ways of integrating user-centred design methods with formal methods so that the benefits of both are fully realised. This paper presents a way of capturing the intentions behind informal design artefacts within a formal environment and then shows several applications of this approach.

Separation of the design and implementation of a graphical user interface (GUI) of a system from what we will refer to as the underlying system behaviour is a common and pragmatic approach for many applications. The development of user interface management systems (UIMS) based on the logical separation of system functionality and user interface (UI) is exemplified by the Seeheim model [20]. The separation allows us to not only focus on the different concerns which different parts of the system development present, but, more importantly, allows for different approaches and design techniques.

In this paper we will introduce a way of formally describing informal design artefacts, called the presentation model. We will give some examples of the use of the presentation model within a formal design context and then show how we can extend this model with another formalism, finite state machines. We can then begin to explore both the static and dynamic meanings of the designs which form the basis of the model.

The key to UCD, therefore, is to ensure that the actual users of the system are involved at all stages of the design process. The sorts of artefacts that are generated during such processes reflect this collaborative way of working and will include things like white-board design sessions with post-it notes used to represent interface elements, textual narrative descriptions of things like domain information and scenarios, task analysis models, user descriptions and paper-based prototypes. One of the problems we face when trying to capture UCD processes within a formal software engineering context is that the artefacts produced are intentionally informal. They aim to encourage users to feel able to participate and change the design, and lo-fidelity artefacts, such as paper prototypes for example, have been

may be that some, or all, of these tools could be adapted or extended to support the sort of work we are currently doing. However, as our focus is currently on existing commonly used design techniques and artefacts, we have deliberately chosen not to consider such tools here. Instead we focus on lo-fidelity artefacts like paper-based prototypes.

Integration of different languages and models within formal methods is not unusual (indeed this activity has at least one whole conference devoted to it, namely IFM [13]). The central idea is to use the differing features and strengths of the different methods as appropriate. Sometimes it is enough to just use different formalisms to specify different parts or different properties of the system, but the best effect is seen when methods are fully integrated so there are formal links between them allowing for a fully rigorous development.

Using formal methods in GUI design is not a new idea, and many different approaches to this have been taken. These may be along the lines of formalising particular parts of the design process, such as task analysis [19], or describing GUIs in a formal manner [10], or deriving implementations from formal models [11],[7]. However, what we are trying to do is to look at an existing design methodology, i.e. user-centred design, examine the types of processes and artefacts that are used and find ways of incorporating these into a formal process.

The presentation model is used to formally capture the meaning of an informal design artefact such as a scenario, storyboard or prototype. It is a deliberately simple model because the informal artefacts it describes are themselves simple and easy to understand. This is important as it makes it easier to encourage others to adopt and use the model. When we talk about the meaning of a design artefact we are talking about what the UI described by the informal artefact is supposed to do,

When a designer shows a prototype to a user, there is a discussion about what the prototype will do when the parts shown are interacted with. This forms what we call the narrative of the prototype, the accompanying story which allows the user to understand how it will work and what the various parts do. This allows a simulated interaction to take place which enables the user and designer to evaluate the suitability of the proposed design. The presentation model is a formal model which describes an informal design artefact in terms of the widgets of the design and captures their meaning. It is deliberately abstract and high-level. The presentation model is not intended to replace the informal design artefact, rather it acts as a bridge between the meaning captured by the design and the formal design process

This model describes a UI with two components, p and q (where these may be dif- ferent windows, or different states of the UI). The entire UI (i.e. the combination of p and q ) is described by r and the : operator acts as a composition. p has two wid- gets, aCtrol and bCtrl , which are both ActionControls. The behaviours associated with aCtrl are eAction and fAction and for widget bCtrl the associated behaviour is dAction. q has one widget, cSel , which is a SValSelector with the behaviours eAction and fAction. Presentation model r , therefore, is the combination of all of the widgets of p and q and describes the total possible behaviours of the UI.

The following example is an adaptation of an example given by Calvery et al. in [5] and [4]. The example involves a home heating control system which is accessible via several different devices, namely a home-based, wall-mounted control panel, a web- server running on a standard PC, a PDA and a WAP-enabled mobile phone. The control system supports the monitoring and control of temperatures in a number of different rooms as well as overall adherence to ambient temperature levels. For the purposes of our example we use an amended version of the mobile phone application UI which allows us to illustrate our particular points.

Our first use for the presentation model is to enable us to include the design of the UI in our formal refinement process. We have previously given a detailed account of this process [3] and it is not our intention to repeat these details here. However we will give an outline of the process and direct the interested reader to [3].

An application may consist of numerous different screens and dialogues, so main- taining consistency throughout is not a trivial task. One of the things we can ensure, using the presentation model, is that controls which have the same function have the same name (so the user does not have to remember that in one part of the interface they use Quit to exit the interface and in another they use Close). Conversely we can also check, again using the model, that controls with the same name have the same function and this ensures that the user always knows what to expect when they encounter such a control.

The problem with trying to capture the idea of dynamic change of the UI via the presentation model is that that the model gives us a static view of the design. It describes a total environment given by the design (which we can consider to be all of the possibilities of that design), but the (deliberately) simple use of a triple for each widget does not hold enough information to extend its use to dynamic be- haviour. One possible solution to this would be to extend the model with additional information. However, we want to avoid making it so complex that it becomes a burden upon designers or formal practitioners to learn and use. We have decided to use another common formalism, in conjunction with the presentation model, in order to be able to prove these more dynamic properties. The formalism that we have chosen is that of Finite State Machines (FSM).

from the behaviour sets of the presentation models. In this way we can associate the UI functionality of parts of the design with the dynamic behaviour which makes available different parts of the interface to the user. We call the combination of presentation model and FSM in this way a presentation and interaction model (PIM).

Now, in order to show that a particular behaviour is reachable we first need to show that the part of the UI it is in (i.e. the component presentation model which includes this behaviour in its set of behaviours) is itself reachable in the FSM, and this can be shown using standard FSM methods.

