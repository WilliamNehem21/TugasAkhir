Instruction List (IL) is a simple typed assembly language commonly used in embedded control. There is little tool support for IL and, although defined in the IEC 61131-3 standard, there is no formal semantics. In this work we develop a formal operational semantics. Moreover, we present an abstract semantics, which allows approximative program simulation for a (possibly infinte) set of inputs in one simulation run. We also extended this framework to an abstract interpretation based analysis, which is implemented in our tool Homer. All these analyses can be carried out without knowledge of formal methods, which is typically not present in the IL community.

Programmable Logic Controllers (PLC) are widely used in automation control. They drive assembly lines, robots, and whole chemical plants. The standard IEC 61131-3 [14] defines a number of programming languages for PLCs. These languages range from high-level, graphical ones with powerful structuring pos- sibilities to low level languages close to circuit design or machine language. One of the low level languages is Instruction List (IL).

little structuring possibilities, in fact, goto-like jumps are the only ones. This makes IL programs difficult to read and difficult to manually analyze. Fur- thermore, there are hardly any tools available for algorithmic analyses of IL programs. The situation is even worsened by the fact that the standard itself does not provide a formal semantics.

When considering analysis techniques for IL programs it is important to have in mind the users of these techniques. PLCs are foremost programmed by control engineers more familiar with technical design of the driven plant than, e.g., formal methods. Hence, any proposed analysis should reflect this, i.e., should be able to be carried mostly automatically or reside in the known context.

The developed operational semantics allows to simulate the code for given inputs. A complete coverage is, however, tedious or even impossible. In this section we propose two solutions: One is an abstract simulation of the code. This means, we estimate the range of variables in a simulation run not only for single inputs but (possibly infinite) sets of inputs. Second, we explain how to extend this framework to abstract interpretation which gives us an approximation for all runs at all program locations.

To replace the concrete semantics with an abstract one, we have to replace the concrete domain with the mentioned abstract domain and define for any concrete operation a corresponding abstract semantic operations. Based on this we define the abstract semantics allowing for abstract simulation. And by enforcing safe termination of the simulation, we extend it to the standard abstract interpretation.

While abstract simulation is a way to execute IL programs for set of inputs and tracks program behavior for certain paths, abstract interpretation approx- imates the program behavior for all possible inputs and all possible paths. Moreover, unlike abstract simulation it ensures termination of the analysis process. In order to do so, acceleration techniques are used to speed-up the convergence of the analysis. These accelerations provided a safe approxima- tion of the program behavior, however, they often come with an additional loss of precision, i.e., can lead to further over-approximation.

[2], and [22]. Our approach is based on these investigations, it uses the abstract semantics as introduced in the previous section and just adds an acceleration as described in [13]. Due to space limitations we do not go into detail here.

This is a simple example without any over-approximation. However, if we increment x by 2 instead of 1 within the loop, our analysis would not be able to reveal that even numbers never occur. Further over-approximations occur when the jump condition cannot be used to give an upper approximation of the variable values.

We implemented the abstract interpretation framework for IL into a prototype tool called Homer. The abstract domains are as introduced and the used abstract semantics is as described before. In this section we present a number of generic properties that can be checked for IL programs. If not otherwise mentioned the checking is done on the abstract interpretation results.

Code is unreachable if there is no program execution ever executing it. In terms of IL language, this means, there are (conditional) jumps that prevent the control flow reaching every line of code and instead always skip some lines. Hence, these code fragments will never be executed.

The prototype is implemented in OCaml [5] and primarily aims at testing the proposed methods and analyses. It is not optimized for speed, and memory consumption is high, since every program location still stores the information of all abstract values at that location. However, a case study of roughly 2000 lines of code with about 100 variables takes nearly 20 seconds to be analyzed, which is promising when having the potential for speed-up in mind.

In this work we presented a formal operational semantics for IL programs. Moreover, we developed an abstract counterpart of this semantics which al- lows approximating program simulation for possibly infinite sets of inputs within one simulation run. We also extended this framework to an abstract interpretation analysis, as implemented in our tool Homer. The advantage of the proposed methods is that they can be used by PLC programmers not familiar with formal methods.

One direction for future work is to develop a tool for guided abstract simulation. Up to now we explore path non-deterministicly whenever there is more than one branching possibility. However, often it is of interest in following particular paths and exploiting jump conditions to constrain variable values for these paths.

Moreover, more work should be put in exploring different abstract domains for the analysis of IL code. The interval based abstraction proposed and im- plemented right now is good for range checking, but lacks precision for other common error such as division by zero. Moreover, the current abstraction does not take any relations between different variables into account. On the other hand, structures such as octagons or, more general, polyhedra [8] ap- proximate the concrete space incorporating relationships between variables.

