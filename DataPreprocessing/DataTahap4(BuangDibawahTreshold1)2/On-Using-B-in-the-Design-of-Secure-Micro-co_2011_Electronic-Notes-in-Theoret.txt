The stepwise formal development of safety critical software is now a well established engineering practice, noticeably in railway systems. However, it has not been applied as successfully to hardware development, where formal methods are mainly used for verification and gate level transformations and optimizations. In this paper, we report our recent experience in the stepwise formal development of a real macro-cell, that opens the way to the design of synchronous digital circuits with zero functional bugs. We propose a development flow suited for obtaining proven correct-by-construction circuits that further possess additional robustness properties desirable for secure chips. The reported work is prospective and is meant to show the feasibility of such a technique for high confidence trustful devices.

Writing test programs, running and analysing simulations, represent a prepon- derant part of this first development effort. The verification plan is solely built upon expertise and experience of specialized designers. Coverage of a verification campaign is measured by using some specialized tools, but functional specification coverage is at best mainly a matter of peer review: the only available reference is the natural language description of the function to be designed.

The simple idea was to adapt this B formal method to the development of our digital circuits. Indeed, microelectronics development tools already resort to many formal methods, but they are used mainly behind scenes, i.e. without designer awareness of their presence, and more importantly, their application only starts after the source code has been written. These methods are used for verification purpose and for various transformations in the long path leading from a Register Transfer Level (RTL) representation to a final placed and routed net list. Nevertheless, the more expensive functional errors are often introduced before the first line of code is even written. Usually they stem from the functional, the high-level design, or

even the detailed design specifications. As already mentioned, no verification tool is available for these natural language representations. Only a thorough peer review can possibly filter out these error seeds before they blossom into forests of erroneous behaviours, once embedded into the circuit.

Next refinement introduces the automaton that drives some exceptions in case of interrupts and on reset conditions of the host micro-controller. Only the state of the automaton and the transitions performed by the concerned events are kept in the next refinement. This is a quite elegant way to constraint the system behaviour for the rest of the development.

type. It could have been done together with the first refinement, but it would have added useless complexity to the automaton definition. This refinement introduces also a local stack to manage clearance levels in case of nested interrupts. Matrices rb1 and re1 get totally defined at this stage using the top of stack (empty or full) and the state of the automaton introduced in the previous refinement.

We introduced the main concept of the case study, the segment, i.e. an accessible address window, through the sole use of sets (given set SEs). Firstly introduced as a set of addresses (sa7 ), see example 3.2, they became sets of address ranges specified with a start and an end address. They were finally refined to be defined by start and end address registers.

Let us mention our use of constructive set expressions to pave the way towards a VHDL translation that can be synthesized. For instance, letting ms7 be the set of mapped segments, we can build the set ea7 of segments associated to a given address a0 with the expression shown in example 3.3.

relation that fails, in general, to preserve security properties such as confidentiality or integrity. This is by no means a serious drawback to the proposed flow. We strongly believe that alternative specific formal methods, and their associated tool- sets, should be used to tackle those properties at each development step. Although the following publications are not very recent, we can refer the reader to [5] for a practical approach to the verification of cryptographic protocols, to [10,8] for an original organization based access control model and its application to network secu- rity policies, to [22] for a survey on enforcing information-flow policies like integrity or confidentiality through static program analysis techniques, or to [20] for a non- interference formulation that can be preserved under process algebra refinement, amongst many other relevant work devoted to security properties.

The critical reader must have noticed that the exhibited invariant is slightly too strong as it only holds for undisrupted circuits. Indeed, as long as none of the state variables, i.e. neither q1 nor q2, gets modified in an uncontrolled way, we can prove that the alarm is never set. This refinement stage allows to prove exactly that.

The design starts with the description of an algorithm, usually a standard one [16,15,21]. For some of these algorithms, desirable security properties are known to significantly thwart power analysis success. For instance, in the case of a sym- metric key algorithm [16,15], property 5.1 has to be satisfied in the final layout of the circuit.

This may seem trivial to most of us, but performing the verification on the real detailed algorithm unveiled quite tricky situations that only a very thorough analysis could have discovered. Furthermore, we were able to suggest an improvement to the detailed algorithm. We convinced the designers to implement it by showing that with the proposed modification, ProB could complete the exhaustive verification of all the properties.

