Attribute grammar specification languages, like many domain specific languages, offer significant advantages to their users, such as high-level declarative constructs and domain-specific analyses. Despite these advan- tages, attribute grammars are often not adopted to the degree that their proponents envision. One practical obstacle to their adoption is a perceived lack of both domain-specific and general purpose language features needed to address the many different aspects of a problem. Here we describe Silver, an extensible attribute grammar specification language, and show how it can be extended with general purpose features such as pattern matching and domain specific features such as collection attributes and constructs for supporting data-flow analysis of imperative programs. The result is an attribute grammar specification language with a rich set of language features. Silver is implemented in itself by a Silver attribute grammar and utilizes forwarding to implement the extensions in a cost-effective manner.

Domain specific languages offer several significant advantages to their users over general purpose programming languages [5]. They allow problem solutions to be expressed using the notational constructs of the problem domain. These languages are often declarative in nature, resulting in concise programs. Also, important opti- mizations and analysis are often only feasible when the domain specific information is directly represented in the language constructs of the DSL. But, domain spe- cific languages have some disadvantages as well. Van Deursen et. al. [5, page 27] describe several and we quote three that pose particular challenges to DSL imple- menters here:

In the domain of language analysis and translation, attribute grammar specifica- tion languages offer many advantages but are also not as widely used as they might be. Attribute grammars (AG) were developed almost 40 years ago by Knuth [10] and there has been a steady stream of research in such systems since then, see [17,7,2] to cite just a very few. The continued interest is due to the fact that they provide a high-level, declarative means for solving a wide variety of language analysis and translation problems. Evidence of this can be seen in their use in implementing language processing tools for full-fledged popular languages such as Java 1.4 [6,7] and Icon [9].

Our experience using attribute grammars is primarily with our own system, Silver. We have developed an attribute grammar specification language called Silver to incorporate an extension to AGs called forwarding [14] that has proven useful in the specification of extensible programming and modeling/specification languages. We have used Silver to specify an extensible implementation of Java 1.4 [16] and several modular language extensions. One embeds SQL into Java and performs static type-checking of the embedded SQL queries [13]. We have also built an extensible version of (a substantial subset of) the synchronous language Lustre (used in embedded safety-critical systems) and various language extensions [8].

easily composed to create domain-adapted general purpose languages. We thus decided to implement Silver as an extensible language in order to mitigate some these challenges. Through a series of boot-strapping steps we were able to implement Silver as an AG specification written in Silver.

store (undecorated) syntax trees. This is useful for creating new trees in building, for example, optimized versions of a program or for constructing data structures such as representations of types used for type-checking. To support interesting language extensions, the core host Silver language must be Turing complete and thus higher- order attributes are essential.  The core language also includes forwarding [14], a feature we introduced that allows productions to implicitly define the value of attributes by translation. aspect productions allow new attributes to be defined for an existing production typically defined in a different grammar or file. Core Silver also has a module system used in composing host language and extension specifications. Section 2.1 discusses core Silver.

Several general purpose and domain-specific language extensions have been made to core Silver to create the full features version. These include pattern matching on trees (by production), type-safe polymorphic lists, collection attributes [2], and con- venience constructs such as auto-copy inherited attributes. Additional extensions provide constructs for building control flow graphs for imperative programs and per- forming dataflow analysis via model checking [15]. These extensions are discussed in Section 2.2 and 3. We will not provide formal definitions of attribute gram- mars [10], higher-order attributes [17], forwarding [14], or collection attributes [2] but will instead describe their functionality through examples. Formal descriptions can be found in the cited papers.

Next a synthesized attribute c of type String is declared. It contains the trans- lation of SimpleC constructs to C and decorates the non-terminals specified in the occurs on clause. The attribute typerep is a higher-order attribute that holds trees whose root is a non-terminal of type TRep. The type of an Expr is represented by these trees.

Following are a few sample production declarations. Productions with the concrete modifier are used to generate the input specification to a parser generator. Different extensions to Silver integrate different parser and scanner generators into Silver. These extensions provide translations of concrete productions and termi- nal declarations to the input language of a parser/scanner generator. Productions marked as abstract or aspect are not used in the parser specification. The first production is named program, its left hand side non-terminal is Prog and is named

tribute definitions are given between the curly braces ({ and }). Here, the attribute c on p is defined as indicated. Definitions of other attributes that use features added as language extensions such lists ([...]) and collections (:=) are also shown but de- scribed below in Section 2.2. Attributes can be defined on concrete and abstract

productions; for SimpleC we evaluate attributes on the concrete syntax tree since it is a simple language. For more complex languages, one may separate the concrete and abstract syntax so that the only attributes on the concrete productions are used to construct the AST over which attributes are evaluated. Productions for conjunc- tion and negation follow. These define the higher order attribute typerep to be the tree constructed by the abstract production booleanType to indicate that they are boolean expressions. Following are the abstract productions used to construct different type representations.

We focus on the global transformation that adds attribute definitions for prodName and childList to productions in the object grammar. The transfor- mations that add the declarations and occurs-on declarations are done in a similar manner. These transformation is additive and do not impede or conflict with other additive global transformations since it only adds declarations and attribute defini- tions to productions. (It is the responsibility of the developer of the global trans- formation to ensure that it can in fact be composed with other extensions. Name clashes are the primary concern but these are easily handled as the implementation of Silver uses of fully-qualified names based on unique module names.)

This specification composes the attribute grammars that are imported and composes their concrete specifications (when imported with the with syntax clause). The semantics of import are as if the imported extension (but not what it imports) was textually included directly in the importing file. The hiding clause is a mechanism for excluding certain items from being imported into a grammar specification. This is used above to ensure that silver:full is type-safe by not importing into the grammar the concrete syntax of the type-unsafe constructs AnyType and cast.

The main production plays a role that is similar to main in C and takes the command line arguments as its String-type parameter. This production forwards to the silver driver production that controls compilation of Silver grammars. It passes this its arguments and the parser that recognizes the language composed of the concrete syntax specifications that are imported.

1.4 [16], a subset of Lustre [8], and Silver itself. Different full featured versions of Silver are implemented as the composition of a core Silver language and various gen- eral purpose and domain-specific language extensions. It supports the specification of composable local and additive global transformations. Higher-order attributes, forwarding, and collection attributes have not previously been available in a single AG system and were initially developed by different research groups. While none of these features is themselves new, a framework in which one can easily combine dif- ferent general purpose and domain specific features is. These general-purpose and domain-specific additions to core Silver reflect the need for language evolution. In Silver, the evolution is achieved by adding these new features as modular extensions to the host language, core Silver.

