Lime is a middleware communication infrastructure for mobile computation that addresses both physical mobility of devices as well as logical mobility of software components by providing a rich set of primitives for local and remote operations. The original Lime speci cation is surprisingly complex and tricky to implement. In this paper, we start by deconstructing the Lime model to identify its core compo- nents. In a second step we attempt to reconstruct a simpler model, which we call CoreLime, that scales better to large and rapidly changing con gurations of agents and hosts.

Traditional computational models are based on the assumption that devices as well as software components are deployed before being used and that once de- ployed con gurations are static. In the emerging eld of wireless computing, in which PDAs or Java-enabled phones can establish ad hoc network connections and application software may control its own deployment, these assumptions do not hold. Instead new computational models are needed to ease the task of developing application codes in such uid environments.

In the last few years a number of theoretical models, from Ambients [7] to Seal [16] have been put forward as foundational models for mobile com- putation. Each of these models centers around some concept of migratory computation, or mobile agent, which is used to abstract both physical and logical mobility. In practice, dealing with mobile hosts is much more challeng- ing than with software mobility. Thus mobile agent systems, such as Aglets [11], JavaSeal [4] and many others, mainly focus on providing a host execution

environment along with support for logical mobility. Support for physical mo- bility is, as of this writing, mostly lacking and the communication primitives provided in these systems are left overs from traditional static computational models. The latter is arguably the largest obstacle to success of mobile agent technologies.

Designing communication mechanisms for mobile environments is a chal- lenging task. Mobile systems have markedly di erent characteristics from traditional distributed or concurrent systems. Communication in a mobile system is transient and opportunistic, applications need to take advantage of available resources without assuming their continued connectivity, but con- sidering the possibility of sudden interruptions. Communication in mobile systems is also anonymous, relying on the services being o ered and not on identity of the entity providing those services.

This paper documents our attempts to understand Lime and to provide a scalable implementation of its key ideas. Our rst contribution is a formal- ization of the core concepts of the model as a process calculus. This gives us well understood starting point for reasoning about Lime programs as well as a speci cation for implementers. Our second contribution is the de nition of CoreLime, a simple and scalable basic calculus. This yields a variant of Lime without some of its potentially costly features which we intend as a basis for building next generation Lime implementations.

This section introduces the Lime middleware communication infrastructure for mobile environments. Lime was speci ed informally in a 1999 paper [15] and large parts of the model were formalized in Mobile Unity notation in Murphy's thesis [13]. Furthermore, a Java implementation is available from www.sourceforge.org. When necessary we will di erentiate between the Lime implementation (denoted Limeimp ) and the Lime speci cation (denoted Limespec). Examples will be written both in Java syntax and the Lime calculus of Section 3.

Lime lets agents perform operations on tuple spaces of other agents by the means of location parameters. Location parameters restrict the scope of tuple space operations. For the out operation, a location parameter can be used to specify the destination agent of a tuple. Its semantics is that Lime will deliver the tuple to the destination as soon as the destination agent becomes reachable. While the destination agent is not reachable tuples remain under the ownership of their creator. One way to represent this ownership information is to think of each tuple as having two additional elds current and final such that current denotes the current owner of the tuple and final its destination. A small producer/consumer example with two agents exchanging data over a common space is shown next:

On top of the standard Linda primitives, Lime introduces the concept of reactions. A reaction can be viewed as a triple (t, s, p) consisting of a tuple space t, a template s and a code fragment p. The semantics of a reaction is that whenever a tuple matching s is deposited in t, the code fragment p should be run. The main di erence between the blocking rd and reactions is that all

matching reactions are guaranteed to be run when a matching tuple is found. Furthermore, Lime speci es that reactions are atomic; in other words while p executes, no other tuples space operation may be processed. Atomicity ensures that reactions always execute in a consistent state. The code of a reaction is allowed to perform tuple space operations and may thus trigger other reactions. Lime executes reactions until no more reactions are enabled. To avoid deadlocks reactions are not allowed to issue blocking tuple space operations such as in or rd. By default, reactions are red once, but it is also possible to specify that a reaction be red once per tuple. Continuing the previous example, the producer agent inserts new tuples only when receiving an acknowledgment from the receiver.

By default, the tuple spaces of di erent agents are disjoint and agents can not use tuple spaces to communicate. The key innovation in Lime is to support a exible form of tuple space sharing referred to as transient sharing. An agent can declare that some of its tuple spaces are shared. The Lime infrastructure will then look for other spaces, belonging to di erent agents, with the same name and silently merge them into a single apparently seamless space. The sharing remains in e ect as long as the agents are co-located.

The last and most ambitious part of Lime is the support for federated spaces. A federated space is a transiently shared tuple space that spans several hosts. Federations arise as a result of hosts issuing the engage command. Hosts can leave a federation by issuing an explicit disengage command. The semantics of Lime operations are not a ected by federations, it is up to the implementation to provide the same guarantees as in the single host case. This complicates the implementation and imposes some constraints on the use of Lime primitives. In particular, Limeimp limits strong reactions to a single host and introduces weak reactions. A weak reaction may be scoped over multiple hosts, but it adds an asynchronous step between identi cation of the tuple and execution of the reaction code.

agent is running. In this model all agent tuple spaces are modeled by a single global tuple space T . Additional information attached to each tuple will let us distinguish ownership and current location of tuples. Similar to Limespec, agents can have multiple private tuple spaces. In the Lime calculus these are represented by disjoint views over the global tuple space T . These private tuple spaces are identi ed by names, and any two private tuple spaces with the same name are considered to be transiently shared. The names used over several hosts in the system are recorded in the set X, ensuring their unicity.

Processes are ranged by P and Q. The rst four process primitives (in- ert process, parallel composition, replication and name creation) follow the asynchronous -calculus. The inert process 0 has no behavior. Parallel com- position of processes P j Q denotes two processes executing in parallel. Repli- cation of processes ! P denotes an unbounded number of copies of P executing in parallel. The restriction operator ( x) P generates a fresh name x lexically scoped in process P . In our model, names are used to denote agents, hosts, tuple spaces, as well as primitive values.

Output (out ) is asynchronous in Lime, and thus has no continuation. Each output tuple hv a si is rst transformed into a Lime value tuple, i.e. hv a a0 si, and added to the global space. The Lime value tuple format has two agents names, a is the current agent that \owns" the tuple and a0 is the destination agent. We say that a tuple for which a 6= a0 is misplaced. This can occur only if the destination is not connected 3 . The auxiliary function mkt makes a new Lime value tuple. If it can not locate the destination the tuple will be misplaced otherwise the tuple will be delivered.

The second set of three rewrite rules de nes the semantics of reactions. In the Lime calculus, reactions are stored in the tuple space, as distinguished tuples hidden from normal user code. Thus to evaluate a reaction, we need only have a tuple space as it contains both normal data and the reactions de ned over that data. The rules are of the form

where T is a tuple space and S is the multiset of tuples that are candidates to trigger a reaction. All candidates in S will be examined. When all reactions have completed executing, the new tuple space T 0 is returned. In the simplest case, if there are no candidates the global tuple space is left as is:

reaction is removed from the global tuple space. A dummy agent is created under a fresh name to run the reaction's body. Once the process terminates, the resulting tuple space T 00 is used to recursively look for other reactions that are ready to re. We assume that move commands may not occur in the body of the reaction. The rule is:

In Limeimp hosts joining a federation must be brought to a consistent state. This boils down to making sure that all of the weak reactions that hold over the federation be enforced for the new host. For each weak reaction, a strong reaction must be registered on the incoming host. The current engagement procedure is atomic which is awkward as it means that new hosts must be serialized and that other tuple operations are blocked while they are being added to the con guration.

The semantics of the Lime calculus speci es that moves are atomic. There is no clear statement about moves in Limespec. Making moves atomic has pleasant properties, for instance we are guaranteed that in the following con guration the non-blocking inp will succeed.

because regardless of scheduling, the inp will always be run in an environment where agent a is connected, either from host h or host h0. In practice, this is of course not the case as there will be some time when a is in transit between hosts. Thus, in Lime implementations, the inp in the above program may not succeed. A simple way to model this behavior is translate every move into a two-step operation, the agent rst moves to a distinguished host which is disconnected, in the Lime sense, from the every other host and then, in a second step, moves to its destination.

where agent b is assumed to be remote. If the input operation is selected rst, should the implementation wait for the input to complete before allowing the move. Since this is a blocking in, the wait time is unbounded. On the other hand if it allows the agent to move then it must be ready to handle the additional complexity of messages sent from b's host while a is in transit.

and semantics of most Lime operations is retained, the main restriction is that operations are scoped over the local host only. The second part of our research will be to de ne semantics for the remote operations provided in Lime. For these we plan to give a translation to CoreLime using agent mobility to specify remote e ects. In this paper, we present CoreLime and hint at the translation.

We are currently working on an implementation of CoreLime in Java. The interface of Limeimp will be mostly retained with some additional constraints to enforce the local semantics of CoreLime. We are using the SecOS imple- mentation of [3] as an underlying tuple space engine.

The operational semantics presented in this paper resemble the ambient calcu- lus of Cardelli and Gordon [7]. However, in the ambient calculus the primitive used for reading messages is not based on pattern matching and thus com- municating processes must know each other's identity. Moreover, processes cannot transparently read messages located in sibling ambients.

As future work we plan to add security mechanisms to CoreLime. Since in a mobile environment communication is anonymous, entities do not trust each other. In a real setting there are situations where features like secure channels, the possibility to authenticate communicating parties and to restrict access to resources are desirable. We will add capabilities to control access and security lters to authenticate and restrict rights. Capabilities will provide granularity at the level of tuple spaces, by encapsulating secret tuple space names. Legitimate users will not be given the right to distribute them, and the addition of rights will be forbidden. Security lters will be wrappers around

[4] C. Bryce and J. Vitek. The JavaSeal Mobile Agent Kernel. In D. Milojevic, editor, Proceedings of the 1st International Symposium on Agent Systems and Applications, Third International Symposium on Mobile Agents (ASAMA'99), pages 176{189, Palm Springs, May 9{13, 1999. ACM Press.

