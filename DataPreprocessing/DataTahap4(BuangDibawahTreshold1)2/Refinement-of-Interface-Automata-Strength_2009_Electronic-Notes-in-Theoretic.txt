composition of two compatible interfaces can be used together in at least one design thanks to the non-input-enabled property, which means that at every state, some input actions may not be enabled contrarily to I/O automata and CSP [12]. There interaction is made by synchronizing shared input an output actions, while the internal actions of concurrent automata are interleaved asynchronously. Automatic compatibility verification and refinement checking can be made. The formalism of interface automata has been applied in several cases as a formal model to specify the interface behaviors of software components [4,9]. A path often taken in the lit- erature is to check the interface compatibility of components at the semantic level of operations. In our previous work [6], we improve the model of interface automata to ensure a more reliable verification of components interoperability by taking into account the semantics of actions. The proposed method enrich transitions of inter- face automata by pre and post-conditions of actions which are atomic prepositions over a set of variables. The scope of our previous work do not cover the totality of interface automata by treating refinement. This paper is essentially written to expose the refinement our extended interface automata.

The role of refinement relation is to formalize the relationship between the ab- stract and the concrete versions of the same component. For I/O automata, refine- ment is usually defined as trace containment or simulation [10]; this ensures that the output behaviors of the refined automaton are behaviors that are allowed by the abstract one. Such definitions of refinement do not hold for non-input-enabled setting, such as interface automata: if the set of legal inputs of the refined interface is a subset of the inputs allowed by the abstract one, then the refined interface could be used in fewer environments than the interface abstraction. While a new approach is adapted to compose interface automata, an alternating approach is used to refine them.

Alternating refinement simulation is defined to study refinement between al- ternating transition systems [13]. They are introduced as a general model for component-based systems which allow the study of adversarial relationships be- tween individual system components. Unlike in labeled transition systems where each transition represents a possible step of the system, each transition of an alter- nating transition system corresponds to a possible move in a game between different components. The proposed refinement of interface automata is based on this ap- proach by viewing them as alternating transition systems. Explicitly, a refinement of an interface automata expresses that the refined component can offer more ser- vices (input actions) and fewer service demands (output actions). In this article, we adapt the alternating refinement simulation of interface automata by taking into

account the relation between pre and post-conditions among the input and output transitions of an automaton and their correspondent refinements. In other word, a refined version uses more variables to formulate pre and post-conditions of the refined and added input actions. We suppose that the pre and post-conditions of the remaining output actions do not change. Intuitively, while the offered services are local in the component, we have to strengthen their semantics constraints if which is not the case for demanded services because the component ignore if the demanded service was refined or not in the environment.

I/O automata have been introduced by Nancy A.Lynch and Mark.Tutle [12] as labeled transition systems. Commonly, they are used to model distributed and concurrent systems. Labels of I/O automata fall into three categories of actions: input, output, and hidden actions where input actions are enabled at every state of an automaton.

Our approach presented in [6] extends interface automata by considering the action semantics to ensure a more reliable verification of component interoperability. In [1], the checking of the component compatibility uses only action signatures, which are not sufficient to decide if two interfaces are compatible or not. Our contribution uses pre and post-conditions over a set of variables to annotate the actions of in- terface automata. These constraints on actions show their semantic effects which can be useful to strengthen the compatibility checking. The proposed algorithm to verify the composition and the compatibility between interface automata takes into account of pre and post-conditions of actions.

The composition condition is the same as the preexisting approach. The compo- sition of two automata may take effect only if their actions are disjoint, except shared input and output actions between them. When we compose them, shared actions are synchronized and all the others are interleaved asynchronously.

The verification steps in this approach are the same as [1] except that we consider the action semantics. The proposed algorithm [6] verify the compatibility of two interface automata by checking if their composition is nonempty. We mention that our approach does not increase the linear complexity of the previous proposed one. Finally, we add that the associative criterion of the composition operator  between three automata is undefined when some of them are not composable.

The aim of the refinement relation is to concretize an abstract version of a compo- nent interface. It permits to move a component or an interface from a high-level understanding to a more concrete specification. Contrarily to traditional types of I/O automata, refinement is defined as trace containment, the refinement of in- terface automata is based on an alternating refinement relation in the spirit of simulation. A more concrete version of an interface have to be used in stronger environments than its abstraction. In other words, the refinement of an interface must allow more legal inputs, and fewer outputs than the abstract version.

Defining pre and post-conditions of actions of the refined interface must obey to some variant constraints. On the one hand, when we refine a component, we add to their provided services (input actions) some other new services by defining new signatures of actions and on the other hand, we strengthen their former operations by adding some other constraints on their pre and post-conditions. We take into account the principle that, in the refined interface, an old input action must have a fewer precondition than the precondition of the same corresponding action in the abstract one and its post-condition must be stronger than the corresponding post-condition in the abstraction.

We illustrate our works by applying refinement to the component vehicle of the CyCab car component-based system studied in [6]. The CyCab [7] car is a new electrical means of transportation conceived essentially for free-standing transport services. It is totally manipulated by a computer system and it can be driven automatically according to many modes.

