Beneath the algorithm of DNA lies the mechanism of biomolecular computing, the DNA self-assembly. It serves as the underlying driver to achieve various DNA applications. Eric Winfree and his colleagues have conducted a bundle of research on this subject, and [17,18] are some of their results.

In fact, the two aspects of the study between biomolecular disciplines and Com- puter Science are not clearly cut, blurred by mutual benefiting. For example, the advantage of high parallelism in DNA computing offers its efficiency in aid to solve hard problems such as NPC problems, and reversely, the theories in Computer Sci- ence, especially those mathematical ones based on computer automation can be used to boost the analysis and comprehension of a variety of biological processes, particularly on the molecular level, of which the major form is to model biological procedures with formal methods to verify and predict certain properties or events. These two aspects actually interact with each other in several ways, prompting both to develop further on the whole. Below we try to do something related to the scenario described above.

Albeit the basic thought is analogous to some other algorithms, the algorithm here is aimed at the efficiency in building a DNA-driving device, so it has to save more time than space. Generally speaking, it is using brute force, that is, prepares all the possible results during the bit-computing and combines them to get a final result. From theoretical view, the time efficiency is satisfactory, linear in bio-steps 4 . And the number of DNA oligonucleotides needed is also linear in the number of the maximum bits of the two numbers.

volves in vitro environment a number of techniques, each of which can contribute to the error rate, for example during the connecting and read-out, and this is discussed more in [12]. This renders the algorithm hard to scale up. And another challenge is that the computation procedure is badly continual, that is, it is nearly impossi- ble to add three numbers by doing binary addition twice, and the experimenting complexity makes the first computing leave out a result incompatible for another computing. These disadvantages, among others, make the DNA addition algorithm described here a bit far from application in DNA computers(in fact other algorithm faces similar challenges).

Activation. Consider the two sites of each protein. The connecting on the left site will activate the right one, switching it to be visible for future connection. We will give some examples. For example, the two rules below belong to this group. Note x is an edge, so is it in the other examples.

Connection. After the right site of a protein is activated, it can react with a specific protein on its left site to form another connection. This proceeds with the steps of the addition. For example, the two rules below belong to this group.

Kuttler, C., J. Niehren and R. Blossey. Gene Regulation in the Pi Calculus: Simulating Cooperativity at the Lambda Switch. Transactions on Computational Systems Biology, Special Issue on BioConcur 2004, and Lecture Notes in Computer Science, Lecture Notes in Bioinformatics, Springer Verlag, 2005.

