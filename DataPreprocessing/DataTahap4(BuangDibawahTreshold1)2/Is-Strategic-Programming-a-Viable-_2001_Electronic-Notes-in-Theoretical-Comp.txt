In Algol 60 call-by-name parameters of procedures provided a deviation from the standard innermost evaluation order. In the case of a call-by-value parameter of a procedure P , the value of the actual parameter is computed once and used throughout the execution of the body of P . Note that the actual parameter may be a complicated expression. In the case of call-by- name, the value of the formal parameter is determined by evaluating the value of the actual parameter expression at each occurrence in P . This is very much like outermost evaluation. However, since variables occurring in the actual parameter expression may be changed between two occurrences, successive values need not be the same. A typical application of call-by- name in Algol 60 is the successive computation of an expression for di erent parameter values. This technique, known as Jensen's device, has been used with success in numeric applications.

It is interesting to observe that these backtracking-based execution models have been superseded by more limited, declarative, mechanisms. In the case of string matching, declarative syntax de nitions and implementations based on parser generation have taken over. In the case of logical programming, more controlled paradigms are being tried.

In the case of theorem proving axioms and proof rules are given and the problem is to prove or refute a potential theorem. The order in which proof rules are being applied is an essential part of the problem solution and it is very natural to express this order in the form of a strategy (also known as \tactic"). This is relevant for automatic theorem proving (the strategies guide the prover) as well as for interactive theorem proving (the strategy records decisions taken as a result of user interaction). It is also true that an individual proof step may constitute a complex computation.

In the case of programming-in-the-large the problem is how to combine pro- gram components to form a complete application. This problem can be ap- proached from a static as well as from a dynamic point of view. In the former case, static import relations, parameter bindings and the like have to be con- sidered. In the latter case, the dynamic interaction of components is to be considered. This is the realm of so-called coordination languages where some form of concurrent calculus ( -calculus, ACP, and others) is used to describe the protocol between the cooperating components. This application area has precisely the characteristics mentioned before:

