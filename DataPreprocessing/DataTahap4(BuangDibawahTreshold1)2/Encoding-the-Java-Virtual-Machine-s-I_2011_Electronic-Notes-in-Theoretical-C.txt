The development of programs that parse and analyze Java Bytecode [9] has a long history and new programs are still developed [2,3,4,7,13]. When developing such tools, however, a lot of effort is spent to develop a parser for the bytecode and for (re-)developing standard control- and data-flow analyses which calculate, e.g., the control-flow graph or the data-dependency graph.

OPAL SPL does not have a hard-coded type hierarchy. Instead, each specifica- tion written in SPL contains a description of the type system used by the bytecode language being described. The only restriction is that all types have to be arranged in a single, strict hierarchy.

In OPAL SPL, the stack is modeled as a list of operands, not as a list of slots as discussed in the JVM specification. While the effect of an instruction such as dup2 is more easily expressed in terms of stack slots, the vast majority of instructions naturally refers to operands. In particular, the decision to base the stack model on operands rather than slots avoids explicit modeling of the higher and lower halves of category-2-values, e.g., the high and low word of a 64 bit long operand.

Based on the specification, we have developed two generators which are both implemented using XSLT. The first XSLT transformation generates the classes to represent all instructions and is 350 lines long. Each generated class represents an instruction as a Java object and offers the functionality to get an XML and a Prolog representation of the concrete instance of an instruction. The second XSLT transformation generates the parser for a code array which creates the instance of the instruction classes on the fly. This transformation is another 300 lines long. We compared this with the Bytecode Code Engineering Library (BCEL) [2] which uses a similar approach for representing and handling instructions. When compared to the instruction-related code of BCEL, the generator is between 15 and 20 times smaller.

Another advantage of the approach is that changes that affect all instructions are localized. For example, in case of the Prolog representation we tested several dif- ferent representations which often affected all instructions. Nevertheless, in general less than 40 lines of code of the generator needed to be changed.

