Automatic differentiation is a technique for the rule-based transformation of a subprogram that computes some mathematical function into a subprogram that computes the derivatives of that function. Automatic differentiation algorithms are typically expressed as operating on a weighted term graph called a linearized computational graph. Constructing this weighted term graph for imperative programming languages such as C/C++ and Fortran introduces several challenges. Alias and definition-use information is needed to construct term graphs for individual statements and then combine them into one graph for a collection of statements. Furthermore, the resulting weighted term graph must be represented in a language-independent fashion to enable the use of AD algorithms in tools for various languages. We describe the construction and representation of weighted term graphs for C/C++ and Fortran, as implemented in the ADIC 2.0 and

This paper represents a reinterpretation of existing work together with an expo- sition of implementation details relevant to the use of term graphs for imperative programming languages. The rest of the paper is organized as follows. The next section sketches the construction of weighted term graphs for imperative program- ming languages. Section 3 describes some of the static analyses used in automatic differentiation tools. Section 4 discusses a procedure for merging the term graphs for individual statements into larger term graphs. Section 5 describes an XML rep- resentation for term graphs. In Section 6, we speculate on how ideas from term graphs could benefit the automatic differentiation community (and vice versa). We conclude with a brief summary.

One of the most important analyses implemented in OpenAnalysis is alias analy- sis. Alias analysis is used to identify whether two inputs to a statement should share a vertex or be treated as separate variables. In addition, alias analysis is needed for other static analyses, including data-flow analyses such as reaching definitions. Reaching definitions is a static analysis used to determine which definitions of a vari- able can possibly reach a particular use of a variable. It can be used to construct the du- and ud-chains used in the flattening procedure described in Section 4.

While the precise flow of information cannot always be determined statically, one can often determine that certain variables, no matter what control path is taken, will never lie along the paths between the independent variables and the dependent variables of interest. Such variables are called passive and do not need to have their derivatives computed. Thus, these variables can be ignored in the construction of term graphs. The OpenAnalysis infrastructure implements an interprocedural data-flow analysis called activity analysis to identify the set of passive variables.

There are several possible advantages to interpreting automatic differentiation as a rewrite system for weighted term graphs. First, although linearized computational graphs are always acyclic, the introduction of cycles, following the example of cyclic term graphs, might facilitate the development of more sophisticated differentiation algorithms for code with loops and/or recursion. Currently, automatic differen- tiation tools use either the forward mode or reverse mode at scopes larger than basic blocks. It also seems likely that the transformation of a computational graph into a linearized computational graph can be recast as a graph rewrite system. Fi- nally, term graphs are the most natural way to express and reason about automatic differentiation of functional programming languages.

We have presented automatic differentiation as a rewrite system for weighted term graphs. The automatic differentiation rewrite rules guarantee termination at a unique, bipartite graph. We believe that this interpretation may lead to new al- gorithms for recursive functions and support the theoretical analysis of automatic differentiation algorithms. We have described an infrastructure for the static con- struction of term graphs from imperative programming languages and an XML representation for term graphs.

While we have focused on static techniques in this paper, our automatic differ- entiation tools often employ hybrid static-dynamic techniques. For example, the determination of whether a variable is active or passive can be deferred until run- time, at least for those variables where static analysis is inconclusive [9]. Future work will examine similar techniques for the situation where static alias analysis is ambiguous.

There is evidence to suggest that rewrite rules that introduce new vertices into a linearized computational graph may reduce the cost of computing derivatives. However, adding such rules to the rewrite system removes the guarantee of termi- nation. Because these new rules are a modified form of copying, we believe that the work of Ariola et al. [1] on bisimilarity in term graph rewriting may provide insight into efficient ways of computing derivatives under such a system. We also note that the NP-hardness proof of [13] relies on the addition of collapsing operations to the differentiation rewrite rules.

