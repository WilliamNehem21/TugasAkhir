a form general enough to cover all the examples in this paper. In some other cases, defining an appropriate data type and a coalgebra on it is less straightforward than above, while the method of proving unicity of solutions using bisimulations still works nicely. Example 4.1 in the next section illustrates this point.

Recursive step: tk+1 is generated from tk in the following way. We take the head and tail of tk and simplify them as described in the two steps below. During simplification, we are allowed to replace the head of any recursive variable x with a fresh object parameter dx and its tail with a fresh recursive variable x'. In other words, we postulate x = dx :: x'.

Similarly, when proving that the tails are similar, recursive variables in the term correspond to subterms that are similar either by assumption (the original recursive variables) or inductive hypothesis (the recursive variables x' introduced as tails of the original ones) or by the application of one of the derivation rules (the recursive variables replacing instances of previous terms). We are allowed to apply any of the previously constructed rules: this corresponds to substituting any instance of a previous term with a recursive variable. Also, we are allowed to replace tails of recursive variables with fresh variables because of the corresponding induction hypothesis. If the simplified term is just a variable, then we know that the tails can be proved similar. Otherwise we add a new rule stating exactly that the generalizations of the tails are similar.	2

