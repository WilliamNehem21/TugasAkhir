There are, however, well-known program transformation techniques which do address these issues. Of particular interest to this paper are the deforestation techniques introduced by Phil Wadler and the fold/unfold program transformation techniques introduced by Burstall and Darlington. These techniques are shadows of an underlying cut-elimination procedure and, as such, should be more generally recognized as proof techniques.

An obvious alternative starting point, in which the symmetry between in- duction and coinduction is given by duality , uses the categorical universal property associated with inductive (initial) and coinductive (final) datatypes. This is familiar to category theorists who would claim that this the funda- mental property expected of datatypes. The basic idea (see section 3) is that inductive (coinductive) datatypes are initial algebras (resp. final coalgebras) and as such have uniquely determined maps to all other algebras (resp. from all other coalgebras).

However, we should not loose sight of the fact that symmetry has been regained. Furthermore, these notions do seem to capture the fundamental properties of these structural types. Thus, any system we might choose to devise should, at a very minimum, satisfy the abstract categorical properties of initial and final datatypes.

In general, we shall not be punctilious about recording cuts as there is a significant notational overhead instead we will feel free to use the substituted (although often not derivable) term. However, we remark that the presence of a cut is often going to be an indication that something can be simplified. Notice also that we will feel free to use names of previously defined circular functions.

There is another important way in which a regenerated type variable differs from the datatype from which it originated: we do not allowed the construction (or destruction) rules to be applied to a regenerated variable. This is because such an application would reverse the regeneration process. However, we do allow a regenerated variable to have the circular proof rule of the datatype applied to it. It is thus possible to have multiple regenerations, that is for a regenerated variable to be itself regenerated.

We now have to show that we can simulate all the proofs of the circular proof system in the algebra based proof system. This is a little more difficult as we also have to handle the possibility of multiple regenerations and simul- taneous recursion. We shall therefore approach this in three stages. First we

Next we will illustrate how to remove simultaneous recursion within the circular proof system. This transformation uses the higher-order aspects of the language non-trivially: the transformation is well-known and was pointed out to me by both Eric Meijer and Simon Thompson. I shall illustrate the technique by transforming a proof which has a simultaneous recursion on two arguments. Here is a typical such proof:

The first and most obvious cuts involving the datatypes are those which are concerned with the construction and destruction. Both these cuts remove structure and so must be eliminated in any deforesting transformation. They are what we shall call deforesting cuts. A term with residual deforesting cuts will, by definition, not be deforested.

There are three ways this can happen: two inductive cases and one coin- ductive. For the inductive cases the cut formula can be on the left or the right. The case where the cut formula actually is the inductive type itself was handled above.

The difficulty with the idea of knot tying was to secure the termination of the search for knots. That is a guarantee that every path in the term will either be finite or go round a knot. While some special conditions are known it seems that in general the general recursive case there can be no guarantee that one can actually complete the tying of the knot.

There are two ways that demand can occur in a term. The first source of demand is expressed at an argument of a term. This can either be at the active arguments of an inductive circular definition (including a coproduct) or at the argument of a destructor (including projection). This is one reason why we carefully labeled the active (often recursive) arguments of the induc- tive circular definitions using :=. However, these two expressions of demand only become real demand when they can potentially be put together with a supplier. For an active argument of an inductive circular definition a supplier is a constructor or something which could potentially produce a constructor. For a destructor a supplier is a coinductive circular definition or someone who can supply such a definition.

Below, through examples, I am describing an algorithm which can be im- plemented. If this algorithm terminates it will return a deforested term. Of course, the problem concerns the termination (see also [10]); I conjecture that this procedure does terminate and so will always return a deforested (finite) term, however, at the time of writing I do not have a proof.

We shall indicate the demand we are working on by a dot. This will usually be the demand nearest the root. However, the knot tying process may actually oblige us to calculate certain demands in order to secure the match it wants.

Deforestation can make large efficiency improvements. Here is a classic exam- ple of an O(n2) program which can be improved to an O(n) program. This transformation is interesting as it derives precisely what one might hope would be derived. Consider the following definition of reverse:

This is now deforested as all the demand has gone. However, we may make a further simplification: we can note that second argument can be obtained from the first at every call by xs = F @nil. This means we do not need the middle argument at all it can be replaced by the calculation. While this is a

Now, in principle, this is easy to achieve. The idea is this: one unrolls the two programs in parallel. The demand to unroll arrives now from two sources. The first is because there are still deforesting cuts as usual. The second is because one wants to keep the programs unrolling in parallel. Thus, if there is demand on the one program this must be transmitted to the second. Finally knot tying must be done in parallel.

I hope that these discussions have underlined that arriving at an appropri- ate semantic and proof theoretic formulation for inductive and coinductive datatypes is an extremely important for the field of program transformation and optimization. Furthermore, that a satisfactory semantic formulation (as given by mathematical induction or categorical initial and final datatypes) does not necessarily translate into a good manipulative system. In the case of inductive and coinductive datatypes, I would argue, the circular proof system provides a crucial insight and link between formal settings and the various techniques which have proved to be most useful in practice.

This paper has provided a walk through some of the ideas which underpin the development of good transformation and proof tools for the basic program- ming system provide by a cartesian closed category with datatypes. I have not attempted to provide detailed proofs and, indeed, I have introduced tech- niques, such as the deforestation algorithm, in a very informal way. I would be the first to admit that there remains alot of work to be done. Therefore, what I have described should be regarded as a program for future work. I hope, however, that I have provided some indications that this program might be fruitful.

