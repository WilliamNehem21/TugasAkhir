typable. However, it should be pointed out that the secure process ah. bl + bl is not typable either. Hence, rule (Sum) is stricter than we would wish. In order to make process ah. bl + bl typable, we could envisage replacing rule (Sum) by the following

Here the second getX action may be executed before the first putX action. This means that the same value v0 may be read for X in both assignments, and thus the same value v1 = v0 + 1 may be assigned twice to X. Hence, while C only produces the final value v2 = v0 +2 for X, [[C ] may also produce the final value v1 = v0 + 1. It is then easy to see that the translation does not preserve security.	Let CL = (XL := XL +1  XL := XL + 1) and DL = (XL := XL +1 ; XL := XL + 1).

Indeed, it is easy to see that our translation is not fully abstract (with respect to any of our security properties, whether nil-sensitive or nil-insensitive). For instance the process of Example 3.4 is not secure nor nil-insensitive secure, while its encoding into CCS is secure. For the nil-sensitive security property, another reason of failure for full abstraction is illustrated by the program:

At this point of discussion, it may seem surprising that a full abstraction result could be obtained in [9] for a time-sensitive security notion, which is stronger than our security properties and thus further away from weak bisimulation. In fact, as mentioned earlier, this full abstraction result was obtained by using special tick actions in the translation, whose function was precisely to enforce a correspondence between steps in the source program and their encodings in the target process. Indeed, it is easy to see that full abstraction would fail for time-sensitive security in the absence of such tick actions. For consider the program:

Now, it is easy to see that [C ] is not typable in the security type system of Section 2. Indeed, there is no assignment of security levels for the channels lock, unlock and d which allows [C ] to be typed. First of all, note that channels lock and unlock must have the same security level since each of them follows the other in the semaphore (and in the registers). Consider now the two top parallel components of [C]]: for the first component to be typable, unlock and d should be high (and thus lock should be high too); for the second component to be typable, d and lock should be low (and thus unlock should be low too). In other words, the two components impose conflicting constraints on the levels of channels lock, unlock and d.

A possible solution to this problem is to relax the type system by treating more liberally channels like lock, unlock and d (and hence done, since d is obtained from done by renaming), which carry no values and are restricted. The idea, bor- rowed from previous work [16,14,15,33,17], is that actions on these channels are data flow irrelevant insofar as they are guaranteed to occur, since in this case their occurrence does not bring any information. The typing rule (Sum) may then be made less restrictive for these actions, while keeping their security level to h. It can be observed that replacing rule (Sum) by the rule (Sum-Lax) discussed at page 8 would not solve the problem.

