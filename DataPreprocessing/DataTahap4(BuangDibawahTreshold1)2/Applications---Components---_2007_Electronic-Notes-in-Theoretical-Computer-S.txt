The rest of this paper is organized as follows: in Section 2, we briefly describe the main features and design rationale of the GLoo framework and present the design and implementation of the Language-of-Java-Services in Section 3. In Section 4, we discuss both related work and its impact on the design of the GLoo framework. We conclude this paper in Section 5 with a summary of our main observations and outline future activities in the area of the specification and implementation of narrow-focused domain sublanguages.

that concurrency is a language feature and should therefore be made an integral part of the underlying language specification. However, the identification and definition of the right set of abstractions for concurrency within a given language is not an easy task. Consider, for example, the industrial-strength languages Java and C#. Both languages offer a rich set of primitives to cope with concurrent activities within a software system. Nevertheless, these abstractions are not powerful enough to separate coordination from computation concerns, as, for example, synchronization has to be specified at the method level or the lifetime of object instances may change due to application-specific settings controlled by the lifetime management of the .NET Remoting infrastructure [31].

GLoo does not offer any predefined abstractions to denote algorithms, except se- quencing. However, GLoo allows for both syntatic and semantic extensions. More- over, even though GLoo recognizes most Java operators, their actual semantics is undefined, that is, the user has to supply the GLoo system with an appropriate implementation.

In order to define the Language-of-Java-Services, we need to integrate Java classes and Java objects in the GLoo framework as first-class values. More presicely, we need to define two container value types that encapsulate classes and objects, re- spectively, and a JavaClass meta level that defines the core abstractions to load classes, create objects, call methods, and map GLoo values to Java values and vice versa. Container value types are specified directly in Java as part of the package JavaSupport that is automatically loaded into the GLoo system when processing a specification unit.

The definition of the container value type for Java classes is shown in Listing 2. The type JavaClassValue defines a read-only value denoting a runtime instance of a Java class. Besides the getter method getClassValue(), we also have to redefine the toString() method to obtain a standard textual representation for the newly defined data type. In addition, by deriving JavaClassValue from the class LiteralValue we guarantee a sound integration of the new container value type in the GLoo framework and promote Java classes to first-class values in the GLoo system.

The core of the Language-of-Java-Services is shown in Listing 4. The core ex- poses two abstractions: the type constructor JavaClass and the function new that takes a class container value and returns a function, which expects an extensible record denoting the constructor arguments to be passed to the meta level function Java.newInstance. The term (|Args, class = Class|) defines a so-called bind- ing extension in which the record Args is refined by the binding class = Class. Again, the order of bindings in an extensible record is insignificant. However, in case of the occurrence of bindings with the same label, the right-most binding has precedence.

In addition, the core also defines the function propagate positions, visible to the local scope of the unit only. The purpose of this function is to combine the posi- tion information specified in the signature record with the bindings in the argument record. The term (|Positions # Arguments|), denoting the composition of the bindings of both records giving the bindings of Arguments precedence [15], yields a record that has the same bindings as Arguments, except that positions have been added if necessary. More precisely, if a binding in Arguments does not possess an explicitly specified position, then the record Positions is consulted to assign that binding a position.

Crucial to the success or failure of a software project is not only our understand- ing of the problem domain, but also the choice of the programming languages and their support for modeling the problem domain. General-purpose programming languages offer a reasonable support for the encapsulation of domain expertice in prefabricated software entities that can be reused by rearranging them in new com- posites [29]. However, general-purpose programming languages are less useful when specifying applications as compositions of reusable software components, as they exhibit a mismatch between the the abstraction level of the supported language constructs and the level of abstraction at which software composition takes place.

In this paper, we have analyzed GLoo, a novel component-oriented programming framework that allows for the definition of narrow-focused compositional domain sublanguages that provide a user-centric view of a given problem domain for the application programmer (i.e., the component assembler [29]). GLoo is a dynamic, open-ended composition language that rests upon dynamic binding, explicit names- paces, incremental refinement, and a foreign code gateway, concepts all crucial for a comprehensive component-oriented software development approach.

The foreign code gateway is the most important innovation of GLoo with respect to its predecessor Piccola and provides us with an effective means to incorporate Java code directly into the scope of GLoo specification unit to construct problem- oriented domain abstractions, as illustrated in the definition of the Language-of- Java-Services. The GLoo programming model allows for a light-weigth and scal- able approach to define domain abstractions. Rather than building large, mono- lithic domain models, the GLoo approach fosters the definition of small, first-class subject-oriented development artifacts that can be composed and extended to build larger and more complex and possibly concurrent compositional programming ab- stractions.

The GLoo framework also provides support for Model-Driven Engineering [26]. Model-Driven Engineering (MDE) technologies combine domain-specific modeling languages with program synthesis tools for creating domain-specific models of large- scale systems. Models are considered first class entities. The GLoo programming paradigm does not impose any restrictions on definable development artifacts. In future work we plan, therefore, to use the GLoo as a model-integrated computing platform and perform feasibility studies to ascertain the effectiveness of representing domain models in the GLoo framework.

