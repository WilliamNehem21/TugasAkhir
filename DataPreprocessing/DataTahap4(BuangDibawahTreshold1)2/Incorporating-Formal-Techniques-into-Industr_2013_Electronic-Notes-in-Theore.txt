We report about experiences at Philips Healthcare with component-based development supported by formal techniques. The formal Analytical Software Design (ASD) approach of the company Verum has been incorporated into the industrial workflow. The commercial tool ASD:Suite supports both compositional verification and code generation for control components. For other components test-driven development has been used. We discuss the results of these combined techniques in a project which developed the power control service of an interventional X-ray system.

To support a fast realization of the quickly increasing amount of medical proce- dures that use this type of image guided surgery, a component-based development approach is introduced. New components are developed according to this paradigm and existing parts are gradually replaced by components with well-defined formal interfaces. The definition of formal interfaces supports parallel, multi-site develop- ment and improves the integration with the increasing amount of 3rd party compo- nents.

At Philips Healthcare, the component-based development approach is based on a formal approach called Analytical Software Design (ASD). This approach is supported by the commercial tool ASD:Suite of the company Verum [27]. ASD [6,17] enables the application of formal methods into industrial practice by a combination of the Box Structure Development Method [21] and CSP [14]. The ASD approach contains two types of models which are both based on state machines and described by a similar tabular notation: interface models and design models. At Philips, these models are exploited as follows:

Given an interface model of a control component, its internal behaviour can be described by means of a design model which typically uses the interface models of other components. By means of ASD:Suite it can be verified formally whether the design model refines the interface model. Very important in our industrial context is that ASD:Suite supports complete code generation from design models to a number of programming languages (C, C++, C#, Java). Hence, design models provide a platform-independent description of internal component behaviour.

This paper is structured as follows. Section 2 presents the workflow that has been used to combine formal and traditional approaches for developing software components. Section 3 introduces the PCS and its role in the interventional X-ray system. Section 4 describes the application of the presented workflow to the PCS. In Section 5 we discuss the results achieved in this project. Section 6 contains our main observations and current answers to the questions raised above.

For planning and tracking a Work Breakdown Structure (WBS) is created. A WBS consists of tasks that need to be completed in a certain order to obtain a finished product. At the beginning of each increment a new WBS for that increment is created. For each task, the time needed to complete the task is estimated with the Wideband Delphi estimation method [25]; this means that the effort needed for every task is estimated by two or more experienced software designers in the first phase. In the second phase, the software designers need to get consensus on the estimate. The outcome of the estimate is used in the planning. Not all tasks of the WBS are estimated; some are derived from historical data. Examples are overhead and average time needed to solve a Problem Report (PR).

ties. Usually such a design is the result of iterative design sessions and approved by all team members. When the aim is to use ASD, a common design practice is to organize components in a hierarchical control structure. Typically, there is a main component on the top which is responsible for high-level, abstract behaviour, e.g., dealing with the main modes and the transitions between these modes. More de- tailed behaviour is delegated to lower-level components which deal with a particular mode or part of the functionality.

The TDD approach starts each increment with the definition of a set of test cases. To validate the test set, it is checked whether all tests fail on an empty implementation. Next the components are developed iteratively, gradually increasing the set of passed test cases. When all tests succeed, the code of the components is reviewed by the team before it is integrated with the code generated by the ASD approach.

Moreover, the PCS may lose connection with other components at any time due to a failure of other components (e.g., applications) or with the PDU (e.g., due to a network outage). The PCS has to be robust against such failures, especially when the PCS is in the middle of executing a particular scenario. When the PCS detects that the system is in a faulty state, it should take appropriate actions and log the events for further diagnostics by the field service engineer. As soon as the cause of malfunctions has disappeared, the PCS ensures that all its internal components are synchronized back with other external components to a predefined state.

The ASD components of the PCS have been realized in a top-down order. Each ASD component is designed as a state machine that captures the global states of lower level components. Starting point is the PduEventController component which is modeled as a top-level state machine that captures overall global states (or modes) of a PC: normal mode, installing, starting/stopping applications, etc. Later, lower- level components are realized. For instance, the component InstallTransitioning implements detailed behaviour of the installation mode of the top-level state ma- chine and is responsible of safeguarding detailed transitions from normal mode to installation mode, and vice versa.

After the completion of the design model of a component, given interface models of a component and its used components, ASD:Suite has been used to formally verify absence of deadlocks, livelocks, illegal calls, and conformance of the design model with respect to the interface model. Usually this revealed quite a number of errors, both in the design model and the interface models. Since changes in interface models affects other components this sometimes leads to a chain of changes. However, since our components are kept small, it is easy and fast (usually less than a second) to re-check these other components.

Specification review, code generation and integration. Although the formal verification is very useful to detect errors, it does not guarantee that the design model realizes the intended behaviour. For instance, the correct relation between client calls and calls to used components is not checked. Also the value of parameters is not verified. Hence, when all formal checks succeed, the ASD models were reviewed by the project team. The review process performed for the ASD models was similar to the review process of any normal source code developed manually. After the team review, including corrections and a re-check of the formal verification, C# source code was generated automatically using ASD:Suite. This code is then integrated with the manually coded components.

The entire PCS code was exposed to further testing on module level at the end of all increments. After that, both manually written code and test code were carefully reviewed by team members. As a result of review, minor issues were identified and immediately resolved. Test cases were rerun in order to assure that the rework after review did not break the intended behaviour of the service.

Throughout all increments, no major redesign was needed. In general, the con- struction of all PCS components was rather smooth and gradually evolved along the development increments. Both code and ASD models are stored in a code management system, called IBM ClearCase [18].

more than 300 rule cases and include at most 2 asynchronous stimuli. Hence, the formal verification of interface and design models took less than a second. Small models are also easy to inspect and to maintain. Keeping the components small, however, increases the number of models. Since the verification is compositional, this does not increase the complexity of the formal verification; each component is verified in isolation with respect to its interfaces.

The end quality result of the PCS service is remarkable, and the entire service exhibited only 0.17 defect per KLOC. This level of quality favorably compares to the industry standard defect rate of 1-25 defects per KLOC [20]. The PCS service was deployed on all PCs, and further tested by independent teams responsible of developing the clinical applications on each PC. The result of testing was that no errors were found and the service appeared to function correctly on every PC, from the first run.

We have described the experiences at Philips Healthcare with a component-based development method which is supported by the commercial formal tool ASD:Suite. The proposed workflow also includes test-driven development. This approach has been used for the development of a basic power control service. We list our main observations and lessons learned.

Test and integration. Concerning the code generated by ASD:Suite, state- ment and function tests can be safely discarded since all possible execution scenarios have been covered by the model checker of this tool. However, it is important to test the combination of ASD components and hand-written components. In the PCS project this revealed a few errors.

Experience from other projects using more conventional approaches shows that integrating concurrent components is usually a challenging task. It is often the case that components work correctly on their own, but do not function as expected when they are integrated with one another. Sometimes, errors are profound in length, hard to analyze and often tough to reproduce due to the concurrent nature of components. Moreover, fixing an error in the code often causes others to emerge, but unpredictably others to be unveiled with a great potential of causing unexpected failures in the field.

fication thoroughly checked the correctness behaviour of components under all cir- cumstances of use. It was often the case that fixing an error caused other errors to emerge, which were deeper in length and complexity than a previous one, but these design errors were detected with the click of a button. Fixing these errors was done iteratively until components became neat and clean from all sources of errors. Since formal verification of each ASD design model was done with the interface specification of the boundary components, integrating the code of all ASD design models is often quick and accomplished without errors.

Future Work. A disadvantage of having many small components is that it is less clear whether together they realize the desired functionality. In future work we would like to investigate whether additional formal techniques can help to check the overall functionality of a set of components. Another relevant direction that will be explored is the use of formal interface models for conformance testing, using model-based testing techniques.

