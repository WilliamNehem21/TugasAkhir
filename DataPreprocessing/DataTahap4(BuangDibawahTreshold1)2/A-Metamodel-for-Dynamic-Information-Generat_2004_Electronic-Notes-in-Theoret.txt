Fully understanding object-oriented systems is difficult if one is limited to merely performing static analysis of the source code: Techniques based on dynamic analysis are needed. Several tools exist that implement techniques for analyzing traces of object interactions; however, due to lack of a common exchange format these tools do not interoperate. In this paper, we propose a graph-based format, called Compact Trace Format (CTF), for exchanging traces of object interactions. The design of CTF takes into account the size explosion problem that makes run-time information hard to manipulate. To achieve this, we start by presenting techniques for reducing the size of traces without affecting their content. Then, we show how the concept of transforming the tree representation of a trace into an acyclic compact graph can be used to define the core of CTF schema.

There are several tools that operate on traces of object interactions to help software engineers in their daily maintenance activities [2, 3, 12, 13, 15, 16]. However these tools have different formats for representing traces, which hinders interoperability. In order to take better advantage of these tools we need to define a common format for exchanging traces of object interactions. An exchange format consists of two main components: a schema that represents the entities to exchange and their interconnections and the syntactic form of the file that will contain the information to exchange. This paper introduces a schema for representing traces of object interactions called the Compact Trace Format (CTF). The syntactic form can be represented using existing formats such as GXL (Graph eXchange Language) [11] or TA (Tuple

Traces are usually very large and difficult to manipulate. A good exchange format should therefore address scalability problems in an efficient way. To achieve this, we use two techniques. The first technique is based on investi- gating ways to reduce the size of a trace without affecting its content. For example, repetitions of a method invocation that are due to loops can be removed and replaced with the number of repetitions without affecting the content of the trace. This technique can result in an important reduction as we showed in our previous experiments described in [8].

In this section, we present the compact trace format (CTF), which is a format for exchanging traces of object interactions. We use a UML class diagram to represent the information represented by CTF. Although, this format can only represent interactions between objects in terms of method calls, we believe that it can be easily extended to represent other kinds of relationships such as interactions among clusters of objects.

The class Trace is an abstract superclass that describes common informa- tion that different types of traces may have. This class allows extending the model to consider other type of traces such as traces of inter-process com- munication. Although, we focus on object-oriented systems, we added the RoutineCallTrace class to represent traces of routine calls of procedural sys- tems. By routine, we mean any function that is not a method of a class. In addition to that, some programming languages such as C++ use routines as well as methods. To deal with this problem, we decided to represent traces of method calls as a subclass of RoutineCallTrace. By doing so, an analyst can create traces of routine calls only, traces of method calls only or traces of routine and method calls such as C++ execution traces. In addition to that, this allows keeping the design simple and understandable.

Trace patterns are represented using the class TracePattern. This class contains one attribute that can be used to assign a high-level description to the trace pattern. The same trace pattern can occur in more than one trace. Indeed, a pattern that occurs in several traces might be more relevant than another pattern that appears in one or two traces only. Relevance, here, is defined with respect to how close the pattern is to a design concept. Finally, the class PatternOccurrence is used to depict in which trace the pattern occurs.

We support the idea that a schema should be defined independently from any syntactic form of the file that represents the data. GXL [11] is one candidate for the syntactic carrier for CTF. A GXL file consists of XML elements for describing nodes, edges, attributes, etc. It was designed to supersede a number of pre-existing graph formats such as GraX [6], TA [10], and RSF [14]. GXL has been widely adopted as a standard exchange format for various types of graphs by both industry and academia.

However, a GXL representation of CTF would tend to be much larger than necessary due to the use of XML tags and the explicit need to express the data as GXL nodes and edges. The compactness benefits of CTF would therefore be partially cancelled out. Whereas the wordiness of GXL would not be a problem when expressing moderately sized graphs in other domains, the sheer hugeness of traces suggests an alternative might be appropriate.

In this section, we illustrate the use of CTF schema through an example. First, we explain the different techniques for extracting traces of object interactions. Then we introduce an imaginary trace and model it using CTF. The result is an instance diagram of the CTF schema.

The trace involves three classes namely A, B and C and three objects, which are obj1, obj2 and obj3. There are five methods that have been invoked: m0, m1, m2, m3 and m4. We notice that the call generated to obj2:B.m1 is repeated five times in the trace, probably due the existence of a loop in the

This paper introduces CTF (Compact Trace Format). We describe the CTF schema using a UML class diagram. To deal with the size explosion problem of execution traces, we transformed the tree representation of the traces into their corresponding directed acyclic graphs, where repeated sub- trees are represented only once. We also removed repetitions for a better compression.

Future work should focus on three aspects: The first aspect consists of experimenting with numerous execution traces of many systems to test the efficiency of CTF. By efficiency, we mean the ability of the format to convey information from large system executions as compactly as possible. The sec- ond aspect is concerned with the adoption of CTF by tool builders. In order to move towards this, we need to arrange to have several tool builders use CTF, or a descendent, as their standard format. Finally, we need to extend CTF to handle other types of execution traces such as traces of inter-thread communication.

