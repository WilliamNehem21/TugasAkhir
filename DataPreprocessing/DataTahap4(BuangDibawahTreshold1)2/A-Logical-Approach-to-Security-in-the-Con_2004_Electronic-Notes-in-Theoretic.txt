security properties. Our logic is a more expressive alternative to Ambient Logic, based on a single modality, but still powerful enough to handle mobility and dynamic hierarchies of locations. Moreover, having a temporal logic to express properties of computation, we can reuse the algorithms for model checking temporal logics in analyzing models for security problems.

We resort to syntax trees of Ambient Calculus and enrich them with some labeling functions in order to obtain what we called labeled syntax trees. The labeled syntax trees will be used as possible worlds in a Kripke structure developed for a propositional branching temporal logic. The accessibility relation is generated by the reduction of Ambient Calculus considered as reduction between syntax trees.

The main idea of Ambient Logic is treating processes as spatio-temporal entities, thus were used two types of modalities - one for assertions about space and the other for assertions about time. We will prove here that a sin- gle modality suffices for describing the behavior of these entyties. The main intuition is that we only need to calculate the modification that each move- ment of the system is making over the initial state, because this information suffices to reconstruct the actual shape of the system using only a propositional branching temporal logic based on Ambient Calculus.

In this section we define an Algebra of labeled syntax trees extending the compositional operations of Ambient Calculus from syntax trees to the labeled syntax trees. This mean that, starting from the labeled syntax tree of P1 and P2 we will define those for P1|P2, c1.c2...cn.m[P ] or !P .

We developed the labeled syntax trees to use them as states in our logic. The choice of the initial state depends on the purpose of our analysis. If we are interested in the future of an ambient calculus process P by himself, then the labeled syntax tree of P will be the initial state. But if P will interact with another process Q, or will become child of an ambient, or both like in m[P |Q], then, even if we have a particular interest in P, the initial state will be the labeled syntax tree of m[P |Q] (we can use, for defining this, the computation operations developed for labeled trees, i.e.  and m@).

Definition 5.6 A state formula p (resp. path formula p) is valid provided that for every structure M and every state S (resp. fullpath x) in M we have M,s |= p (resp. M,x |= p). A state formula (resp. path formula) p is satisfiable provided that for some structure M and some states S (resp. fullpath x) in M we have M,S |= p (resp. M,x |= p).

of this paper is to show the advantages that could be obtained in analyzing the security problems expressed in Ambient Calculus by using our logic. For this reason we will not present here the algorithms that can compute the accessibility relation. These can be found in [8]. We present only the idea behind our implementation.

18 it will analyze if the spatial arrangement of the process to see if it allows this reduction. Moreover, this algorithm will check more then the conditions generated by the reduction rules; it will stop the consuming of a forbidden capability, as in the case c1.(c2.P |Q) where the consuming of c2 is forbidden as time as c1 exists

We investigated this possibility in connection with Ambient Calculus. Con- sider, for example, that the firewall is expected to interact with all the agents that know the passwords. Generally speaking this is the situation in reality. Now the previous definition of the firewall is not satisfactory because it was modelled such that, if the interaction with one agent was done, the firewall cannot interact with any other, being unable to recognize the passwords once again.

