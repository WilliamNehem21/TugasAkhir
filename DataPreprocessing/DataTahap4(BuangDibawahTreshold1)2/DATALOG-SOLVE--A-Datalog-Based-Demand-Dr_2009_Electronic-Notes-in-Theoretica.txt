Static program analysis extracts semantic information from a given program without running it. An example of such an analysis is the definition-use analysis that is used to analyze data-flow program dependencies. The analysis is run on an abstract representation of the program that contains the variable definitions as well as their use at each program statement.

Recently, a very efficient Datalog program analysis technique based on binary decision diagrams (Bdds) has been developed in the Bddbddb system [13], which scales to large programs and is competitive w.r.t. the traditional (imperative) ap- proach. The computation is achieved by a fixed point computation starting from the everywhere false predicate (or some initial approximation based on Datalog facts). Datalog rules are then applied in a bottom-up manner until saturation is reached, so that all solutions satisfying each relation of a Datalog program are exhaustively computed. These sets of solutions are then used to answer complex formulas.

able atoms, our approach focuses on demand-driven techniques. In the context of program analysis, note that all program updates, like pointer updates, might potentially be inter-related, leading to an exhaustive computation of all results. Therefore, improvements to top-down evaluation remain attractive for program analysis applications. Recently, Zheng and Rugina [14] showed that demand-driven Cfl-reachability with worklist algorithm can compare favorably with an exhaus- tive solution, especially in terms of memory consumption. Our technique to solve Datalog programs based on local Bes resolution goes towards the same direction and provides a novel approach to demand-driven program analyses.

The Datalog approach to static program analysis [13] can be summarized as fol- lows. Each program element, namely variables, types, code locations, and function names, are grouped in their respective domains. By considering only finite program domains, Datalog programs are ensured to be safe (i.e., query evaluation only gen- erates a finite set of answers). Each program statement is decomposed into basic program operations, namely load, store, assignment, and variable declarations. Each kind of basic operation is described by a relation within the Datalog program. A program operation is then described as a set of tuples satisfying the corresponding relation. In this framework, a program analysis consists in either querying extracted relations or computing new relations from existing ones. Let us show an example of analysis specification in our approach.

The last part of the program specifies which kind of information are we able to infer by using the information extracted from the program. In this case, the four rules infer possible points-to relations from local variables and method parameters (Datalog variables of the domain V) to heap objects (Datalog variables of the do- main H), as well as possible points-to relations between heap objects through field identifiers (Datalog variables of the domain F). In summary, the rules model the effect of the input relations over the heap.

the Datalog program, e.g., :- vP(x,y)., where x and y are variable arguments of vP. This goal aims at computing the complete set of variables x that may point to any heap object y at any point during the program execution. The Datalog query is not specified in the Datalog program, but provided independently by the user.

Example 3.2 Let us consider the implicit representation in the Example 3.1. As- sume the following carrier for the variable domains: carrier(H) = {heap1,heap2}, carrier(F) = {a,b}, and carrier(V) = {var1,var2}. Then, the parameterless repre- sentation for the boolean variable hP(h1:H,f:F,h2:H) is the following:

