The use case is completed by specifying the use case extensions. These extensions constitute alternative scenarios which may or may not lead to the fulfillment of the use case goal. They represent alternative (and sometimes exceptional) behavior (relative to the main success scenario) and are indispensable to capturing full system behavior. Each extension starts with a condition (relative to one or more steps of

User task modeling is by now a well understood technique supporting user-centered UI design [18]. In most UI development approaches, the task set is the primary input to the UI design stage. User task models describe the tasks that users perform using the application, as well as how the tasks are related to each other. The origin of most task modeling approaches can be traced back to activity theory [10], where a human operator carries out activities to change part of the environment (artifacts) in order to achieve a certain goal [5].

as a directed graph. Tasks are hierarchically decomposed into sub-tasks and atomic actions. Leaf tasks are also called actions, since they are the task that actually carried out by the user or the system. The execution order of tasks is determined by temporal operators that are defined between peer tasks. Various temporal op- erators exist; the most popular are: enabling (>>), choice ([]), concurrency (||), and disabling ([>). A complete list of the CTT operators together with definition of their interpretation can be found in [17].

[1] and Katoen and Lambert [9]. Alur et. al. propose a semantics for a subset of MSCs which only allow message events as possible MSC events types. In contrast, the semantics of Katoen and Lambert is more complete. They map MSCs to a set of partial order multi-sets (pomsets). A pomset is a so-called isomorphic class of a corresponding lposet. A pomset contains all objects that can be derived by a bijective projection from a base lposet. Approaches based on pomsets are very similar to approaches based on lposets.

Mizouni et. al. propose use case graphs as an intermediate notation for use cases [15]. Use case graphs are directed, potentially cyclic graphs whose edges represent use case actions and nodes represent system states. This allows for a natural representation of the order in which actions are to be performed. In order to integrate several use cases into a single specification, Mizouni et. al. describe an algorithm for transforming a set of (related) use case graphs (each representing one use case) into an extended finite state machine (EFSM). The merging of the graphs is done on the basis of common states within the use case specifications.

In use case modeling, state conditions often constrain the execution of use case steps. For example the pre-condition attribute of a use case denotes the set of states in which the use case is to be executed. In addition, every use case extension is triggered by a condition that must hold before the steps defined in the extension are executed. In order to be able to evaluate conditions, the semantic model must provide means to capture the notion of the state and should be able to map state conditions to the appearance of events.

In this section, we illustrate an approach to semantics in which we demonstrate how CTT task models and use cases can be mapped to sets of partially ordered sets. We start by reiterating the definition of a partially ordered set (poset) and then define some operators over posets. Finally, we will describe semantics functions that will define a mapping from use cases and task models into sets of posets.

In order to derive a task expression from the task model we first create a cor- responding expression tree. In general, an expression tree is a tree whose leaves are operands and whose inner nodes are operators. In this case, the operands of the expression tree are actions (tasks at the leaf-level) and the operators are the temporal relations defined in CTT. In CTT, all temporal relations are defined as either binary operators (e.g. enabling, disabling ) or unary operators (i.e. iteration, option). Hence in the expression tree all inner nodes have between one and two children. Since the conversion of trees to expressions is fairly conventional, it will not be described any further.

The next step consists of mapping that task expression into a corresponding set of posets. Action tasks correspond to the elements of the poset. Composite tasks are represented by sets of posets, which have been composed using the composition operators, defined in Section 4.3.1. Our (compositional) semantic function is defined in the common denotational style.

In this section we discuss how use cases can be transformed into sets of posets. The transformation consists of two parts. First the textual use case is transformed into an intermediate graph form, which we will refer to as the use case graph. Next, based on the use case graph a corresponding set of posets is iteratively constructed.

Based on the use case graph a set of posets is constructed. The construction can be performed mechanically using the following two steps: First, we assign a set of posets to each transition in the use case graph. Typically the set of posets consists of a single poset, which in turn defines a single event representing the execution of the corresponding use case step. Second, the use case graph is iteratively transformed into a labeled transition system that only consists of an initial state and a final state. With each iteration one node of the use case graph is eliminated and a new transition is defined between its incoming node(s) and its outgoing node(s). Similar to the first step, a set of posets is assigned to the newly inserted transition.

This set of posets is the result of the composition of the sets of posets attached to the incoming transition and the outgoing transition. At this point it no longer represents a single use case step, but a composition of use case steps. Special care must be taken if the eliminated node contains a self loop or if there already exists a transition from the incoming node to the outgoing node.

