We define a framework for the analysis of access control policies that aims at easing the specification and verification tasks for security administrators. We consider policies in the category-based access control model, which has been shown to subsume many of the most well known access control models (e.g., MAC, DAC, RBAC). Using a graphical representation of category-based policies, we show how answers to usual administrator queries can be automatically computed, and properties of access control policies can be

Access control systems are used to protect resources against unauthorised use. In its most basic form, an access control policy specifies the actions that each user is allowed to perform on each resource. A pair of a resource and an action is called a permission.

A variety of access control models and languages for access control policy spec- ification are currently in use. One of the most popular is the ANSI (hierarchical) role-based access control (H-RBAC) model [2], where users are assigned to roles and each role is assigned a set of permissions (extensions of RBAC, using time and location constraints, are discussed in e.g., [19]). More flexible models, such as the

The remainder of the paper is organised as follows. In Section 2, we recall the category-based access control model. Section 3 discusses emergency policies. Section 4 presents a graph-based framework to represent and analyse category- based policies, and Section 5 describes its implementation (a Ruby application for policy visualisation and analysis). In Section 6, we discuss related work, and in Section 7, conclusions are drawn and further work is suggested.

An axiomatisation of distributed category-based access control was proposed in [11] to specify federative policies, obtained as a composition of individual ac- cess control policies. In a federation, each member has its own access control policy, and contributes to the definition of a global access control policy. We will use this notion of distributed access control to define emergency policies in the next section. We recall the main axioms below.

The operational semantics of the distributed model is defined by extending the functions presented in Definition 2.3, using distributed term rewrite systems (DTRSs), which are term rewrite systems where rules are partitioned into modules, each associated with a unique identifier, and function symbols are annotated with such identifiers (for more details on DTRSs, we refer to [12]). In other words, spe- cific functions defined in a particular site are indexed by the site identifier; functions with no site annotations are assumed to be defined locally.

We start by defining how policies can be represented by means of graphs. Graph- ical or visual representations of data structures and algorithms have a number of established and significant advantages over textual representations. In particular, they tend to be easier to understand and analyse than the corresponding textual representations. Furthermore, being a well-studied area, algorithms and properties of graph theory can be used to analyse properties of policies.

Using graphs to formalise the global authorisation policy PAR is not so straight- forward. One possibility to define PAR is simply by the union, but there are much more sophisticated ways to combine the policies. For now we will take the union of the different policies.

One could consider copies of the same entity as different nodes, which could be linked, and then collapsed into a single node when visually displaying the graph. We will discuss later, different options for effectively displaying a policy. The visibleV , visibleE functions defined above will be useful in the definition of visual- isation algorithms. In terms of graph representation, other more sophisticated com- binations of policies could be defined taking into account, for example, conflicting information, but we will deal with that in the future.

Relations between the entities in our model can change in an autonomous way (e.g. due to events that happen in the system), with principals/permissions being added or removed from certain categories. In this sense a policy graph can be seen as a photo-shot of the system at a particular time. From the graph one can extract the relations PCA, ARCA and PAR at a particular instant, but not how to get the next photo. This is the purpose of the ld function.

One can also ask, for a given union graph, what is the minimum unique graph that corresponds to a policy. This can be computed by starting in nodes of type S and considering the edges that are in the spanning tree considering only branches that end in nodes of type P , C and R. This way one eliminates edges between nodes of type A and R that are not associated to any category, and edges between nodes of type C and R that are not associated to any resource.

For a given policy-graph G, and given sets of principals {p1,..., pn} and permis- sions {(a1, r1),..., (an, rn)}, what is a minimum number of changes (in term of adding/deleting elements in the PCA and ARCA relations) necessary to ensure that, collectively, the given set of principals has the given permissions?

Our main motivation is to provide an analysis framework to deal with policy up- dates, allowing security administrators to detect changes introduced into a policy in a scenario involving emergency situations. As mentioned in Section 3, an emergency policy can be modelled using an additional emergency site. The graph representa- tion of a policy in an emergency scenario will be given by combining the graphs of the normal policy with the emergency policy (taking an appropriate composition operator). For example, when combining the two policies using a union operator with priority to grant, then the union-graph defined above will suffice.

Note that, unconnected entities cannot be associated to any site, in which case the function visibleV can be used to determine the colour(s) of the nodes. When representing the union-graph, the function visibleE is also used to determine the colour of the edges. Other possibilities could be considered such as representing different copies of the same entity corresponding to the different sites where it occurs, and using especial edges to connect the different copies. Each policy could then be displayed separately, with the connection to other policies being given by the additional edges. This alternative would give a clear visualisation of each individual policy (particularly if the additional edges could be omitted), but would not provide a proper overview of the general policy.

In terms of graphical display of policy data, the Policy Manager provides user- friendly visual representations that facilitate the task of identifying policy flaws. The application provides the user with a complete view of a policy as a tree, allowing users to zoom in on overcrowded sections of the tree. It also allows the selection of particular entities, highlighting the nodes and edges associated to that entity. For example, by clicking on a principal name, the tree will centre on the selected object, allowing a clearer view of the categories and permissions associated to that principal. Furthermore, the user is able to reposition the elements by dragging, as

The specification of policies by means of rewriting systems allows, not only to take advantage of the extensive theory of rewriting to establish security properties, as shown in [29,17,10] amongst other works, but also to make use of rewriting-based frameworks (such as CiME, MAUDE or TOM) to reason about policy properties. Our work addresses similar issues, but is based on a notion of category-based access control for distributed environments, which we interpret using labelled graphs, and which can be instantiated to include concepts like times, events, and histories that are not included as elements of RT or RBAC. In [15], CiME is integrated in a tool designed to automatically check consistency and totality of RBAC access control policies. A similar technique could be used to analyse the rewrite system in a dynamic policy graph.

