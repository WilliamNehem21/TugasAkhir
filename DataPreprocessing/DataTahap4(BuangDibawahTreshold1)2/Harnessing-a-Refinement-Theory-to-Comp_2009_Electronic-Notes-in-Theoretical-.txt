Closed Form Function. Central to the derivation of a loop function is the discovery (reverse engineering) of the inductive argument that gave rise to the loop in the first place; giving the loop function by a recursive formula merely replaces an inductive argument by another. We resolve to derive the function of the loop in closed form, by describing how the execution of the loop affects all relevant variables of the program.

Stepwise Derivation. We derive the function of a loop in a stepwise manner, by analyzing arbitrarily small parts of it, from which we infer arbitrarily small functional details about it. This allows us to handle arbitrarily large loops with relatively little complexity overhead.

Once the loop body is structured in CCA form, we can derive lower bounds by looking at one statement at a time, or two statements at a time, or three statements at a time, etc. For the sake of controlling combinatorics, we resolve not to look at more than three statements at a time. To derive lower bounds of loop functions, we scan their loop body written in CCA form, match their statements or combinations of statements against pre-cataloged code patterns, and derive duly instantiated lower bounds in case of a match. We use the term recognizer to refer to the aggregate made up of variable declarations, code patterns, and corresponding lower bound; and we distinguish between one-recognizers that match one statement at a time, two-recognizers that match two statements at a time, three-recognizers that match three statements at a time. The current status of development of the extraction algorithm can be characterized by the following statements:

Our divide-and-conquer approach is heavily dependent on writing the loop body as an intersection of concurrent assignments. The introduction of conditionals (if-then, if-then-else) compromises this regular structure by introducing union operators be- tween the assignments. In order to find a superset of a union, one has to look at both terms of the union, which is at odds with our divide-and-conquer philiosophy, that advocates localized inspections. The theorem below allows us to derive a lower bound of the loop function in the presence of if-then-else statements, without having to look at their then-branch and else-branch simultaneously, but rather in turn.

Generally, the derivation of loop invariants is closely related to the derivation of loop functions since they both aim to discover the inductive argument that un- derlies the behavior of the loop. Furthermore, a theorem by Mills [22] shows how loop functions can be used to produce loop invariants. Also, the generation of lower bounds that we carry out to approximate the function of a loop is reminiscent of the extensive work that has been done and is being done on generating loop invariants [15]. Many researchers in the theorem proving and the program verifica- tion communities have lent much attention to the goal of extracting loop invariants [3,25,5,24,17,4,7,16,6,18,26]. In [10] Ernst et al. discuss a system for dynamic detec- tion of likely invariants; this system, called Daikon, runs candidate programs and observes their behaviors at user-selected points, and reports properties that were true over the observed executions, using machine learning techniques. Because these

