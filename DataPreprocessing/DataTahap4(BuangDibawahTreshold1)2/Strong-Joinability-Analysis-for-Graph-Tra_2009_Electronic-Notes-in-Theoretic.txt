The notion of confluence is prevalent in graph transformation systems (GTS) as well as constraint handling rules (CHR). This work presents a generalized embedding of GTS in CHR that allows to consider strong derivations in confluence analyses. Confluence of a terminating CHR program is decidable, whereas con- fluence of a terminating GTS is undecidable. We show that observable confluence in CHR coincides with

We begin with the introduction of the necessary notions of graph transformation systems and CHR in Sect. 2. Section 3 then presents our proposed encoding of a GTS in CHR, for which Sect. 4 proves soundness and completeness. Finally, Sect. 5 introduces observable confluence and its application as a sufficient criterion for confluence of an embedded GTS, before we conclude in Sect. 6.

Note that the example makes use of the type graph consisting only of a single node with a loop. Furthermore, we use a shorthand notation that only shows the morphisms l and r implicitly by the labels of the nodes which are mapped onto each other. Nodes and edges which are removed or added in the graphs L or R are not labeled, as there is no node or edge in K which is mapped to them.

In order to embed a GTS in CHR, we have to encode its graph production rules as CHR rules and provide a conjunction of goal constraints corresponding to the host graph. To this end, we provide a correspondence between graphs and their representation by CHR constraints given by the constructions in Sect. 3.1. Sec- tion 3.2 presents the encoding of the rules of the GTS for recognizing cyclic lists and a complete example derivation.

We assume all nodes and edges of the type graph TG to be uniquely labeled such that the introduced constraints have unique names as well. Note that when annotating host graphs with these labels they can occur multiple times, i.e. their uniqueness is restricted to the type graph only.

Section 4 discusses the importance of degree variables with respect to the en- coded GTS. Intuitively, nodes using these cannot be removed by a rule application. These nodes prove to be vital for the strong joinability analysis presented in Sect. 5.

In this section we show soundness and completeness of our encoding. Whereas in [9] we showed soundness and completeness only for an encoding corresponding to chr(host, G) we generalize these results in this work for an encoding based on chr(keep, G). The following definitions specify these strictly more generic host graph encodings, as well as some properties of our encoding used throughout the remainder of this section.

In Sect. 3.2 the example shows that during the CHR computations we may encounter states which are not a direct encoding of a host graph. Nevertheless, these states represent a graph G without explicitly specifying node degrees. In order to uniformly argue on all of these states we introduce an invariant on states which, intuitively, is satisfied when a state is an encoding of a graph.

Both graph transformation systems and constraint handling rules provide the notion of a confluence property. This property guarantees that any derivation made for an initial state results in the same final state no matter which applicable rules are applied. This section introduces the necessary definitions used for GTS and CHR confluence before comparing the two notions. It is shown how automatic observable confluence checking in CHR can be reused to yield a decidable sufficient criterion for confluence of a GTS encoded in CHR.

After defining the different notions of confluence we now further investigate the difference between critical GTS pairs and critical CHR pairs for CHR programs encoding a GTS. The following lemma shows that there exists a corresponding CHR overlap for each critical GTS pair. Therefore, by examining the overlaps and using the previous soundness result we can transfer joinability results to the critical GTS pair.

In order to use the graph invariant G for the notion of observable confluence, we have to investigate the properties of this invariant. We introduce the following definitions from [4]. As overlap states themselves may not satisfy the invariant we have to examine all possible extensions that satisfy it [4].

Combining these two results yields the criterion in Cor. 5.11 for deciding G- local-confluence. Note that this decision criterion is essentially the same criterion as used for traditional local confluence, except that the invariant G restricts the set of investigated overlaps.

In practical terms Theorem 5.14 effectively means that the automatic confluence check for terminating CHR programs [2,6] can be reused to prove confluence of a terminating GTS encoded as a CHR program. Due to the earlier results presented in this section we can apply the standard confluence checker only to those overlaps satisfying the invariant G. The possible causes for an overlap to not satisfy G are duplicate node constraints or inconsistent degrees which can easily be checked. If all critical CHR pairs stemming from these overlaps are joinable we know by Cor. 5.11 that the CHR program is G-confluent, and hence by Theorem 5.14, that the GTS is confluent. As no modification is needed for the confluence checker itself this means that by a restriction of inputs to the confluence checker we can decide G-confluence and in turn get a sufficient criterion for GTS confluence for free.

In [9] we have shown that constraint handling rules (CHR) provide an elegant way for embedding graph transformation systems (GTS). The resulting rules are concise and directly related to the corresponding graph production rules. We presented a generalization of this encoding. It allows to model strong derivations that are used to analyze strong joinability.

