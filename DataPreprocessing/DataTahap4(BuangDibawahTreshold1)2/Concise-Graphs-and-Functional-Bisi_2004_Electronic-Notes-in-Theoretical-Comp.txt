We investigate the conditions under which least bisimulations exist with respect to set inclusion. In particular, we describe a natural way to remove redundant pairs from a given bisimulation. We then introduce the conciseness property on process graphs, which characterizes the existence of least bisimulations under the aforementioned method.

We solve this problem by introducing the notion of concise graphs (Sect. 3). If G is concise, then one can construct the least bisimulation between G and H for any bisimilar H (which need not be concise). More precisely, we start with any bisimulation R between G and H and remove the pairs that are not reachable when R is given the transition structure described in [1].

Definition 2.3 Let s be a node in G. A path p in G is called an access path of s if r ~ s, where r is a root of G. The set of access paths of G is denoted AccPath(G). A node s is said to be reachable if it has an access path. Let reach(G) denote the set of reachable nodes in G (with transitions inherited from G).

The next theorem states that the maximal LTS on R satisfies the condi- tion of Theorem 2.7. (This result is also noted in [1].) It is routine to verify this is in fact the largest such structure. In the special case that R is func-

Theorem 3.5 Let R be any bisimulation between G and H. Suppose either G or H is concise. Let S be any process graph with functional bisimulations g :S G and h : S H . Then the restrictions of g and h to reach(S) factors (necessarily uniquely) through reach(R), as shown in Diag. (2).

Theorem 3.10 Assume G is concise and H is bisimilar to G, Moreover, assume that every node in H has at most one access path (i.e., reach(H) is a forest). Then the least bisimulation R (from Theorem 3.7) between G and H is a partial function from H to G, total on reach(H).

In this section, we define four closely related categories of process graphs. The most fundamental of these is the category P of process graphs and functional bisimulations. The category CP is the full subcategory of P consisting of concise process graphs.

Corollary 4.3 Let R be a bisimulation on a process graph G. There is a process graph G/R and a functional bisimulation q : G  G /R such that every functional bisimulation f : G H respecting R factors through q uniquely, as shown.

We now turn to binary coproducts of bisimilar process graphs. We approach this by first taking the coproduct G + H in Set (i.e., disjoint union) for bisimilar G and H. There is an evident process graph structure on G + H, but

P. Suppose, now, that G and H are in RP (CP, CRP, resp.). Then, (G + H)/R is also in RP (CP, CRP, resp.). By fullness and faithfulness of the inclusion, (G + H)/R is a coproduct in RP (CP, CRP, resp.).	 

This coproduct construction may fail without conciseness. Consider again the graph G in Diag. (1) and let R be the swap relation. Then, in (G + G)/R, the two leaf nodes are identified. This is not the coproduct, because there is no functional bisimulation from (G + G)/R to G.

is a reflective subcategory of P. This gives a canonical means of constructing, for each process graph G, a bisimilar concise graph H. This construction should be viewed as an analogue to closure operators on partial orders, with one caveat: The graph H is constructed by taking a quotient of G, not by enlarging G. Following this task, we comment on the categories of restricted process graphs.

It is clear that obviously concise graphs are concise. In practice, the spec- ification of a concurrent system often generates a relatively small state graph; hence it will be feasible to check whether the specification is (obviously) con- cise. This raises hope that we can apply our results about least bisimula- tions to prove properties between a specification and its implementation, even though the latter may not be concise.

Aside from such broad aims, our work here leaves open a number of specific questions. First of all, we are not completely satisfied with Theorem 3.8. It says that conciseness characterizes the existence of least bisimulations under the reachable part construction. However, it is unclear whether conciseness is also a characterization for general existence, i.e., without reference to any particular construction. It would be nice to find a necessary and sufficient condition on G so that the least bisimulation between G and H exists for any bisimilar H.

Finally, we would like to compare our categories of process graphs to the well-developed models of parallel computation in [8]. On the one hand, one may ask whether conciseness leads to useful subcategories in their setting. That is, whether conciseness yields interesting constructions if we take our morphisms to be (generalizations of) functional simulations as in [8]. On the other hand, we can use the approach taken in [4] as a guideline for our consideration of weak bisimulations.

