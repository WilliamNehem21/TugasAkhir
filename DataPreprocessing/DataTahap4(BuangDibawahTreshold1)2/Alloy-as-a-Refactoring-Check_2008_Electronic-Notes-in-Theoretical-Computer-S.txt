addition, besides referring to the actual process of changing software, refac- torings are also generic descriptions of how the program should be modified. A popular book by Fowler [6] presents a collection of 72 refactorings to sys- tematically improve the structure of (object-oriented) code. Still, refactorings are not limited to programs only. They are also used in modelling, for instance for refactoring UML models [14,20], or formal specifications [10,11].

In the following section we start with a small example of a Z specification and present its translation into the Alloy language. Section 3 explains why the Alloy Analyzer cannot be used to verify refinements and identifies the conditions under which refactorings can be checked nevertheless. We discuss some limitations of the translation in section 4 and conclude in the last section, along with a review of related works.

The declarative specification language Alloy [8,9] is developed by the Software Design Group at MIT CSAIL. Unlike Z, it is strictly based on first order logic which facilitates automatic analysis. The Alloy Analyzer [12] provides fully automatic simulation and checking on specifications written in Alloy. It translates a given model into a boolean formula [7] and hands it to a SAT solver. The solver then tries to find a model of this formula. All examples we show in this chapter refer to the Alloy Analyzer in version 4.0 RC11. It is available free of charge at [12].

There is a solid theory on how refinements can be proven in Z. With the aid of a downward simulation, we can show that a Z data type C refines a data type A. With I being a fixed set of operations, [4, p. 90] gives a definition:

In order to clarify the existential quantification problem, we start out with an example used by Daniel Jackson [9, p. 156]. Suppose, we want to check that sets are closed under the union operator. We write a model to specify sets:

Working with integers in an Alloy model is somewhat inept. One reason is that Int is handled like every other signature. This means, it does not contain integers but atoms representing numbers. In order to get the numerical value of an atom a, the function int[a] has to be used. In contrast, the function Int

Another reason is that we cannot exactly specify the range of the integers we would like to use. By default, the scope of Int is set to 4 int. This is 24 = 16 integer values, ranging from -8 to 7. In a scope command we are only allowed to set the integer bitwidth. Hence, the next bigger scope will be 5 int with values from -16 to 15.

A motive for this limited integer support are technical issues. The Alloy Analyzer translates a model into a CNF formula and hands it to a SAT-Solver. Encoding numeric manipulations into CNF as well as converting from Int to int (and vice versa) is expensive. Therefore, Alloy is not well suited to work with heavily numerical specifications.

Alloy signatures allow some sort of inheritance which is very useful in its own right (cp. [9, p. 91]). Nevertheless, this concept cannot generally be utilised to implement the schema operations available in Z. Examples for schema op- erations are schema conjunction and schema extension. In order to make a translation possible, we suggest to resolve all schema calculus operations on state schemas before translating the Z specification. This means, a single state schema containing all state data needs to be constructed. We must consider, though, that the information about schema operations will be lost in case of a retranslation.

In this paper we investigated how Alloy can be used to check behaviour- preservation of refactorings. We demonstrated that the translation from a Z specification into the Alloy language is mostly simple and intuitive but at the same time has its limitations. Especially the existential quantifier produces problems within the translation and, even worse, prohibits a simple verification of refinements. Nevertheless, we were able to show that the Alloy Analyzer can be used to check the correctness of refactorings as long as we assume a total bijective representation relation between the original specification and the refactored one. This assumption is legitimate for a lot of refactorings.

The Z specification language has often been criticised for its lack of verification tools. Alloy fills this gap by offering the desired kind of fully automatic analysis, at least to a certain degree. The great conformity of the two languages often allows an easy translation and it can thereby support the process of writing specifications. With respect to the idea of building a refactoring-tool that uses Alloy or any other model checker only as a back-end system, however, an elegant translation is not significant. Instead, it would be necessary to identify if our assumption of a total bijective representation relation prohibits the checking of practically relevant refactorings. Probably even more important would be a performance analysis comparing the Alloy Analyzer to other model checkers like SAL. We leave this as future work.

