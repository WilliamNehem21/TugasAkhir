As a special class of fair exchange protocols [20], a CEM protocol is supposed to guarantee fairness with respect to non-repudiable evidences. Informally, at the end of a fair protocol run, either both parties acquire all the evidences, or no party gets an evidence. A trusted third party (TTP) can be introduced to take charge of the whole procedure and to provide undeniable records of submission (of the sender) and delivery (of the receiver). However in this way, a TTP may easily become a bottleneck, if she has to be involved in a large number of CEM services.

The structure of our protocol consists of an exchange sub-protocol, an abort sub- protocol and a recover sub-protocol. The exchange sub-protocol is executed by the communicating parties to deliver an email as well as exchanging undeniable evidences. The other sub-protocols are launched by a party to contact a TTP to deal with awry situations. Each exchange that uses the protocol is called a protocol round, and one initialisation phase followed by a number of protocol rounds is called a protocol session. Each protocol session belongs to a unique pair of communication parties.

Recovery sub-protocol. Alice is allowed to launch the recovery sub-protocol provided she has sent out message 3ex, but has not received message 4ex. Similarly, Bob can launch the recovery sub-protocol if he has sent out message 2ex, but has not received message 3ex. The first message of the recovery sub-protocol for Alice is

Parallel composition p  q interleaves the actions of p and q; moreover, actions from p and q may synchronise into a communication action, if explicitly allowed by a predefined communication function. Two actions can only synchronise if their data parameters are the same, which means that communication can be used to capture data transfer from one process to another. If two actions are able to synchronise, then in general we only want these actions to occur in communication with each other, and not on their own. This can be enforced by the encapsulation operator

Communication is modelled using shared variables. Evidences (EOO and EOR), key and emails are modelled as boolean variables which are initialised as false and updated by its sender. We model the action of sending out an evidence, or other messages as a guarded command in which the sender resets the corresponding vari- ables as true. In the model for honest participant PiH, the guard consists of all the conditions to be satisfied strictly according to the protocol, and the command consists of all the corresponding actions to be executed. However, for the dishonest Pi, the guard just consists of necessary messages to generate the message to be sent. List. 1 gives the Mocha code describing the behaviours of honest Alice. At first, Alice can do idle actions after she initiates a protocol round by sending out EOOM . For honest Alice, she mainly performs two kinds of actions in the exchange sub- protocol, which includes sending evidence of origin and the key. They are described in step (1) and (2). Step (1) models the action of sending EOOM , in which we use boolean variables hk and pa eoo to represent the hashed value of Kj and the message

List. 3 models the corresponding behaviours of TTP. TTP is a special player that has to be modelled in a particular way. It must be objective, and cannot act in collusion with protocol participants. We build the model for TTP that strictly

It has been acknowledged that formal verification is important for security protocols, because of the seriousness of security flaws. In this paper, we use the technology of model checking to check automatically whether a given model of CEM protocols satisfy some given specifications. To our knowledge, the literature of formal veri- fications of CEM protocols includes the works of Kremer et al. [13], Cederquist et al. [8] and Abadi and Blanchet [1].

Kremer et al. [13] propose an approach for modeling and analysis of CEM pro- tocols using model checker Mocha. The advantage of using Mocha is that it allows to model CEM protocols with concurrent game structures, and specify properties in ATL, a temporal logic with game semantics. Therefore, Mocha is well suited for checking properties such as fairness, timeliness and effectiveness that can be naturally interpreted with game semantics. For similar reasons, Mocha has been

