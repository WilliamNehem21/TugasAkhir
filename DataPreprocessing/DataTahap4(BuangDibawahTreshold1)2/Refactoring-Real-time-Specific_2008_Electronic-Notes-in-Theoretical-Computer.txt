The way in which we structure an abstract specification of a system is often quite different to the way in which we structure its implementation. Generally, an implementation will have many more interacting components. Including such architectural details in an initial specification may obscure the essential functionality and complicate reasoning. Additionally, the final implementation architecture may not be able to be predicted until further into the development process.

The need for introducing design into specifications is also important in the domain of real-time embedded systems, i.e., systems where software compo- nents interact with a continuously changing non-software environment. Typ- ically, components such as clocks, although central to any implementation, are ignored in abstract specifications of such systems. Also, sensor devices (distinct components in an implementation) are commonly modelled as sim- ple inputs to another component at the specification level. Hence, a means of refactoring real-time specifications is desirable.

Real-Time Object-Z [17] is an extension of Object-Z which enables the specification of real-time embedded systems. It adds the notation of the Timed Interval Calculus (TIC) [4] to Object-Z enabling real-time constraints and interactions with a continuous environment to be specified. In this paper, we adapt the Object-Z refactoring approach of McComb and Smith to Real-Time Object-Z. To do so, we first need to define a semantics of objects in Real-Time Object-Z as the current definition of the formalism does not support object instantiation.

The paper is organised as follows. In Section 2, we introduce Real-Time Object-Z using a speedometer example. In Section 3, we introduce object instantiation to Real-Time Object-Z and, in particular, provide a means of specifying synchronisation between operations in different objects. In Sec- tion 4, we discuss the adaptation of the Object-Z refactoring approach and refactor the speedometer example to reflect a particular design. In Section 5, we examine the issues of refinement and compositionality that arise from our semantics of objects before concluding in Section 6.

of operation occurrences (modulo the retrieve relation) and hence the possible real-time histories of the class, YOZ (O ). Similarly, refining the TIC part of a class restricts the real-time histories of the effect E , YTIC (E ), and/or increases the real-time histories of the assumption A, YTIC (A). The overall effect of refining either part of a class, therefore, is to restrict the real-time histories given by Y(C ).

The class has an operation Count which conjoins two operations to increment the count (IncCount) whenever the object clock performs a ClockPulse op- eration (clock .ClockPulse). Similarly, CalculateSpeed conjoins an operation to calculate the new speed (NewSpeed ) whenever the object sensor performs a WheelPulse operation (sensor .WheelPulse). Initially, the count is set to a large enough value so that the first speed calculation, when the wheel starts rotating, will be zero. Also, the object clock is initialised. The details of class Clock and WheelSensor will be seen in Section 4. Note that there are no TIC predicates in Speedometer as the timing constraints appear in the other classes.

Unlike Object-Z, however, the current definition of Real-Time Object-Z does not support object instantiation. In Object-Z the type of an object is the set of histories of its class. That is, the value of an object at any instant is a single history denoting the operations the object has undergone and the states it has passed through.

In Real-Time Object-Z, the situation is not as straightforward. If the start or end time of the operation P , and hence S 6 , are precisely defined, for example, then the migration to object a will remove this constraint from S . The constraint will be part of a.P and, under the semantics of synchronisation of operations, S need only share a time with a.P (not necessarily its start and end times). Hence, we will not have a refinement, since there will be more possible times that S can occur and hence more, rather than less, real-time histories.

Again we have a refinement due to the explicit duplication of the predicate which constrains when WheelPulse can be occurring in NewSpeed . Note that the duplicated predicate refers to the wheel angle? input of sensor (since this is the one that is used to constrain the timing of sensor .WheelPulse). The effect predicate on sensor .WheelPulse and the synchronisation of this operation with CalculateSpeed ensures the original constraints this effect predicate had on CalculateSpeed (through WheelPulse).

We are now in a position to significantly simplify all three class definitions. In Clock and WheelSensor , we can remove features which are not referenced. Since these classes were introduced by our process the only class referencing them will be Speedometer . Hence, the removal of the features will have no effect on the semantics of the specification. In Speedometer , we can remove

operations which we introduced in the orignal refinement and which have been migrated to Clock and WheelPulse. Since the specification did not reference these before we began the refactoring process, their removal will again have no effect on its semantics. In addition, below we assume that the origial spec- ification did not access the enviornmental input wheel angle? of Speedometer allowing its removal as well.

Given the semantics of operation synchronisation in Section 3, the specifica- tion of the previous section ensures that the operation Count of Speedometer overlaps in time with the operation ClockPulse of the object clock . Similarly, the operation CalculateSpeed of Speedometer overlaps in time with the op- eration WheelPulse of the object sensor . This notion of overlapping is very loose, however, and does not precisely capture the timing or causality of the synchronisations. For example, the ClockPulse operation of the object clock needs to occur first and trigger the Count operation of Speedometer .

CountTime communicates the value of the variable overlap! to ClockPulse and IncCount through the Object-Z parallel composition operator. In Object-Z, the parallel operator (  ) unifies output variables with input variables where the basename is shared, and hides those variables. In this case overlap! is unified with overlap? in the latter operations and hidden.

