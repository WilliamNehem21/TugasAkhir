In this paper, we advocate for a seamless design-flow for embedded reactive programs. We particularly concentrate on the use of assume-guarantee contracts (as a form of non-deterministic specification) and present how these can be used for early execution of reactive specifications. We illustrate the approach on a case-study taken from an avionic application, trying to show the implications of this simulation method on the design-flow.

Reactive systems, as defined in [11], are characterized by the interaction with their environment being the prominent aspect of their behavior. Software embed- ded in aircraft, nuclear plants or similar physical environments, is a typical exam- ple. They interact with a non-collaborative environment, which may impose its own rhythm: it does not wait, nor re-issue events. Synchronous languages [2] rep- resent an important contribution to the programming of reactive systems. They are all based on the synchronous hypothesis that establishes that communications between different components of a system are instantaneous and, more importantly, that computations performed by components are seen as instantaneous from their

In software engineering in general, an answer to the increasing complexity of systems has been the definition of complete design flows. These describe the differ- ent steps in the development of a system, and associate to each of these steps some informal or formal method to help validate the system as it is developed. An inter- esting approach consists in following a continuous path from the early prototypes towards the final product. Each new step in such a design flow can be automated, or at least some form of consistency can be checked between successive versions. An important validation feature of such methodologies is the use of simulation tech- niques, by which a developer can observe the possible behaviors of the system in its current status of development, without having a full implementation yet at hand.

Section 2 presents a subset of the Lustre language that we will use for describ- ing our running example. Section 3 introduces a system example. Through this we illustrate the progressive design-flow that we introduced earlier. Starting from the general description of the architecture of the application in 3.1, we gradually refine parts of the system by giving contracts and final deterministic implementations of some components (3.2). Section 4 introduces a formalization of components and describes the approach we propose for simulating networks of deterministic and non-deterministic components. Section 5 describes a simple implementation of this framework that uses existing tools and discusses the practical problems raised. Sec- tion 6 discusses related works while section 7 concludes and introduces possible future work.

We first define a language for programming reactive systems. It is a light version of the Lustre language [8]. Programs manipulate lists of variables. Given two such lists V and V', we use V&V' as the concatenation of V and V'. We will use this for describing our running example.

introduced in [21], that can be seen as limited higher-order operators. The syntax map  N, n  defines a mapping operation of a node N that is applied on n- elements arrays. red N, n defines a reduction (similar to fold in functional languages) that iterates the node on n-elements arrays . In the current work, we

Note that we also need an initialization property, because the guarantee de- pends on some past values that are not available during the first instants of the execution. The global guarantee of the channel is encoded by a call to node during then (initProp, TIME, normalProp) which states that initProp holds during the first TIME instants (TIME is a constant) and then normalProp holds for the rest of the execution. A contract for the Voter can also be designed, but we will not give it here, for obvious space reasons.

We also give a description of the environment of the whole application to be able to do simulations. The simplest environment env takes as inputs the AxisValue com- puted by the Voter and gives some channel inputs back to the channels. Describing such an environment is a complex part of the application design, but we will not concentrate on it here. We will assume that such a description is given in the form

We start with a set of variables V, taking their values in a domain D, intended to represent the state of a dynamical system. The semantics of a reactive system is given in terms of step-relations. Intuitively, a step-relation relates two valuations of V, that are intended to represent the valuations at two successive instants in time. Then we define components on top of step-relations. Variables may be typed. However, we forget about the typing mechanism, which is necessarily particular to the language in which step-relations are described.

The previous semantics gives us a denotational characterization of our deterministic components, as well as of assume-guarantee contracts. From a simulation point-of- view, we need a way to describe operationally the generation of traces of values that satisfy these specifications. Practically, we need to be able to describe a component C by some functions initC(), computeOutC() and updateStateC() that can be used to build those traces. The exact implementation of these functions depends on the form of each component.

a constraint that should be checked at each instant on input values. We thus define a boolean function checkAssert() that takes current values of the input variables of the component and checks whether those values satisfy the constraint it represents. This test function can be compiled out and used whenever the component is to be activated. The non-deterministic aspect of the assertion is left aside here since it is not used to actually generate values.

Now, we are able to associate to each component Cj a function computeOutCj() and a function updateMemCj(). Whether the component is deterministic or not, there is no difference in how we consider it in the writing of the simulation algorithm. The only difference, as noted earlier, is in the way the computeOut will be implemented.

RML is a language designed for the implementation of reactive systems. It combines the synchronous paradigm found in the Esterel with the classical features found in asynchronous settings (such as dynamic creation of processes). It is built on top of OCaml, and thus benefits from its power of expression. An extension of RML has been recently developed in which one can describe the behavior of a particular component in Lucky. This extension was first designed to allow the description of non-deterministic environments for RML programs. The mechanism used is as follows. At each time tick, the RML code is executed. When it comes to executing the Lucky environment, the RML program calls the Lurette tool so as to produce the environment new outputs. The solving of the non-deterministic aspect of the environment is totally delegated to Lurette. In the paper, we have

The whole system could be described in Lustre. Here we benefit of the existing connections between the tools. The translation of Lustre contracts into Lucky automata is not an obvious process, and was performed in an ad hoc manner here. Full automation of this translation should be studied. Limitations would certainly appear in the general case.

to Java in which certain part of the behavior of the system can be expressed using constraints on program variable. Upon simulation, these constraints are interpreted in a way similar to what Lucky does in our case. Finally, this work can be seen as an attempt to propose a methodology impact of the work presented in [23]. There, the author proposes a simulation framework for arbitrary synchronous data-flow networks where non-deterministic components are expressed directly in the Lutin language. Our approach is only different with respect to the language used (we use assume-guarantee contracts which are a strict subset of Lutin). The exact same simulation algorithm can used (the one implemented in Lurette). We are interested in defining a particular usage of these simulation techniques in a contract-based design flow. Probably, an interesting extension of this work would be to allow description of contracts by couples of Lutin components.

It was not shown in this example, but it is trivially possible to plug in additional input generators or observers that are not directly part of the system itself but that can significantly help in its development. These can be described as Lustre nodes or observers and can then be simulated in the same manner. In that sense, this approach seems quite promising.

We still would like to push it further in several directions. The first one concerns tool support. As we mentioned earlier, the translation from Lustre to RML is performed manually. We would like to either automate this translation or preferably work directly in Lustre. One idea we would prefer would be to integrate the use of the Lurettetool in a debugger like Ludic [17]. More important issues concern the

expressiveness of the languages used. First we would like to extend this approach to consider the probabilistic part of Lucky. This is a feature which has proved very useful in testing [23], and we believe it should be incorporated in our framework. It would then mean finding a good way of expressing these probabilistic behaviors as contracts. Second is the extension of this approach from purely synchronous systems to GALS (Globally Asynchronous, Locally Synchronous) systems. From a language point of view, it would be interesting to see how our contracts can be used for specifying GALS systems (using the work of [7] as a basis). We will study the application of our simulation method to these systems.

