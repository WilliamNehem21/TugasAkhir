In system modeling simulation performance usually improves when we move to more abstract models [9]. In software development it is often the opposite; abstract models suffer an abstraction penalty [25]. As a modeler abstracts, performance may, at some point, begin to degrade. One goal is to ameliorate the abstraction

Excellent overviews of pipelining, hardware implementation techniques, and tax- onomies are described in [17,15]. The compiler research community has developed high-level notations for pipelines to generate instruction schedulers [5,20]. Our no- tation is inspired by that of [20]. The work in [1,13,14] describes notations for specifying pipelines for downstream tools. Mishra and Dutt [18] describe how to validate a pipeline specification written in the architectural description language [10]. Petri Nets [21] and Process Algebra [11,12] have been used to model and simulate pipelines.

SystemC is a discrete event modeling and simulation language for designing hard- ware/software systems [22,19]. SystemC modules have ports connected through channels. SystemC has predefined channels for hardware like wires (sc signal) and higher-level channels such as blocking FIFOs. Users can also define their own channel types. A SystemC module is a class that inherits sc module. Modules can contain threads (SC THREAD) or methods that fire on event changes (SC METHOD). SystemC also has a large library of hardware data types including bit vectors and fixed-point types.

A pipeline expression defines the route a transaction follows through a pipeline. In a static pipeline this route is fixed. In a multi-function static pipeline there may be two or more different transaction types each with a different route. The language

Stage hard-codes a performance model of a one nanosecond delay. A trivial way to generalize this is to allow the user to pass an integer through the constructor and use that as the delay. This assumes that the performance model will be a simple wait statement and nothing more complicated; not very general. Additionally we might want to support an untimed model where we would expect there to be no simulation performance penalty in calling wait. One way to do that is to ensure that the call to wait is removed by the compiler for untimed models. We define two timing policies TimedPolicy and UntimedPolicy fully aware that the modeler could design more complicated policies.

Ashok Halambi, Peter Grun, Vijay Ganesh, Asheesh Khare, Nikil Dutt, and Alex Nicolau. Expression: A language for architecture exploration through compiler/simulator retargetability. In Proceedings of the European Conference on Design, Automation and Test (DATE). IEEE Computer Society, IEEE Computer Society, March 1999.

