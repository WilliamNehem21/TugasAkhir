Here, improvement of structure refers to object-oriented structuring (i.e. class hi- erarchies) in as much as the same way as to modularisation of classical imperative programs. Nowadays, refactoring is a technique which is not only applied on pro- grams but also used in modelling, for instance for refactoring UML models [21,17] or formal specifications [12,13]. For a survey on software refactoring see [15].

The paper is structured as follows. We start with a small example of an Object-Z class on which we illustrate four different refactorings of methods, and on which we discuss our notion of behaviour preservation. Section 3 will then give a short introduction into SAL and show how to check correctness of refactorings with SAL. The last section concludes and discusses other type of refactorings, in particular with respect to the notion of correctness needed for them.

Refactoring is a method for modifying software without changing its behaviour. Using refactorings is common to software developers, but it is also useful to refactor formal specifications. In the following we give an example Object-Z specification and discuss some refactorings on it.

When applying refactorings to specification or programs, structural differences between the refactorings can easily be seen. Some refactorings change methods in- ternally and leave all other components of the class untouched. Other refactorings change parts of the class hierarchy and leave classes outside their range unchanged. A classification of refactorings might thus consider their scope as the main differen- tiating criterion. We found four scopes on which refactorings operate:

The Symbolic Analysis Laboratory (SAL) [3] is developed by the Formal Meth- ods Program at SRI International. It is a framework combining different tools for program analysis, theorem proving and model checking of state-transition systems. Currently SAL provides four different model checkers, one of them for checking CTL properties [9], a simulator and some other tools which all work on the same input language, called SAL language.

The SAL language was developed as an intermediate language, serving as a tar- get platform for translators of high-level languages like Java. Therefore it supports a wide range of type definitions and expressions. Nevertheless, the SAL language can also be used to describe transition systems in their own right. It is not that different from languages used by verification tools like SMV, Murphi or SPIN. A complete specification of the SAL Language can be found in the SAL Language Manual [4]. At this point we introduce some of the basic constructs necessary to understand the SAL encodings of our Z specifications.

Comments are preceeded by the % symbol and terminated by an end-of-line. The SAL Language is case sensitive and reserved words like CONTEXT, BEGIN and END are written in capital letters. In the following we explain the parts of our SAL specification step by step.

SAL supports built-in basic types like BOOLEAN, NATURAL, INTEGER or REAL. All of them can be used with the infinite-bounded model checker of the SAL toolbox. But as the CTL model checker works on finite types we have to declare our own types by implementing them in the form <Name>: <Type>. To define a new type we use the following construct <Name>: <Type>= <Expression>, which can also be used to express functions. In our example we have defined our own natural and integer types (Int, Nat) as well as a function to negate a natural number.

If a transition with such an command is executed we get 5 successor states with values for currentTemp between 58 and 62. Hence guarded commands are much more powerful constructs than just simple if..then expressions. As described in [20] we use them as an universal method to encode predicates of Z schemas into SAL.

Finally, attention should be paid to the last guarded command ELSE --> in our example. To receive correct results from the modelchecker it is necessary that the transition relation is total such that a module cannot deadlock. This special guard evaluates to true iff all other guards evaluate to false and leaves the states unchanged.

The starting point is the SAL specification of our original class. In a first step we have to solve the problem that CTL does not allow propositions referring to operations. Therefore we augment State : Exp by a variable ev . Furthermore we

It may appear irritating that we consolidate the two methods which we have split during the refactoring. Nevertheless we must not forget that this is only an effect of the translation between Z and SAL. Imagine a tool that creates correct SAL code for any Object-Z specification it will reveal us any failure in an inner method refactoring.

