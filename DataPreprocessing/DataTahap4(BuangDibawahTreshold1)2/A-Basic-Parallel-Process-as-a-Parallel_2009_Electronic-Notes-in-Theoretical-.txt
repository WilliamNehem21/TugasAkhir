In this paper, we study the class of basic parallel processes. This class was in- troduced in [7] as the class of all processes that have a finite guarded recursive specification over the small process algebraic language with 0, action prefix, choice and parallel composition without communication (just interleaving). More work about this class can be found in e.g. [8,11]. Some results correspond to analogous results in formal language theory, such as the fact that every basic parallel language can be presented as a parallel pushdown automaton (a pushdown automaton not with a stack but with a bag, a multiset of variables).

We investigated the set of context-free processes (defined with 1) in [4]. There, the addition of 1 makes an essential difference: a process can be defined that has unbounded branching, something that cannot be done without 1. Furthermore, we established in [4] under what conditions a context-free process can be presented as a pushdown automaton. In this paper, we investigate a similar result for the class of basic parallel processes. For basic parallel processes, the added expressivity is less spectacular (a corollary of our main theorem is that basic parallel processes have bounded branching, even those including 1), but still, without 1 a bag process expressed as a basic parallel process cannot be tested for being empty. In general, adding 1 makes that the theory becomes more challenging, and in our opinion also more interesting.

Another difference between automata theory and process theory is that pro- cess theory allows us to make communication explicit and abstract from it modulo branching bisimulation. In a setting with explicit communication, a pushdown au- tomaton can be seen as a regular process communicating with a stack. Since every context-free process can be realized in this way, and the stack is a context-free process itself, we can look upon the stack as the prototypical context-free process. Similarly, we show in this paper that every basic parallel process can be presented as a regular process communicating with a bag, a multiset of data elements. Since the bag is a basic parallel process itself, it can be seen as the prototypical basic parallel process.

with the definition of the notion of transition system from process theory. A finite transition system can be thought of as a non-deterministic finite automaton. In order to have a complete analogy, the transition systems we study have a subset of states marked as final states.

These two observations are the reason to restrict to guarded recursive specifi- cations only. It is well-known that a guarded recursive specification has a unique solution in the transition system model (see [6,5]), and we show later on that this solution is also finitely branching. This restriction leads to our following definition of the basic parallel processes, a subclass of the parallel processes given by recursive specifications over CA.

Now we prove the following lemma, which is crucial for the main proof. This lemma expresses that if the finite control is at a point where it can choose a variable from the bag, it does not make the actual choice. The choice is determined by the first action that is performed by a candidate variable. It also shows that when this has happened, this particular variable has also been removed from the bag.

explicit. As a result, we can see the bag as the prototypical basic parallel process. As a corollary, we established that every basic parallel process has bounded branching. This is in contrast to the situation with context-free processes. We saw in [4] that context-free processes can show unbounded branching. For a context-free pro- cess with unbounded branching, we cannot show it is rooted branching bisimilar to a regular process communicating with a stack. We could only show this in con- trasimulation. Here, for basic parallel processes, the situation is simpler, and we

Finally, note that the addition of 1 allows termination exactly when a bag is empty. This check on emptiness is not possible without 1. This is different from the situation with a stack, where a check on empty is also possible in an ACP-style language.

