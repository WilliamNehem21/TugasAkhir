cally started proctype. To fix |si| all variables are padded to the size of an integer using compiler directives. The introduced overhead is mitigated by pins as our per- formance and memory benchmarks show (Sec. 4). Sec. 3 shows how Mr can be encoded in the model.

ified that indeed all these models are correctly explored by our tools (see Sec. 4). To this end, we had to turn off control flow optimization (-o3) in some cases, due to its limited implementation in SpinS. The following subsections present different verification strategies on these models with LTSmin and give some background on the used algorithms.

For parallel LTL model checking, we can use our latest and best multi-core NDFS algorithm CNDFS [6]. While this algorithm is heuristic in nature, we found that on a large set (over 400) of examples it scales rather well, i.e., speedups of 10 to 48

Symbolic model checking. The tool prom2lts-sym implements symbolic model checking, learning the symbolic transition relation on-the-fly [2]. This approach also works well on models with high locality. As such models have a sparse pins de- pendency matrix, our reordering algorithms (-rga) can optimize them further for BDDs. Using a chaining heuristic [3], we can explore > 1020 states in a second: prom2lts-sym -rga --order=chain peterson5.prom

counter-example [8] and owcty typically explores a large portion of it [6, Sec. 4.2], and CNDFS is found to return even shorter counter-examples than a parallel BFS- based algorithm [6, Sec. 4.3]! On the other hand, the BFS-based algorithms owcty and PB can be distributed on a cluster, as DiVinE demonstrates [1].

