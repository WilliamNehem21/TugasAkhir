LR parsing [11] is a powerful tool in the toolbox of the language designer. It provides a parsing algorithm that works in linear time for a wide range of context-free grammars. The theory of LR parsing has been explored in numerous works and it has become a standard part of lectures and textbooks on compiler construction [1]. It also forms the foundation of a whole range

While there has been some evolution of the tools with respect to modular- ization of parsing actions and integration of the specifications of parsing and scanning, the actual raw matter, the grammar, remains in its original form in the parser specification. Since large grammars may well run into several hun- dred productions, grammar maintenance can become a tedious task. Hence, it is surprising that none of the parser generators has a facility for introducing abstractions over grammar rules.

used like functions. They can be invoked with actual parameters in the right- hand side of a production. Some care must be taken to restrict the actual parameters suitably, for example, to only one nonterminal or one formal pa- rameter. Without restriction to the actual parameters, we would obtain the notion of a macro grammar which is strictly more powerful than a context-free grammar [4].

Before developing the theory of parameterized LR parsing, we make an excur- sion into formal language theory to introduce the reader to macro grammars and macro languages in Section 2. After defining a suitably restricted notion of macro grammar, Section 3 introduces the basic definitions for parameterized LR parsing. Section 4 defines the parsing algorithm, starting with a non- deterministic specification and then defining the notion of conflict to obtain deterministic parsers. Section 5 is devoted to attribute evaluation. It defines a type system that assigns polymorphic types to parameterized nonterminals. Section 6 describes our implementation of parameterized LR parsing in the

3 The definition we are giving above is not the one that has been used to obtain the cited results. The original definition considers strings as trees build from monadic operators (the characters) so that standard nonterminals in a context-free grammar are also monadic operators serving as placeholders for trees. In a macro grammar, nonterminals receive additional parameters that range over monadic operators. Adding further parameter sets leads to higher levels in the mentioned hierarchy.

Hence, restricted macro grammars with OI reduction define exactly context- free languages. The restriction that actual parameters are either single nonter- minals or formal parameters is less severe than it may appear. Alternatively, the actual parameters may be restricted to either a single formal parameter or an arbitrary word over terminals and (nullary) nonterminals. Such a gram-

Example 2.4 A restricted macro grammar for a fragment of the grammar of JavaScript [9] expressions serves as running example. The fragment encom- passes constants, c, array literals enclosed in [ and ], as well as object literals enclosed in { and }. Array and object literals both contain comma-separated lists modeled with the parameterized nonterminals L and N . Object literals consist of key-value assignments as described by nonterminal A. Terminal

In traditional LR parsing, the state of a parser is the closure of a set of kernel items. In parameterized LR parsing the state of a parser is a mapping from tuples of nullary nonterminals to a set of PLR(k) items. The notion of closure corresponds to a notion of consistency of a state.

Parser combinators [20,8] are a highly flexible way of specifying parsers in functional programming languages. In particular, the use of polymorphic functions and parameterized parsers is a natural way of structuring code with parser combinators. In contrast to the present work, they perform predictive or top-down parsing. Recent advances [19] have widened their scope consider- ably with respect to earlier, inefficient proof-of-concept implementations. The present work makes some of the polymorphism and flexibility that make parser combinators attractive available to the construction of LR parsers.

The syntax definition formalism SDF [22] supports arbitrary context-free grammars and creates GLR parsers [12,21,15] for them. For convenience, right-hand sides may contain an extended set of regular operators. An SDF specification also defines a lexical syntax. SDF includes an abbreviation mech- anism which works by expansion.

One reviewer mentioned van Wijngaarden (or W-) grammars [23], a Turing- complete parameterized grammar formalism used in the definition of AL- GOL 68. Conceptually, W-grammars consist of two-levels. The first level defines context-free languages of interpretations of grammar symbols. These interpretations are used to generate the actual grammar productions by substi- tution into rule templates. However, W-grammars are a conceptual modeling tool and are not geared at generating efficient recognizers. Rather, they have been designed for describing context-sensitive aspects of programming lan- guages. They lack the conciseness and ease of use of direct parameterization, which is a familiar concept from programming practice.

