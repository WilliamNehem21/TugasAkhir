Over the last decade, software architecture emerged as a critical issue in Software Engineering. This encompassed a shift from traditional programming towards software development based on the deployment and assembly of independent components. The specification of both the overall systems structure and the interaction patterns between their components became a major concern for the working developer. Although a number of formalisms to express behaviour and to supply the indispensable calculational power to reason about designs, are available, the task of deriving architectural designs on top of popular component platforms has remained largely informal.

Note that class M implements the context for process M , by declaring and grouping its two actions, but still, it does not capture its behaviour. In fact, there is no method invocation order subjacent to class M, whereas in process M one can only perform method coffee() after method coin() has been activated. Even more, in process M the execution of method coin() is immediately followed by a single execution of method coffee(). The speci- fication does not allow, for example, that several calls to coin() precede the coffee() call or that several calls to coffee() follow a coin() insertion.

Interaction restrictions within a process are handled in CCS by the new com- binator. Its implementation at the prototype level resorts to the accessibility mechanisms of the .Net platform. Thus, for every variable in the scope of a CCS restriction, the corresponding method is set to an internal method, rather than to a public one, as used so far in our toy example.

Both ways provide an encapsulation of the entire system and a simple way to test it. They rely on the introduction of an additional class, called the sys- tem interaction class. This class encapsulates the entire system, exposing only its free variables and ensuring a correct execution order for all the assembled processes.

The buildSystem function relies on several auxiliary functions, but three of them really constitute the building blocks where the entire Automatic Trans- lator stands upon. These functions analyse the CCS specification and were already mentioned above as central functions for an automatic implementa- tion. They are, respectively, getFinalPorts, which computes all the final ports of a given process, getInitialPorts, which computes all the available initial ports when a process executes and finally portPreds, which finds all the possible preceding ports of a given port in a given system.

skeleton architecture in .Net, one has to perform the two-phase procedure described in the previous section. For illustration purposes, we shall consider here process Signal in some detail, and abstract a little of the entire system, though some calls to other processes which interact with Signal will appear in the implementation. A similar procedure applies to the other processes.

Function buidSystem relies on many other functions, many of them work- ing exhaustively with strings and string manipulation. To improve this sort of operations a new type ShowS = String -> String was introduced. The ad- vantage of resorting to ShowS values, instead of directly working with String, is that functional composition with ShowS maintains linear complexity in func- tions dealing with many string concatenations.

The resulting implementation of the process specification must then be stimulated with the initial action string (in this case the empty string), and the result written to a .cs file or passed to other function. The result of applying function buildSystem is the different .cs files implementing each process defined in the CCS specification. For example, Signal.cs contents is as follows:

Note that every method receives a boolean value. This has to do with cross reference calls when treating calls to complementary actions. Its objective is to prevent the system to get into an infinite loop when complementary actions are called. This is achieved by forcing false as an argument in every user call to a method. Only internal calls use the value true to call other com- plementary actions. This protocol guarantees that each method can inspect if it is being called by an internal call and therefore not needing to call the method that called him again from users calls that do need to check if there are complementary actions to be called.

skeletons, able to be re-used in architectural design. Recall that a software connector [7,5,2] is an abstraction intended to represent the interaction pat- terns among components, the latter regarded as primary computational el- ements or information repositories. The aim of connectors is to mediate the communication and coordination activities among components, acting as a sort of gluing code between them. Examples range from simple channels or pipes, to event broadcasters, synchronization barriers or even more complex structures encoding client-server protocols or hubs between databases and applications. All of them can be specified in a process algebra notation (as in, e.g., [1,12]) and, therefore translated to .Net skeletons.

D. Garlan. Formal modeling and analysis of software architecture: Components, connectors and events. In M. Bernardo and P. Inverardi, editors, Third International Summer School on Formal Methods for the Design of Computer, Communication and Software Systems: Software Architectures (SFM 2003). Springer Lect. Notes Comp. Sci, Tutorial, (2804), Bertinoro, Italy, September 2003.

