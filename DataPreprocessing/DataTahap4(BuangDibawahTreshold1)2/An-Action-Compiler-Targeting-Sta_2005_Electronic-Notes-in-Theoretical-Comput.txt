We present an action compiler that can be used in connection with an action semantics based compiler generator. Our action compiler produces code with faster execution times than code produced by other action compilers, and for some non-trivial test examples it is only a factor two slower than the code produced by the Gnu C Compiler. Targeting Standard ML makes the description of the code generation simple and easy to implement. The action compiler has been tested on a description of the Core of Standard ML and a subset of C.

an action. The front end is then connected to an action compiler, and the result is a compiler for the described language. Previous results [20,21] have shown that it is possible to generate compilers that produce code that is less than ten times slower than the code generated by handwritten compilers, and in some cases even as fast as only two times slower. Some restrictions have been put on the actions handled by the compiler to achieve this result, and often the implementation of the code generator in the action compiler is very complicated.

An action compiler annotates and transforms the action in several steps. Our action compiler performs type inference (Section 3) and code generation (Section 4), but no optimizations on the action as seen in previous results. Instead we generate code that can easily be optimized by MLton.

Action Semantics (AS) is a hybrid of Denotational Semantics and Operational Semantics. As in a conventional denotational description, inductively defined semantic functions map programs (and declarations, expressions, statements, etc.) compositionally to their denotations, which model their behavior. The difference is that here denotations are actions instead of higher-order func- tions.

Actions are expressed in Action Notation (AN) [12,16], a notation resem- bling English but still strictly formal. AN consists of a kernel that is defined operationally; the rest of AN can be reduced to kernel notation. Actions are constructed from yielders, action constants, and action combinators, where yielders consist of data, data operations, and predicates. Yielders are not part

The performance of an action might be seen as an evaluation of a func- tion from data and bindings to data, with side effects like changing storage and sending messages. We shall often refer to the input data/bindings of an action as the given data/bindings. The action combinators correspond to dif- ferent ways of composing functions to obtain different kinds of control and data flow in the evaluation. The evaluation can terminate in three different ways: Normally (the performance of the enclosing action continues normally), abruptly (the enclosing action is skipped until the exception is handled), or failing (corresponding to abandoning the current alternative of a choice and trying alternative actions). AN has actions to represent evaluation of expres- sions, declarations, abstractions, manipulation of storage, and communication between agents. The yielders can be used to inspect memory locations and compute data and bindings.

In Section 2 we present the Action Environment which serves as a front end generator in our compiler generator. Type inference of actions is an essential part of generating efficient code from actions, and the subject of Section 3. The main contribution of this paper, namely the rules for translating actions into SML, is described in Section 4. Before evaluating the action compiler in Section 6 we take a look at previous work on compiling actions in Section 5. In Section 7 the limitations of our action compiler are discussed. Section 8 concludes.

How the type information is used will be explained in Section 4. Knowing that we translate actions to SML and that the SML compiler does type infer- ence, one might wonder whether this type inference is necessary. If the SML code can be produced without knowledge of types, the SML compiler could try to infer a type and thereby check that the input action is type correct. The problem with this approach is that the generated SML code would be less efficient if the code generator could not take advantage of type annota- tions. To give an example, the translation of the and combinator (Rule 4 in

In this section we will look at a representative selection of the rules; the rest can be found in the appendix. We shall use A to range over actions, O to range over data operators, E to range over SML expressions (e.g., anonymous functions), d and I to range over SML identifiers, n to range over integers, i and j to range over labels, and t to range over types. Some rules use the function T that takes an action and returns its type. The type of an action is of course context dependent and has been derived by the preceding type inference. We shall also assume that all identifiers occurring in an action have been mapped into identifiers that are not reserved words in SML.

The action copy has the simplest translation (Rule 1) since it just returns the data given to it. Translating result D is only a little bit more complicated (Rule 2); here the data D produced by the action must be translated into an SML expression E. If the data D is an action it is translated using the rules, in other cases it is translated into SML representations of the data, e.g., integers and booleans are just translated to the same integers and booleans.

AN contains a number of builtin data operators on integers and booleans that can trivially be translated to corresponding SML data operators. The builtin data operators on binding maps (operators for creating single bindings, looking up bindings, uniting binding maps, etc.) are translated into selection of elements from records and construction of records. To translate these data operators the type information about the given bindings is used. ASDF lets the user specify data and data constructors, and these are also translated into SML by the action compiler.

The Actress system [7] showed how to compile actions into C code. The compilation involved several action optimizations where the most important one was binding elimination. The system has been tested on a specification of a small imperative language called Specimen, and the running time of the generated C code for some programs has been compared to running times for implementations of the same programs in Pascal. This comparison shows that the generated C code is between a factor 5 to 28 slower than the compiled Pascal code. The rules describing the code generation are complicated because they use a set of variables to pass data between actions and must keep track of which variables are used and have been used by sub-actions.

Continuing the work done by Brown, Moura and Watt on the Actress sys- tem, Kent D. Lee developed the Genesis system [13]. The systems have many similarities with respect to type inference and action transformations, but in- stead of generating C code, Genesis generates Java bytecode. One advantage of this is the portability of the generated code. As with the OASIS system, the low level target language makes code generation complicated, and special transformations of actions are needed. Lee does not present any evaluation of the generated code.

A somewhat different approach has been demonstrated by Bondorf and Palsberg in [2]. By writing an action interpreter in Scheme and applying the Similix partial evaluator, they were able to generate an action compiler that generates Scheme code. The advantage of this approach is that it is easier to write an action interpreter than an action compiler, and the hard work is done by Similix. Should AN change it is also easier to update an action interpreter than an action compiler. Their evaluation of the generated scheme code shows that it is almost 100 times slower than code generated by a hand written compiler.

In Gentle [18] the specification of a compiler is done in a logic program- ming language which is used in all parts of the specification. The specification language resembles Prolog but is more restricted and therefore the unification algorithm could be optimized. In [19] Vollmer reports that Gentle generates very efficient compilers with respect to compilation time, and that user ex- perience shows that developing compilers in Gentle saves time compared to hand-coding compilers.

The test programs exploit both the functional and the imperative aspects of the Core ML language. The second column shows the running time for the output from the action compiler. The third column shows the running time for the program compiled with the MLton compiler, and the last column shows how many times slower the output from the generated compiler is.

on this program. The problem with tail recursion is not noticeable in the recursive Fibonacci program (fibo), because the recursive function there is not tail recursive. In the AS description of Core ML the action representing a function is wrapped in a data type, and this is the main reason for the bad results when running the church test program which exploits higher-order functions.

The compiler generator has also been tested on a small subset of C. The subset includes simple expressions, assign-, if- and while- statements, state- ment blocks, variable declarations, and recursive functions. The values are integers and arrays of integers, but no pointers. The seven test programs are:

Comparing a compiler generated from a subset of C with a compiler for the whole C language is of course not fair. It is likely that the generated compiler will become less efficient when we extend the subset of C, especially if we allow more data than just integers and arrays of integers. Adding more features often means that the simple semantics of a construct is replaced by a more complex semantics, for instance, adding pointers and floats to the subset of C would mean that the semantic of + becomes more complicated because the operator should now be overloaded. On the other hand our compiler generates code that performs bounds checking on arrays, which the GCC compiler does not, which makes the generated compilers less efficient.

Support for user defined data types is work in progress. Currently we sup- port the data defined in the ASDF modules as part of a language description. It is only possible to describe languages where the user can define his own data types to some extent. The length program in Section 6 is an example of how the user can define a list data type in the Core ML language, but the description of data types in Core ML is not fully supported by the action compiler yet, and only works on some examples. The representation of data is the main reason for performance loss in the generated compilers.

Future work includes investigating how to generate code that is easier for the SML compiler to optimize. Especially the way data is represented in the generated code needs improvement. Relaxing the restrictions put on actions would also improve the system. Improving the type inference algorithm such that it accepts a bigger set of actions, would allow more natural descriptions of languages, but here we are also limited by the target language (SML) being strongly typed.

