In this work we explore the applicability of the programming method of Feijen and van Gasteren to the construction of security protocols. This method addresses the derivation of concurrent programs from a formal specification, and it is based on common notions like invariants and pre- and post-conditions. We show that fundamental security concepts like secrecy and authentication can nicely be specified in this way. Using some small extensions, the style of formal reasoning from this method can be applied to the security domain. To demonstrate our approach, we discuss an authentication protocol and a public-key distribution protocol, and we deal with their composition. Although this work does not contain any new protocols, it does offer a new view on describing, constructing and reasoning about security protocols.

The formal correctness of security protocols is generally considered to be im- portant. The most common approach to establishing it is by means of ver- ification after the protocols have been designed. The usual styles include automated state-space exploration [21] and interactive theorem proving [28]. However, actually designing and reasoning about security protocols is still considered to be complicated.

For the reasoning about security protocols, also various dedicated ap- proaches have been proposed, e.g., in [30]. In contrast, we study the use of a general method, which gives more flexibility, and enables the integration with techniques developed for other application domains. A similar approach has been explored in the context of data refinement [6], but its complexity seems to remain a problem [19].

Simplicity of exposition is at the core of the method of Feijen and van Gasteren [17] for constructing concurrent programs. It is based on the classical axiomatic theory of Owicki and Gries [27], where the reasoning about execution traces (like [28,30]) is replaced by the reasoning about assertions and invariants, i.e., predicate abstractions of states. This method has shown its merits in various application areas, e.g., [18,17,20,24]. In this work we explore its applicability to the formal derivation of security protocols.

To demonstrate our approach we reconstruct the authentication protocol of Needham and Schroeder [26]. The well-known attack that was once detected by Lowe [21] is avoided in our derivations in a natural way. Apart from this classical authentication protocol, we also address a public-key distribution protocol, and we discuss their composition.

In Section 2 we summarise the theories and methods that we use. Our derivation approach is described in Section 3, followed by our specification of authentication in Section 4. We demonstrate them using an authentication protocol in Section 5, and using a public-key distribution protocol in Section 6. We use these results in Section 7 to explore the composition of security pro- tocols. Finally we draw some conclusions and sketch some further work in Section 8.

The programming language that we use for the components is based on the Guarded Command Language from [12]. The semantics of the atomic statements follows from the weakest liberal precondition, wlp, (and the weakest precondition, wp) predicate transformers. The weakest liberal precondition of a statement S and a predicate Q, to be denoted by wlp.S.Q, is the weakest predicate P that guarantees that each terminating execution of statement S starting from a state satisfying P establishes Q; in contrast to the wp, the wlp does not guarantee termination of the statement. In particular we use the following two kinds of atomic statements:

The components can communicate using messages. The kinds of messages can be defined recursively. An atomic (plaintext) message is just a data value, where we assume that values from different data types are different. Another view on it is assuming that the values are explicitly typed. In particular the data values include component identifiers, nonces (introduced later on) and keys.

{.. .} for assertions and to avoid the extra subscript for k. It is straightforward to generalise this kind of encrypted messages to containment of other num- bers of messages, and to trivial encryption (i.e., just a tuple of messages). The usual models of encrypted messages distinguish explicitly between concatenat- ing the messages y and z, and encrypting the result. We leave the intermediate concatenation step implicit, in order to emphasise the more-important encryp- tion step, to simplify the descriptions of the intruders, and hence, to make the protocol derivations more effective.

tion [13], i.e., the intruders can intercept, read and create messages. Based on the observed messages, the intruders can also derive new messages. If any key k and any two messages y and z can be derived, then the messages can be composed to derive the message [k : y, z]. If any encrypted message [k : y, z] and the key k can be derived, then the encrypted message can be decomposed to derive the messages y and z. The key k denotes the key that undoes the encryption with key k; in asymmetric encryption models the keys k and k cannot be derived from each other.

Partial correctness (or safety) is specified by annotating the program with assertions. An assertion is a predicate on the state of the system and it is located between brackets {.. .} at a control point. The control points are the locations between the atomic statements in the components.

An important issue is whether these options endanger the correctness of the other assertions. Introducing additional assertions cannot endanger the cor- rectness of the other assertions, and typically the weakest possible strength- ening that serves the goal is calculated. However, modifying the program may transform all assertions into queried assertions again. The typically-used modification of the program is inserting a new statement (to establish local correctness).

Like its underlying theory [27], this method does not formally address progress. Since the role of progress in the derivations is often limited, progress is usually discussed in a pragmatic ad-hoc manner. Although in [15,16] we have shown how to integrate a full progress logic [14], in the current work we follow the original approach since progress plays no significant role.

Our treatment of intruders will be based on a technique for faulty channels. Faulty channels are channels that can duplicate, reorder and lose messages, but in contrast to intruders (see Section 3.2) they cannot insert new messages or modify messages. Such channels have been studied in relation to, for example, alternating bit protocols [18,17] and sliding window protocols [20]. In this section we discuss an operational model, and an elegant rule for proving that an assertion is established by the receipt of a message.

To avoid explicitly reasoning in terms of this operational model, an elegant proof rule can be derived. We discuss this rule in detail in order to facilitate its reuse in Section 3.2. Moreover, it serves as a quick introduction to the style of program development, although we will refrain here from introducing any new statements.

Consider any series of message m.x depending on parameter x, and any predicate P that does not contain C or R. Given a send and a receive state- ment in two different components, we want to derive a rule for establishing an assertion P after the receive statement. This specification can be summarised

So, apart from any possible violation of the predicate (v := x).P , for any x, by the other statements in the system, the assertion P is established by this receipt of a message m.v if before every transmission of any message m.w the assertion (v := w).P holds. This rule is called the rule of import (upon

The capabilities of the intruders are such that they can completely control the message flow in the system. Hence we would like to model the intruders as a special type of communication channel. Such a channel is similar to a faulty channel, as described in Section 2.5, but with the extra capability of

To prove maintenance, we can directly apply the normal proof rules [27], but this may become quite complicated given the definition of D. In what follows we develop a simpler and sufficient proof approach, as far as the set DK in the antecedent is concerned. We will treat such a compound expansion of DK by showing that each of its expansions with a single message maintains the invariant.

Usually we simplify and weaken the antecedent into only one of the conjuncts. In turn, term DK.y or DK.z in this new condition may need to be considered regarding composition, hence leading to a finite number of extra invariants. This number is usually very small, since the typical messages do not contain many nested layers of encryption.

Notice that it is not useful to decompose any message that was created via composition; see also [9]. Hence we only need to consider the recursive decomposition of the transmitted messages. Upon transmitting a new mes- sage, at least the new message must be decomposed recursively. However, in contrast to composition, decomposition may also derive new keys, in which case the earlier transmitted messages may become further decomposable. In what follows we discuss these two series of transmitted messages separately.

Progress and termination of security protocols can mainly be hindered by the receive statements, which can be blocked. As the intruders may intercept and lose all sent messages, denial-of-service attacks cannot be prevented in our model, and hence in general progress cannot be guaranteed. In this work we will only consider progress in case the intruders behave like a proper commu- nication channel. In particular we will rely on the following variation on the ground rule of progress from [17]:

To demonstrate our formal reasoning approach, we present a derivation of the authentication protocol of Needham, Schroeder and Lowe [26,21]. Our derivation is based on the specification of authentication from Section 4, but, for simplicity reasons, restricted to singleton sets of honest components, viz., A = {a} and B = {b}.

Also this invariant can be initialised using the freshness of nonce nb, and it is trivially maintained under composition. Although it can be simplified using the other invariant on D.nb, we prefer to maintain the structure and combine it with the original invariant on D.[k.b : nb] using disjunction in the antecedent of the implication.

This invariant can be initialised using the freshness of nonce na, but regarding composition the shape of the existing invariants is not very helpful. The last invariant on D.nb might become useful, and although nonce nb is not accessible in component a, we can try to exploit the term p = nb.

After separately studying the two message communications, i.e., the one from this section and the one from Section 5.1, we must consider their com- bination. For the new invariants, (recursive) decomposition of the previous message [k.ma : p] leads to the following two proof obligations:

The hardest part of the construction was in fact the introduction of the nonces, in the beginning of the derivation. The problem is that our specification does not mention the possibility that the protocol might be run more than once by a single component. Apart from running the protocol several times in succession, this could also include running it several times in parallel. To make this explicit in the specification of authentication, it must be possible to not only distinguish the different components, but also to distinguish the different runs of the components. We expect that such an identification mechanism would guide the derivation more easily towards the notion of a nonce.

It may seem to be more realistic to model the constants ma, mb, na and nb as variables that are explicitly assigned a value by the components. A dis- advantage of such a more-dynamic model is the additional amount of proof obligations. In particular, the correctness proof would demand some addi- tional assertions to address the cases in which the variables have not yet been initialised; see also the discussion about variables p and q at the end of the previous section. In our opinion this would primarily increase the amount of work and formulae, while adding nothing to the understanding of the essence of this protocol.

The remaining queried invariant can usually be initialised, and it is main- tained under composition using the first invariant on D.k.s. For progress reasons, we must introduce in component s a send statement for a message [k.s : k.v, v], for any variable v.

As the public key k.s may be derivable, the transmitted key k.v may be revealed by the intruders via decomposition. Regarding this new key, the invariants are maintained, using the assumption that the private and public keys are different. Regarding the earlier transmitted messages, we strengthen the invariants using our generalisation and the singleton key set {k.v}. This turns out to maintain their correctness, thus yielding the following intermedi- ate program:

There are no more queried assertions or invariants, but for progress reasons we must still ensure that variable v in component s can be set to ma. To this end we can safely introduce a message communication, without any invariants or security concerns. By assigning any value to v, the invariants must be strengthened again, but maintenance remains guaranteed. We use (c :: k.c) to denote the set of all public keys, and obtain the following final program:

Notice that the first (plaintext) message does not contain the value a, which might be useful for sending the reply to the right component. However, as we only consider broadcasts, this is not needed in our model. Moreover, we can easily extend this example to distribute keys to a series of components, for which a repetition (or a parallel composition) is likely to be introduced in the server component.

The protocol so far deals with an instance of the specification from Section 4, viz., mutual authentication between one pair of components. Given a common assumption on the keys and nonces, we present a reduction technique that shows that the same protocol can deal with the general specification from Section 4, viz., mutual authentication between any number of disjoint pairs of components. Although this more general case can also be addressed directly using our method, the reduction simplifies matters as it does not refer to the details of the annotation.

At the end of this exploration of the derivation of security protocols, we must assess what we have achieved. The general style of reasoning from the pro- gramming method of Feijen and van Gasteren also turns out to be effective for this application area. In particular it avoids the well-known attack on the original authentication protocol of Needham and Schroeder in a natural way. After introducing the notion of a nonce, this protocol practically develops itself. The annotation developed along the derivation can even be used for reasoning about the composition of protocols.

To achieve these results, we have developed simple specifications of se- crecy and authentication, in a familiar style of pre- and post-conditions and invariants. For dealing with the interference caused by the intruders, we have slightly modified an existing approach to deal with traditional message com- munication. The resulting method benefits from such a well-understood basis, and it is flexible enough to address patterns for both public-key confidentiality and private-key authentication.

created in a demand driven way, and their correctness can easily be checked. Their annotation records the design decisions, and it provides a safe basis for reasoning about the messages. To reduce the size of the annotation, some of the invariants have been combined. Although this makes these invariants less appealing, they remain highly structured. A continued attention to notational concerns is an important piece of further work for effectively deriving and reasoning about protocols.

In contrast to automated approaches, we have already noticed that after- wards experimenting with minor variations of the protocols is a bit tricky, in which case the annotation should be checked carefully. In this sense it might be a useful piece of further work to develop an easy way to automatically verify the developed annotation using theorem provers, e.g., along the lines of [25,24]. Nevertheless we want to stress the importance of keeping the deriva- tion techniques manageable, in order to avoid the introduction of errors, and to emphasise the design decisions.

For further work we want to develop some heuristics to better predict the effects of the design decisions, and hence simplify the derivations. It is also further work to specify other security properties in this style. Our specification of authentication should be extended to cover other notions of authentication [22], components that act both as an initiator and a responder, multi-party synchronisation [10], and components that perform the protocol several times. It is also further work to study different intruder and encryption models, such that the derivations can highlight where the specific assumptions are used. We are also interested in studying the effect of this approach on other security protocols, and to create a taxonomy of protocols that are presented in the same way. Apart from studying some of the protocols for two or three components from [8], we want to consider various protocols with multiple

