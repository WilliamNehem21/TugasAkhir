Mismatches may appear at different interoperability levels that are usually dis- tinguished in interface description languages [5]: signature level (operation names and types), behavioural level (interaction protocols), quality of service level (non- functional properties such as security or efficiency), and semantic or conceptual level (functional specification of what the service actually does). Recently, many academic approaches and industrial platforms have integrated behavioural descrip- tions in interface models and programming languages such as BPEL [1] or Windows Workflow Foundations [19] (.NET 3.0) in the context of Web services. Indeed, the behavioural interoperability level is essential [17], because even if services match from a signature point of view, their composition can lead to erroneous behaviours or deadlock situations if the designer is not aware of their execution flows, and does not take them into account while building a new system.

The rest of this paper is structured as follows: Section 2 presents our service model and contract specification language, as well as a case study which will be used to illustrate the different issues introduced throughout the remaining sections. Section 3 first describes the automatic contract generation algorithm that we use in our approach, and then presents how it is extended with an interactive environment for semi-automatic contract specification. Section 4 presents some experimental results that we used to assess the benefits of our approach. Finally, Section 5 reviews related work, and Section 6 draws up some conclusions.

This formal model has been chosen because it is simple, graphical, and it can be easily derived from existing implementation languages (see for instance [13,18,12] where such abstractions for Web services were used for verification, composition or adaptation purposes). For space reasons, in the rest of the paper, we will describe service interfaces only with their STSs. Signatures will be left implicit, yet they can be inferred from the typing of arguments (made explicit here) in STS labels.

This section first presents our automatic generation process for adaptation con- tracts. Although this process is capable of generating correct contracts from the behavioural point of view, it cannot control the semantic constraints present on ser- vice interfaces. Hence, in the second part of this section we present a semi-automatic approach to contract specification as a solution to this problem. Rather than pursu- ing a fully automated approach by making use of semantic technologies (which may not be enough to infer complete interface operation semantics and their relations), our solution is based on extending our automatic generation process with an interac- tive contract specification environment that helps in customizing and constraining automatically generated solutions.

The heuristic function (see [14] for more details) is based on the direction of the operations and the matching between their arguments. It represents a measure of the suitability of the contract for service adaptation since it ranks first those contracts which synchronize compatible operations and avoid incompatible branches of the service behaviour. This function imposes a total order among the contracts and those which assume the minimum number of mismatches, i.e., contracts where every operation corresponds to another and all the parameters match, are placed first.

provide fully automated techniques: (i) Simulation. Our environment implements an algorithm able to determine how the different behavioural interfaces evolve step- by-step as different vectors in the contract are executed; and (ii) Trace-checking. Potential system execution traces are first generated, and then traversed to detect those leading to deadlock situations or infinite loops.

the user considers the given vector valid or not. env input vectors returns a set of vectors composed by the user. env select STSs returns a pair of STSs. env select returns a set of vectors selected from a set of contracts. gen contracts (detailed in Algorithm 1) receives a pair of service STSs and a partial contract that will be used as restrictions (may be empty), and returns different contracts connecting the interfaces. env edit V LT S receives the current VLTS, and returns an edited version, and the new active VLTS state selected by the user. env edit vectors receives a set of vectors, and returns its edited version.

In order to assess the benefits of our approach to contract specification in terms of development effort and contract accuracy, we conducted an experimental study with the help of a group of volunteers who were divided in three categories (ex- pert, average, novice) according to their expertise and familiarity with behavioural interfaces and software composition. The tests consisted in handing over to the volunteers adaptation problems which included the graphical description of the be- havioural interfaces to be reused in the composition and a short specification in natural language of what was the intended functionality of the system. Since we measure user productivity in our experiments, the automatic approach as an inde- pendent tool is left out of our study. The three different approaches for contract specification included in the experiments were: (i) manual contract specification (M), where the user had to write down the contract without further assistance; (ii) interactive contract specification (I), where volunteers made use of our interactive environment; and (iii) Semi-automatic contract specification (A+I), where the user specified the contract using the approach presented in this paper.

happened in the case of time, in problems where multiple small services have to be adapted, this improvement is lost since the user must modify or create additional bindings to integrate all the pairwise bindings returned by the automatic approach. It is worth observing that in the case of online-med-003, the general trend be- tween the interactive and the semi-automatic approach is reversed since users always solved the problem correctly in the first attempt using the interactive approach but, in the case of the semi-automatic approach, they need to modify two bindings on the contract returned by the automatic approach to integrate the third service of the example. In easyrest-005, the semi-automatic approach hardly improves (5.3%) the result of interactive specification since the problem contains two main interfaces

Automatic contract specification. The authors of [7] outlined a methodology for the automatic generation of adaptors capable of solving behavioural mismatches between BPEL processes. In their adaptation methodology they use YAWL as an intermediate workflow language. Once the adaptor workflow is generated, they use lock analysis techniques to check if a full adaptor has been generated or only a partial one (some interaction scenarios cannot be resolved). They solve protocol in- compatibilities but their approach does not address signature mismatch since they assume same operation names (and arguments) among the services. In [4], the au- thors address the enforcement of certain behavioural properties (namely liveness and safety properties expressed as LTL properties) out of a set of already imple- mented components. Starting from the specification with MSCs of the components to be assembled and of the properties that the resulting system should verify, they automatically derive deadlock-free adaptor glue code for the set of components in order to obtain a property-satisfying system. However, although this approach en- ables a precise specification of the desirable behaviour of the system, it works by pruning branches of the behaviour which are incompatible or do not satisfy the spec- ified properties. Hence, the range of situations where mismatch can be reconciled is limited compared to other approaches.

Manual specification of adaptation contracts is a cumbersome and error-prone task. In this paper, we proposed a novel solution to ease the task of contract specification. The proposed approach is semi-automatic, and relies on an interactive environment and automatic generation techniques to support the designer. Our solution has been fully implemented in tools, which have been applied to many case studies. Furthermore, we have shown that our approach remarkably reduces the time spent to build the contract, as well as the number of errors made during the process. More concretely:

