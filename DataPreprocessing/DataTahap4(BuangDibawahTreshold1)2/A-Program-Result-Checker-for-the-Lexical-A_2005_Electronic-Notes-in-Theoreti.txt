In theory, program result checking has been established as a well-suited method to construct for- mally correct compiler frontends but it has never proved its practicality for real-life compilers. Such a proof is necessary to establish result checking as the method of choice to implement compilers correctly. We show that the lexical analysis of the GNU C compiler can be formally specified and checked within the theorem prover Isabelle/HOL utilizing program checking. Thereby we demon- strate that formal specification and verification techniques are able to handle real-life compilers.

Program checking [2] has been introduced to improve the reliability of pro- grams. It assumes that there exists a black box implementation P computing a function f . A checker for f checks for a particular input x if P (x)= f (x).

We check the lexical analysis of the GCC compiler by recomputing its result via a formally verified implementation and by comparing this correct result with the one produced by the GCC, cf. subsection 2.3. For this purpose, we specify the lexical analysis within the Isabelle/HOL theorem prover and use

In the remainder of this subsection, we discuss the most interesting parts of both specification possibilities for the above example automaton. The spec- ification of the scanner recomputing the results of the GCC follows these lines directly, except that it is much larger, cf. subsection 4.2. In discussing the smaller example first, we can illustrate the underlying principles more clearly.

To check the lexical analysis of the GCC, we need to have access to the tokens and their values computed by it. In subsection 5.1, we describe the modifica- tions of the GCC code necessary for that. In subsection 5.2 we explain our overall checking architecture, in particular how we have connected the Isabelle

the list of expected tokens and their values. This list is written back by the function write token list to the format in which also the modified GCC analysis outputs its tokens and their values. In this format, each token and its value are separated by a whitespace and closed with a new line.

Altogether, our checking architecture integrates well into the GCC sys- tem. We only need very simple modifications of the GCC code to extract the computed tokens and their values. Also, the Isabelle checker can easily be connected with the GCC code.

Program checking has been used in the construction of correct compilers, most prominently in the Verifix project [5]. It has proposed program checking to ensure the correctness of compiler implementations. Program checking has been applied in the context of frontend verification [7], as already discussed in section 2. The program checking approach has also been used in further projects aiming to implement correct compilers. [9] shows how some back- end optimizations of the GCC can be checked. In [12,11], the problem of constructing correct compilers is also addressed, but only for very limited ap- plications. Only those programs consisting of a single loop with loop-free body are considered and translated without the usual optimizations of compiler con- struction. Those programs are translated correctly such that certain safety and liveness properties of reactive systems are sustained. In more recent work

Formal verification of compiler frontends has been investigated e.g. in [15] where proof fragments for the correctness of lexical and syntactic anlysis have been formalized in the mechanical theorem prover NQTHM. Formal verifica- tion of lexical analysis has also been addressed in [10]. This work shows the formal verification of a very simple lexical analyzer generator that takes a reg- ular expression and yields a functional lexical analyzer. Emphasis in this work is placed on the formal verification of transforming a regular expression into an initially nondeterministic automaton and then into a deterministic one. In future work we plan to connect our checking architecture with the theory described in this work. In doing so, we would only need to extract the reg- ular grammar for the lexical analysis and could construct the corresponding deterministic automaton as described in this related work.

With the results presented in this paper, we have set up an architecture for checking results of frontend computations, in particular for the lexical anal- ysis. We have shown how to specify the task of scanning tokens within Is- abelle/HOL. Furthermore, we have demonstrated how to access the interme- diate results of the GCC system by minimally modifying its C source code. In doing so, we have shown that program checking can handle large non- academic compilers which are extensively used in practice. The presented checking method is not specific to the GCC nor to the C langugage and can be applied to other compilers as well. In future work, we plan to connect our checking architecture with the results of [10] which provides a formal proof in Isabelle/HOL for the generation of a functional lexical analyzer (i.e. a finite automaton) given a regular grammar. Since the regular grammar for the C tokens is directly given in the C language specification (as is the case for the specifications of many other programming languages as well), this will yield a completely verified result of the lexical analysis.

