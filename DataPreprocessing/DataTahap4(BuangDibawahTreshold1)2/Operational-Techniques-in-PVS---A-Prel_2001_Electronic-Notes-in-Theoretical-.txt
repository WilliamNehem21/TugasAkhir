With complicated specifications in PVS, it is possible to get overwhelmed by TCCs. Accordingly, a mechanism is provided to alleviate the buildup of TCCs via judgements, that make available more specific information to the typechecker. Judgements come in two varieties. Constant judgements state that a particular constant has a more specific type than its declared type, while subtype judgements state that one type is a subtype of another. We point out in the proof where we make use of the judgement mechanism.

A background collection of theories is provided in the PVS prelude. In- cluded are theories for numbers, set operations, finite sets, ordinals, functions, induction schemes and abstract data types, including a list definition. The prelude also contains a number of judgements.

The PVS prover accepts commands in Emacs via a Lisp-like interface. These commands consist of high level commands called strategies and a num- ber of more specific commands known as rules. Strategies are designed to tackle a broad range of problems and ideally finish proofs automatically. Rules, on the other hand, give the user much more control over the proof, although the actions taken are generally more atomic. For example, the split rule splits the current proof into a number of subproofs, while the prop strategy splits the proof and then applies propositional flattening and simplification. It is generally a good idea to attempt proofs using the higher level strategies first, resorting to lower level commands only when necessary. In addition to in- creasing the level of automation, this approach produces proofs that are more resistant to changes in the specifications.

A PVS specification is split up into theories and data type definitions. Each theorem consists of a (possibly empty) list of parameters, importing and exporting statements, type definitions, constant definitions, function defini- tions, judgements, and lemmas. The parameters can be types, subtypes, or constants. Exporting statements are used to specify the names that are made visible to theories that are importing the current theory. Importing state- ments specify a list of theories to be imported and can be either parametrized or unparameterised.

Defining FV allows us to treat renaming and substitution. The renam- ing function replaces all free occurrences of one variable with another. To achieve this it may sometimes be necessary to rename the bound variables of an expression to prevent capture.

It is in defining the renaming function that we first run into trouble with TCCs. As mentioned in section 3, TCCs need to be proved by the PVS system, or the user. Unfortunately it is possible to generate unprovable TCCs, often from fairly innocuous specifications. For example, consider the lambda case

