Programmers need mechanisms to store application specific data that persists multiple program runs. To ac- complish this task, they usually have to deal with storage specific code to access files or relational databases. Functional logic programming provides a natural framework to transparent persistent storage through per- sistent predicates, i.e., predicates with externally stored facts.

We extend previous work on persistent predicates for Curry by lazy database access. Results of a database query are only read as much as they are demanded by the application program. We also present a type- oriented approach to convert between database and Curry values which is used to implement lazy access to persistent predicates based on a low level lazy database interface.

Programming languages need mechanisms to store data that persists among pro- gram executions. Internal data needs to be saved and recovered, and external data has to be represented and manipulated by an application. For instance, web appli- cations often read data stored on a database server and present it to the user in a structured way.

The remainder of this paper is structured as follows: in Section 1.1 we motivate persistent predicates by reflecting related work on database access in declarative programming languages. In Section 2 we present the interface of our database library. We discuss a low level implementation of lazy database access in Section 3. We sketch a type-oriented approach to conversion between database and Curry values in Section 4 that is used to implement lazy access to persistent predicates based on the low level interface. Finally, Section 5 contains concluding remarks.

Both problems are solved in [7] where database access is only possible inside the IO monad [11] and a transaction concept is provided. Eliminating side effects is especially essential in the context of functional logic programming languages which are based on sophisticated evaluation strategies [1]. [4] extends the library presented in [7] by a database implementation of persistent predicates. We improve this implementation by means of lazy database access and slightly simplify its interface. Section 2 recapitulates the interface to our library and mentions differences to the

A combinator library for Haskell, which is used to construct database queries with relational algebra, is provided by [9]. It allows for a syntactically correct and type safe implementation of database access. The authors provide a general ap- proach to embed domain specific languages into higher-order typed languages and apply it to relational algebra to access relational databases. While [9] syntacti- cally integrates a domain specific language into the Haskell programming language, persistent predicates transparently integrate database access into a familiar pro- gramming paradigm.

An extension of Curry similar to Concurrent Haskell [10] that supports concur- rent i/o actions could make use of this feature for synchronization. We could define an alternative version of retract that does not suspend on partially in- stantiated arguments but deletes all matching facts from the database without propagating the resulting bindings to the program. These bindings would then be encapsulated in the call to retract. However, this behavior can be achieved using getDynamicSolutions defined below and, more importantly, the implemen- tation of retract would become inefficient, if the encapsulation would be done internally for all calls to retract, i.e., also for those that do not involve free vari- ables. Moreover, a similar alternative does not seem to exist for the implementation of assert. Representing unknown parts as null -values seems to be appropriate at first glance. However, the information about which variables are identical is lost, if all free variables are represented as null -values, thus, suspension or failure seem to be more practical for retract and the only reasonable options for assert. We chose suspension to support possible extensions of Curry concerned with concurrency.

can be used to query only one solution. Note that this function would not be necessary if getDynamicSolutions were lazy. But with a strict implementation all solutions are computed in advance even if the program demands only the head of the result list. Unfortunately not all Curry implementations support lazy encapsulated search and we can provide it only for predicates that are stored in a database. Also note that only encapsulated access to a dynamic predicate is provided. Dynamic predicates cannot be used in guards like ordinary predicates and, thus, cannot cause nondeterministic behavior of the program.

Often information needs to be queried from more than one persistent predicate at once, or a query has to be restricted with a boolean condition. To combine several persistent predicates, we provide two different forms of conjunction. One combines two values of type Dynamic similarly to the function (&) for ordinary constraints.

The function transaction is used to start transactions. The given i/o action is performed atomically and Nothing is returned, if the i/o action fails or is explicitly aborted with abortTransaction. Nested transactions are not supported and lead to a run-time error. We simplified the interface of [4] by eliminating the function transactionDB that takes a database name to perform the transaction in. Now, transactions are specified with the function transaction regardless whether they

Relational database systems allow us to retrieve result sets of queries incremen- tally via an API. In this section we show how we access this API from a Curry program. One possibility to access the database API is to use external functions. However, implementing them is a complex task and more importantly external func- tions need to be re-coded for every Curry implementation, so it is a good idea to avoid them wherever possible.

Java supports a variety of database systems. Curry supports distributed program- ming using ports [6] and it is possible to port this concept to Java and write dis- tributed applications that involve both Curry and Java programs. So we can access all database systems supported by Java in Curry if we can communicate with a Java program using Curry.

The last two functions destroy type-safety of port communication because their return values are polymorphic. The predicates openPort and send ensure that only type correct messages are sent to or received from a port. With openNamedPort and connectPort, however, it is possible to send type-incorrect messages to a port. The function openNamedPort creates a stream of messages of unspecified type and the type of messages that can be sent to a port created by connectPort is also unspecified. If ports are used for communication over a network, this communication is no longer type-safe. Therefore, we have to carefully establish type-correct message exchange ourselves. The user of our library is not concerned with these issues because the ports-based interface is not exported.

Each row is queried on demand by sending a NextRow message and the result set is empty if endOfResults returns True. Note that we demand the contents of each row, when the corresponding constructor (:) of the result list is demanded. Since every call to endOfResults advances the result pointer to the next row, we may not be able to demand the contents of previous rows later.

Note that the presented functions are not i/o actions. Although i/o is performed by the Java application we communicate with, the communication itself is done with send-constraints outside the IO monad. Therefore, the presented functions can be considered unsafe and need to be used with care. Demand driven database access

Note that the presented functions are not part of our database library. They are only used internally in the implementation of persistent predicates. The function query can be used to define a lazy version of getDynamicSolutions to retrieve all solutions of a persistent predicate abstraction on demand. Its implementation has to consider predicates that are combined from heterogeneous parts. Predicates stored in a database can be freely combined with others stored in files or those with facts held in main memory. The details are out of the scope of this paper. However, an interesting aspect of these details is how to convert between the datatype DBValue and Curry values automatically. An approach to this problem that employs type- oriented database specifications is discussed in Section 4. Beforehand, we consider an example that demonstrates lazy database access with persistent predicates:

To implement the operations to access persistent predicates we need to convert between Curry values and values of type DBValue. Especially, to implement en- capsulated search with the function getDynamicSolutions, we need to parse the rows of type [DBValue] that are returned by the function query introduced in Sec- tion 3.2. In this section we describe an approach to this problem using type-oriented database specifications. A similar technique has been employed in [8] to construct web user interfaces.

resemble the structure of the argument types of person. The first resembles a constructor with two string arguments and the second represents an integer. The string arguments to the primitive specifications string and int denote the column names where the corresponding values are stored. Declarations like the one shown above are generated automatically from the provided type information. However, less intuitive column names would be selected by this automatic transformation.

The presented specifications serve different purposes. Firstly, they store infor- mation about the corresponding column names and SQL column types. Secondly, they store functions to convert between database and Curry values. We define a datatype DBSpec for these specifications as follows:

In fact, these types are a bit more complicated in the actual implementation. How- ever, the presented types are sufficient for this description. The first two components of a DBSpec store the column names and types. A function of type (ReadDB a) is a parser that takes a list of database values and returns a value of type a along with the remaining unparsed database values. A function of type (ShowDB a) takes a value of type a and a list of database values and extends this list with the represen- tation of the given value as database values. We can define the primitive combinator int presented above as follows:

The parser for integers reads one column from the list of database values and returns a free variable if it is a null -value. The show function extends the given database values with an integer value and suspends on free variables. Database specifications for other primitive types, viz. string, float, bool and time, can be defined similarly.

The idea of type-oriented combinators seems to be applicable in a variety of applications. They bring the flavor of generic programming to a language without specific generic programming features. We plan to explore this connection in more detail in the future.

We described a lazy implementation of a functional logic database library for Curry. The library is based on persistent predicates which allow for transparent access to externally stored data, i.e., without storage specific code. We extend [4] with an implementation of lazy database access and simplified the declaration of transactions by discarding the function transactionDB.

