RIS are often designed specifically according to the layouts of stations. When the layout of a station is changed, the corresponding RIS has to be modified. This causes high costs for resources and time [23]. In order to reduce the effort in modifying RIS, one can develop RIS under the object oriented approach. With this approach, it is only necessary to specify the new neighboring structure of the objects when the layout of the station is changed instead of modifying the whole interlocking system completely.

Along the track, one can find another kind of infrastructure component: the signal. Signals (e.g., P 1) can be used to control train movements by showing the aspects. Two types of aspects will be considered in this work, they are clear and stop aspect. Some signals can also indicate the allowed speed of the corresponding track section. Indication of speed will not be considered in the current work.

As mentioned above, in multi-object checking, a D1 formula holds iff the outermost D formula holds. Otherwise, a counterexample has to be generated if this D for- mula does not hold. If model checking is used to verify the outermost D0 formula, an initial part of a counterexample is generated. This forms a part of a global counterexample and it is called a local counterexample. If the initial local coun- terexample does not contain communication with further objects, it is the global multi-object checking counterexample. Similarly, whenever the local counterexam- ple contains communication with further objects, the local counterexample is a part of a global counterexample.

This algorithm works on the grounds that each communication partner pro- vides a corresponding communication scheme. As it has been mentioned before, it is difficult to determine the expressiveness of a counterexample, the selection of a random counterexample for each object does not guarantee that a global coun- terexample can be generated. Whenever a communication partner of an object does not provide a demanded communication scheme one of the possibilities is that, the counterexample of this object has not been properly chosen. This issue can be solved by automatically selecting a different counterexample for the initiating object that shows a different communication scheme. Alternatively, users can interactively examine the part of the global counterexample that has been generated so far.

Both solutions show drawbacks. The first solution implements a kind of greedy/backtracking algorithm with all the well-known (dis-)advantages. The more often local counterexamples have to be regenerated, the less efficient the algorithm is. Finally, the global counterexample may not illustrate the error that clear as expected. In contrast, applying the second strategy, the user may not have enough information to decide whether the partial global counterexample shows the origin

In this contribution, a strategy for generating counterexamples for multi-object checking is described. We have demonstrated the usefulness of our strategy by a case study featuring a UML-based RI. RIS are considered as safety critical systems. The guarantee of the correct behavior throughout the system lifecycle is demanded. In order to save resources in developing and modifying RIS for amended railway layouts, an object oriented approach for establishing interlocking systems is investi- gated in this work. Infrastructure elements are considered as infrastructure objects in a UML-based RI. The objects of a RIS cooperate with each other to function as an interlocking system.

Multi-object checking has been successfully applied to verify UML-based RIS. We concentrate on verifying the safety aspect of the model. The provided graphical counterexample in this contribution helped correcting the state machines displaying the obviously unhandled situation. We believe that this methodology that improves the understanding and communication among professions of different disciplines, can improve the whole development process of a system.

We have also shown a further step of improving system development by designing a more comprehensible verification strategy. It provides illustrative counterexam- ples and generates test cases automatically. Therefore, we have demonstrated how TTCN-3 test cases can be derived from checking conditions during the early stage of system development.

Pavlovic, O., R. Pinger, M. Kollmann and H. Ehrich, Principles of Formal Verification of Interlocking Software, in: E. Schnieder and G. Tarnai, editors, Proc. of the 6th Symposium on Formal Methods for Automation and Safety in Railway and Automotive Systems (FORMS/FORMAT 2007) (2007), to appear.

