The rest of the paper is structured as follows: Section 2 sets out the notions of programs, models and safety properties we use. Section 3 shows how to use two- player games to falsify safety properties without performing any of the usual tasks listed above. Section 4 presents an illuminating example of falsification. Section 5 shows how our approach supports the easy incorporation of must information when it is available. Section 6 concludes and discusses related work.

The preceding example only works because we distinguish F and P nodes, and use different rules for them; if P controlled the choice of n, he could force n = 0 and then ERROR is not reached. The example also illustrates the style in which we intend to deal with nondeterminism, which is needed to ensure that the program is tested over all inputs. Instead of using atomic nondeterministic statements such as havoc (e.g. [13]), we propose to encode them using small control flow graphs consisting of choice edges and deterministic statements, and then analyse these with over-approximation in the same way as the rest of the program. The game structure will take care of making sure that all the possible choices are explored.

