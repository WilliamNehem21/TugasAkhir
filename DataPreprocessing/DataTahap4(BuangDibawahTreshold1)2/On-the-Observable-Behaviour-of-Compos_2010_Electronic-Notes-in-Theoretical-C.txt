Building upon [4,19] our component model will first be described by an appro- priate metamodel and then precisely defined in terms of an algebraic approach. We distinguish between simple (i.e., basic) components, component assemblies, i.e., net- work structures of components connected via their ports, and composite components which make up large scale components by encapsulating assemblies. For the formal representation of behaviours we use I/O-transition systems which are based on in- terface automata [12]. Explicit I/O-labellings allow to distinguish between input, output and internal actions which can be hidden to compute (derive) the observable behaviour of components. The behaviour of an assembly is also an I/O-transition system which is derived from the composition of the observable behaviours of the connected components of the assembly.

The second goal of this study is to provide support for an efficient construc- tion and behavioural analysis of large scale component systems. In the context of component-based systems this usually means construction and analysis of assembly behaviour or, in other words, facing the state explosion problem, which has been the source of investigation at many places. There are, for instance, approaches to compositional reachability analysis (CRA) such as [10] and, even more prominent under the umbrella of component-based systems, approaches which focus on efficient analysis of safety and liveness properties such as [5,9,16,18,17]. However, the men- tioned studies focus essentially on the analysis of assembly behaviour, whereas our focus is on the construction of the observable behaviour of a composite component which encapsulates an assembly. Given a composite component CC that encap- sulates an assembly a with behaviour beh(a), the observable behaviour obs(CC) of CC is formally defined by observational abstraction from beh(a). The idea is then to identify components within the assembly a which do not play any role for the observable behaviour of CC. Formally, this idea will be reflected by our no- tion of behavioural neutrality. Then, instead of computing the behaviour beh(a) of the complete assembly it is sufficient to compute the behaviour of a simpler as-

The cost of the reduction algorithm depends primary on the cost of the neut- rality checks which are performed between connected components of the assembly and hence depends on the complexity of the observable behaviours of the subcom- ponents. But we can reduce the cost of neutrality checks between components if we utilise the fact that components are connected via ports, that ports have themselves, usually much simpler, behavioural protocols and that component behaviours should conform to the behaviour of their ports. We show, as a further important result, that it is sufficient to perform neutrality checks for the behaviours of connected ports provided that ports to be checked for neutrality have a weakly deterministic behavioural protocol.

The remainder of this paper is structured as follows: Section 2 summarises definitions, operators and facts for I/O-transition systems. In Sect. 3 we review our component model by means of a metamodel and an example and complement the description by a precise algebraic definition. We consider behaviours of ports and of simple components and we describe how assembly behaviours and observable behaviours of components can be formally derived from their parts. In Sect. 4 we focus on our main results concerning simplified computation of the observable behaviour of composite components and we discuss the important role of ports for efficient neutrality checks. Section 5 provides a detailed discussion on related work and, finally, Sect. 6 summarises our approach and outlines future work.

For deriving behaviours in our component framework we will use the following operators on iotss: hiding, relabelling and the formation of products. Hiding and relabelling on iotss are generalisations of the usual operators used in various process algebras (see, e.g., [26,23]), the product of iotss is defined in accordance with the product of interface automata [12].

We illustrate our component model by the compressing proxy system also used by Bernardo et al. [5]. In contrast to [5] we use here an additional component for the compression of graphical data which will be useful for our discussions later on: An HTTP proxy server mediates connections between a web server and their clients. In order to increase network bandwidth, the proxy server may apply different compres- sion techniques depending on the kind of information transferred. The proxy server distinguishes between textual (txt) and graphical (gif) data and applies different compression tools before sending the data further downstream.

The simple components as well as the composite component show port declar- ations (like t : TxtCompr or l : UpStream). The port declarations of the composite component are called relay ports. Port declarations are interconnected by as- sembly connectors inside the assembly (like the connector tz between t : TxtCompr and z : Zip) 4 and delegate connectors to the outside (like the anonymous connector between u : UpStream and l : UpStream).

Based on the static structure of the compressing proxy system the informal descrip- tion of its intended behaviour reads as follows: A proxy of type CompressingProxy receives stream-based data on its port l which is delegated to the port u of the contained component adapt. The adaptor distinguishes textual and graphical data received at u and forwards textual data for compression via port t and graphical via port g. After receiving the compression result, adapt sends the data further downstream using d which is relayed to r.

We complement the metamodel presentation of our component model with an al- gebraic description, which defines formally all previously mentioned concepts and behaviours in terms of algebraic structures and iotss resp.; see Sect. 2. In particular, we distinguish between those behaviours which have to be provided by the compon- ent developer and those that are computed (derived), by rendering the latter as definitions. We use italics for denoting all kinds of derived operators.

Based on the notion of behavioural neutrality, we can describe our reduction strategy for assemblies: If a component at the border of an assembly topology is behaviourally neutral for the next component attached to it, this leaf can not have a behavioural effect on the remaining assembly. We can thus reduce the assembly by removing a neutral leaf component. In order to obtain again a syntactically well-formed assembly, the particular binary connector is removed and replaced by a unary connector (Lem. 4.2). In a second step, we can eliminate also the unary connector, by hiding the port to which the neutral leaf was connected (Lem. 4.3).

A closer look reveals that in order to decide on neutrality along Def. 4.1, one needs to compute the composition of a leaf component behaviour with the behaviour of the attached component, which can still be quite expensive. To further optimise our method we are interested in criteria to avoid composition of full behaviours of components and to compose smaller transition systems instead. In Sect. 4.3 we show that port behaviours, in particular weakly deterministic port behaviours, can be used to provide such criteria. For this purpose we first need some further technical definitions and results on I/O-transition systems which are presented in the following Sect. 4.2.

In this section, we focus on the behavioural neutrality checks which are performed component-wise in our reduction algorithm of Sect. 4.1. We show that these neut- rality checks may be optimised by considering instead of component behaviours the protocols of connected ports.

Closer to our approach is Darwin [24,20] as a language for design specifications of distributed systems. In particular, in combination with the Tracta method [15] it becomes evident that we do not only share key abstractions such as components encapsulated by ports but also the semantic domain of labelled transition systems (LTS) together with a compositional reachability analysis (CRA) for composed sys- tems which utilises specifications of the static structure. Even though I/O-transition systems provide a more convenient way to be precise about whether an action is a message reception, a message sending or an internal action, we could have used LTSs for the purpose of this article as well. However, since we are currently also working on a refinement relation where the difference between input and output becomes important, we just sticked to our semantic domain of I/O-transition systems.

We have studied composite components and their observable behaviour based on a metamodel which clearly distinguishes different kinds of behaviours that are relevant for the construction and analysis of hierarchical systems using port-based compon- ents. We have provided conditions for a more efficient computation of the observable behaviour of a composite component using syntactically reduced assemblies. At the core of our reduction strategy is a notion of neutrality between component beha- viours. The approach is particularly useful for rooted composite components with acyclic assemblies, since then it might be the case that it is only the root component which remains in the reduced assembly.

