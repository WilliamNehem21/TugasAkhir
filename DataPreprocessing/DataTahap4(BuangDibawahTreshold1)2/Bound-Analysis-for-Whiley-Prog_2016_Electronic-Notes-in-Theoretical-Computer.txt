The Whiley compiler can generate naive C code, but the code is inefficient because it uses infinite integers and dynamic array sizes. Our project goal is to build up a compiler that can translate Whiley programs into efficient OpenCL code with fixed-size integer types and fixed-size arrays, for parallel execution on GPUs. This paper presents an abstract interpretation-based bound inference approach along with symbolic analysis for Whiley programs. The source Whiley program is first analyzed by using our symbolic analyzer to find the matching pattern and make any necessary program transformation. Then the bound analyzer is used to analyze the transformed program to make use of primitive integer types rather than third-party infinite integer type (e.g. using GMP arbitrary precision library). The bound analysis results provide conservative estimates of the ranges of integer variables and array sizes so that efficient code can be generated and integer overflows avoided. The bound analyzer combines the bound consistency technique along with a widening operator to give fast time of solving program constraints and of converging to the fixed point. Several example programs are used to illustrate the bound analyzer algorithm and the program transformation.

Static program analysis techniques validates the consistency between software spec- ifications and program behaviors using mathematical methodologies. For example, the bound consistency technique is widely used to solve the finite constraint do- main problem (a.k.a constraint satisfaction problem)[17]. However, the problems of object-oriented program languages, such as side-effect problems or non-deterministic results, makes it a grand challenge[15] to create such a compiler, with automated

Whiley[20] is a new and verification-friendly programming language with the aim of resolving verification issues that arise from object-oriented programming languages. Whiley verifying compiler can detect bugs at compile-time and convert the program into bug-less Java or C code. However, translating high-level Whiley programs into efficient implementations has some challenges, for instance, the use of unbounded integers causes substantial slowdown on the performance of Whiley implementations.

This paper is organized as follows. Section 2 reviews some related works about static analysis, bound analysis and symbolic loop bounds. Section 3 describes the bound inference procedure, fixed-point approximation using widen operator, and pattern matching along with program transformation. Section 4 illustrates the algorithm of bound analysis with example programs and shows the performance of generated C code with/without program transformation. And the final section concludes the future work.

Loop bound analysis is a compiler optimization technique to obtain the number of loop iterations and prove the loop termination. It also can unroll the loop to reduce the compiler heap consumption. The commonly used techniques include pattern-matching and counter increment.

The bound analyzer is implemented as a Java plug-in on top of the Whiley project. It infers the bounds of integer variables in two phases. First, the analyzer evaluates each WyIL code semantics to extracts the constraints on the abstract domain. Then the analyzer computes bounds with the bound consistency technique and converge the termination time by using the abstract interpretation-based widening operator.

CFG Construction. The analyzer processes each WyIL code semantics to build up a control flow graph (CFG) for each function and add it to a map for later use. Based on WyIL code type, the analyzer creates different types of CFG blocks (see CFG Definitions[1]), then extracts the bound constraints and place them into the CFG block.

The gradual widening operator broadens an increasing upper bound to the min- imum of possible maximal thresholds. Otherwise, the upper bound u stays un- changed. And the operator widens the decreasing lower bound l to the maximum of minimal thresholds. The widening operator is repeatedly applied on the bounds until all the bounds have no changes. The inferred bounds allows the code generator to determine the smallest fixed-sized integer data type. For example, short integers can be used to store the variables in the range of I16min and I16max.

A typical while-loop is classified as incremented or decremented loop pattern (see Theorem 3.4 and Theorem 3.5). Build List pattern is also an extension of while- loop pattern with an additional list and list predicates. As the list is initialized with an empty array and inserted with only one item at each iteration, build list pattern suggests that the list size can be estimated by inferring the number of loop iterations (see Theorem 3.6).

The transformer changes the while-loop structure to the for all pattern and divides the program into several parts, including pre-loop, loop header, loop body and loop exit. The pre-loop part is split into S1 and S2 by init; the loop body part is grouped into S3 and S4 by update; S5 is the loop exit. S1 ... S5 can be preserved and put into the transform program in order without changes (see Theorem 3.7).

In Nested If-else test cases, the bound results show that the bound analyzer propagates the bounds for each function call and produces context-sensitive bounds that are as precise as the bounds from the industrial Frama-C. In the while-loop test case, the bounds analysis result show that the bound analyzer using the grad- ual widening strategy achieves more precise bound results than Frama-C (without unroll-loop option). In the Dynamic-sized List test case, the performance chart shows that the program transformation speeds up the generated C code, but allows the bound analyzer to replace the dynamic list by a fixed-size array with in-place updates. This will be a good basis for generating parallel code in the future.

The symbolic and bound analysis enable the code generator to make use of fixed- sized integers and fixed-sized lists in translation so the generated code avoids integer overflows and out-of-range list errors and reduces memory usage. This makes our project similar to the w constraint operator[8]. But our gradual widening operator increases the precision of bound analysis, and the support for program transforma- tions improves the efficiency of generated code.

