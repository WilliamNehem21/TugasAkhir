Unfortunately, LGGs are still not convenient enough to de ne a VL in gen- eral because of at least missing Negative Application Conditions (NACs) and further conditions for rules. Therefore, a new form of LGGs, called Contextual Layered Graph Grammars (CLGGs) was developed [2] which support vertex embedding, NACs, and complex predicates. This approach includes the de - nition of layering conditions guaranteeing termination of the parsing process. Furthermore, static analysis techniques like critical pair analysis [10,9,12] are available which can be exploited to identify a maximum set of rules which may be parsed without any need for backtracking.

might be tricky to use in more complex cases. CLGGs are related to Reserved Graph Grammars (RGGs), another restricted and modi ed form of LGGs [13]. RGGs o er some kind of embedding mechanism, too, but do not support the de nition of predicates (however, not used in GenGEd) and NACs. Their rules have to be locally con uent, so that the polynomial naive LGG parsing algorithm in [11] works. Backtracking for handling recognized critical rule pairs is not supported.

The GenGEd environment implements concepts for the visual speci cation of VLs [1]. A VL-speci cation is given by a visual alphabet and a visual grammar. In the visual alphabet the types of symbols and links occurring in a VL are speci ed. The visual grammar consists of a start expression and a set of context-sensitive grammar rules. Originally the grammar rules de ne the syntax-directed editing commands of a language-speci c graphical editor, i.e., the visual grammar does not only comprise language-generating rules but a convenient set of editing rules as well. In the following we show that the concepts of VL-speci cations can be easily extended by the speci cation of parsing.

GenGEd is based on algebraic graph transformation [4] and graphical constraint solving [7]. A visual alphabet is represented by an attributed graph structure signature 2 and a constraint satisfaction problem de ning positions and sizes of visual elements. Correspondingly, a visual grammar is represented by an attributed graph structure grammar where the constraint satisfaction problem of each visual expression is satis ed. Moreover, we distinguish two syntactical levels, namely the abstract syntax describing the logical part of a VL, and the concrete syntax denoting the layout.

According to the constituents of a VL-speci cation, the GenGEd envi- ronment comprises an alphabet editor and a grammar editor. The speci ed alphabet is the input of the grammar editor, where so-called alphabet rules are generated de ning the editing commands of this editor.  In this way it is guaranteed that only correct visual expressions can be de ned by a lan- guage designer. For the transformation of visual expressions according to the abstract syntax the Agg system [6] is used. The graphical constraints are solved by the constraint solver ParCon [7].

The parsing algorithm proposed in [2] (which is based on Contextual Lay- ered Graph Grammars (CLGG) and critical pair analysis) is now implemented using the Agg system, hence we call it Agg graph parser. In GenGEd we in- tegrated the Agg graph parser such that we yield a parser for visual languages. In this sense, not only syntax-directed editing but also free editing is available in speci c graphical editors generated by GenGEd, similar to [8]. As before, the alphabet editor supports the de nition of visual alphabets comprising the types for symbols and links. Based on a visual alphabet, the grammar editor may be used in two ways: for the de nition of comprehensive syntax-directed editing rules as well as for the de nition of a parse speci cation. The latter one is explained in the following.

Graph rules occurring in a parse grammar consist of a left-hand side (L) and a right-hand side (R) over typed (labeled) graphs. Parts of both rule sides are related to each others. The related parts are preserved during a graph transformation. All non-related graph objects of L are deleted, all non- related objects of R are created. Moreover, a rule may contain a set of NACs specifying exactly those fractions of matching situations that must not exist for a rule to be applicable.

Assigning rules as well as vertex and edge types to layers such that a certain layering condition is satis ed (cf. [2]), the layer-wise application of rules (according to the rule layer) toa given terminal graph always terminates. Roughly speaking, the layering condition is ful lled if each rule deletes at least one vertex or edge coming from a lower level (deletion layer) and creates graph objects of a higher level (creation layer).

In the GenGEd grammar editor, the critical pairs are generated automat- ically from the Agg graph parser, but the remaining constituents the language designer has to de ne. For our example of simpli ed UML class diagrams, the parse rules express the deletion of visual symbols such that for each lexical symbol of the visual alphabet there is one parse rule. These rules and the layer function are proposed in the following.

According to the visual alphabet, a class symbol always has to be linked to a package which is expressed by the left-hand side L of the rule. Moreover, we expect that the user always inserts a class symbol together with a class name represented by the node x':CN holding the value represented by the variable cn. The NAC states that the class name has to be unique in one package.

The layer function for our small example is given below. Thereby we use the abbreviations dl for deletion layer, cl for creation layer, and rl for rule layer. Note that the rule layer supports the ordering of rule application, whereas the deletion and the creation layer are necessary for the termination of the parsing algorithm. Note that the language designer must not de ne creation nor deletion layers for links; those are generated automatically in dependence of the symbols the links have in their domain, i.e., the source vertices of the corresponding link edges.

For the critical pair analysis which must be done only once, the Agg graph parser is called with the parse grammar and the layer function. The resulting parse speci cation and the visual alphabet is the input of the graphical editor where the user can manipulate visual expressions (diagrams) in a free editing style. In order to check the visual expression against the visual syntax, the Agg graph parser gets the parse speci cation together with the visual expres- sion as input and checks whether the expression is correct or not. The result will be illustrated in the graphical editor.

[9] M. Lowe and J. Muller. Critical Pair Analysis in Single-Pushout Graph Rewriting. In G. Valiente Feruglio and F. Rosello Llompart, editors, Proc. Colloquium on Graph Transformation and its Application in Computer Science. Technical Report B-19, Universitat de les Illes Balears, 1995.

