TestEra is a novel framework for automated testing of Java programs. We have built TestEra upon Alloy, a lightweight rst-order relational language, and the Al- loy Analyzer, a fully automatic simulation and checking tool. Checking a Java program with TestEra involves modeling the correctness criteria for the program in Alloy and specifying abstraction and concretization translations between instances of Alloy models and Java data structures. TestEra automatically generates all non- isomorphic test cases within a given input size and veri es the correctness.

TestEra presents a solution to the problems encountered in modeling com- putation|TestEra executes the actual implementation code, exploiting Al- loy's suitability for expressing structural properties to automatically generate test cases. TestEra provides a novel lightweight approach to formal meth- ods. The abstraction and concretization translations for evaluating INS using TestEra were constructed in a day by a researcher (the second author), who had a limited experience with Alloy and no prior knowledge of INS code.

Our study has several signi cant aspects. First, it shows how to use a simple declarative language to perform automated testing of complex Java programs. Second, our study illustrates the role a lightweight formal method can play in interactively correcting a awed implementation without the need for modeling computation. Third, our study illustrates how easy it is for sys- tem builders to overlook subtle bugs that can be detected using fairly small inputs. It also shows how the lack of a formal speci cation can cause devel- opers to develop incorrect intuition about the behavior of their system.

The rest of this paper is organized as follows. Section 2 presents an overview of the TestEra framework and the key notions of Alloy and AA. Section 3 describes the fundamentals of the naming architecture of INS. In Section 4 we apply the TestEra framework to test the Java implementation of INS. Related work is presented in Section 5, and we conclude in Section 6.

Alloy can be used in various approaches to analyze Java programs. One approach is to model both the inputs and the computation in Alloy and to use AA to verify the correctness criteria, also expressed in Alloy. Our earlier analysis [16] of INS proceeded in this fashion. We discovered that manually modeling computation is complicated due to Alloy's declarative nature. Fur- ther, this translation is hard to automate due to scalability issues of AA's automatic analysis.

Alloy is a strongly typed language that assumes a universe of atoms partitioned into subsets, each of which is associated with a basic type. The standard mathematical notion of a relation is the only datatype. The value of any expression is always a relation, i.e., a collection of tuples of atoms. Each element of such a tuple is atomic and belongs to some basic type (i.e., the element cannot itself be a relation). A relation may have any arity greater than one. Relations are typed.

There are two product operators: dot and arrow. The dot operator is com- position: p.q is the relation containing the tuples hp0;::: ; pm 1; q1 ;::: ; qni, where p contains hp0;::: ; pmi, q contains hqo;::: ; qni, and pm = q0 . When p is a unary relation (i.e., a set) and q is a binary relation, the composition p.q is standard composition.

Expression quanti ers turn an expression into a formula. The formula no e is true when e denotes a relation containing no tuples. Similarly, some e, sole e, and one e are true when e has some, at most one, and exactly one tuple, respectively.

A declaration is a formula v op e consisting of a variable v, a comparison operator op, and an arbitrary expression e. A side-condition on the variable v might be added by embellishing the expression e with multiplicity markings. There are two kinds of markings. A set marking is one of the keywords set or scalar pre xing the expression; scalar adds the side condition that the variable denotes a relation containing a single tuple, and set says it may contain any number of tuples. The default marking is set, except when the comparison operator is the colon (:) or negated colon (!:), and the expression

The Alloy Analyzer 1 (AA) [12, 14] is an automatic tool for analyzing Alloy models. Given a formula and a scope|a bound on the number of atoms in the universe|AA determines whether there exists a model of the formula (i.e., an assignment of values to the sets and relations that makes the formula true) that uses no more atoms than the scope permits, and if so, returns it.

Since rst-order logic is undecidable, AA's analysis cannot be a decision procedure. Instead, AA limits its analysis to a nite scope that bounds the size of the carrier sets of the basic types. A model is within a scope of k if it assigns to each type no more than k elements. AA's analysis [12] is based on a translation to a boolean satisfaction problem and gains its power by exploiting state-of-the-art SAT solvers.

AA can enumerate all possible instances of an Alloy model. AA adapts the symmetry-breaking predicates of Crawford et al. [6] to reduce the total number of instances generated|the original boolean formula is conjugated with additional clauses in order to produce only a few instances from each isomorphism class [22]. TestEra exploits this functionality to automatically generate test cases from an Alloy model of inputs to a Java program.

One proposal for service discovery in dynamic networked environments is the Intentional Naming System (INS) [1, 21], which allows services to de- scribe and refer to each other using intentional names. These names describe a set of properties that the services provide rather than the network loca- tion, e.g., \the nearest color printer that handles transparencies" rather than

Queries made by clients are resolved by calling Lookup-Name method. In- voking Lookup-Name on the example query and database returns R0, because the value of attribute \service" sought by the client (i.e., camera) does not match that provided by R1 (i.e., printer).

A Java implementation of the naming architecture of INS appears in [21]. About 1500 lines of Java code implement the core functionality of INS. Ap- pendix A shows relevant parts of the Java data structures and Appendix B gives the Java implementation of Lookup-Name provided in [21].

A DB is an AVTree that introduces two new elds. For each DB db, db.records is the set of all records in db, and db.recs is a relation that maps non-root values in db.vnodes to records stored there. A group of constraints expresses

The example concretization operates in two stages. In the rst stage, a2j creates for each atom in the Alloy instance, a corresponding object of the Java classes and stores this correspondence (in map). The only non-trivial part in the example is that the value corresponding to the root of the database is mapped to a NameTree, whereas all the other values are mapped to a ValueNode. In the second stage, a2j establishes the relationships between the Java objects created in the rst stage and builds the data structures. In our running example, a2j only links the value and attribute nodes using the existing methods from their corresponding classes.

Translations use the class MapAJ to store bi-directional mapping between Alloy atoms and Java objects. This class behaves like java.util.HashMap; e.g., map.get(atom) returns the Java object corresponding to atom. (Abstrac- tions use method map.getAtom(object,sig) that returns the Alloy atom cor- responding to (Java) object if there is such an atom in the mapping; if there is no atom, getAtom creates a new atom for the signature sig, adds it to the mapping, and returns it.)

Next we show a slightly di erent use of TestEra. We evaluate a partial cor- rectness property of INS that involves the operations Lookup-Name, Add-Name, and Get-Name. For a query q and an advertisement a, INS does not specify how to evaluate whether a service r advertising a provides the properties de- sired by an application querying for q. A fair assumption is that a conforms to q if Lookup-Name(db,q) = r, where db is the database containing only the advertisement a made by r. We use this assumption as a basis to test whether Lookup-Name returns exactly those services whose advertisements conform to the query.

This counterexample points out two defects in the design of Lookup-Name. First, there is no consistent notion of conformance. Second, simply adding new services to the system can reduce results produced by Lookup-Name, i.e., addi- tion is not monotonic in INS|a property that is essential for the correctness of any such naming scheme.

Having established that INS does not originally have a consistent notion of conformance between a query and an advertisement, we de ne this notion for INS. We regard an advertisement to conform to a query if the query is a sub- tree of the advertisement, i.e., the advertisement mentions all the attributes and values that make up the query in the correct order. With this de nition of conformance, we test if INS inventors' implementation of Lookup-Name returns exactly the conforming records.

a scope of 3 Attributes, 3 Values, and 2 Records in phase 1 of TestEra, AA produces 16 test cases in 8 seconds. Phase 2 analysis takes 6 seconds and reports that only 10 pass. This is not surprising, since we are testing the original implementation of Lookup-Name for correctness against our de nition of conformance. Nonetheless, doing so illustrates the diverse kinds of analyses allowed by TestEra.

We use the aws in Lookup-Name identi ed thus far to correct its im- plementation with respect to the sub-tree de nition of conformance given in Conforms. The test cases generated for evaluating CorrectLookup above are re-used to test this modi ed implementation. Phase 2 analysis of TestEra concludes in 6 seconds and results in no counterexamples.

Recall that AA compiles Alloy models into boolean formulas and uses o -the-shelf SAT solvers to generate instances (counterexamples). Hence, it comes as no surprise that phase 2 analysis of TestEra takes lesser time than phase 1|in phase 2, a correctness condition is veri ed for a given valuation of relations in the Alloy model, whereas in phase 1, a valuation is generated; cf. verifying that a given solution makes a boolean formula true as opposed to nding a solution.

Horcher [11] presents a technique for software testing based on Z [23] spec- i cations. This technique provides automated test execution and result eval- uation. However, concrete input test data need to be selected manually from an automatically generated set of test classes.

Chang et al. [4] present a technique for deriving test conditions|a set of boolean conditions on values of parameters|from Assertion De nition Lan- guage (ADL) speci cations. These test conditions are used to guide test se- lection and to measure comprehensiveness of existing test suites.

program's state space through program slicing and data abstraction. It allows users to analyze properties of Java programs by modeling them into the input language of one of several existing model checkers like SPIN [10] and SMV [18]. JavaPathFinder [9] and JCAT [7] transliterate Java programs to Promela programs. They handle a signi cant portion of Java including dynamic object

