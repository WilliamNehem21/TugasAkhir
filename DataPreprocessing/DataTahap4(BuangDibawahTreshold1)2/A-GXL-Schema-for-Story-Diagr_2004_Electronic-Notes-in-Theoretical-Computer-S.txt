This paper briefly outlines the process of generating story diagrams, and describes a GXL schema to represent them. These diagrams result from a static, heuristic reverse engineering analysis and combine the data and behavioral information of UML activity and collaboration diagrams. This paper also summarizes potential issues in representing and visualizing story diagrams.

UML is a popular object-oriented modeling notation used in software devel- opment [9]. The story diagram is a combination of the UML activity and object collaboration diagrams. This diagram was originally developed as a graph grammar language for forward engineering [6,7]. When used for reverse engineering, it can be used to better understand the control behavior and object-level dependencies of the software being analyzed [5]. For example, the story diagram can present the notions of links being created and deleted between objects within the control flow of the program [2].

Section 2 uses an example to illustrate how GXL is used to represent the method-level story diagram and how the information can be extracted from the source code to form the story diagram. Section 3 summarizes some of the issues we encountered in designing a GXL schema. Section 4 concludes the paper.

Extract object collaborations: In the activity nodes (depicted as boxes), the specific actions are illustrated by object collaboration diagrams. The method calls or statements are marked by numbers according to the order in which they are invoked. For each method, start and end nodes depict the entry and exit points of the control flow.

Extract link creation and deletion: Knowing the data dependencies or links formed or destroyed between objects can help programmers under- stand the detailed object interactions. Heuristics are used to extract these links statically. A green edge depicts a link that has been formed, and a red edge depicts one that is now broken. The following sub-section describes the current heuristics.

Link creation and deletion are distinct features that separate story diagrams from normal UML collaboration diagrams. Since the relationships between the objects are not always direct, and might occur through library routines, some heuristic rules are applied. The main approach considers the keywords of the method name at the site of a method call upon an object. If the call contains arguments, the referred objects are checked against the following rules to see if a link potentially exists between it and the receiving object of the method call.

Link deletion rules are similar (with keywords such as remove, delete, etc.), with the added case of set*(null). For example, if anObj is discovered to be linked to some other object, then anObj.setComponent(null) will break the link between the two objects.

Currently, we are working towards a consistent schema for the representa- tion and visualization of story diagrams at higher levels of abstraction. Repre- sentation aspects include appropriate text labels with source code fragments. Visual aspects include the shapes and colors of nodes and edges. At present, this information is stored as attributes of the corresponding nodes or edges.

In generating control flow diagrams in GXL format, we encountered the need for compound subgraphs where edges need to span the boundaries of two subgraphs at different levels (i.e., are not contained wholly within a nested subgraph). According to [12], we should put these edges in the least-common- ancestor graph node. These kinds of dependencies create graph-layout chal- lenges.

GXL can be used to represent method-level story diagrams using the schema outlined in this paper. XML markup over Java code and the GXL represen- tation can be used at the same time to present the code view and graph view of the story diagram. Extending the schema for higher-level story diagrams is ongoing work. Also, difficulties arise in the graph layout of complicated compound graphs such as story diagrams.

