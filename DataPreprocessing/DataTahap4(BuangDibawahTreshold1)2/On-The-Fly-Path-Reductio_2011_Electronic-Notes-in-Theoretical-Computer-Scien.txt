Despite a significant amount of research on abstractions, state explosion is still a major obstacle for the applicability of (explicit-state) software model checking to real-world applications [5]. One such abstraction for CTL model checking is the so-called path reduction [18]. The key idea of path reduction is to collapse single- successor chains in the state space if intermediate states cannot influence the validity of a specification. This means that states are only stored when visiting program locations that cause a branching in the state space or influence the validity of the CTL specification. These program locations are called breaking points. For instance, a program statement that alters the value of a variable used in an atomic proposition or reads a nondeterministic value, which causes a branching in the state space, is called a breaking point. Storing states only at these specific locations reduces the memory footprint of the state space, possibly at the cost of increased runtime.

To guarantee termination of the model-checking process, states need to be stored in possibly nonterminating loops (for fixed-point detection). Thus, at least one location in each loop has to be breaking. Despite the advances in termination proofs for high-level programs [7], these techniques are not yet applicable to low- level code.

Our main contribution in this paper is a new technique called on-the-fly path reduction, which performs state-space reductions dynamically while state spaces are built (see Sect. 2). This technique is novel in that it performs tasks such as detecting fixed points while states are generated. We also detail how to expand counterexamples obtained with path reduction to concrete counterexamples [3,6] (see Sect. 3). To evaluate the effectiveness of on-the-fly path reduction, we compare its performance to results obtained using static detection of breaking points in Sect. 4. Finally, Sect. 5 presents related work and Sect. 6 concludes the paper.

We will now evaluate the criteria for a state to be breaking, i. e., to show up in the reduced state space. For SPR, this criterion solely depend on the program counter. Here, breaking program locations (breaking points) are found using static

The first two conditions make locations breaking where the corresponding state has more than one successor in the state space. The third condition guarantees that all changes of variables used in the formula are visible to the model checker. Finally, the fourth condition ensures the existence of a breaking point in every loop in the program, such that every loop in the state space has at least one breaking state for fix-point detection.

show up in the state space. To maintain visibility of all changes to the model checker, the second condition assures that at most one transition might influence the formula in each elementary path. The last criterion is needed to guarantee termination and will be studied in detail later on. First, we formally describe the algorithm for the OPR successor state generation:

The third criterion is an improvement of the second criterion. It takes just the 64 bit hash code of the raw state data as a criterion for detecting already encountered states. This is faster and less memory intense, since only the hashes of all intermediate states have to be stored while simulating along an elementary path. As our case study will show, the third criterion offers the high accuracy while being a very fast possibility to detect a loop in the state space.

d. States omitted by the path reduction (b and bj) are shown as dotted circles. To understand such a counterexample trace, it is crucial to know which nondeterminis- tic decision has been taken for the (a, b) transition. Unfortunately, this information is not readily available from the (a, c) transition visible in the counterexample trace: State c might be too far away to distinguish the (a, b) transition from the (a, bj) transition without manual investigation.

For each criterion, the model checker had to generate the entire state space of the program. The results of these runs are shown in Tab. 1. The reference values without any abstraction are shown in Tab. 2, in the entry for vector.

In the next program, reentrance, a 16-bit integer variable is accessed concur- rently in the main process and in an interrupt handler. As the ATmega has an 8-bit architecture, such accesses are non-atomic, thus leading to race conditions. The reduction in states stored achieved by SPR is 93.84%. OPR reduces the state space further by halving the number of remaining states, yielding a reduction of 96.92%. The increase in runtime due to revisits was 10.85% for SPR and 11.94% for OPR.

Considering that far less states are stored using OPR, this increase is actually surprisingly low. An explanation for the large difference between the two approaches to path reduction is the different handling of loops. In order to guarantee termi- nation of the state space generation in the presence of program loops, SPR has to assume at least one position in the loop to be breaking (cp. [13]). In our implemen- tation, this position is indicated by the head of the loop. Thus, on each revisit of the program counter position of the head, SPR terminates the current chain and stores a state. OPR, on the other hand, does not have to store at the head of a loop (in fact, it is unaware of the existence of the program loop), unless it uses the same program counter approach for termination detection. Hence, OPR compresses loop iterations far more efficiently.

So far, we examined the effect of OPR when checking the formula AG TT , which is true in every state. In this section, we will now evaluate the effects of OPR when checking actual formulae whose validity depend on variables. Since path reduction needs to store states when a transition influences the formula, we expect an increase in the size of the state spaces.

For the first examinations, we decided to use the window lift program. The results are shown in Tab. 3. As described in Sect. 4.2, the program models an auto- motive electrical window lift, and is based on a state machine. The state machine is implemented using a global integer variable called mode, which is expected to assume only the values 0 to 6 at any time during execution. Hence, our first test was to check this using the formula

Our second test program for this case study was plant, also described in detail in Sect. 4.2. The first property to verify was, similar to window lift, to verify that a global variable satisfies certain constraints, which can be specified by the formula

prematurely stop the state space generation. Thus, the time for model checking and the size of the state space is not comparable to the other case studies. For the verification of formula (1), we have an increase of 83.24% of the state space size, while the time decreased slightly, due to the smaller number of revisits. For formula (3), the increase of the state space size is negligible.

Later, Quiros [12] has adapted the approach of Yorav and Grumberg to a byte- code language used in a virtual machine. This bytecode language is similar to a parallel while language. This means that function calls are handled using inlining, communication is performed at certain program locations, and indirect control is not supported. Hence, SPR turns out to be effective for this domain. Our own prior work [14] adapts these earlier approaches to the domain of binary code verification by introducing tailored static analyses and revising breaking conditions for binary code.

Behrmann et al. [1] implemented a similar technique for the model checker Up- paal, which focuses on timed automata. Their approach is similar to our imple- mentation of SPR: they decided for a static analysis of the control structure of the automata in order to obtain a so-called covering set of edges. This set is used in order to guarantee termination in case of loops in the state space. States that are targets of edges in the covering set have to be stored, which exactly corresponds to the breaking property used in SPR. As we have illustrated, this property can prove a significant disadvantage of SPR in the presence of long-running but terminating loops. Our contribution, OPR, can handle such loops without storing states in each

This paper describes a new technique for dynamic path reduction and shows the pre- dominance of this method over approaches based on static analysis for the specific application of binary code model checking. Further, it shows how counterexam- ples generated using this abstraction technique can be expanded in order to ease their comprehensibility. In terms of effectiveness, the OPR approach allows for formidable state space reductions, comparing it to static path reduction techniques. The smaller memory footprint, however, may lead to higher runtimes. Thus, OPR provides a technique that allows to trade runtime for memory.

