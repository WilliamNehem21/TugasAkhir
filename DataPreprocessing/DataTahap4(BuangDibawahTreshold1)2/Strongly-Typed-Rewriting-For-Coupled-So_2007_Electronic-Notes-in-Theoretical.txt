Coupled transformations occur in software evolution when multiple artifacts must be modified in such a way that they remain consistent with each other. An important example involves the coupled transformation of a data type, its instances, and the programs that consume or produce it. Previously, we have provided a formal treatment of transformation of the first two: data types and instances. The treatment involved the construction of type-safe, type-changing strategic rewrite systems. In this paper, we extend our treatment to the transformation of corresponding data processing programs.

The key insight underlying the extension is that both data migration functions and data processors can be represented type-safely by a generalized abstract data type (GADT). These representations are then subjected to program calculation rules, harnessed in type-safe, type-preserving strategic rewrite systems. For ease of calculation, we use point-free representations and corresponding calculation rules.

Thus, coupled transformations are carried out in two steps. First, a type-changing rewrite system is applied to a source type to obtain a target type together with (representations of) migration functions between source and target. Then, a type-preserving rewrite system is applied to the composition of a migration function and a data processor on the source (or target) type to obtain a data processor on the target (or source) type. All rewrites are type-safe.

produce it. In the context of software renovation, this problem occurs for example when the schema of a database needs to be adapted. The adaptation of the database schema must then be coupled with migration of the database instances and with updates of the programs that connect to these database instances.

An important research challenge remains in providing a general and comprehen- sive conceptual framework for coupled transformations [15]. Previously, we have taken first steps to providing such a framework. In particular, we have provided a formal treatment of two-level data transformations, i.e. coupled transformation of data types and instances [6]. In this paper, we extend our previous treatment to include transformations of data processors.

The query q that consumes values of type A and the producer p that gener- ates such values are examples of data processing programs. To obtain queries and producers on the transformed type A', we can simply compose q and p with the migration functions from and to. This amounts to a wrapper approach to program migration where the original type and the original processors are still explicitly present. The challenge that we take up in the present paper is to calculate proces- sors q' and p' from those wrapper compositions in such a way that they no longer involve the original type and processors. In Section 4 we explain how such program calculations can be harnessed in an additional type-preserving strategic rewrite sys- tem on type-safe representations of the functions (queries, producers, migrations) involved. The key idea is to use fusion or deforestation techniques [24] in order to eliminate the intermediate data type A.

program calculation (Section 4), and the type-changing rewrite system for two-level data transformation (Section 5) can be combined to perform coupled transforma- tions. Both rewrite systems employ a strongly-typed representation of types at the value level, recapitulated in Section 3. Section 7 discusses related work and Section 8 concludes.

a list (in ascending order of keys), and Map.map applies its argument function to each range element. Note that the migrated queries do not involve the original album type as intermediate format, and are not defined in terms of the original query wrapped by a migration function.

In both rewrite systems that we will define, we need access to type-representations on the value-level. The type-preserving rewrite system on point-free expressions needs them for type-directed rewrite decisions, while the type-changing rewrite sys- tem performs rewrites on types themselves. To ensure type-safety of both rewrite systems, a universal representation of types does not suffice.

Notice that in this declaration the type a that parameterizes Type a is restricted differently in each constructor. This is precisely the difference between a GADT and a regular parameterized data type, where the parameter of the resulting type must always be unrestricted. For example, the type constructor Int has type Type Int but List Int has type Type [ Int ]. Thus, the parameter a of the GADT Type a allows us to carry around the necessary type-information to ensure type-safety.

In this section, we explain how type-safe, type-preserving strategic rewrite systems are defined to apply program calculation rules to migration functions and data processors. In particular, we aim to apply fusion laws to simplify wrapped processors of original data into processors that work directly on new data, thus avoiding to build intermediate data structures of the original types. If fusion is successful, substantial gains of efficiency can be achieved.

We used a different approach. Before applying any rule concerning products we apply comp assocr exhaustively in order to guarantee that all compositions are associated to the right. Then some completion must be performed on the laws with an outermost composition when the right parameter is not arbitrary. As example consider the encoding of Prod-Cancel:

first succeeds).  is a left-biased choice that tries to apply the first rule or, if it fails, it tries the second. The many combinator repeatedly tries to apply a rule until it fails. many1 is similar but must succeed at least once. try tries to apply a rule and

us to combine local, single-step transformations into a single global transformation. Sample two-level rewrite rules  Depending on the scenarios to be addressed, the strategy combinators above can be combined with different sets of single-step rewrite rules to obtain appropriate rewrite systems. Elsewhere we provided sets of rules for format evolution and for hierarchical-relational data mappings [6]. The

The inside combinator applies its argument rule under a given tag. The addf ield combinator adds a new field, whose value is obtained by querying existing data. The assocr rule associates a nested product to the right. Below we will introduce further rules where necessary.

type is only available dynamically, after computing it. Hence the staging. In the first stage, we apply the transformation to obtain b dynamically, using showType , in the form of its string representation. In the second stage, that string representation is incorporated in our source code, and gets parsed and compiled and becomes statically available after all. Below we will demonstrate the use of this staged approach in interpreter sessions.

Note that this staged approach is not our only alternative for making use of the dynamically computed result type and migration functions. Instead, we can make judicious use of existential and universally quantified types to model dynamic types and dynamically typed values and functions, in a type-safe way [1]. With these, migration functions can be computed and used in a single stage.

ments. We do not show the straightforward extension of eval for these primitives. Of course these functions could be written in terms of more fundamental list and map functions, such as folds, but that would unnecessarily complicate calculations. Getting the right compromise between expressiveness and ease of calculation is one of the most challenging tasks when choosing the set of primitives for a particular application scenario.

tation tagged with "Album". The graceNote function (whose definition is omitted) uses the ASIN field to lookup track titles in some external data source such as the internet. After the field addition, the assocr rule is applied exhaustively to bring the resulting nested tuple into the desired right-associated form.

Program transformation in calculational form Several systems have been developed for performing program transformation in calculational form using fusion laws. Among these, MAG [19] and Yicho [13] are prominent, but both are targeted towards Haskell programs written in the pointwise style. In order to cope with fusion laws for generic recursion patterns both resort to advanced higher-order matching algorithms. We do not need such techniques because our recursive functions are limited to very specific patterns, such as maps, for which fusion is easier to encode.

In previous work [7] the first author presented a rewriting system for simplifying point-free expressions, which was used to optimize expressions resulting from a program transformation tool that translates pointwise Haskell code into point-free style. The main improvement of the system presented in Section 4 is typing: we can now use type representations to guide the rewriting process and rewrite rules are guaranteed to be type-safe. In his introductory book to Haskell programming [2], Bird presents a functional calculator that can also be used to simplify point-free expressions. Unfortunately, the expressions are not typed and, likewise to MAG, it uses a fixed rewriting strategy, which makes it difficult to apply in our scenario.

Alternatives to GADTs Our solution relies heavily on GADTs both for type representations and for type-directed and type-safe point-free rewrite rules. Although convenient, GADTs are not essential for these particular tasks. For ex- ample, it is possible to encode type representations in Haskell using existential quantification [1,3]. Type-directed rewrite rules could in principle be encoded also with type-classes using the techniques described in [18]. It would be interesting to see whether all ingredients of our solution to coupled rewriting could be realized with similar elegance without resorting to GADTs.

be generated by our type-preserving rewrite system. Likewise, each type-preserving rewrite rule on point-free expressions must be proven to be semantics preserving. But, once the properties are proven for individual rules and proven to be preserved by the basic combinators, any system composed from them inherits those properties. Termination and confluence are also for the responsibility of the programmer.

