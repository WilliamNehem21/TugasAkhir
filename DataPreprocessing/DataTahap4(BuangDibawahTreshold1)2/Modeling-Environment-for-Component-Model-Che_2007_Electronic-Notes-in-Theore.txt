(LTL, CTL). Checking whether a property is satisfied in the model is based on an exhaustive traversal of the state space determined by the model. This way, model checking can help to find concurrency errors like deadlocks, which are very subtle and quite hard to discover with traditional approaches such as testing. However, the main advantage of model checking - traversal of the complete state space (i.e. checking of the property in each state) - is also its main weakness. Especially in case of more complex software systems, the state space may be large enough to make model checking of a system not feasible; this is well-known as the state explosion problem.

However, considering only primitive components, the problem with model check- ing of these components is that they are not complete programs (e.g. with main method) - and model checkers typically analyze only complete programs. This triggers the problem of missing environment. An obvious solution is to create an environment of some form for each primitive component subject to model checking, and then separately check the complete programs, each composed of a primitive component and its environment.

It is a parallel composition of two subprotocols. The first of them specifies that the component should accept finite number of calls of backup on the bk interface. The second subprotocol states that the component has to accept call of start on its tm interface and then a finite number of calls of begin on tm, then it should accept calls of begin, commit and abort on tm in parallel, and finally it should accept the call of stop on tm.

We designed an algorithm, which is based on syntactical expansion and substitution of (parts of) behavior protocols. Its input consists of the frame protocols of all the components in the architecture (except the target one) and the graph of the bindings between the components, and its output is the environment protocol of the target component. The algorithm is divided into three steps, described below.

The problem of model checking of isolated software components, which form a component-based application, can be seen as a variation of compositional model checking [4], whose basic idea is to (i) decompose a target system into several com- ponents, (ii) verify local properties of the components via model checking, and (iii) deduce global properties of the whole system from the local properties of the com- ponents. The key point of this approach is checking properties of a composition of a selected component with a model of its environment, instead of checking prop- erties of the isolated component; by using an environment, it is guaranteed that the checked local properties are preserved also at the global level. The difference between compositional model checking and our approach is that the former aims at checking global properties of the whole program (or a set of processes) via checking local properties of individual components (or processes), while our approach aims at checking the properties specific to individual components (e.g. obeying of a frame protocol).

For verification of properties of software components, the assume-guarantee ap- proach [6][11] is often used. The idea is to check a component only in such envi- ronments that satisfy certain assumptions typically provided by the user; we can say that the assumptions model the valid environments of a component subject to model checking. This way, the need to check the component in all possible environ- ments (or in a universal environment), what is usually an infeasible task, is avoided. Application of model checking to a component with an environment satisfying a cer- tain assumption then verifies whether the component satisfies the given property under the given assumption. If the model checker returns a positive answer, it is guaranteed that the component, when used in an environment that satisfies the specific assumption, must satisfy the given property in this environment. In order for the checking of a component to be of practical use, the assumptions should together model the real environment of the component (e.g. an architecture the component is to be used in). The most popular means for expressing the assump- tions is the temporal logic (LTL), which is commonly used also for specification of the properties.

