We motivate, define and design a simple static analysis to check that comparisons of floating point values use compatible bit widths and thus compatible precision ranges. Precision mismatches arise due to the difference in bit widths of processor internal floating point registers (typically 80 or 64 bits) and their corresponding widths when stored in memory (64 or 32 bits). The analysis guarantees that floating point values from memory (i.e. array elements, instance and static fields) are not compared against floating point numbers in registers (i.e. arguments or locals).

Storage locations for floating-point numbers (statics, array elements, and fields of classes) are of fixed size. The supported storage sizes are float32 and float64 . Everywhere else (on the evaluation stack, as arguments, as return types, and as local variables) floating-point numbers are represented using an internal floating-point type. In each such instance, the nominal type of the variable or expression is either float32 or float64 , but its value can be represented internally with additional range and/or precision. The size of the internal floating-point representation is implementation-dependent, can vary, and shall have precision at least as great as that of the variable or expression being represented. An

The successive field store forces the value to be truncated to 32 bits, thereby changing the value. In the example, 9.42477822 is coerced to a float, causing a loss of precision resulting in the value 9.424778 being stored in the field this.balance. When the postcondition is evaluated, the truncated value of balance is re- loaded from memory, but the addition in the postcondition is re-computed with the internal precision. Comparing these two values causes the postcondition to fail,

We have implemeted the analysis described in this paper in Clousot, our static analyzer for CodeContracts [2]. The analyzer first reads the IL from disk, then con- structs for each method the control flow graph, inserting contracts at the necessary points. Then it simplifies the program by getting rid of the evaluation stack and the heap, reconstructs expressions lost during compilation, and finally produces a scalar program.

Several analyses are run on the top of the scalar program, i.e. non-null, numeri- cal, array, or arithmetic. We added the detection of precision mismatches in floating point comparisons described in this paper to the arithmetic analysis. The analy- sis is fast and accurate: on the core library of the .NET framework, mscorlib.dll, constisting of 25089 methods, it adds less than 10 seconds to the total time, and it reports 5 warnings. We manually inspected those, and they all represent real warnings similar to the following example:

We decided to detect problems with precision mismatches only when comparing floating point numbers. Another view would be to write an analysis that warns users whenever some higher precision float is implicitly cast to the nominal type width (effectively whenever a result is stored into memory). The problem with such an alternative analysis is that it would a) warn about most memory writes, b) miss implicit narrowings arising due to register spilling into memory introduced by the compiler. We found that warning about comparisons addresses the problem in a more actionable way.

