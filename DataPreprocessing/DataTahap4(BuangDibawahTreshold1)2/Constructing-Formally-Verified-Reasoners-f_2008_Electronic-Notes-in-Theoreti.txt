For processing knowledge in the Semantic Web, reasoners of Description Logics (DLs) such as RACER, Pellet and FaCT++ [6,11,12] are being used. Description Logics [3] are a family of logics used to represent conceptual and terminological knowledge. Among these, the ALC logic is a ground logic, which can be extended to the more expressive logic SHOIN, which corresponds to the Ontology Web Language.

Formally verifying the reasoners for DLs could increase their reliability and so that of the Semantic Web. However, formal verification of properties of reasoners for DLs is a time and resource consuming task. Moreover, if we carry out the formal verification of different reasoners for a logic, we will probably have to solve analogous problems for each one.

In this step, the algorithm is generic in the sense that the strategy of appli- cation of completion rules is not determined. That is, the specified algorithm depends on a selection function coding the strategy. The correctness of the algorithm has been proved, assuming some generic hypotheses about the non- determined selection function.

A built-in prelude and loadable libraries provide standard specifications and proved facts of a large number of theories. PVS specifications are packaged as theo- ries that can be parametrized with respect to types and constants. The definitions and theorems of a theory can then be used by another theory by importing it.

In this section we present a sketch of the type and operator refinement techniques developed in PVS in order to relate different specifications of the same notion. The point is that if we want to prove properties about a program, the development of the formal proof will strongly depend of the used datatypes as well as the concrete implementation of it. Thus, the idea is to verify the desired properties for a generic specification of this program and that the verified properties can be transferred to it.

This section is devoted to present the construction of a generic algorithm corre- sponding to the specification of the generic framework that we have described in Section 3. In addition, our purpose is to do it in such way that its termination, soundness and completeness can be deduced from the corresponding properties of the generic framework. For this, we will use the methodology of refinements ex- plained in Section 4.

It should be noted that the specification of the generic framework cannot be transformed into an algorithm by composition of refined operators for each of the operators composing this specification. The main reason is that in the generic framework, the searching process that the algorithm has to carry out in the space E(C) of the expansions of the initial ABox {x0 : C} is not specified. So, in the process of construction of the algorithm we have to concretize how to carry out the search. Also, we have to consider the following facts:

Firstly, let us note that in the specification of the generic framework we have used the same name (for example, left) to denote different accessor functions of the data types used to represent concepts and assertional axioms. However, although overloading of names does not present any problem for reasoning about the spec- ifications, this fact is problematic for the PVS evaluator, since they cannot be distinguished by their type. This problem has been easily solved specifying new types that refine the previous ones, with different names for each function. For example, the type used to refine the datatype assertional_ax is the following

Secondly, it should be taken into account that the applicability of a rule does not only depend on an instance axiom of an ABox L. In order to capture the notion of applicability of a rule, the type activation (activ) was introduced in the generic framework. An activation is a structure consisting of an instance axiom Aa and a witness x, which made it applicable. Now, we refine in a natural way the type activ, and we specify a function computing a list with the ABoxes obtained by application to L of the rules corresponding to an activation Ac

The idea is that f (L) selects an activation applicable to L. With this activation the algorithm will carry out the next step of the completion process. Due to typing reasons, given an ABox L, f (L) provides a list of activations. Thus, if there is not any activation applicable to L, f (L) should be the empty list.

