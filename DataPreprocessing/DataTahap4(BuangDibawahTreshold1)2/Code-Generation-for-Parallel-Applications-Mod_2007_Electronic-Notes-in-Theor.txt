During the development of a parallel application, besides being able to analyze performance aspects, it is highly desirable to be able to assure functional properties as early as possible. Assuring functional properties about a model of the parallel applicationcan lead to important savings since it reduces the time spent in application development and debugging. In this direction, model-checking and automatic code generation can be used as complementary tools during the development, making possible to analyze the system behavior and allowing the fast generation of corresponding code. In this paper we propose the use of Object-Based Graph Grammars (OBGG) for the specification of parallel applications. OBGG is a formal, visual language suited for the description of concurrent systems based on asynchronous message passing. Models described using OBGG can be verified through model checking. Following this approach, a translation from OBGG models to C code using MPI (Message Passing Interface), which is suited for clusters, is presented. To illustrate the contribution, a sample parallel application is modelled in OBGG; functional properties of the model are proven by model-checking; the C/MPI corresponding model is presented and performance results

Object-Based Graph Grammars (OBGG ) [5] is a formal visual language suited to the specification of asynchronous distributed systems based on message passing. Parallelism is implicit, through the declaration of rules that define possible state changes, and non-determinism is supported. The few abstractions provided and the object-based style makes it relatively easy to learn. Due to the few constructions and its formal semantics, OBGG models can be model-checked via a translation to PROMELA [4] [11], the input language of the SPIN model-checker [8].

In this paper we propose the use of OBGG for the construction of parallel ap- plications models and a translation step to generate C/MPI implementations from OBGG models. One of the arguments is to allow the specification of parallel applic- ations using a language with implicit parallelism, increasing the level of abstraction offered to the designer. Another argument is to bring the possibility of model- checking the parallel applications under development as an OBGG model, which can then be directly translated to a C/MPI implementation. These ideas are illus- trated with a simple parallel application which is defined in OBGG, model-checked for some properties, has its C/MPI code generated through the proposed trans- lation, and is executed on a cluster, generating performance graphics which are discussed.

Standards for parallel programming exist about two decades in many forms such as design patterns [14] [17], skeletons and templates [13], for example. Skeletons and templates provide a structure with parallel code, where the user introduces the application dependent code. Design patterns are basically descriptive structures for code fragment of common use.

design patterns as an extensible library for parallel programming. An application is built using one or more design patterns, and they can be combined with other code fragments using also low level communication primitives. New design patterns can be incrementally added in the system, making it extensible.

Attributes could be primitive data types (such as integer, byte, float ) or Abstract Data Types (ADT). User defined ADT can be used in OBGG models under some restrictions: (i) the correctness of the user defined data types must be assured by the user; (ii) the operations on user defined data types must be atomic, i.e, they finish during the rule application. For instance, they can not leave any thread created or pending processing such as receiving a response 5 .

In OBGG, rules of a class present in the left-hand side one message being re- ceived. Each rule specifies the reaction of any object from that class to the reception of such message. In the right-hand side of the rule, this message will be consumed, attributes of the object can change values and new messages can be generated. All actions described in one same rule occur in an atomic step. The identification of a possible rule application is called match. Each rule describes the treatment of only one message. An object can send a message to another object only if exist at least one reference to the destination in the right-hand side of the rule. This reference can be an attribute of the object or a parameter of the incoming message.

[8] verifier. More details about the OBGG-PROMELA translation can be found in [4], including a formal proof of the semantics compatibility between original OBGG model and translated model. The SPIN model-checker supports the verification of properties described in Linear Temporal Logic (LTL). In [4] [11] it is proposed how to specify properties over OBGG models using LTL, taking into consideration

[3] allows one to edit OBGG models and translate the models into PROMELA in an automatic way. Moreover, the counter-examples generated by SPIN (when the model violates an LTL specification) can be translated to OBGG abstractions such that the counter-example can be interpreted using the OBGG model instead of the PROMELA generated one. This feature keeps the same level of abstraction for the developer.

[10] and results in true. Again, it is important to remember that this step as- sumes as correct the functions ins() and rand(). These functions where manually translated. In the PROMELA model, rand() always returns the same 0 value and ins() may return 1 or 0 non-deterministically. This abstraction was used to di- minish the state space, and does not modify the meaning of the given system,

Convergence: The convergence of the model can be shown with the res- ult within an expected interval. However, since the model-checking process will consider all combinations of random points generated, there will be computations where all points fall outside the circle and therefore will not converge. On the other side, there will be computations that converge. It is possible to prove by model-checking that exist computations that converge. Using LTL, to prove that convergence is possible, we work trying to prove that the model will never con- verge. The result is a trace where the model converges. How often the method will converge is a matter of the quality of the random number generator employed in a real implementation. The LTL formula verified for this property is:

An OBGG model is comprised by various concurrent objects interacting by message passing. It is therefore natural to map OBGG objects to processes and the message passing communication among OBGG objects to message passing among processes. The non-determinism offered by OBGG can be embedded in the way that incoming messages are treated by the process. Dynamic object creation can be

Another aspect to be considered is related to the number of messages supported by the model. An OBGG state graph holds (in thesis) an unbounded amount of messages. This characteristic is represented using a linked list (Lin) to store the messages already received and still not processed for each OBGG process. Therefore, the limit of the real implementation is the available memory.

Complementarily, the attributes of OBGG objects are mapped to local variables of the corresponding OBGG process. Basic data types available in the destination language (C) can be used in OBGG specifications. User defined data types that follow the restrictions already discussed can be used as well.

OBGG messages are translated to MPI messages using C data structures. These structures are composed by primitive data types such as char, int and float. MPI messages are constructed field-by-field, using packing primitives offered by the lib- rary. Such messages must be unpacked in the same order by the generated Receiver code.

Inside of the data structure of generated by the translation, the first field contains identification of the type of the corresponding message. The other fields (when existing) are related to each present parameter in the message. In this presented translation schema, the generated system uses only one type of data structure for all messages, which is a superset of all the allowed parameters of messages in the system.

In OBGG the termination of objects is not represented explicitly. A system stops processing when there are no more matches possible. However, explicit process termination is necessary in real systems to, for example, deallocate the resources of a cluster. Therefore, in order to consider the system terminated and thus be able to deallocate the resources, we have to somehow detect that there are no more matches possible in the distributed processes representing the OBGG objects. When such a situation is detected, then the various processes are signalized and terminate. The identification of the distributed termination (no more matches) is coordinated by the INIT process, after having performed the initialization procedures.

In a totally asynchronous setting, this problem is analogous to a voting protocol. However, in our translated model we can assume certain communication character- istics and avoid a high amount of messages. The distributed protocol for detecting the termination is described bellow. It uses three control messages: R, B and C. The behavior of each participant process and the behavior of the INIT (coordinator) is as follows.

Thread Evaluate is responsible for searching the input buffer for messages and identifying matches for them. If this thread does not identify any match for all the messages in the buffer or the buffer is empty, then it blocks until a new message is received. Once Evaluate is blocked for a certain amount of time, a control message (B), signaling the blocked state, with destination INIT, is appended to Lout and will be eventually sent by Sender.

Non-determinism: As stated in the algorithm describing the steps per- formed by an object, the calculation of matches consider all messages in the input buffer, and, for every message, all possible rules (a message may be handled by more than one rule). From all the enabled rule applications a random choice is taken. This random choice among all enabled rules represents the non-deterministic beha- vior of OBGG models.

In this section we present performance measurements for the parallel application generated from the model presented in Section 3. The parallel application was executed in the CPAD 8 cluster, which is comprised by 16 dual PentiumIII stations (550MHz, 256 MB-Ram) interconnected via a Fast-Ethernet network. For the model execution was used one cluster node per process.

There are various reasons for the performance difference. While on the base program only one MPI call is needed to transmit a message (that consists only of an integer value), in the generated application there are many MPI calls involved: one for packing every parameter, one for sending, and finally one unpacking calls for every parameter. Also, due to the OBGG behavior, a (linked) list of messages has to be manipulated, and the matching is calculated over all messages in this input list each time a rule has to be chosen for application. Moreover, it has to be considered that this performance penalty is due to the more abstract modeling formalism which offers non-determinism and implicit parallelism.

The performance of the translated model in Section 4.7 show the impact of offer- ing the abstraction provided by OBGG. Some aspects of the translation are under investigation in order to allow a better performance. For instance, in the current translation only one MPI message type is defined for a whole model. In terms of message parameters, this MPI message is the superset of all OBGG messages, lead- ing to extra processing and communication overhead. A next optimization is the generation of various MPI message types, one for each message type of the OBGG model.

