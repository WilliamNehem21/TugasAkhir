This paper is about exploring the space of RI automata for a given gram- mar. We shall give examples from ANSI-C, IBM VS-COBOL and Pascal which show that making small compromises in the amount of stack activity suppres- sion can drastically reduce automaton size whilst not significantly affecting run time stack activity. We shall describe some heuristics that may be used to guide the specification of these automata but our main goal is to develop a tool that automatically optimises RI automaton size for a given applica- tion. We shall report on work-in-progress in the automatic derivation of these parsers giving algorithms and some preliminary indications of computational feasibility.

A technical compromise would be to place an upper bound on the levels of nesting that may be used. We can write a regular grammar for any bracket nesting language with a finite maximum nesting level simply by enumerating all the possible nestings. The size of such grammars grows rapidly so a low upper bound might need to be imposed.

A much more attractive idea is to somehow separate out the regular parts of a grammar from the parts that are truly context free: i.e. those that include fully embedded recursion in which a recursive call has both non-empty left and right contexts. RI parsing is such a technology.

Reduction Incorporated parsing was introduced by Aycock and Horspool [3] with further development described in [4]. Their algorithm does not admit hidden left recursion. Our closely-related RIGLR algorithm allows completely general context free grammars to be used, and we also describe an alternative automaton construction process [7].

In the rest of this paper we present a variety of experiments that show features of RIGLR behaviour that motivate our automation project. The main message is that small changes to grammar terminalisation schemes can yield big reductions in the size of RI automata without significantly impacting parse times. These experiments give at best glimpses of the overall picture: a fuller characterisation of the space of RI automata will be possible when our automated tools are complete.

In principle we could define programming language grammars in terms of individual ASCII characters, but a traditional compiler usually comprises a lexical analyser that consumes tokens defined as regular sets over characters; and a parser which performs context free matching on the resulting token stream. This arrangement is attractive for several reasons: a regular lexer will usually be faster than a context free parser; segmenting the input stream into meaningful tokens can aid error reporting; and the terminal set of the parser can be large with respect to the underlying alphabet which can reduce the number of non-determinisms in the grammar. (Consider, for instance an LL(1) parser for Pascal which was attempting to work with individual characters: the keywords do and downto would generate a left-factoring conflict.) In addition, it is convenient to allow white space and comments to be quietly discarded by the lexer. A full character-level context free grammar for, say, C would

We can reduce the size of the automaton by adding extra terminalisations within this chain. If we break a chain of length n in the middle, we convert an exponential in n to the sum of two exponentials in n/2. We expect, therefore, that if we try adding one extra terminalisation at all the positions in the chain then we shall see a steadily decreasing size towards the middle and then an increase.

expect our profiler to perform. COBOL lends itself to manual manipulation because keyword introduced statements are placed into separate rules. This makes it easy to terminalise just those parts of the grammar that relate to specific statements. In block structured languages like C and Pascal, the rules are far more intertwined, rendering manual analysis ineffective. Terminalisa- tions of particular, rather than all, instances of a nonterminal are likely to be effective for C and Pascal and these could also be identified via profiling.

Adrian Johnstone, Elizabeth Scott, and Giorgios Economopoulos. The grammar tool box: a case study comparing GLR parsing algorithms. In Gorel Hedin and Eric Van Wick, editors, Proc. 4th Workshop on Language Descriptions, Tools and Applications LDTA2004, also in Electronic Notes in Theoretical Computer Science. Elsevier, 2004.

