Program debugging is an extremely time-consuming process, and it takes up a large portion of software development time. In practice, debugging is still very much of an art, with the developer painstakingly going through volumes of execution traces to locate the actual cause of an observable error. In this work, we discuss recent advances in debugging which makes it systematic scientific activity in its own right. We explore the delicate connections between debugging and formal methods (such as model checking) in the overall task of validating software. Moreover, since any deployed software undergoes changes in its lifetime, we need debugging methods which can take the software evolution into account. We show how symbolic execution and Satisfiability Modulo Theories (SMT) solvers can be gainfully employed to greatly automate software debugging of evolving programs.

Assume that the bug is in line 4, where the variable savedValue should be set to something other than an empty string. Thus, line 4 is the root cause of this particular error. However, this wrong value may be propagated elsewhere (e.g. via line 6 in the above code) and the program may make several decisions based on this wrong value. Thus, the error may be manifested much later in the program execution and in a completely different line in the program. We need automated tools to detect the root cause from the manifested error!

The rest of this article is organized as follows. In Section 2 we review the state- of-the-practice in debugging. In particular, we discuss the commercially available debugging tools. In Section 3, we review some advances in debugging methods in the past decade where the bug is localized via trace comparison based dynamic

The typical tools available for this purpose are command line tools such as gdb (for C) or a similar tool jdb (for Java). These command line tools simply allow the programmer to step through the execution of a test case, stopping it at places and observing variable values. The entire process in such command line tools is manual, the programmer must step through the execution, the programmer must stop the execution at desired points (by setting a breakpoint), and the programmer must decide which variables to look at in these breakpoints. Due to the short- term memory of humans, such a manual process quickly goes out of hand for large programs.

Typically the program P will be endowed with a test suite (set of test cases) based on some coverage criteria (covering all statements or all branches in the program). We construct the execution runs for the test cases from the test suite. Let this set of execution runs be Runsall(P ).

The bug report in this case consists of more statements. Moreover, the statements do not pinpoint to the actual error cause in the program, they are only manifestations of the error cause. This simple example should demonstrate to the reader that the choice of successful run is crucial for the usefulness of the bug report generated by fault localization methods. Thus, we need systematic methods to choose a successful run corresponding to a failed execution run. Research results on this problem have been reported in [4]. More discussion on lightweight software debugging methods appear in [5].

may be based on. Indeed, many of the existing literature loosely refer to model checking as a method for debugging! In doing so, they simply mean that model checking can be employed on software for finding latent bugs. However, from the end-user perspective, model checking and debugging are very different software pro- cesses! In the following, we illustrate these differences.

Details of debugging methods for evolving programs appears in [6]. This ap- proach can not only debug program versions, but also two completely different im- plementations of the same protocol. Thus, our solution can also be used to debug errors in the situation where P , P' are two completely different implementations (of the same protocol specification), rather than being two versions of the same program. This feature of our method is shown in [6], which reports experiments from debugging different web-servers (all of which implement the well-known HTTP protocol).

Our advocated method for debugging evolving programs is built on symbolic execution and Satisfiability Modulo Theory (SMT) formula solving. With the recent progress in the scalability of SMT solvers, analysis methods based on symbolic execution and formula solving have become feasible in practice. Such methods are based on formal foundations, which most program debugging methods lack. Even though symbolic execution based test generation has been studied recently [9], the utility of symbolic execution for program debugging has not been tapped (apart from the most recent work [6]). The software engineering research community needs to focus on these directions, building debugging methods with formal foundations which scale up to large-scale industrial software. Symbolic dynamic analysis and SMT formula solving are likely to be key ingredients of such debugging methods.

