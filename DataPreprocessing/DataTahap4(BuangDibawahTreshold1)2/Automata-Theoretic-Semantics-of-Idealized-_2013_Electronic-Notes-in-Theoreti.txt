The traditional models for imperative programming languages, dating back to those of Scott and Strachey, are state-based. These models envisage that programs operate on a store which goes through states. Commands are interpreted as func- tions from states to states, factoring out all the internal state manipulation details carried out by them. Thus, these models may be regarded as being extensional

The main contribution of this paper is to provide a denotational model of Idealized Algol that satisfactorily models passivity while being extensional. In particular, this means that passive expressions do not have side effects, not even temporary ones. In the main body of the paper, we do this for a language without divergence, but treat it in such a way that it generalizes to divergence. The issues of divergence are then briefly mentioned in Sec. 5. The treatment without divergence is also novel in

that it is the first model of passivity that is able to deal with a language without divergence. All the previous models [1,34,45] depend on the presence of divergence for modeling passivity. However, intuitively, passivity is independent of the issues of divergence. Our treatment is able to decouple the two issues.

Formally, the four components: store shapes, morphisms between store shapes, logical relations between store shapes and squares between them, form a reflexive graph of categories. Further, they satisfy additional axioms laid out in [10] to form a parametricity graph. Formal definitions describing the structure may be found in the Appendix.

In recent work, Ahmed, Dreyer and colleagues [2,9] have applied the ideas of possible worlds (similar to functor categories) and automata-theoretic reasoning in the setting of operational reasoning. While the ideas seem intuitively similar, it is difficult to make a formal comparison at the present stage because the starting points of denotational and operational approaches are quite different. Some remarks regarding the comparison may be found in [36]. It is also worth remarking that these researchers have not yet tackled the issues of passivity in their approaches.

Other questions that this work might enable is a semantic understanding of the various notions of passivity present in specification and verification frameworks, e.g., program specification systems [18], ownership type systems [22] and fractional permission-based methods [6,37]. Secondly, the successful modeling of passivity takes us one step closer to modeling program logics such as Syntactic Control of Interference [24], Specification Logic [39,45] and Separation Logic [37,41]. We en- visage that the model presented here will be helpful to streamline the semantic treatment of such programming logics.

