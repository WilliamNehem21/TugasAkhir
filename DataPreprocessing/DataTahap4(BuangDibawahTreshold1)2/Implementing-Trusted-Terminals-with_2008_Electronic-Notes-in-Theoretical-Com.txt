We discuss how SITDRM and Trusted Computing (TC) fit together, and how one can use TC to implement such a terminal. We describe a prototype implemen- tation of a secure terminal as well as difficulties encountered in development of the software. Finally, we describe how the prototype terminal was incorporated into the full SITDRM Enterprise system.

Goal 2: Prevent Data Exposure. Data should not be leaked to processes not complying with SITDRM licenses. When being read or otherwise utilized, sensi- tive data must be kept unencrypted in memory. This memory must be managed in a secure manner similar to that for keys.

An item of data X can be protected by encrypting it with a unique content key Ck. Any license that grants a right to perform an action on that item contains Ck encrypted by the public key PKT of the terminal on which that license is to be used. If license issuers only issue licenses to terminals that they have verified to be genuine as above, the content encryption key and therefore the data is accessible only to trusted terminals.

Signing and Binding. Additionally, the TPM supports encryption (binding) and decryption (unbinding) as well as signing and verification using the RSA keys it generates. Keys can be generated an used on the TPM and without ever copying them in main memory; this avoids the risk of involuntary memory disclosure vulnerabilities. (For examples of these vulnerabilities see [7].)

Our aim in using a TPM chip to harden a SITDRM data user terminal is to control as tightly as possible the existence and movement of secret keys and unencrypted data. Ideally, we would like to be able to use the TPM as a trusted input/output channel between the SITDRM software and output devices. Unfortunately this is unrealistic, since the TPM is not designed to be used as a cryptographic processor. We consider a situation where a custom SITDRM data user terminal is run on a trusted platform.

The client software provided a simple interface that allowed the user to connect to a server, download licenses or digital items, then exercise grants provided by any downloaded licenses. The client implemented a client-side of the network protocol when communicating with the server. It also made heavy use of the TPM.

Though this prototype illustrates the majority of the TPM implementation, se- cure memory was not established. The development platform contained only an emulator for the TPM chip, and so the OS was not a trusted operating system. Additionally, there was no support for isolating process memory spaces on the de- velopment system, so memory disclosure attack vulnerabilities may still have been present.

SITDRM Enterprise solves this problem by using a simple role-based access con- trol model. In addition to the key pairs possessed by terminals, SITDRM Enterprise assumes that every role R is associated with a key pair SKR and P KR. We as- sume that the public keys of all users and roles can be verified using a public key infrastructure.

TPM keys are created with a specified type, either as a signing key, binding key (for encryption) or as a legacy key (general use). After some testing, it was deter- mined that the signing and binding keys do not always work when the public key is exported and used with different software. Additionally, when the key is created, its encoding method must be specified as either RSA v1.5 or OAEP. Omitting one of these specifications when creating a key causes the TPM to assign defaults which are not specified by the TCG and can result in unexpected behavior.

credentials do not exist (are not created by the manufacturers) and they are not distributed in a PKI fashion. If a public key infrastructure were implemented prop- erly to distribute credential signer certificates, then integrity reporting is strong. Until then, a third party wishing to verify my terminal is trusted must simply trust on blind faith all certificates we provide.

