A number of works on coordination models and languages are centered in software interoperability. Such models and languages have evolved towards data oriented models and control-event oriented models [1]. Recently a new model, called Reo, based on the combination of connectors (constructed as a set of communicating channels) has been defined [2].

The expressive power of both models (Linda and Reo) has been independently studied by using different approaches. A very complete study on the expressive power of Linda was made by Brogi and Jacquet in [6,7] where different Linda-like concurrent languages were compared by using the notion of modular embedding [5]. On the other hand, when Reo was introduced, Arbab [2] provideda number of examples to show the expressive power of his proposal, simulating in a simple and elegant way different communication mechanisms. The objective of this paper is starting a comparison between both models, making a comparative analysis between Reo and Linda, considering both the asynchronous behavior (inherent to Linda), and the synchronous one. Both models present very different abstraction levels: Linda is based on a set of communication primitives accessing to a shared tuple space, whereas Reo is also defined in terms of communications primitives, but acting on connectors which are constructed as a combination of different kinds of channels. In order to have an homogeneous level of abstraction which allows a fair comparison, we will define two process calculi for each formalism, following the work by [9], and we will compare them.

The rest of the paper is organized as follows. In Section 2 we present both interaction models, their semantics, the two process calculi previously mentioned, and the properties defining them. The comparing method and its application to compare both models is presented in Section 3. Finally, we give some conclusions and future work.

The variety of channel types that can be used in Reo makes possible to construct other coordination models. Consider the bag channel type, it has one input end, one output end and an unbounded buffer in which all data items matching the filter of the channel are accepted and kept, as in a multiset. So the write operation is always possible, and a read or take operation over the output end selects in a non- deterministic way one of the items that match the pattern specified. This behavior permits us to simulate the actions of Linda over the store. In a forward section we will prove this relation.

Following [9], we shall consider a process algebra L containing the communication primitives of Linda. These primitives permit to add a tuple (out ), to remove a tuple (in), and to test the presence of a tuple (rd ) in the shared dataspace. The language L also includes the standard prefix, choice and parallel composition operators in the style of CCS.

We also propose a process algebra R based on the communication primitives of Reo. We consider the basic actions to insert an item in a connector (write), to remove an item from the connector (take) and to capture an item without removing it (read). Agents in R are constructed by means of the prefix operator, the nondeterministic choice and the parallel composition. Formally, the syntax of R is defined as follows:

where 0R denotes the empty process and c denotes an input or output end of a connector. The prefixes wr, tk and rd are shorthand for the basic operations write, take and read respectively. As in Reo communication is possibly only in presence of a connector, in order to define the operational semantics of R we must consider the semantics of the connector on which actions are acting on.

In this section, we will compare the languages previously defined, L and R, taking into account that we will get different versions of R depending on the connector to be considered. To do this, we first formalize the notion of modular embedding used for the comparison. Then, we analyze the expressiveness of both languages L and R, in both directions, by defining compilers for each case, and proving the existence of modular embedding between L and R.

In this section we work over the asynchronous case. We compare the expressive power of L and R in presence of the connector LR introduced in section 2.2. As the connector LR has only one input end (I1) and one output end (O1), to sim- plify the presentation of the compiler we will omit them when R-actions are used. Thus, input actions like tk(t, O1) and rd(t, O1) will be denoted by tk(t) and rd(t), respectively, and the output action wr(t, I1) will be denoted by wr(t).

In this context, we consider that the parallel composition of two processes in Reo is translated into the parallel composition of two independent processes in Linda, that are identified by different labels. On the other hand, in the case of the nondeterministic choice, the application of the compiler must preserve the identifier of the original process to avoid the synchronization between two branches of the same process. Now we show some useful results to prove the modularity of the embedding.

Proof. The properties (1) y (3) of 3.1 are satisfied directly, considering the no- tion of observables and that D is the identity . (2) is evident observing that the compiler preserves the operators. In order to prove (4), we need to verify that O(C(A))) = O'(A). We will proceed proving the double inclusion considering the possible elements in the sets of observables: ss y ff.

