It is a challenge for automatic tool support to formal design by refinement transformations. In this paper, we bring this matter to the attention of the research community and discuss a component-based model transformational approach for integrating refinement into software development tools. Models, their con- sistency and correctness, in an object-oriented and component-based development process are defined in rCOS, that is a refinement calculus recently developed at UNU-IIST. Correctness preserving transforma- tions between models are formalized and proved as refinement rules in rCOS. In this paper, we will discuss on how these transformations can be implemented in the relations language of Query/View/Transformation

Graph-Transformation approaches are inspired by theoretical work in graph transformations and specifically designed to represent UML-like models. These approaches are visual notations and formally founded. Examples of graph- transformation approaches include VIATRA [27], AToM3 [8], GreAT [2], UMLX [28], and BOTL [20].

Several tools and development approaches of these transformation languages are used to help the software development [26,1,9]. Also an attempt of studying the correctness and completeness of transformations in VIATRA was made in [27]. This shows a direction to introduce formal methods into model transformation languages and to help software development.

A Customer arrives at a checkout with items to purchase. The Cashier records the purchase items and handle either a cash or a card payment. On completion, the sale is logged and the inventory is updated, and the Customer leaves with the items.

Detailed design can be carried out on the component architecture so that each method in each component is designed. The components can the be verified, tested and checked by various tools such as a model checker or a runtime checking tool (e.g. JML [19]).

A transformation can be invoked to check two models for consistency (no side effect), or to modify one model to enforce consistency. Whether or not the relation maybe enforced is determined by the target domain, which may be marked as checkonly or enforce. When a transformation executes in the direction of the model of a checkonly domain, it is simply checked to see if there exists a valid match that satisfies the relation. When a transformation executes in the direction of the model of an enforce domain, if the checking fails, the target model is modified so as to satisfy the relation, it is a check-before-enforce semantics. The more detailed semantics of the checking and enforcement can be found in [12].

In the transformation from the object-oriented model to the component-based architecture, the functionality of the use case will be handled by several components. The decision of functionality decomposition of the use case should be made by the designer. The strategy is mapping Classes into Components and assigning Methods to Component or hide them based on the above mapping. The detailed transformation rules are defined in the following.

While transforming the Message in the source domain to the target domain, the Order Number of the Message is kept. The agents of the lifelines that send and receive the message will be transformed from the classes to the corresponding components. If class Ca1 is in component Co1 and class Ca2 is in component Co2, Co1 calls Co2 only when Ca1 calls Ca2. The interface of the component which is the agent of the lifeline will be cre- ated.

For the tool support of this correctness preserving transformations, at first we choose one of the transformations which is proved to be correct using rCOS and imple- mented using QVT. Then we import a source model which will be transformed and parameterize the transformation based on the design decisions. Finally this transformation will be executed.

Transformations may be unidirectional or bidirectional. In a unidirectional transformation, changes must be propagated from the source model to the target model. In a bidirectional transformation, changes must be propagated in either direction. In some cases, changes may be made to both models. Our implementation is a unidirectional transformation which does not work backwards.

For some transformations, such as class decomposition pattern, the design de- cisions are needed and the transformation will not be a fully automatic process. If the interaction between the designer and the QVT tool is possible, the de- signer can provide design decisions for the transformation. There are two parts of the QVT transformation, one containing the transformation rules executed automatically, another introducing the design decisions made by the designer (cf. the query QClassToComponent).

Quite often, the functionality of a use case is handled by a number of compo- nents. The component decomposition task is needed in this situation, e.g. the use case Process Sale is partitioned to four components. But there are also situations that we need to combine the functionality of several use cases for a component. The component composition task is needed here, e.g. some of the functions of the use cases Process Sale, Order Products, Change Price and Show Report are used to complete the interfaces of the component Inventory. These different situations make the transformation more complex.

We propose to implement the OVT transformation for all the rCOS refinement rules, especially the expert pattern which is quite often used in the object- oriented design. If we implement a group of automatic transformations, the work will be more useful. This makes it possible to reuse the transformation with only proving its correctness once.

A state diagram specifies the behavioral patterns of the classes and the func- tionalities of method invocations. A state diagram consists of states and tran- sitions. A transition from a state is either one of the methods of classes or triggered by external invocations. A transition may have a trigger event and an action with the guard:

I would like to thank Zhiming Liu and Volker Stolz from UNU-IIST for their dis- cussions and useful comments for the paper. This work is partially supported by the project HighQSoftD funded by Macao Science and Technology Development Fund and the National Grand Fundamental Research 973 Program of China (No. 2002CB312001).

