After several decades, most proof assistants are still centered around TTY-based interaction in a tight read-eval-print loop. Even well-known Emacs modes for such provers follow this synchronous model based on single commands with immediate response, meaning that the editor waits for the prover after each command. There have been some attempts to re-implement prover interfaces in big IDE frameworks, while keeping the old interaction model. Can we do better than that?

of Isabelle/ML to the outside world. The Scala language (by Martin Odersky) is sufficiently close to ML in order to model well-known prover concepts conveniently, but Scala also runs on the JVM and can access existing Java libraries directly. By building more and more external system wrapping for Isabelle in Scala, we eventually reach the point where we can integrate the prover seamlessly into existing IDEs (say Netbeans). To avoid getting side-tracked by IDE platform complexity, our current experiments are focused on jEdit, which is a powerful editor framework written in Java that can be easily extended by plugin modules. Our plugins are written again in Scala for our convenience, and to leverage the Scala actor library for parallel and interactive programming. Thanks to the Isabelle/Scala layer, the Isabelle/jEdit implementation is very small and simple.

Classic Proof General uses the relatively powerful Emacs environment, al- though that has grown quite old. Some branches like XEmacs are practically unmaintained. The GNU Emacs 23 branch has caught up in the past few years, but it still appears somewhat archaic to current user generations. There are also fundamental limitations of the Emacs platform, such as the single-threaded execution model of its LISP engine.

further operations below. Such a document is understood as a persistent entity, with purely functional update operations. There are explicit version identifiers. Operating on the initial root created via begin document produces a tree of ver- sions evolving over time. A final end document chooses a single success path to be committed to the theory database eventually.

The edit document operation updates a document via insert and remove primi- tives of commands as defined above. This results in a new document with a fresh identifier, and the prover will report internal state changes eventually. The asyn- chronous toplevel maintains a multitude of such related document versions, which typically share common sub-structures. Results emerging from a new document version are reported as they arrive, according to the parallel evaluation process managed by the prover. Messages are explicitly identified by the corresponding command within a certain document version (the toplevel prompt is abolished).

The above primitives roughly sketch a protocol between the editor and the prover that can give the user the impression of continuous checking of text, providing prover feedback as it emerges incrementally. The editor never waits for the prover, and never stops the user from typing. The prover is free to schedule the evaluation of partial proof documents to exploit the potential of parallelism as much as possible. Even without parallel checking, the prover can arrange document processing in a way that allows the user to edit proofs independently from each other, without costly replay of the whole script.

Our genuine task is to build provers, not to re-implement editors or IDEs from scratch. So we prefer to link to existing frameworks, even though this means to accommodate the split into two different processes: ML vs. JVM. Explicit inter- process communication definitely raises some additional questions, and the inhomo- geneous language situation complicates things further.

We argue that cutting the conceptual components at these process boundaries complicates the system integration, even without the (optional) broker in between. The protocol suite defined here covers many accidental details that the prover or editor happen to expose at their respective process boundaries. Implementing and maintaining such complex protocols is very hard.

A jEdit plugin consists of the main JVM object-code as a regular jar, together with some meta-data via JVM property files and some judicious use of XML. Com- ponents are glued together via code snippets in BeanShell, which is essentially a light-weight interpreted version of Java. There is even an interactive BeanShell console (as a standard plugin) that exposes the name space of JVM classes of the running editor environment. This is reminiscent of the Emacs scratch buffer, with its direct access to the LISP runtime environment.

Getting started in implementing jEdit plugins is very easy by studying docu- mentation, example plugins, and the sources of the editor and some major plugins. The jEdit console plugin greatly helps interactive exploration and debugging. Alter- natively, the whole application can be run under control of existing JVM debugging tools, say the Java source-level debugger of Netbeans.

Input wiring involves a regular event handler for insert and remove actions on plain text produced by jEdit. These events are locally buffered, and eventually forwarded to the underlying document model together with the history identi- fier. The Isabelle/Scala library turns text edits into larger chunks based on the command structure of the proof language.

Isabelle messages contain rich information represented as markup-trees. This is rendered by mapping it to XHTML internally, and letting the Lobo browser http://lobobrowser.org display it by means of a given CSS. Thus we gain quite flexible output facilities almost for free. Proof General style syntax highlighting of free vs. bound variables, type variables etc. can re-use the existing CSS for Isabelle HTML presentation of theory sources. Further semantic information provided by the prover, such as references to formal entities (types, constants etc.), can be linked to internal Scala operations to implement hyperrefs, although this is not fully activated yet.

The Protocol dockable displays the raw stream of prover input and output mes- sages using XML notation. Note that the internal protocol uses the more efficient transfer syntax of YXML. Significant slowdown is caused by printing all protocol messages explicitly within a Swing text component, so this is really for debugging only.

Console with our Scala sub-plugin to provide a regular read-eval-print loop. This uses the existing class Interpreter provided by the Scala compiler suite from EPF Lausanne. It is important to note that the interpreter really runs within the same JVM environment as the application itself.

Our answer to this cultural problem: Keep ML as clean implementation language for the prover, use Scala on the JVM for GUI/IDE connectivity. Higher-order programming in Scala works very well, and we gain access to interesting frameworks that happen to be implemented in a slightly odd language (Java). Scala also has quite nice standard libraries to offer, including actors as efficient model for parallel and interactive components.

