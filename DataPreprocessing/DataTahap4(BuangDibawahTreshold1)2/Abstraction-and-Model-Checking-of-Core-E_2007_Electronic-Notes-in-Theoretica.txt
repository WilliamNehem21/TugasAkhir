The remainder of this paper is organized as follows. Section 2 presents the Core Erlang programming language by sketching its syntactic constructs and their intu- itive meaning. Section 3 briefly introduces the Rewriting Logic Framework. Finally, Sections 4 and 5 constitute the main part of this paper in which the Rewriting Logic specification of the operational semantics of Core Erlang and its implementation in Maude are studied.

identified by a name, followed by a list of exported functions, and a list of function definitions. In our example the system is defined in one module named locker. It is initialized using the start function. By calling the spawn builtin function, the latter generates two additional processes both running the client function from the locker module. Here the self builtin function returns the process identifier (pid) of the locker process, which is then passed as an argument to the clients such that these are enabled to communicate with the locker.

The function names ai/ni are treated as variables that range over the special domain of function abstractions. Evaluation of a letrec expression yields a new binding whose scope reaches over e and e1,... , em. This extended scope is reflected in the semantics by propagating the letrec statements into the bodies of the function abstractions (cf. the definition of e' in the premise).

where i1,... , in denote the included processes and prunning(ik ) states the existence of the kth process. The predicate pscheduled(ik ) holds iff the process with identifier ik caused the last system level transition, and pblocked(ik ) is valid iff the corresponding process is blocked during message reception. Intuitively, it states that whenever a process exists, it is scheduled sometime later or it becomes blocked waiting for message reception.

