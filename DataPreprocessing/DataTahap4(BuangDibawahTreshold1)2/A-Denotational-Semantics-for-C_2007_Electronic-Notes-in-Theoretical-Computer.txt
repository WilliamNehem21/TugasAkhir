Throughout the past decades two schools have been developing formal techniques for precise and correct software development. Model based languages like Z [18] focus on data aspects of the systems; constructs to model behavioural aspects are not explicitly provided by any of these languages. On the other hand, CSP [9,15], among other process algebras, focuses on the behavioural aspects of the systems; however, it does not support a concise and elegant way to describe complex data aspects of the systems.

Many formalisms combine constructs to specify data and behavioural aspects of the systems. For example, combinations of Z with CSP [7] and Object-Z with CSP [6], and new notations like RAISE [8], are some attempts to combine both schools of formalisms. As far as we know, however, none of them has a related refinement calculus. This lack of support for refinement of state-rich reactive sys- tems in a calculational style, like that presented in [11], has motivated the creation of Circus [17]. In this concurrent language, systems are characterised as processes, which group constructs that describe data and control; the Z notation [16] is used to define most of the data aspects, and CSP is used to define behaviour.

In [17], Cavalcanti and Woodcock present a semantic model for Circus based on the Unifying Theories of Programming (UTP) [10], a relational framework that unifies programming science across many different computational paradigms. Al- though usable for reasoning about systems specified in Circus, the semantics in [17] is not appropriate to prove properties of Circus itself. This happens because it is a shallow embedding, in which the Circus constructs are mapped to their semantic as a Z specification, with yet another language being used as a meta-language.

For this reason, we redefined the Circus semantics and mechanised it using ProofPower-Z [14], a theorem prover for Z. Based on the new definitions, we proved over ninety percent of the one-hundred and forty-six proposed refinement laws. These proofs range over all the structure of the language and include all the data simulation laws; their proofs can be found in [12].

In Section 2 we present Circus. Section 3 introduces the UTP and reactive designs. In Section 4 we have the main contribution of this paper: we present a definitive reference for the Circus denotational semantics based on the UTP. Sec- tion 5 discusses the structure of the library of lemmas and theorems created during this work, and illustrates the usefulness of the library by presenting the proof of one of our refinement laws. Finally, we draw some conclusions in Section 6.

The declarations of all the channels give their names and the types of the values that they can communicate; however, if a channel does not communicate any value its declaration contains only its name. Generic channel declarations introduce fam- ilies of channels. For instance, channel [T ] c : T declares a family of channels c. For every actual type S , we have a channel c[S ] that communicates values of type

A guard may be associated with any action: given a Z predicate p, if the condition p is true, the action p & A behaves like A; otherwise, it deadlocks. The parallel and the interleaving operators are slightly different from those for processes. In order to avoid conflicts in the access to the variables in scope (state components, and input and local variables), parallel composition and interleaving of actions must also declare two disjoint sets of variables. In A1 |[ ns1 | cs | ns2 ]| A2, A1 and A2

Stop has a true precondition because it never diverges. Furthermore, it never en- gages in any event and is indefinitely waiting; therefore, its trace is left unchanged and wait ' is true. Since it represents deadlock, Stop must refuse all events (the final value of the refusal set, ref ', is left unconstrained because any refusal set is a valid observation). As state changes do not decide a choice, in order to be the unit for external choice, Stop must leave the values of the state components unconstrained. In [4], we have proven that this definition corresponds to that of the UTP.

refuse any communication on the set composed by the events on c that communicate values of the type of c that satisfy the predicate P . After the communication the trace is extended by one of these events. Besides, the final value of x is that which is communicated. The function snd returns the second element of a pair, and the function last returns the last element of a non-empty list.

Divergence can only happen if it is possible for either of the actions to reach divergence. This is characterised by a trace that leads one of the actions to diver- gence and on which both actions agree regarding cs. For instance, the predicate below characterises possibility of divergence for A1.

synchronisation on cs should be considered (1.tr T cs = 2.tr T cs). The definition of A2 independently; however, only those combinations that are feasible regarding the  cs is omitted here but can be found in [12]; it is similar to that presented in [15] for

not terminated. In this case, the parallel composition refuses all events in cs that are being refused by any of the actions and all the events not in cs which are being refused by both actions. We merge the states when both actions terminate: for every local variable and state component v , if it is declared in ns1, its final value is that of A1; if, however, it is declared in ns2, its final value is that of A2; finally, if it is declared in neither ns1 nor ns2, its value is left unchanged.

The interleaving does not have to consider any synchronisation channel. An interesting aspect regarding the differences between the definitions of parallel com- position and interleaving is the much simpler precondition for interleaving. Since both actions may execute independently, the interleaving of two actions diverges if either of the actions do so. Therefore, its precondition is the same as that for ex-

The semantics of a reference to an action name is given by the copy rule: it is the body of the action. Invocation of unnamed parametrised actions is defined simply as the substitution of argument for the formal parameter. The renaming of the local variables and state components is simply the syntactic substitution of the new names for the old ones.

dition if its precondition holds; only the variables in the frame can be changed. Furthermore, on successful termination, the trace is left unchanged. Now, we use u to denote the variables that are not in the frame (u = v \ w ).

specification statements. We assume that the schema expressions have already been normalised using the normalisation techniques presented in [18]. Besides, in Circus, the Z notations for input (?) and output (!) variables are syntactic sugaring for undashed and dashed variables, respectively. This implies that we actually have schemas containing the declaration of dashed (ddecl ') and undashed (udecl ) variables and the predicate that determines the effect of the action. As a small abuse of notation, ddecl also stands for a comma-separated list of undashed variables introduced as dashed variables in ddecl '.

By way of illustration, we conclude this section by presenting one out of over a hundred proofs we presented in [12]: the external choice unit law (Stop  A = A). Its proof illustrates the use of our library and shows the reasons for choosing Stop to leave the state loose. Before presenting this proof, we present two lemmas that are used in the proof. These lemmas are also part of our library and are proved using Lemmas 5.2 and 5.3 discussed above. Lemmas 5.4 and 5.5 give the conditions on which Stop diverges and the effects of Stop when it does not diverge, respectively.

The semantic model for Circus processes presented in [17] was a Z specification. For this reason, the state invariant was implicitly maintained by all operators. In our semantics, this is no longer a fact: nothing is explicitly stated about the invariant in our semantics. We assume specifications that initially contain no commands, and therefore, change the state using only Z operations, which explicitly include the state invariant and guarantee that it is maintained. For this reason, our semantics ignores any existing state invariants, since they are considered in the refinement process, just as in Z.

extra restrictions. For us, in the semantics of parallel composition and interleaving, each side of the composition has a copy of all the variables in scope. They may change the values of all these variables, but only the changes to those variables that are in their partition have an effect in the final state of the composition. For

The semantics presented in this paper has been mechanised in ProofPower- Z [1]; this work was based on a mechanisation of the UTP theories [14]. As far as we know, the mechanisation of its semantics in ProofPower-Z makes Circus the first specification language of concurrent systems that has a mechanised semantics. Based on this result, we intend to mechanise the proof of the theorems and lemmas of our library and, ultimately, the refinement laws. This will provide both academia and industry with a mechanised refinement calculus that can be used in the formal development of state-rich reactive programs as the one presented in [13].

