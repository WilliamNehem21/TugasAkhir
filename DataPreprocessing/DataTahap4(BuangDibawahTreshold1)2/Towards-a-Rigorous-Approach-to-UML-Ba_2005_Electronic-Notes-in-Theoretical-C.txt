The multi-view and multi-notational aspect of UML has an obvious good purpose to allow the split of an overall system model into several views and decompose it into chunks of manageable size. Each single view focuses on a different aspect and this will ease for analysis and understanding. This decomposability of the model enable the development team to split the work of producing models among different people. It is also important for tool support as it would be more difficult for a tool to deal with one large and complex model. UML also intends to support modelling a system at different levels of abstraction. However, without clear means for information hiding, this promise is not as obvious as the one discussed earlier and we need more effort to make UML support model transformation and refinement better.

After this introduction, we give an introduction in Section 2 to the refine- ment calculus for object systems. We then outline the ideas in Section 3 about how the model for object systems is to be extended to deal with component systems. In Section 4, we briefly discuss the relation between object systems and component systems.

private	U1 u1 = a1,.. ., Um um = am; protected V1 v1 = b1 ,... , Vn vn = bn; public	 W1 w1 = d1; ... Wk wk = dk; method	 m1 (T 11 x1, T 12 y1 , T 13 z1){c1 };

We will use Java convention to write a class specification, and assume an at- tribute protected when it is not tagged with private or public. We have these different kinds of attributes to show how visibility issues can be dealt with. We can have different kind of methods too for a class. However, we omit the

{x1 : T1,... , xk : Tk}. The type Ti of xi, denoted by decltype(xi), can be either a primitive type or a class name. We assume they are declared at the beginning of the main program and will not be changed afterwards.

