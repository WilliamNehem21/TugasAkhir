The key idea of declarative debugging is to build a computation tree (also called an evaluation dependency tree) representing the computations performed by an erroneous program. The exact form of the computation tree depends on the kinds of errors that are to be diagnosed. Each node of a computation tree represents the outcome of a computation step in the program and is connected to the nodes representing the subcomputations that were performed in order to produce the result of the computation.

If a program does not compute the expected result or produces unexpected results, its computation tree contains one or more erroneous nodes, whose result does not match the semantics intended by the programmer. Some of these erroneous nodes are just the result of other erroneous computations, while other erroneous nodes represent genuine programming errors. These buggy nodes are distinguished by the fact that they do not have any erroneous children, i.e., their represented computation steps compute a wrong result from correct inputs.

In this paper, we present a modification to the standard program transforma- tion approach that avoids these shortcomings by transforming functions in the IO monad in a specific way. This is made feasible by the fact that IO is an abstract type and elements of that type cannot be inspected directly by user-defined func- tions. Therefore it is sufficient to define appropriate adaptors for the primitive IO functions. For almost all of these adaptor functions, their definition can be derived mechanically from the semantic model of the IO type. Only for a few distinguished primitives one needs to provide predefined implementations. Nevertheless, no ad- ditional non-standard primitives are needed for their definition. Thus, while using the semantic model of the type IO in order to derive the adaptors, their concrete implementation does not rely on any particular implementation technique of I/O actions in the target implementation.

The rest of this paper is structured as follows. In the next section, we briefly review the standard program transformation approach for detecting wrong answers in functional and functional logic programming languages. The third section de- scribes monadic I/O and the problems that it poses for the program transformation approach. In section 4, we introduce our modified program transformation that mixes well with monadic I/O. Finally, the two last sections present related work and conclude.

The computation trees used by the debugger will have basic facts at their nodes. Each node has an associated program rule, the program rule used at the corre- sponding computation step. Thus, the debugger will point out the program rule associated with a buggy node as an incorrect program rule. The children of a node correspond to the subcomputations carried out while evaluating the guard and right hand side of the program rule. The soundness and completeness results in [1] ensure that, given a wrong answer, an incorrect program rule is detected by the debugger.

Several strategies have been proposed to create and navigate computation trees. A well-known approach widely employed in Logic Programming uses meta-interpreters to re-execute the goal during the debugging phase. Thus, the computation tree is not computed explicitly, and both wrong an missing answers are easily handled. This idea has been extended in the case of NUE-Prolog to functional logic languages [7]. However, this solution is not available to languages that do not provide built-in meta-instructions, as Haskell or Curry. To the best of our knowledge, only declara-

logic languages. The reason is twofold: first, the computation trees necessary for detecting missing answers are much more complicated. Second, often wrong and missing answers occur simultaneously, as in the case of our buggy reverse example. In these cases, it is enough to find out the reason for the wrong answer to get rid of both errors. This is also the case of our debugger.

we loose the computation trees in the first case. However, this is unproblematic. Recall that we are diagnosing only wrong answers. Yet, the error case (Left e, w) corresponds to an exception condition where no answer is computed. Keeping the computation trees of such computations therefore is not necessary.

