XPath is a well-known query language for finding and extracting information from XML documents. This paper shows how the characteristics of this domain-specific language fits very well into the functional-logic paradigm. The proposed framework allows the user to write XPath-like queries as first-class citizens of the functional-logic language T OY, using higher-order combinators for constructing the queries and non-determinism in order to obtain the different answers that XPath queries can return. The result is a very good example of cross-fertilization of two different areas. In the case of T OY, the users can now integrate XML queries in their programs without using any external library or ad hoc interface. In the case of XPath, the use of higher-order patterns allow us to define functions for easily processing the queries. In particular, the paper shows how to trace and debug erroneous queries, and how to detect that a query is a refinement of another query, which can be useful for improving the efficiency of query processing.

In the last years the eXtensible Markup Language XML [18] has become the de facto standard for exchanging structured data in plain text files. This was the key for its success as data structures are revealed and therefore they are readily available for its processing (even with usual text editors if one wishes to manually edit them). Structured data means that new, more in- volved access methods must be devised. XQuery [21,23] has been defined as a query language for finding and extracting information from XML documents. It extends XPath [19], a domain-specific language that has become part of general-purpose languages. Although less expressive than XQuery, the sim- plicity of XPath makes it a perfect tool for many types of queries. Due to its acknowledged importance, XML and its query languages have been embodied in many applications as in database management systems, which include na- tive support for XML data and documents both in data representations and query languages (e.g., Oracle and SQL Server). Some of them extend SQL to include support for XQuery, so that results from XML queries can be used by the more declarative SQL language in the context of a database, making possible to share relational and XML data sources.

[10] proposes a rule-based language for processing semistructured data that is implemented and embedded in the functional logic language Curry [9]. Re- cently, in [5], we have proposed an implementation of XPath in the functional- logic language T OY [11], where a XPath query becomes at the same time implementation (code) and representation (data term). XML documents are represented in this proposal by means of data terms, and the basic construc- tors of XPath: child, self, descendant, etc. are defined as non-deterministic higher-order functions that can be applied to XML terms.

This paper continues this work, showing that XPath fits very well into the functional-logic paradigm. The proposed framework allows the user to write XPath-like queries as first-class citizens of the functional-logic language T OY. To this end, higher-order combinators are used for constructing queries, and we take advantage of non-determinism in order to obtain the different answers that XPath queries may return. The result is a very good example of cross- fertilization of two different areas:

[24] in the field of relational databases to our scheme. This refers to the ability of reusing previous cached query results for enhancing query solving performance (Section 5). Finally, in Section 6 we draw some conclusions and point out some future work.

In T OY variable names must start with either an uppercase letter or an underscore (for anonymous variables), whereas other identifiers start with lowercase. T OY includes two primitives for loading and saving XML documents, called load xml file and write xml file respectively. For convenience all the documents are started with a dummy node root. This is useful for grouping several XML fragments. If the file contains only one node N at the outer level, root can be removed defining the following simple function:

The input arguments of this operator are a string S representing the file name and a XPath query Q. The function applies Q to the XML document contained in file S. This operator plays in T OY the role of doc in XPath. The XPath combinators / and :: which correspond to the connection between steps and between axis and tests, respectively, are defined in T OY as function composition:

produces a single answer, with R instantiated to a list whose elements are the nodes in "food.xml". XPath abbreviated syntax allows the program- mer to omit the axis child:: from a location step when it is followed by a name. Thus, the query child::food/child::item/child::price becomes in XPath simply as food/item/price. In T OY we cannot do that directly because we are in a typed language and the combinator ./. expects XPath expressions and not strings. However, we can introduce a similar abbreviation by defining new unitary operators name (and similarly text), which transform strings into XPath expressions:

Notice that a new function append is used for concatenating XPath expres- sions. This function is analogous to the well-known append for lists, but defined over xPath terms. This is our first example of the usefulness of higher- order patterns since for instance pattern (A.::.B) has type xPath, i.e., xml

the context node X, returning a new context node Y. Then the if condition checks whether Y satisfies the filter F, simply by checking that F Y does not fail, which means that it returns some value represented by the anonymous variable in F Y == . Although XPath filter predicates allow several possibilities, in this presentation we restrict to XPath expressions. Multiple predicates can be chained together to filter items as with the and operator, which can be formulated as follows:

One of the most appealing features of our setting is that XPath queries can be manipulated. In this section we use this feature for tracing and debug- ging queries. We distinguish two types of possible errors in a XPath Query depending on the erroneous result produced: wrong queries when the query returns an unexpected result, and missing when the query does not produce some expected result. We present a different proposal depending on the error.

In the case of a single step (A.::.B) the first rule checks that indeed the step applied to the input produces the output returning the three elements. In the case of two or more steps, the second rule looks for the value O1 produced by the single step A such that the rest of the query B applied to O1 produces the erroneous result O. The variable O1 is a new logic variable, and that the code uses the generate and test feature typical of functional languages. The function wrong produces a list where each step is associated with its input and its output. However, using wrong directly produces a verbose, difficult to understand output due to the representation of XML elements as a data terms in T OY. This can be improved by building a new XML document containing all the information and saving it to a file using the primitive write xml file:

The first function traceStep generates an XML element step containing the information associated with a XPath step: the step combinator, its input, and its output. This function uses the auxiliary function show to obtain the string representation of the step (only part of the code of this function is displayed). Then function generateTrace applies traceStep to a list of steps. It uses the functions map and rev whose definition is the same as in functional programming. In particular, rev is employed to ensure that the last step of the query is the first in the document, which is convenient for tracing back the result. Finally writeTrace combines the previous functions. It receives four parameters: the query, the name of the initial document, the unexpected XML fragment we intend to trace, and the name of the output

The answer indicates that the step child .::. (nameT "type") is the possible source of the error. Thus this simply function is useful, but we can do better. Instead of simply returning the erroneous step we can try to guess how the error can be corrected. In the case of name tests as the example the error is usually the same erroneous string has been used. Replacing the string by a logic variable such that the query now succeeds can help to find the error. Therefore, we implement a second version of missing:

In this case missing returns a pair. The first element of the pair is the same as in the first version, and the second element is a suggestion pro- duced by function guess. This function first checks if the Step is of the form (A.::.nameT B). If this is the case, it replaces the name B by a new variable C and uses the condition in the second if statement ((StepBis ./. Y) R == ) to check if C can take any value such that the query does not fail. If such value for C is found the returned string proposes replacing B by

The first rule handles the merged node, assigning the children of the first argument to the second argument whenever they have the same label test. Second and third rules are recursive rules for handling steps and filters. Third rule accumulates filters by means of the XPath operator /&. The auxiliary functions children, filter and root compute the children and filter of the root, and the root of a XPath expression, respectively. Let us now see an example of use. For instance, defining:

/*[variety] in the standard XPath syntax. In summary, we are able to use the logic features of T OY for building the compensation of a certain view. Currently, T OY is able to solve one of the problems related to compensations: to find them. T OY offers as output a set of compensations when they exist, otherwise fails. To find a minimal compensation is considered as future work of this implementation. Moreover, we would like to extend our implementation to cover with compensations to multiple views.

A T OY implementation that includes the XPath primitives for loading and saving XML documents and most of the examples of this paper can be downloaded from: http://gpd.sip.ucm.es/rafa/xpath/toyxpath.rar. As future work, we plan to consider exploiting the same T OY characteristics for optimizing XQuery expressions.

S. Schaffert and F. Bry. A Gentle Introduction to Xcerpt, a Rule-based Query and Transformation Language for XML. In Proc. of International Workshop on Rule Markup Languages for Business Rules on the Semantic Web, page 22 pages, Aachen, Germany, 2002. CEUR Workshop Proceedings 60.

