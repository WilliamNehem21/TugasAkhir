JML specifications use Java syntax, and are embedded in Java code within special marked comments /*@ ... @*/ or after //@. A simple JML specification for a Java class consists of pre- and post-conditions added to its methods, and class invariants restricting the possible states of class instances. Specifications for method pre- and post-conditions are embedded as comments immediately before method declarations. JML predicates are first-order logic predicates formed of side- effect free Java boolean expressions and several specification-only JML constructs. Because of this side-effect restriction, Java operators like ++ and -- are not allowed in JML specifications. JML provides notations for forward and backward logical

signals (E e) R. specifies an exceptional method post-condition R. It says that if the method throws an exception e of type E, a subtype of java.lang.Exception, then the JML predicate R must hold. Predicate R is a valid JML predicate. JML allows the use of the alternative clause exsures for signals.

assignable L. specifies that the method may only modify location L. Any other location not listed in L may therefore not be modified. This must be true for both normal and exceptional post-conditions. Two special assignable specifications exist, assignable \nothing, which specifies that the method modifies no location, and assignable \everything, which specifies that the method may modify any location. JML allows the use of the alternative clauses modifies and modifiable for assignable.

invariant I. declares a class invariant I. In JML, class invariants must be estab- lished by the class constructors, and must hold after any public method is called. Invariants can temporally be broken inside methods, but must be re-established before returning from them.

The normal behavior specification for method setValue says that if v is non- negative then the method will terminate normally, the new value for decimal will be v * PRECISION, and the value returned by the method will be the object this. The exceptional behavior specification for method setValue states that if v is negative, the method will throw an exception of type DecimalException and no location will be modified. The keyword also expresses that setValue can have either a normal or an exceptional behavior.

We tested the specifications for the Ax-LIMS project manager plugin by using the JML common tools [10]. The JML common tools is a suite of tools providing support to run-time assertion checking of JML-specified Java programs. The suite includes jmlc, jmlunit and jmlrac. The jmlc tool compiles JML-specified Java programs into a Java bytecode that includes instructions for checking JML specifications

at run-time. The jmlunit tool generates JUnit [13] unit tests code from JML specifications and uses JML specifications processed by jmlc to determine whether the code being tested is correct. Test drivers are run by using the jmlrac tool, a modified version of the java command that refers to appropriate run-time assertion checking libraries. For the case study presented in this paper, we provided JML specifications for the main classes of the Ax-LIMS project manager plugin, however some classes regarding the Graphical User Interface (GUI) were not specified. We used jmlunit to generate JUnit tests for each method in every class and jmlrac to run the tests.

precondition property and that it follows from other properties of the specification, e.g., a class invariant stating that T != null exists. Redundant properties serve to bring them to the attention of the readers of the specification and the people working in the implementation of the application.

Thinking about invariants prior to writing code is a practice to which program- mers do not easily adhere. Having a previous formal specification of the application and systematically using a tool for checking the correctness of the code as it is writ- ten forces programmers to think about how the written code affects the consistency and the correctness of the whole program. We present below a correct implemen- tation for the method setTasks. The implementation relies on method delTask for removing the current project tasks and addTask for adding the new tasks. The correctness of the implementation of setTasks depends on the correctness of the implementation of both delTask and addTask, e.g., for re-establishing the state of the project each time a task is deleted or added.

We can further use JML for checking insight on how method setAsd works in some particular cases. To do this, we use the JML assert specification construct, which checks for satisfaction of a predicate at a dedicated point within a method. For instance, we are interested in knowing what the state of a project would be if setAsd is called with an empty list of tasks. We assert the specification below immediately before the end of method setTasks. JML reports errors for any value of _state other than State.UNRESOLVED.

Therefore, besides assigning a value to asd, method setAsd must also set the project state accordingly. After several iterations of specifying and checking, we came up with an appropriate JML code for setting the project state. The JML specification code is shown below together with the actual Java code. The Java predicate expression c ? s : t returns s if the evaluation of c is true, otherwise it returns t. We use the set command of JML for setting the ghost variable _state.

In previous software developments carried out by the ParqueSoft engineers, OCL (Object Constraint Language) was used for expressing constraints on the UML models. However, for this case study, the ParqueSoft engineers decided to use JML for expressing these constraints instead. The ParqueSoft engineers found JML specifications much easier to code than OCL constraints. JML will therefore be used as the language for expressing model constraint in future ParqueSoft Java- based software developments.

