An important missing link in the construction of secure systems is finding a practical way to establish a correspondence between a software specification and its implementation. We address this problem for the case of crypto-based Java implementations (such as crypto protocols) with an approach using automated theorem provers for first-order logic, by linking the implementation to a specification model. In this paper, we present details on an application of this approach to the open-source Java implementation Jessie of the SSL protocol. We also shortly comment on how these results can be transferred to the standard Java Secure Sockets Extension (JSSE) library that was recently open-sourced by Sun.

of work reported in the current paper (which was started in [13,12]) is targeted to legacy implementations of crypto protocols. It is motivated by the fact that so far, crypto-based software is usually not generated automatically from formal specifi- cations, or even created in ways under control of the security analyst. Thus, even where the corresponding specifications are formally verified, the implementations may still contain vulnerabilities related to the insecure use of cryptographic algo- rithms. An example for a crypto protocol whose design had been formally verified for security and whose implementation was later found to contain a weakness with respect to its use of cryptographic algorithms can be found in [17].

Our goal is not to provide a full formal verification of Java code but to increase understanding of the security properties enforced by crypto protocol implementa- tions in a way which is as automated as possible. For the moment, we assume that the cryptographic algorithms called in the crypto protocol implementations have been implemented correctly (and our goal is to verify that they are used correctly in the crypto protocol). Also, because of the abstractions introduced for efficiency reasons (as explained below, for example abstracting from the identity of the sender of a message), the approach may produce false alarms (which however have not surfaced yet in practical examples).

Therefore the contents of the variable depends on the initialization of the cur- rent random object and thus also on the program state. Thus we need to trace back the initialization of the object. In the current program state, the random object was passed on to the ClientHello object by the constructor. This again was delivered at the initialization of the Handshake object in SSLSocket. doClien- tHandshake() to the constructor of Handshake. Here (within doClientHandshake()), we can find the initialization of the Random object that was passed on. The second parameter is generateSeed() of the class SecureRandom from the package java.security. This call determines the value of randomBytes in the current program state. Thus the value randomBytes is mapped to the model element RC in the mes-

According to the annotations defined based on the textual specifications, the check g is implemented by the method call session.trustManager. checkServerTrusted(peerCerts, suite.getAuthType()) (which throws an exception if the check fails). By tracking the various write and read calls, the tool also determines where the program points p resp. q are located, where the last message is received

