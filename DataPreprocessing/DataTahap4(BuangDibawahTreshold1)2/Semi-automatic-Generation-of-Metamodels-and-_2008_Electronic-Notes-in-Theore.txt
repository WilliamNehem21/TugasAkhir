...) are defined by using a grammar-based notation. Although the definition of a language by metamodels is more convenient in terms of understandibility, precision and the ability to reuse abstract concepts from other language definitions, most current textual languages are still missing a complete metamodel. Unfortunately this implies that modern model-based software development tools are not able to process programs written in those languages.

We propose a framework which generates a metamodel for each programming language defined by a gram- mar. Moreover the framework is able to create a compiler which reads programs of the given grammar and produces models which conform to the generated metamodel. The generation of the metamodel can be adjusted by a predefined set of annotations which can be written directly into the grammar, so the generated model is more appropriate for whichever application.

The rest of the paper is structured as follows. After this introduction we present some related works. In section 3, we define a measurement of quality which is needed to understand the proposed framework described in section 4. Section 5 describes our current implementation, while section 6 summarizes the paper.

The solution first described in [10] (and later in [2]) goes further. In this paper the author describes the generation of a metamodel for the ITU-T language SDL [3]. His approach was to generate the metamodel in two steps. A very simple metamodel was generated fully automatically from the grammar and then transformed in a number of manual steps until the metamodel had become a metamodel that was considered sufficient. However, this approach has two drawbacks: (i) these model transformations are not generic as they are only able to generate the metamodel of SDL and (ii) the model level (M1) is still not handled.

from programs. The proposed framework looks very similar to the one proposed by us but there are differences in the details. They also propose the automatic gener- ation of simple metamodels which will be improved in later model transformations. However we have different opinions about when to solve which specific task and where to annotate the additional information needed to improve the metamodel. While they rely only on model transformation we start to improve our first meta- model before it is even generated. Moreover they propose to add the additional information into the metamodel created in the first step while we do not want to change intermediate models since they will be overwritten if we start the whole gen- eration process again (e. g. if there is a slightly change in the underlying grammar). We propose to add all additional information into the grammar instead.

Whenever you can define an application for your metamodel, you instantly get a measurement of quality. This measurement is defined rather pragmatically: the more appropriately the metamodel satisfies your needs, the higher quality it has. This implies that there is no global measurement of quality but many local ones.

When we talk about higher or lower quality metamodels in this paper we con- sider the application mentioned in the introduction. We are especially interested in metamodels whose instances (i. e., models) can be easily transformed into other models which are instances of other metamodels.

This implies that it has to represent the semantics of the language and not the syntax. Therefore it is a good idea to start with an abstract grammar and not with a concrete one (as done in [10]). When no abstract grammar is given (as in most textual languages) it is useful to create one by stripping all terminals from the concrete grammar that are only needed for the concrete syntax (e. g. semicolons as statement separators are only needed in the concrete syntax and can therefore be deleted when generating the abstract grammar).

Another concept from grammars no longer needed in metamodels are identifiers. Identifiers are only used in programs to reference other parts of the program, but in metamodelling we do not need this helper construct. Associations between referring and referred objects should be used instead. A by-product of this approach is that

The repository used by the parent and child compilers for model generation and later for model transformation is a MOF 2 repository called A MOF 2.0 for Java [11,9]. Since the only interface used to communicate with the repository is JMI [5], the repository can be exchanged with any other JMI-conforming MOF 2 repository without any further changes needed in our implementation.

Once our implementation is finished we have a good base to migrate programs written in many textual languages into the field of (meta-)modelling. This implies that we can use all available model-based tools for software development, reengineer- ing, modernization, etc. on programs written in legacy languages, which will make the mentioned applications much more understandable, easier and less error-prone.

Scheidgen, M., CMOF-model semantics and language mapping for MOF 2.0 implementation, in: Joint Meeting of the 4th Workshop on Model-Based Development of Computer Based Systems (MBD) and 3rd International Workshop on Model-based Methodologies for Pervasive and Embedded Software (MOMPES), 13th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (ECBS), 2006.

