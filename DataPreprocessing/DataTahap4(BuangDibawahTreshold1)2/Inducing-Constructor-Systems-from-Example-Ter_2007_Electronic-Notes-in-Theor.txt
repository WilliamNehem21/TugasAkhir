proaches and also formulated within the term rewriting framework is described in [6]. Extensions to the previous methods are that subfunctions/subprograms and additionally needed parameters are inferred automatically and in a systematic way. All these functional analytical two-step methods are restricted to small fixed sets of primitive functions (basic constructors and selector functions for the respective data types and a predicate for testing whether a constructor is atomic, e.g., the empty list) of which the induced programs can be composed. That is, they cannot handle additionally provided problem-specific functions as background knowledge to induce more complex programs. Particularly, testing for atomic expressions as the only used predicate restricts the class of inducable programs to programs for structural problems. Reversing a list falls into this class for example, but not sorting a list, since for sorting a list a predicate for comparing two elements regarding an order is needed. Moreover, the described systems have in common that the pro- vided I/O-examples may not arbitrarily be chosen from the graph of the target function but have to be the first k examples regarding the inductive structure of the underlying data type.

The analytical and functional approach described in this paper represents I/O- examples as well as induced programs as constructor term rewriting systems (CSs) as a generic model of functional programs, instead of using a particular programming language. Compared to DIALOGS-II it is more general in that induced programs are not restricted to particular predefined data types, e.g., to lists or numbers, but I/O- examples can be defined over arbitrary finite signatures which are then adopted for the induced programs. Decompositions of inputs and argument terms for recursive

The class of flat one-function CSs contains several standard functions for lists, e.g., Head , Tail , Append , Length, Last (returns the last element), Init (returns the given list without the last element), Take and Drop (keeping only the first n elements of a list and dropping the first n elements from a list respectively), Zip (takes two lists and returns a list of pairs of corresponding elements), Sum (takes a list of natural numbers and returns the sum of all contained numbers), and Reverse (reversing a list by using an accumulator variable). Examples of flat one-function CSs for functions on natural numbers are Add , Sub, and several predicates, e.g., Odd , Even,

Induction of a correct CS is organized in two levels as follows: At the higher level, lhss of the rules of the CS to be induced are searched for. This is essentially a search for patterns because each pattern determines the lhs of a rule. At a second level, an rhs is computed for each lhs. If computation of a rhs succeeds for each found lhs, then the result is the completely induced CS. If computation of rhss fails for at least one lhs, then a new set of lhss is searched for. Computation of an rhs fails if and only if no rhs exists for the corresponding lhs such that the resulting rule is correct.

Generally there is an infinite number of CSs with different normalizing relations which are correct w.r.t. a set of I/O-examples because correctness w.r.t. I/O- examples makes no claim concerning all terms other than the example inputs. The induction algorithm returns only one CSs and therefore it is important to know, which of the correct CSs will be selected. Such a criterion is called inductive bias. Informally, the inductive bias of our algorithm can be described by three criteria (the stated order is relevant): An induced correct CS has (i) as few as possible rules,

(ii) as specific as possible patterns, and (iii) as general as possible rhss. As few as possible rules means that there exists no other correct CS containing fewer rules. As specific as possible patterns means that each pattern pn is the lglg of all example inputs in which it subsumes. As general as possible rhss means that if there are different possibilities for a particular position, then a variable from the pattern is preferred over a recursive call and a recursive call is preferred over a constructor symbol.

Now suppose a state P with an arbitrary number of patterns which comply with the stated conditions. If for at least one pattern a correct rule could not be computed, then successor states have to be computed. Let pn be such a pattern for which no correct rule exists. Then the I/O-examples whose inputs are subsumed by pn has to be partitioned into a minimum number of at least two subsets and pn has to be replaced by the lglgs of the inputs of the respective subsets. We call the

This is done as follows: First a position u from F (pn) which is labeled by a variable in F (pn) and by a constructor in each subsumed example lhs is selected. Since F (pn) is the lglg of the subsumed example lhss it then holds that in at least two example inputs these constructors differ. Then respectively all example inputs with the same constructor at position u are taken into the same subset. That leads to a partition of the example inputs. Finally, for each subset the lglg is computed.

A successor state is a state in which all patterns for which no correct rule could be computed are replaced by corresponding sets of mgpls. Since the position which determines a partition is generally not unique, also the sets of mgpls are not unique. Thus, all combinations of replacing these patterns by mgpls are included as successor states.

1.2 denotes the variable qs in the current lhs and the constructors [] and cons in the remaining example inputs respectively. It partitions the I/O-examples into one set consisting of I/O-examples 2 and 3 and another set consisting of I/O-examples 4-6. This leads to two new patterns, [q] and [q, q']. Thus, we get two successor states for the pattern state {[], [q|qs]}, namely first {[], [0|qs ], [s(x)|qs]} (cp. the

Constructor: The roots of all outputs are the same constructor f with arity m: Then the rhs becomes the term f (t1,... , tm) where the ti are constructed by considering these three cases for the subterms of the outputs at position i.

its ability to induce programs over arbitrary data types and in that the induced programs can contain more than one recursion parameter. Until now, neither back- ground knowledge can be used nor can additional subprograms or parameters not contained in the I/O-examples be induced. Yet techniques for automatic introduc- tion of further subprograms as well as further parameters to the induced programs have been developed within the analytical approaches and should be applicable to our approach as well.

