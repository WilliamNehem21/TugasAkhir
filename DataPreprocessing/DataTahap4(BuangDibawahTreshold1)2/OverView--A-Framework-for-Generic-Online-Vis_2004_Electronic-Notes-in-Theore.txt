Considerable work has been done in the field of visualization and analysis of the execution of Java programs (for a survey see, e.g. [9]). Jinsight [12] does visualization of trace information produced by a special instrumented version of the Java Virtual Machine. Similarly, the system developed by Walker et al. [16] uses program event traces to visualize program execution patterns and event-based object relationships like method invocations viewed within cels. These systems support only an offline mode where the trace of the program execution gets visualized. Also they are not specifically designed for visualizing a distributed system.

Jive [10] does on-line visualization of Java programs. It is a software vi- sualization framework for dynamic analysis of program data. Jive supports only non-distributed systems. Snodgrass presents a method targeted towards distributed debugging and monitoring in which a programmer uses relational algebraic queries to track run-time dynamics [13].

wishes to visualize. Additionally the plug-in will register some IPAs with other IPAs, instead of with its data collector. These IPAs will act in a hierarchy to condense the information sent to the data collector, reducing the overall load. The IPAs collect profiling information and send this to every registered data collector or IPA. IPAs may also register to other IPAs, creating a hierarchy for condensing the amount of information eventually sent to the data collectors. This approach provides scalability, and allows for multiple OverView plug-ins to visualize a distributed system simultaneously.

The data collector receives the events and sends them to the event mapper, which periodically updates the world view and stores events to the historic data. The historic data can be saved to disk and used to replay the events in offline. The IPA, event mapper, historic data and world view are described in greater detail in section 5.

when describes triggers for events, based on actions performed by the entity. start and finish designate if the event should be triggered at the beginning or end of the method invocation (or a constructor). The declaration then proceeds to describe the event sent to the visualization, as well as the values that the event will contain.

update(String item, Object value) specifies that the state of an entity has been updated, along with the value that was updated and the identifier for that object. These events are usually used behind the scenes by the watch declaration. The arguments for this event are the name of the part of the state that was changed, as well as the value that is has now become.

The OverView plug-in utilizes the JJTree software to parse the ESL and in- struments the appropriate Java classes, inserting the appropriate profiling statements for the various events in the ESL. These profiling statements con- sist of passing information about the above events to the IPA. This allows the OverView plug-in to visualize programs for which the source code is not readily available, as long as there are the appropriate entity specifications.

The OverView plug-in can display a view of a distributed program in several ways. Entities are displayed as circles, which can be clicked on to display state data, determined by update events and retrieved from the IPA where that entity is located. Entities are located within other entities, displayed as squares. These act as containers for entities, which may migrate between these containers. Communication between entities is represented by lines, which are color mapped blue, for low amounts of communication, to red, for high amounts of communication. The width of a line determines the average time for communication between the entities: wide, for quick communication, to thin, for slow communication. Entities are colored blue when operating without error, and colored red when an error event has occurred. The entity may be clicked on to determine the error. An example of this world view is

