As an example, consider XML. As a meta-model, XML permits the expres- sion of schemas defined for a specific role. To express the syntactic structure of code, SrcML [13] and JavaML [1] both define XML compliant schemas. How- ever, the former views the source-code as the foundation and adds markup to the code while the latter views the model as the foundation and adds the code, as attributes, to the representation. In this case, XML is used in two ways to accomplish the same purpose but to support differing higher level pressures. SrcML is designed to assist programmers working with the source-code while JavaML is designed to be easily manipulated by other tools for XML.

GXL [7], an XML schema, can be used to express graph-based software structures. When used for this role, GXL has little relationship to SrcML or JavaML. In this case, pressure from below, through the desire to express unrelated concepts, is exhibited.

We believe that a solution to these issues is to support multiple schemas and representation models. The key to this response is to utilize a multi- layered approach, where each layer minimizes the constraints it imposes on higher layers and decouples higher layers from the constraints imposed by lower layers. In this article a three-layered implementation and its elements are detailed.

The storage layer is implemented using a database or repository system. For this reason, the storage model is database specific. Examples of storage models include the relational model, object models and text models. It is not anticipated that there will be significant scalability issues as modern databases are used routinely to store data-sets in the gigabyte range.

It is also possible to consider the storage layer as providing an additional schema. For example, if there is information for which there is no need for a higher-level conceptual model, or for which a conceptual model does not exist, the information can be stored directly using the storage model. This practise is not desirable, as the storage model interface usually lacks a strong set of features for manipulating information. In response to this lack, Paul and Prakash [15] have developed an algebraic query language specifically designed for manipulating source-code.

While it is possible to store multiple XML schemas in the same database, there is no documented research in this area. Specifically, there needs to be further research on the implications of normalization to remove redundancy. As well, the use of a relational database to store source-code is known to be inefficient [12] when the code is decomposed into grammatic units. Queries must reconstruct code segments recursively using sub-queries to access each sub-element. In modern systems, this reconstruction can be performed ef- ficiently, but it is not known whether this performance is maintained when multiple low-level conceptual models are integrated in a single database

In Jupiter [5], we are exploring a multi-level markup approach. For con- ceptual modelling, traditional markup, as seen in JavaML, SrcML and GXL, is used. To store the conceptual models, a second, lower level of markup is used. The second level of markup is highly simplified and is specifically tai- lored for the MultiText structured text database system [3]. While similar to XML-style markup, the storage level markup exhibits several key differences in support of retrieval efficiency. First and foremost, MultiText markup is index- based to support algebraic query solution. Relationships are represented as pairs of indices and have no semantic constraints. As well, apart from re- lationships, markup items are atomic and attributeless tokens that have no imposed limitations on their locations. The similarity of the conceptual and storage models permits conceptual models to be easily mapped to the storage model.

A 3-layered approach stacks conceptual models upon a storage model. Ex- tension of this approach will likely entail the splitting of the conceptual layer into layers focused on a specific concept. For example, a 4-layered implemen- tation could have a low level AST-based layer on top of the storage layer and below a higher level DMM-based layer.

Multi-layered approaches have yet to have a significant impact on the field of reverse engineering. Though they offer improved flexibility, they are more complex to implement and have not been well researched. It is not known how well a storage model, such as the relational model, will integrate multiple conceptual models. More research on the representation of the various con- ceptual models using storage specific models is needed. Similarly, it is known that relational query languages are less desirable for use in some maintenance tasks [10]. Hence, there is also a need for development of techniques to map abstract graphical languages to database retrieval languages such as SQL.

There is some discussion on the development of common conceptual mod- els for information interchange [16] but this discussion has not been carried out with respect to software storage models. Existing repository systems uti- lize relational, object-oriented, text, logical (Prolog) and customized database systems. There is now a need to develop a consensus on the most appropriate storage models for representing conceptual models.

The use of a multi-layered approach unifies much of the work that has been occurring in the development of reverse engineering tools. Research on information extraction and representation is focusing on the schema layer while research on repository systems usually examines the storage layer. These topics should not be viewed as disjoint, but instead as two elements of a more complete layered implementation approach.

Multi-layered approaches improve upon single element models by reducing the demands placed upon each layer. Layered design permits lower layers to abstract storage and management details, lessening lower level pressures on conceptual models. As well, the use of multiple conceptual models, disperses pressure from above by permitting each model to focus on a specific demand. The key to the successful application of this approach is the use of a common storage model that integrates multiple higher-level models, where each may conform to a different schema. When one is not restricted to a single concep-

