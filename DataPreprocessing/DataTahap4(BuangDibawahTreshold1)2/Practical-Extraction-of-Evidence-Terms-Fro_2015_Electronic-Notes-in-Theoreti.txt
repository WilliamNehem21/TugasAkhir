The study of epistemic reasoning, reasoning about knowledge and belief, is one of the core areas of Computer Science and Artificial Intelligence. The traditional systems of formal epistemology are based on modal logics and have been the sub- jects of intense research activity during the past decades [10; 15]. There are several computer-aided systems of modal and epistemic reasoning available (for an incom- plete list, see [17]).

A foundational effort in this area has enriched modal epistemic logic with the internalized notion of justification, which became part of the language of epistemic logic. This development substantially broadens the scope of applications of epis- temic logic. We now have the capability to not only reason about epistemic states of knowledge and belief of agents, but also to track their justifications and to sort those which are pertinent to given facts and sufficient for epistemic conclusions. The very notion of evidence has become the subject of rigorous studies.

The procedure was implemented in OCaml. Evaluation of box families, considered to be trivial on paper, was the biggest hurdle. Each box was assigned a unique family identifier. Proofs have branches, and families grow by transitive extension, thus the disjoint set of sets (families) of box identifiers that are related (belong to the same family) needs to be maintained. What actually occurs is that each box is replaced with Pr(Provisional, F ) where Provisional is this unique identifier. The algorithm recursively walks over the proof tree, assigns these identifiers, and collects information about which identifiers fall into which family. At each step representing application of a rule, we have to track how each formula above the line (of the rule) was transformed and then transform the formulas below the line accordingly.

For this puzzle, a straightforward epistemic logic formalization can lead to in- consistent sets of hypotheses [7; 11; 12]. For example, let c1,..., cn be propositional variables reserved for N children, where ci encodes that ith child is muddy. J stand

We would like to see some modalities realized as proof terms so we replaced all modalities that represent facts that everyone knows (due to public an- nouncements or general conditions of the puzzle) with J. We also strengthen the conclusion to state that at the third moment, everyone knows that everyone knows about themselves, so we have to add lines (6), (7) to bring the knowledge of the first and third children from step 2 to step 3, and we add (9) to reflect the fact that if the second child learns about himself, he will announce it. We did not perform this transformation with the longer version because the prover was overwhelmed by the complexity.

If we unfold all disjunctions, MetaPRL has no problems completing the proof. But it was unable to find the proof in fully automatic mode in an hour. In this sense, this theorem is harder than Muddy Children puzzle for 4 children, which can be solved in 150-250 seconds. The reason why fully automatic mode fails is because all J-boxed assumptions have to be used twice in the reasoning and the prover works by first exhausting all proof matrices with modalities used at most once, then expanding the search space by allowing each modality to have two prefix interpretations; the resulting search space is big and the solution does not appear quickly. The Muddy Children puzzle also needs this search space expansion, but we get luckier there, although it is not clear exactly why.

