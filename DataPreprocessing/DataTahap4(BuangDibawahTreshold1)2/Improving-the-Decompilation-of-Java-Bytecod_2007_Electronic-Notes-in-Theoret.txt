The LP (Ciao) program generated by the class reader contains the bytecode in- structions for all methods in {class 1,.. ., class n}. They are represented as a set of facts bytecode; and also, a single fact class obtained by putting together all the other information available in the .class files (class name, methods and fields signa- tures, etc.). Each bytecode fact is of the form bytecode(PC, MethodID, Class, Inst, Size), where Class and MethodID, respectively, identify the class and the method to which the instruction Inst belongs. PC corresponds to the program counter and Size to the number of bytes of the instruction in order to be able to compute the next value of the program counter. The form of the fact class is not relevant to this work but it can be observed in [1].

In order to guarantee termination of the unfolding process, when building the SLD-trees, it is possible to choose not to further unfold a goal, and rather leave a leaf in the tree with a non-empty, possibly non-failing, goal. The resulting SLD is called a partial SLD tree. Note that even if the SLD trees for all possible queries are finite, the SLD to be built during partial evaluation may be infinite. The reason for this is that since dynamic values are not known at specialization time, the specialization SLD tree can have more branches (in particular, infinite branches) than the actual SLD tree at run-time. Which atom to select from each resolvent and when to stop unfolding is determined by the unfolding rule.

A partial evaluation of P w.r.t. S can then be systematically extracted from the resulting set of atoms T . The notion of resultant is used to generate a program rule associated to each root-to-leaf derivation of the SLD-trees for the final set of atoms

Regarding the efficiency of the PE process, it should be noted that the use of control strategies based on embedding introduces a significant overhead, as we need to keep track of the ancestors (see, e.g., [20]) and to perform expensive embedding checks for each of the atom arguments.

const: which stands for constant. The motivation for introducing this type is just efficiency of the specialization process. Of course, it should only be applied to arguments which we know will always be instantiated to the same value during specialization time. Its usage does not affect the control strategy at all, but it allows avoiding testing the embedding relation over and over again on arguments which never change. This is the case, for instance, of the argument Program which remains constant all over the decompilation process.

The question is whether there is any way to take the previous generalization history into account when abstracting an atom at the global control. The intuition is to keep track of the information which we have been forced to forget during the partial evaluation process and proceed to forget it straight away for all new atoms which are similar to the previously handled ones under some criteria. The motivation for doing so is that since it seems likely that we will end up being forced to forgetting such info, the sooner we forget such info, the better, both in terms of specialization times and size of the residual program. We now propose

the number of pairs of numbers with different sign. Finally, we have used four benchmarks which make extensive use of object-oriented features such as instance method invocation, field accessing and setting, object creation and initialization, etc. Thus, add, exp and simp compute different operations over rational numbers (represented as objects), while forward is invoked over an object representing a date and forwards one day.

