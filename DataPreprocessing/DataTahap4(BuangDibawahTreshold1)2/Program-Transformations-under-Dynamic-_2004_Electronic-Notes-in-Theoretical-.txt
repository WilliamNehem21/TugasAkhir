A new static analysis is proposed for programming languages with access control based on stack inspection. This analysis allows for various security-aware program optimizations. A novel feature of our static analysis is that it is parametric with respect to the security policy in force, so it needs not to be recomputed when the access rights are dynamically updated.

Traditionally, stack inspection has been implemented with the lazy evalua- tion strategy: the call stack is only retrieved and inspected when access control tests are performed. This strategy has some drawbacks. First, the run-time overhead due to the analysis of stack frames may grow very high. Second, stack inspection deeply affects those interprocedural program transformations (i.e. method inlining) that may alter the structure of the call stack.

However, starting from version 1.4.1, the Java security architecture allows for dynamic security policies: the binding between a class and its permissions can be deferred until the class is involved in an access control test. Still, the static binding of permissions is allowed.

In this paper, we introduce a new static analysis for stack inspection, improving over previous analyses of ours, see e.g. [3]. Our present proposal is specifically designed to tackle the issues raised by dynamic security policies. We represent programs by control flow graphs, an idealized model not tied to any particular language. These graphs are extracted from actual bytecode through available control flow analyses; they feature primitive constructs for method invocation, exceptions, and access control based on stack inspection.

Java allows for the dynamic instantiation of permissions (e.g. an application that asks the user for a file name and then tries to open that file). Such parametric permissions are of the form P (x), where x ranges over the set of possible targets for the permissions of class P .

in Java, a new thread upon creation inherits the access control context of its parent. When stack inspection is performed, both the context of the current thread and the contexts of all its ancestors are examined. In this way, a child thread cannot obtain an access which is not granted to its ancestors.

our model only allows for code-centric security policies: permissions are granted to code according to its source, regardless of who is running it. JAAS [18], extends the Java security model by enabling user-centric access control policies, based on the principal who actually runs the code. Permis- sions can be granted to principals, and the doAs method allows a piece of code to be executed on behalf of a given subject. This is done by associating the (authenticated) subject running the code with the current access con- trol context. Stack inspection ensures that subjects are taken into account when access control is performed (see e.g. [15] for a formal specification).

the exponential factor 2D above only occurs when the number of protection domains is proportional to the number of nodes. Actually, the number of protection domains can be considered as a constant, because it depends on static properties of the loaded code (i.e. code origin and digital signatures).

each security check gives rise to a bifurcation in the abstract graph. Then, our approximation to the number of abstract nodes hides an exponential factor in the number of checks. However, the number of security checks in CFGs is usually small: indeed, access control tests are only inserted to guard methods accessing critical resources.

In this section we show that our static analysis provides us with an effective basis for several code optimizations. This is not a trivial task, because per- forming interprocedural optimizations in the presence of stack inspection may break security. Indeed, stack inspection deeply relies on the structure of the call stack, which may be altered by such optimizations.

All the program transformations below have to be revalidated every time that the security policy is updated. This form of dynamic deoptimization is common practice in the presence of just-in-time compilers, e.g. the Java HotSpot Compiler [25]. Again, note that our analysis need not be recomputed.

Dead code elimination is a program transformation which allows the compiler to discard unreachable or useless pieces of code. This optimizazion reduces both the size of the generated bytecode and the total application running time (e.g. when code has to be downloaded from the network).

Method inlining is an optimization that replaces a method invocation with a copy of the called method code. As a side effect, the protection domain of the inlined method is ignored when performing stack inspection. Our analysis gives us the means to compute the set of method invocations that can be safely inlined. Intuitively, a method invocation can be inlined if the outcome of the security checks is not affected by ignoring the protection domain of the inlined method.

Besson, Jensen, Le M`etayer and Thorn [7] formalize classes of security properties through a linear-time temporal logic. They show that a large class of policies (including stack inspection) can be expressed in this formalism. Model checking is then used to prove that local security checks enforce a given global security policy. Their verification method is based on the translation from linear-time temporal formulae to deterministic finite-state automata, and

it can be used to optimize stack inspection. Based on the same model, [6] develops a static analysis that computes, for each method, the set of its secure calling contexts with respect to a given global property. When a method is invoked from a secure calling context, its execution never violates the global property. For some optimizations, e.g. for method inlining, this technique is even too powerful, as the information about calling contexts is unnecessary.

Exploiting the access control logic of [1], Wallach, Appel and Felten [28] propose an alternative semantics of eager stack inspection, called security- passing style. This technique consists of tracking the security state of an execution as an additional parameter of each method invocation. This allows for interprocedural compiler optimizations that do not interfere with stack inspection (at the cost of more expensive method calls).

the set of permissions a class needs in order to execute without throwing se- curity exceptions. Also this analysis suffers from allowing only all-or-nothing optimizations, as in [21]. The analysis is built over access rights invocation graphs. These flow graphs are context-sensitive: each node is associated also with its calling context, i.e. with its target method, receiver and parameters values. In this way, the analysis in [17] can deal with parametric permissions and multi-threading. Our approach can gain precision through the exploita- tion of these graphs. We plan to study this issue in future work.

