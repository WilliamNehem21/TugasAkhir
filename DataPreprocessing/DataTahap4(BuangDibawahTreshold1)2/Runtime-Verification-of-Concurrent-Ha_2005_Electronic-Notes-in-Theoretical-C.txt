In this article we use model checking techniques to debug Concurrent Haskell programs. LTL formulas specifying assertions or other properties are verified at runtime. If a run which falsifies a formula is detected, the debugger emits a warning and records the path leading to the violation. It is possible to dynamically add formulas at runtime, giving a degree of flexibility which is not available in static verification of source code. We give a comprehensive example of using the new techniques to detect lock-reversal in Concurrent Haskell programs and introduce a template mechanism to define LTL formulas ranging over an arbitrary set of threads or communication abstractions.

useful advice on how to try to debug this error. Also, we do not have to limit ourselves to recording events on semaphores. It is useful to have unique markers throughout the program detailing periodically the position and state of the current run. Although this technique mostly resembles hello-debugging, we will show that these traces offer an added value: We can do runtime verification for a running program by means of a runtime verifier embedded into the system.

A temporal logic like the linear-time logic (LTL) [1] lends itself naturally to describing properties depending on the changing states of a program over time. Formulas must never be evaluated to False during program execution. Our system allows the dynamic addition of new formulas which have to hold when the system evolves.

The article is structured as follows: Section 2 gives a brief introduction to Haskell and the technique of recording traces and using them for debugging. Section 3 provides some background on LTL and describes the LTL runtime verifier. Section 4 shows a sample verification of the lock-reversal problem, which can in general be solved by templates, introduced in Section 5. Section 6 concludes the paper and presents future work.

In the IO monad, threads can create MVars (newEmptyMVar), read values from MVars (takeMVar) and write values to MVars (putMVar). If a thread tries to read from an empty MVar or write toa full MVar, then it suspends until the MVar is filled respectively emptied by another thread. MVars can be used as simple semaphores, e.g. to assure mutual exclusion, or for simple inter-thread communication. Based on MVars, higher-level communication objects are built but are out of the scope of this paper.

Running this program for a while shows that the property is violated. The asserted LTL-property does not hold because of a race condition. In the background, we record a trace of the performed concurrent actions, which can be replayed by means of our Concurrent Haskell Debugger. This helps the user to understand the reason for the bug. The trace is produced by overloading every Concurrent Haskell function which writes a trace output into a file, similarly to [3].

In traditional model checking, the complete state space is derived from a specification and all possible paths are checked. There are two reasons why formal verification is often not used in practice: First, for real programs the specification has to be derived from the source code which is to be checked. This usually involves parsing the source and additional annotations, e.g. as comments. Furthermore, model checking is not applicable for large systems, because of state space explosion. In many cases, a system may even have an infinite state space and the model checking problem is undecidable.

Runtime verification does not need the state space beforehand, but simply tracks state changes in a running program. Thus, it limits itself to verifying that a formula holds along the path the program actually takes. This means that although errors could not be detected in the current run, they may still be present in the state space of the program. Various runs taking different paths may be necessary to find a path which violates the formula. However, runtime verification enables the use of well understood, formal techniques for the systematic validation of concurrent systems.

We allow arbitrary types as atomic propositions. Therefore, LTL is polymor- phically defined over a type variable a. We also define disjunction and a release operator R. Like many model checking approaches, it is used as the dual op- erator to U. We deal with negation by pushing all negations in front of atomic propositions. Similarly to Definition 1, we handle the abbreviations F and G:

The step messages for the check engine thread are automatically gener- ated by extended versions of the concurrency actions. I.e., we only consider concurrency actions of the system as steps while calculations, independently of how much time they take, are not interpreted as steps in the state space. This is permissible since a computation does not affect the concurrent system as long as the result is not used for communication.

For debugging Concurrent Haskell programs, we provide an algebraic data type which contains the ThreadId of the corresponding thread so that formulas can contain per-thread expressions. Additionally, we will record the name of the MVar being held. We use this data type as predefined atomic propositions. They are automatically set and released by concurrency actions as follows:

We observe that without further modifications, for example ordering on the arguments, the template might be instantiated too often, leading to redundant formulas, e.g. if the formula is commutative. To optimise the generation of permutations when a new proposition is set, we only generate new permuta- tions by maintaining a list of all already used propositions.

a set of formulas. In addition to specific debugging modules the developer can use explicit annotations to add information to the debugging trace. The debugger supports printing the tail of the trace from the point where it started proving the particular formula which turned False. Furthermore, we extend our previous work [14] with a powerful template mechanism which allows dy- namic instantiation of formulas when the exact propositions are not known beforehand, e.g. because they are parameterised by ThreadIds or MVars.

