Closer to our work is the use of deductive methods based on the calculus of weakest preconditions. The tools caduceus/why [8] and caveat [16] are used in verification of critical applications written in c. They offer a good tradeoff between automation and confindence. However they do not produce a proof of correctness of the original program that could be checked by an independent cer- tified prover: caveat uses internal decision procedures and simplification rules and caduceus/why transforms the original program before generating verifica- tion conditions which entails the correctness. The generation of checkable proofs is addressed in the Proof-Carrying Code architecture (pcc [14]) and its foundational extension (fpcc [22]): the formal proof of an untrusted program is checked before

Our work has been inspired by studies on fpcc [1,9] but it differs on two impor- tant points that were dictated by criteria (i) and (vi) of convincing proofs: 1) we avoid the definition of an operational semantics for all constructions and operators of c; 2) optimized proof-checkers for compact proofs are very complex and will be difficult to certify. For this reason, this paper focuses on transparency of the proof- checker. The compactness of proofs is left for future work. As far as we know it is the first attempt to produce a checkable proof in foundational logic of a non trivial program (a protocol for event driven system) reasoning directly on non-transformed c code and reducing the tcb close to minimum: a compiler and a machine.

The rest of the paper describes our use of this framework to produce a convincing proof of correctness for a complex communication protocol written in c. First, the logical proof-system is enriched with derivation rules that define the semantics of the protocol. Second, the validation of these rules by the evaluators and their translation in prolog furnish a certified proof-checker. Finally, evaluators deliver

In this section we briefly present the protocol that will serve to illustrate our notion of convincing proofs. The protocol is used to implement multi-tasking real-time data-flow applications on an event-based operating system featuring priority and pre-emption [19]. It has been designed for an avionics control system that consists in a pool of tasks running on a single processor. Each task has an id i and is triggered by the environment on arrival of an event i. It then reads available inputs from other tasks, does some computation and outputs its results to all others tasks.

The development of the control system is conducted under the assumption that computations take no time, that is, the output of a task is available instantaneously after its triggering. This so-called synchronous or 0-delay assumption drastically simplifies the development since engineers need only focus on the data-flow be- tween tasks [5]. Therefore, the actual implementation must ensure that a task r (a reader) which uses the output of a task w (a writer) gets the correct output with respect to the data-flow ordering independently of the computation time of each task (see Section 2.2 and [19] for details).

In order to state the correctness property, following [19], we define three events that govern the run of a Task: i denotes a triggering of Task i that begins with the execution of os(i). Triggering events come from the environment through sensors. The others events i and i are produced by the operating system. i indicates

Large parts of the proof were conducted automatically with the help of a sym- bolic interpreter of c programs developed for this occasion. The interpreter inter- acts with the user for conditional instructions and records the derivation steps in a proof-term that is built during the guided execution. The resulting proof-term contains proof-obligations which must be completed afterward. The inductions and the proof of independency were done by hand with the help of lemmata.5

By using a prover such as pvs or b we would have benefited from simplifications and decision procedures for arithmetic but it is not possible to produce an indepen- dent proof-term using these provers. Therefore, we would have had to include the prover in the tcb. Actually we started with the coq proof-assistant which produces proof-terms but the overhead, the complexity of formalization and the numerous proof-obligations revealed that coq was not inappropriate for our purpose, even if it provides tactics to reduce the proof activity. Moreover, the coq proof-checker is not yet certified.

