The motivation for this work has originated from an effort to model scenarios of mobile device applications for the purpose of automatic test generation. We used the PowerToolKit (PTK) [1], a tool developed by the Motorola Labs which automatically generates test cases from MSC diagrams. Nevertheless, modelling some applications, which involved multi-synchronisation, with standard MSC has resulted in diagrams difficult to understand or with a behaviour different from the intended one. Despite this motivation, our approach is application independent.

There are several proposals of extensions to MSC. Different features have been added to the notation, like liveness [6], scenario triggering [17], object-orientation [4] and shared-variable communication [9]. Not surprisingly, synchronous messages have also been proposed in some works [3,6,12,13]. However, to the best of our knowledge, none have introduced multiple synchrony or have used CSP as a se- mantic model for MSC; as already mentioned, this has the advantage of immediate mechanised reasoning. More on related work can be found in Section 5.

This paper is organised as follows. Section 2 introduces the basics of the standard MSC, followed by the definition of our extension described in Section 3. Section 4 presents the semantics of MSC in CSP and, finally, conclusions, applications and future work are addressed in Section 5.

Synchronous communication provides a convenient model to specify interactive sys- tems in a higher level of abstraction in comparison to asynchronous communication. In particular, it abstracts away implementation details of handshake protocols, al- lowing the designer to focus on the communication at the application level. In this section we propose an extension to MSC that allows the user to specify synchronous communication, where two or more MSC instances can be synchronised on the same event. Moreover we propose an algorithm to convert from the extended MSC to the standard MSC.

ing several architectural views. In general these views are presented using different alphabets. Therefore it is necessary to provide a mapping between them [5]. Syn- chronous communication is observed by the environment as an atomic event. At this level of abstraction, we observe the system at specific relevant moments. However, any synchronous communication is implemented by some kind of handshake pro- tocol dealing with asynchronous communication. A designer of such system must

and, therefore, the end of a transaction. These concepts are partly inspired by the time abstraction concept used in hardware design [15]. The asynchronous messages present in the extended MSC are mapped to themselves. The following sections describe how this mapping can be formally defined to provide a solid justification for our transformation algorithm.

The interleaving operator ||| combines processes in parallel which are completely independent from each other. The process (P ||| Q ) behaves as both P and Q simul- taneously. The events are interleaved in time. The indexed notation for interleaving is defined as follows.

These two dimensions are then combined to form the formal semantics of an MSC diagram. The partial order of the events defined in a diagram naturally occurs in the CSP process once we compose the processes that represent the two dimensions in parallel. The parallel composition is defined according to the following rule.

corresponding MSC diagram. Intuitively, each process enforces the partial order rules (recall the instance order and the send-receive relation introduced in Sec- tion 2). The processes instancei ensure the correct order of events along the life axis of each instance. The processes messagej enforce that every send event comes before a receive event. In the standard MSC, there is no synchronisation among instances as they always communicate via asynchronous messages. Messages also do not interact among themselves. Thus we can group them together using interleav- ing. However, messages and instances do synchronise, which is captured by their parallel composition. For instance, the processes B and x synchronise on the event receivex .

Note that the synchronous messages Hello and How are you are represented as a single event in CSP. Nevertheless, the top-level process is constructed in a slightly different way. As the instances now synchronise among themselves, we have to use the parallel operator to group them.

We extended MSC with synchronous messages, which denote an atomic and instan- taneous single event in the MSC traces. Multiple instances are able to synchronise over the same message. Our extended MSC allows both synchronous and asyn- chronous messages to appear in a diagram. An example shows how a conference call dialogue is modelled with the extended MSC. Asynchronous messages are sent to all participants, followed by multiple synchronous messages once the conference call is established.

