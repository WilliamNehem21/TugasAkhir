Note that the problems with the classes B and C above arise even if there are no aliasing issues. What the examples show is that our analysis must somehow simultaneously keep track of the state of multiple objects (like this.x, b.x in B.M , and c.x in C.M ). This situation may look pretty grim, because there is no bound on the number of different objects and all of these

These assumptions were introduced in the Boogie methodology for object in- variants [1,13,3], which is used in the object-oriented Spec# programming language [2]. Note that the pack and unpack statements need not be pro- vided directly by the programmer; they could be implied by rules in the source language or by rules in some stylized use of the language (e.g., unpack on method entry and pack on method exit).

The technique for inferring object invariants that we propose in this paper performs two analyses that work together. One analysis, the local analysis, proceeds flow-sensitively and infers properties of the program at each program point, which is a standard thing to do in abstract interpretation. This anal- ysis more or less determines properties of local variables and heap locations reachable from the local variables. The other analysis, the global analysis, proceeds flow-insensitively and infers, for each class T , properties of all valid

In this section, we describe our technique to infer object invariants using the abstract interpretation-based framework discussed in the previous section. Recall that the framework is parameterized by various traditional abstract domains, which determine the kind of invariants that we infer about objects. To simplify the discussion, we consider a single such abstract domain, which we shall call the policy abstract domain. In other words, we describe a flexible mechanism by which object invariants can be inferred and defer to the user the choice of policy that determines the kind of invariants that are inferred (as well as, how precise the analysis is).

Let P denote the given policy domain. As alluded to earlier, we can transparently extend the policy domain to infer properties about heap struc- tures using the framework described in our previous work [6]. We denote the abstract domain given by this extension by C(P, S) where S indicates the presence of the abstract domain that handles the heap succession predicate for heap updates.

During the local analysis, we may need to instantiate an object invariant to obtain a certain property at a particular point. The object invariant methodol- ogy ensures that changes to fields are guarded by an unpack statement and thus indicates when the object invariant may be temporarily violated. We instantiate object invariants at unpack statements, as it marks the code sec- tion that weakens the object invariant. More precisely, an unpack statement proceeds as follows:

Inferring properties of object-oriented programs poses several challenges. One challenge is the fact that objects can be aliased, that is, distinct variables may refer to the same object. Various pointer analyses exist to address such prob- lems (see, for example, [20,9]). These pointer analyses can then be used as a

languages in the presence of aliasing and a context of other objects. In his recent PhD thesis, Lahiri [11] has considered inferring quantifications whose bodies are boolean combinations of predicates P (k), where k is the quantified variable and P comes from some fixed set of predicate symbols. His technique also performs a join operation to weaken the body of the quantifier by new facts inferred in a flow-sensitive manner.

