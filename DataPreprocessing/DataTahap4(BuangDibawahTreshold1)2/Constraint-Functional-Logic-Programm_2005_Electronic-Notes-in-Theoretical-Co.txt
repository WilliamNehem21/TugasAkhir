In this paper we propose a new generic scheme CFLP (D), intended as a logical and semantic frame- work for lazy Constraint Functional Logic Programming over a parametrically given constraint domain D. As in the case of the well known CLP (D) scheme for Constraint Logic Programming, D is assumed to provide domain specific data values and constraints. CFLP (D) programs are presented as sets of constrained rewrite rules that define the behaviour of possibly higher order and/or non-deterministic lazy functions over D. As the main novelty w.r.t. previous related work, we present a Constraint Rewriting Logic CRW L(D) which provides a declarative semantics for CFLP (D) programs. This logic relies on a new formalization of constraint domains and program interpretations, which allows a flexible combination of domain specific data values and user defined data constructors, as well as a functional view of constraints.

On the other hand, functional logic programming refers to a line of research started in the 1980s and aiming at the integration of the best features of functional programming and logic programming. As far as we know, the first attempt to combine functional and logic languages was done by J.A. Robinson and E.E. Sibert when proposing the language LOGLISP [78]. Some other early proposals for the design of functional + logic languages are described in [26]. A more recent survey of the operational principles and implementation techniques used for the integration of functions into logic programming can be

tation of function and predicate symbols. The resulting semantics had many pleasant properties, but also some limitations. In particular, defined functions had to be first order and deterministic, and the use of patterns in function definitions had to be simulated by means of special constraints.

In the last years, various extensions of CRWL have been devised, to ac- count for various features of functional logic languages, such as higher order functions [37], polymorphic types [38], algebraic data constructors [8,9,10], an ad-hoc treatment of certain kinds of constraints [6,7], and finite failure [60,61,62,63,64]. A survey of previous work on CRWL can be found in [79]. A generic extension of CRWL with constraint reasoning was missing up to now.

of constraint domains D, tailored to the needs of constraint functional logic programming. Section 3 presents CFLP (D) programs and their interpreta- tions, along with results concerning the existence of least program models. Section 4 introduces the constraint rewriting logic CRWL(D), presenting an inference system as well as correctness results w.r.t. the model-theoretic se-

specific primitive functions (e.g. addition and multiplication over R), and user defined functions. Assuming a unique universal signature rather than various domain-dependent signatures turns out to be convenient for technical reasons. Another important limitation of our older CFLP (D) scheme [56,57], name-

is common in higher order functional languages. The usual first order syntax for expressions can be translated to applicative syntax by means of so-called curried notation. For instance, f (X, g(Y )) becomes (f X (gY )). Following a usual convention, we assume that application associates to the left, and we

all the CLP (D) languages in an elegant and uniform way; see [49] for an updated presentation. Previous work on CFLP schemes, including our old scheme CFLP (D) [56,57] had similar aims w.r.t. functional logic program- ming, differing mainly in the kind of semantic framework provided.

Similarly as in Definition 2.1, the monotonicity conditions in item (ii) are intended to capture the behaviour of a possibly non-deterministic function over finite data elements. The radicality condition in Definition 2.1 is omitted here, because user defined functions which return potentially infinite data structures as results are useful for programming and obviously not radical.

