Functions form the building block of the approach presented here. Basically, functions are capsules of behavior, defined by their (external) interface in terms of data and control flow as well as their (internal) implementation. The data flow between the function and its environment is described in form of data signals exchanged between them, allowing the function to observe and control shared signals. The control flow between the function and its environment is described in form of control locations used to pass control between them, allowing the function to be activated and deactivated.

Intuitively, disjunctive composition corresponds to the alternative use of composed functions, while conjunctive composition corresponds to the simul- taneous use of the composed functions. Obviously, disjunctive composition is not sufficient to obtained the intended functionality, since position control and power control are supposed to restrict basic window movement. Similarly, simple conjunctive composition does not lead to a reasonable behavior, since basic movement, position control, and power control as defined above are in conflict to each other. Therefore, a more sophisticated form of combination is needed, describing the priorities between these (sub-)functions.

A component communicates with its environment via its interface. A compo- nent has a completely specified behavior: for each behavior of the environment (in form of a history of input messages received by the component) its reaction (in terms of histories of output messages) is defined. In approaches like [9], [4], or [12] this is defined as input enabledness, input permissiveness, or input completeness. As introduced in [12], in contrast to a component, a function behavior needs not be totally defined. For a partial specification, it is possible to have a behavior of the environment where no behavior of the function is defined by the specification.

Since functions are intended for the modular specification of components with input complete behavior, as semantical basis in the following we use a for- malization similar to [4] to introduce a set Fun of functional descriptions as well as its interpretation; however in contrast to the former, we generalize it to support the description of functions with their partially defined behavior, especially allowing the introduction of new partially by simultaneous combi- nation as defined in Subsection 3.2.4. In the following, Fun corresponds to

As introduced in the previous sections, functions are intended to support the modular construction of complex functionalities in the development process by combining individual pieces of reactive behavior. However, while the de- scriptive form of general functional descriptions eases the combination and reuse of functions and the reasoning about the overall functionality, for the final implementation of the intended behavior in general more constructive forms of descriptions are used, as provided, e.g., by corresponding tools like or [2], [3], or [6]. As stated in Section 1, these descriptions correspond to a restricted form of functions, avoiding the introduction of partiality and ensur- ing input enabledness. On this constructive level, input enabledness is either established implicitly by completion (as, e.g., in [6]) or explicitly by analysis (as, e.g., in [3]).

nition of Power Position Controlled Window is more suited for implementation using state-of-the-art tools. Thus, in a function-based development process, the former should be used in the early stages of defining the function under development, while the latter should be used in the latter stages. However, for a sound and integrated development process, it is furthermore necessary to establish an implementation relation between those functions.

Therefore, here WS1S (weak second order monadic structure with one suc- cessor function) is used to implement automatic proof support. This formalism is, e.g., supported by the modelchecker Mona [7]. Using WS1S, functions are specified by predicates over sets of traces. The operators introduced in Sec- tion 3 can be directly implemented, allowing a compositional construction of the corresponding trace sets. Similarly, the implementation relation can be defined as a relation on trace sets. Besides proving the refinement relation between two functions, Mona can be used to generate a counter-example for functions violating the refinement relation.

Therefore, we suggest functional modular development using functions as construction units, with transitions as the most basic form, as well as disjunc- tive and conjunctive composition to combine modules. Offering separation of concern by modular composition of functions, reasoning about the overall behavior is simplified by conjunctive and disjunctive construction of func- tionalities. Additionally, reuse of modular functionalities is simplified when constructing variants of reactive behavior. Finally, using automatic proof support, the implementation of the integrated modular behavior through a more-constructive form of functional description can be established.

