Web Services and Service-Oriented Architecture in general are promising concepts to overcome difficulties such as heterogeneity, scalability, etc. In this paper we present an algebraic structure of Web Services which assist users in Web Service composition and formal description of their services. Using relation algebra, tests and iteration offer the possibility of an automatic composition of Web Services based on a specified goal.

There are plenty of approaches to Web Service composition. A composition can be achieved agent-based (as in [17,5]), based on interaction protocols [25], symbolic transition systems [23] or based on some kind of logic [8]. Very often process algebras or Petri nets are used, too. The semantic web community has used planning tech- niques to address the problem of automated composition of semantic Web Services,

In this section we develop an algebraic characterisation of Web Services and present also an algebraic definition of Web Service composition. Obviously, a Web Service consists of an interface and the implementation. In the interface (described in WSDL) several Web Methods are defined. These receive input messages and reply with output messages which both can be of a simple type such as string, integer, etc. or of a complex type. For our first formalisation of Web Services we assume that both, the types of the input data and the output data are known before and therefore there is a knowledge set K: a set which includes the input and the output as subsets. Types which might be nested or semantically described are topics for further research and also the concrete binding and port information of Web Services are currently neglected for the sake of simplicity.

Note, that by definition r ; s is defined only if the output set of r has the same size as the input set of s. Unfortunately, this definition yields a strange behaviour in the setting of Web Services, which is illustrated by the following example. Afterwards we will present a possible solution for this deficit.

The problem is, that executing the second Web Method needs more information than the first one provides. Vice versa the second Web Method cannot be executed if the first one provides to many information, like etix in the above example. To bridge this gap, we define a Web Service as a collection of Web Methods which is based on a simple Web Service with additional information, which remains un- touched during execution of the Web Service and is just added to the output data.

In this definition E is the context and the extension of the simple Web Service W , which just takes any information that is not needed as input for execution and adds this information unchanged to the output. Obviously, each element of a Web Service is again a Web Method. Moreover, the definition implies the following result if  . is seen as a function:

the execution of the Web Services in this order yields a positive result (a hotel room and a flight is booked). Note that we use t and not the extended Web Service t , since we want to guarantee that an execution starts without any input. Usually, one has to use the extended one if a test occurs inside an execution (see above).

As we have seen, tests can be used to model assertions for Web Services. But they are also the basis for defining modal operators [3] which are used for modelling ter- mination and an abstract version of the wlp-operator [21]. The resulting formalism is similar to propositional dynamic logic but also strongly related to temporal logics. In this section we discuss these operators with respect to Web Services. In partic- ular we show how to determine necessary information which has to be specified by a customer when a certain goal is given, e.g. to receive an e-ticket in the end.

Of course this result is not a surprise since we constructed the Web Services in exactly that way, but since the modal operators can be applied to any Web Services they can be used to determine the necessary data. For this purpose it is useful to provide some basic laws for boxes and diamonds. All the presented laws as well as many more can be found in [4].

We do not want to discuss this operation and structure (which is known as Kleene algebra) and its connection to Web Services. Instead we will present some longer examples in the next section. More details concerning the reflexive, transitive closure within relations can be found e.g. in [24], about Kleene algebra in [1,15].

We have implemented relations, Web Service composition, tests and modal opera- tors in Haskell. With this implementation we have build up a small case study to show that using the presented theory is useful to determine information about Web Services. The Haskell code, the encodings of our examples and the result sets can be found at the web site of [12].

include a, d, dep and des and (not surprisingly) all recombinations of cc, ff and smt. Since we know that two iterations of flight yield two tickets, the star in the above expression could be replaced by flight2. Nevertheless, since normal users do not have such knowledge we modelled the desired behaviour with an arbitrary finite iteration.

In this paper we presented a first step towards an algebra of Web Services and showed how to make advantage of the resulting algebraic structures. In particular, Web Services can be embedded into the well-known structure of relations which by adding operations for composition and choice form an i-semiring. Henceforth we considered Web Services from a syntactical point of view and started to see them as tuples of input and output data.

This embedding led to a definition of Web Service composition on an algebraic level. After that we were able to add restrictions to Web Services, e.g., to select those Web Services satisfying a specific condition. Furthermore we used modal operators to determine necessary information which guarantee to reach certain goals. Throughout the paper we tried to illustrate the developed theory by an on-going example, which was expanded to a simple case study.

Using a relational approach works fine for calculating inputs and/or outputs. But, so far, we have not mentioned in detail how to determine any execution order for Web Services. Nevertheless, since we have lifted Web Services to an abstract al- gebraic level, a replacement of the relational model by any other model which is also based on i-semirings is possible without recalculating properties again. This is an- other advantage of our approach. In [12] we introduce the algebra of traces, another (well-known) i-semiring, which is useful for Web Service composition. Informally, traces simply save information about the execution order of Web Services.

One of the great advantages of our approach is certainly the simplicity and the well-known theory. For example, using relations allows us to apply all the well- known and efficient algorithm for determining certain relations like the reflexive and transitive closure (e.g. [24]). Such applications will be part of our further work. Overall, this paper is only a very first step towards a full algebraic characteri- sation. Nevertheless it shows the basics and provides the ground for on-going and

