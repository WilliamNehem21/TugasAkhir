The discussion of prover interfaces in the past has focused primarily on the function- ality available to the user. A convenient management of proof scripts [11,8,1,3] is the current basis for using interactive provers like Isabelle and Coq. In this setting, the prover may support the user in writing the proof scripts [5], or check proof docu- ments that are close to mathematical texts [16]. Proof-by-pointing [10,9,31], graph- ical proving metaphors [27], or prover-specific interaction models [23] promise im- proved user experience. Cooperative proof development is enabled by web-interfaces for provers [26]. Integrated verification environments offer prover interfaces for a special application [24,13,15].

Despite presenting medium to large software systems, the cited studies surpris- ingly have neglected the engineering considerations necessary to build these systems. Instead, they focus on the broad software structure: brokers are used to decouple interface components from prover components [4,32]. The construction of web- interfaces focuses on technical aspects of client/server communication [26]. The proof-by-pointing interfaces exhibit the interaction between prover and interface, but not the implementation of the UI [10,27]. The generic interface [24] describes a

This paper addresses the identified question by applying standard approaches for the construction of user interfaces to the particular domain of theorem provers. We base the discussion of engineering considerations on desirable non-functional properties of a prover interface software [6] (Section 2). The concrete example of I3P, the Interactive Interface for the Isabelle Prover ([21]; Section 3), is then used to demonstrate the realization of the engineering goals (Section 4). Throughout, we emphasize the relevance of the general principles for theorem prover interfaces. The discussion of related work (Section 5) then applies our reasoning to existing systems.

It is important to note that these properties are not goals in themselves, which are prescribed by some abstract software design regime. The real goals have been given by identifying their relevance for prover interfaces. The non-functional properties serve as stepping stones in achieving these goals, since the software engineering literature provides techniques to achieve the properties, while not giving any rec- ommendations for prover interfaces. The transfer of the general principles to the specific application is a main point of this paper.

The theory editor component lets the user edit the text of proof documents. It offers an input facility for mathematical symbols that emulates the Emacs XSym- bols mode. Files are saved as usual with encoded XSymbol names. Automatic indentation follows the nesting level of proofs. The theory editor provides syntax highlighting and also handles dynamic definitions of new Isar keywords. The syn- tax highlighting and automatic indentation also recognize embedded LATEX and ML

The result viewer lets the user examine the prover messages stored in the state of single commands (Section 4.5). The display is split into normal output, errors and warnings, and trace messages. Since messages for previously processed commands are kept, the user can go back in the proof script.

This section presents the architecture of I3P, which has been developed to achieve the desirable non-functional properties identified in Section 2. In this way, it ex- plains how engineering considerations have led to the overall system presented in Section 3. Each of the subsections describes a particular design decision or com- ponent, and then proceeds to discuss the resulting non-functional properties. For the property of traceability, we remark in advance that the components, type-set in italics, correspond to concrete classes of the implementation. Further structure is omitted for brevity here, but is provided in the JavaDoc comments of the available source code.

The prover communication layer encapsulates the access to the prover process. A prover driver enables the prover manager to start a process for a specific instal- lation and set of options. The driver also lets the installation manager examine an installation, for instance to list the available logics. When a prover is started, the prover instance hides the inter-process communication, in particular the physical protocol in use.

Testability has enabled us to write around 350 unit tests for different parts of I3P. With a large test coverage, the implication of testability is changeability (Section 2): we can be confident about making changes because any introduced failures will be spotted early, the next time that the automated tests are run. In particular, re-factoring the software [17] tends to clarify the overall structure and enhances, in turn, traceability and maintainability.

I3P employs the concepts developed for object-oriented frameworks [25] and the Interceptor pattern [29], which can be seen as a concise summary of the main points of frameworks, to enable extensibility. In these approaches, a framework is a platform that provides mechanisms that are common for a family of software products. The specific applications are created as extensions to this platform. The interface between the framework and its extensions is defined in an event-based way: the framework specifies some abstract state, such as the file resources or proof documents in Section 4.1. It also defines events as changes in that state, and notifies interested extensions about them.

to a structure maintainer associated with each proof document. The maintainer is responsible for updating the command partitioning. Since it can only split and join commands, the commands always form a partitioning. To decide about changes, the structure maintainer can access the entire proof document, for example to handle comments in a single run or to examine adjacent commands.

This particular instance of event-based design yields, of course, the general ben- efits discussed in Section 4.3. Furthermore, the notifications sent by proof docu- ments have proven sufficient to implement the connections to all other components, including the entire UI layer and the prover (Section 4.6). Further, having these events available enables extensibility by UI components that display the state of commands.

A central design consideration is the expected interaction between the prover and the interface, and the relative distribution of functionality between them. One possible view is that the prover can basically execute and undo commands [2,24], and one can parameterize the interface accordingly. Going one step further, one can explore how much useful functionality can be achieved by the interface without support from the prover [19]. These approaches, by intention, do not target further capabilities of the prover.

I3P is also extensible by new drivers, since the prover manager retrieves in- stalled drivers from the Drivers directory of the system file system (Section 4.4). Similarly, the installation manager (Section 3) looks for installation types in the Installations directory. Both drivers and installation types can therefore be sup- plied by modules developed independently of the I3P core.

The PGKit framework [4] proposes an XML-based communication protocol for provers and display components. A broker component mediates the communication between provers and interfaces, manages the open proof documents, and synchro- nizes the user edits and the prover execution. This architecture aims at re-usability, as Proof General does, but also addresses extensibility by new display components.

However, the protocol does not contain mechanisms for accessing prover-specific functionality. Furthermore, display components in PGKit are heavy-weight in that they need to implement the PGPIP protocol, while I3P UI extensions can directly access the objects in the infrastructure layer. In principle, the defined protocol should enable testability of single components, and the properties and benefits en- tailed by it, but this is not discussed in the published work.

Charles and Kiniry [24] address re-usability by providing a minimal interface which can be adapted to different provers by prover-plugins. Their interface/prover communication is limited to traditional undo/redo of commands and in broad terms follows the adaptation model of Proof General/Emacs [2]. There are no mecha- nisms to expose prover-specific functionality in the interface. The architecture of the Eclipse-based interface itself is not discussed, thus neglecting traceability; if a document-view separation is followed in the implementation, the corresponding benefits could be claimed for the software. While the definition of clear interfaces for prover plugins enables their independent testability, testing is not discussed.

Kaliszyk [26] proposes to access provers through web-services. While the tech- nical foundations of the employed AJAX and DOM APIs are discussed in detail, it remains unclear whether the concrete protocol is private or fixed and public. In the latter case, testability of the server components would be enabled. Further- more, the benefits of the document-view separation, which is implicit in employing web-services, could also be realized in this system.

In summary, the goals for prover interfaces identified in Section 2 have been discussed, though mostly implicitly, in various previous studies. However, the ways to achieve them have always been derived from the specific application, rather than from desirable quality attributes and general software engineering principles, and the potential further benefits of applying these principles have therefore been neglected. As a relative contribution, this paper thus shows how the general principles and strategies from software engineering can be applied to prover interfaces in order to realize these benefits.

