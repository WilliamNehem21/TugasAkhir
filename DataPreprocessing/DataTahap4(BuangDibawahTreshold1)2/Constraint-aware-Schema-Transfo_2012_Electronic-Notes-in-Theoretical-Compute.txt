Data schema transformations occur in the context of software evolution, refactoring, and cross-paradigm data mappings. When constraints exist on the initial schema, these need to be transformed into constraints on the target schema. Moreover, when high-level data types are refined to lower level structures, additional target schema constraints must be introduced to balance the loss of structure and preserve semantics.

We introduce an algebraic approach to schema transformation that is constraint-aware in the sense that constraints are preserved from source to target schemas and that new constraints are introduced where needed. Our approach is based on refinement theory and point-free program transformation. Data refine- ments are modeled as rewrite rules on types that carry point-free predicates as constraints. At each rewrite step, the predicate on the reduct is computed from the predicate on the redex. An additional rewrite system on point-free functions is used to normalize the predicates that are built up along rewrite chains.

must conform, but they also dictate the well-formedness of data queries and up- date functions. Generally, schema definitions consist of a structural description augmented with constraints that capture additional semantic restrictions, e.g. SQL and XSD schemas may declare referential integrity constraints, grammars include operator precedences, VDM specifications contain datatype invariants.

Data schema transformations occur in a variety of contexts. For example, soft- ware maintenance commonly involves enhancement of the data formats employed for storing or exporting application data. Likewise, evolution of programming lan- guages brings along modification of their grammars between versions. More com- plex schema transformations are involved in data mappings between programming paradigms [14], such as between XML and SQL.

In previous work, we and others have addressed the problem of transform- ing schemas together with the data instances and queries that are coupled with them. We have shown that data refinement theory can be employed to formalize schema transformation [1] as well as the transformation of the corresponding data instances [9]. In combination with point-free program transformation, this formal- ization extends to migration of data processors [11] including structure-shy queries and update functions [12]. We have harnessed this theoretical treatment in various type-safe rewrite systems and applied these to VDM-SL specifications [1], XML schemas and queries [11,5], and SQL databases [1,5].

The paper is structured as follows. We introduce the problem of constraint-aware schema transformation with a motivating example in Section 2. We provide back- ground about refinement theory and point-free program calculation in Section 3. Theoretical support about constraints representation and rewriting is provided in Section 4. In Section 5, we explain how this theory can be made operational in the form of strongly-typed rewriting systems implemented in the functional pro- gramming language Haskell. We return to the motivating example in Section 6 to demonstrate the application of our rewriting system to schema-aware hierarchical- relational mapping. We discuss related work in Section 7 and conclude in Section 8.

In XML Schema, such uniqueness and referential integrity constraints are defined by so-called identity constraints, using the key, keyref, and unique elements. More constraints could exist, such as that value is always non-zero, or that the name of an episode is different from the title of the corresponding series. Such constraints could be expressed by general queries, e.g. using XPath.

In this section, we will explain how schema transformation can be formalized by data refinement theory and point-free program transformation. We start in Section 3.1 by providing background on data refinement theory and its application to two-level transformation. In Section 3.2, we recapitulate point-free program transformation and show how it can be combined with data refinement to model query migration driven by schema transformation.

Point-free program transformation can be used after schema transformation to simplify the calculated conversion functions and to migrate queries from source to target type or vice-versa [11]. In Section 5.4 we will use point-free program transformation to migrate and simplify constraints during schema transformation.

In this section we provide theoretical support about constraints representation and rewriting. The formalization of constraints is presented in Section 4.1. Section 4.2 discusses how constraints can be added to data refinement laws to formalize the propagation and introduction of constraints during schema transformation.

In this section, we show how the enhanced data refinement theory of the previous section can be captured in a rewriting system, implemented as a strategic functional program in the functional language Haskell. In Section 5.1 we recall how type- safe representations of types and functions can be constructed using generalized algebraic datatypes (GADTs). In Section 5.2 we extend the type representation to constrained types. In Section 5.3 and 5.4, we explain how rewrite systems can be constructed to transform such constrained types.

The View constructor expresses that a type a can be refined toa type b if a pair of conversion functions between them exist. Note that only the source type a escapes from the type constructor of View . The Rule type expresses that, when rewrit- ing a type representation we do not replace it but augment it with representation functions to translate between the source and the target types.

The primary key constraints of the original schema are captured structurally, by the employment of finite maps. The foreign key constraint is captured by imdb inv , which specifies that the values in the domain of played are contained in the domain of show , i.e. the year and title (defined in the domain) of played are references to the year and title defined in (the domain of) show . This constraint is expected to be propagated through the schema transformation process.

A notion of XML Functional Dependency (XFD) was introduced by Chen et al [8], based on path expressions. Mapping algorithms are provided that propagate XFDs to the target relational schema and exploit XFDs to arrive at a schema with less redundancy. Davidson et al [13] present an alternative constraint-preserving ap- proach, also using path expressions. In contrast, our constraints are not restricted to relational integrity constraints. We have expressed constraints as point-free func- tions, which can be converted automatically to and from structure-shy programs including path expressions [12].

Barbosa et al [4] discuss generation of constraints on relational schemas that make XML-relational mappings information preserving, i.e. isomorphic. Non- structural constraints on the initial XML schema are not taken into account. Con- straints and conversion functions are expressed in (variations on) Datalog, which can be (manually) rewritten to normal form in a mechanical way.

Berdaguer et al. [5] employ a type annotation mechanism to capture constraints. As a result, a smaller class of possible constraints is covered. Nevertheless, the anno- tation mechanism allows for a compositional treatment of constraint-aware schema transformation. Rather than path expressions or labels, our approach employs strongly-typed boolean functions to capture constraints. This has the advantage of being more expressive, and allowing a fully compositional treatment. Also note that our approach is not limited to hierarchical-relational mappings, as it can be used for schema transformation in general.

