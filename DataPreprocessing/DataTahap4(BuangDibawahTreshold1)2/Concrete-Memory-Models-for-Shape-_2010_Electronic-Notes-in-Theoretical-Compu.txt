The purpose of shape analysis is to infer properties on the runtime structure of the memory heap. Shape analysis goes beyond alias and null-pointer analyses, in term of expressivity and precision. The applications of shape analyses include optimizing compilation, absence of runtime errors (dereference of dangling or null pointers), proof of programs, automatic parallelisation, . . .

C, C++, and to a lesser extent ADA, in which pointers can also point inside an object, and where more operations are allowed, such as taking the address of a record field, either explicitly (C, C++) or implicitly (reference parameter passing in C++, ADA), pointer arithmetics, . . .

Motivations. Analyses, like TVLA, were developed for Java-like languages. Oth- ers, such as the separation-logic-based Xisa, target a subset of C. The memory models for shape analyses are often only described at the abstract level. A clear view of the concrete memory model is needed to understand the scope of these analyses and be able to reuse them in different context.

More generally, all the semantics we presented assume a static typing of ex- pressions. Casts introduce a dynamic typing and are not handled by any of them. To handle casts, additional assumptions on the internal representation of types are needed (this could be provided by the ABI), and the memory model needs to keep the value of each byte, like in [7].

We classified the concrete store-based memory models using two criteria: the way they store pointers and the way they represent offsets. For each of the four memory models, we gave a compact semantics of a fragment of Clight, which includes arrays and pointer arithmetics. For this language, the usual semantics can be expressed with our standard memory model (Sect. 3). The object memory model, commonly considered in shape analyses, leads to strong semantic restrictions, that we overcome by instrumentation (Sects. 4 and 5).

