With advances in network technology, software systems are shifting from a closed, centralized architecture to being open and distributed; from being homogeneous in implementation to adopting heterogeneous components for constructing the whole system. To harness the omnipresent components in a distributed system while having to address the inherent complexity of such a paradigm, the functional and non-functional properties of components must be formally captured, and there needs a means to assure the specified QoS (Quality of Service) 9 for the system assembled from components. UniFrame is a framework to address those concerns [26]. It uses a Unified Meta-component Model (UMM) [25] to encode the meta-information of a component such as functional properties, implementation technologies, and cooperative at- tributes.

<aspectname> corresponds to an assembly-related aspect, which already pro- vides a means to specify assembly rules as described in the preceding para- graph. The <type> has to be consistent with the applicable <metatype> in the ADL of <aspectname>. By consistent we mean the <metatype> as in the ADL of <aspectname> should reside at the root position of some meta-type hierarchy (see Section 3.1 for definition), where <type> is part of the hierar- chy. The when directive in AUL further specifies the scenarios using relational expressions, under which this aspect can be applied; in addition to the base- program oriented weaving such as in AspectJ [18], the advice quantification

connector specification based on meta-type consistency, and to apply the as- sociated advice thereafter. The connector specification is translated from the CDLs of the server component (service provider) and the aspectual component specification is translated from the client component (service consumer). Af- ter the full assembly specification is generated, by referencing the component repository (which stores the set of component UMM specifications retrieved by the discovery service in UniFrame), glue/wrapper code will be generated in the final step.

Note that lines D.2-D.5 further implement the advice part for the join points (here, Withdraw and Deposit operations). The body of wrap is to wrap the BankOperation with RMI specific code. This is similar to [24], in which CORBA related operations are modularized as aspects and then woven into application code to derive a CORBA implementation. The difference here is that, those RMI or CORBA related aspects are pre-built and retrieved from the aspect library, and they are represented with high-level specifications (in ADL) rather than at the application code level. Upon weaving in Stage 4, the wrap routine in the connector specification will be weaved into the aspectual component specification.

This paper presents an approach to apply aspect orientation in the gen- erative domain modeling phase and then leverage the aspect weaver to help component assembly, in particular, for assembling components of client/server architecture. Two repositories (aspect library, connector repository) are used, which aligns with the distributed component assembly style. A type-based join point model is used which can efficiently decouple the aspect definition and aspect usage to promote the reuse of aspects. Compared with the inva- sive composition approach as described in [1], we weave the assembly-related concerns toward ultimately generating stub/skeleton code for gluing/wrapping components, while the original components (which represent the business logic core), together with their references to stub/skeleton code, will not be affected. This is necessary for black-box components which do not allow invasive meth- ods.

