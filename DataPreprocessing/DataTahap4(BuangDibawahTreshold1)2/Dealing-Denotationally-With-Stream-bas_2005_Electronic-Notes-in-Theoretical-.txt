We define a denotational semantics for a kernel-calculus of the parallel functional language Eden. We choose continuations to deal with side-effects (process creation and communication) in a lazy context. The calculus includes streams for communication, and their modelization by a denotational semantics is not direct because a stream may be infinite.

Thanks to the stream-based communication in Eden, processes can be defined whose behaviour is similar to introducing continuously characters with a keyboard. However, the modelization of streams by a denotational semantics is not direct because a stream may be infinite and the denotational value for such a stream could not be computed. In the model of continuations the semantic value for an expression is a function that is well defined although its computational effect may be infinite.

argument for the parallel application is a list, the corresponding input com- munication channel is a stream. The same rule applies for the output. The evaluation of a stream is not completely lazy: the constructor and the head must be obtained. In this way, the evaluation is element-wise.

A continuation is a function which contains the details of the remainder of the program, that is, if an expression is inside a context, the information about this context is gathered in the continuation. In order to execute all the tasks derived from the context, a continuation is a state transformer, i.e. the function is applied to a state that is transformed according to the context information contained in the continuation. We can distinguish two kinds of continuations:

A closure is only meaningful once the corresponding process identifier has been provided. Nevertheless, it is still necessary to establish its context; for this purpose the closure has to receive an expression continuation. In this way, the closure becomes a state transformer.

In the case of a maximal semantics, after evaluating the application, if the channel is a stream, i.e. the identifier is bound to a list, then it must be evaluated completely. Again, the function forceFV is invoked, and using the expression continuation kstr x (see Section 3.3.2), each component of the stream is forced, including the free dependencies as well.

their channels are not demanded. In the case of a maximal semantics, every local variable which was bound originally to a parallel application is forced; and this causes the creation of new processes and channels. The function mforce (multiple forcing ) forces a set of identifiers; therefore, its definition, not detailed here, invokes repeatedly the function force (see Section 3.3.1). The function card calculates the cardinal of a set.

If the obtained value is an abstraction: its free dependencies are also demanded, and thus evaluated recursively. If it is the case of a commu- nication variable then the abstraction is communicated and the channel is closed. Finally, the expression continuation is applied to the value that has been obtained.

Our denotational model also allows to extract the degree of parallelism and the amount of speculative computation. In the final state, the nodes of the graph corresponding to the set of channels are the processes which have been created in the system during the evaluation of the main expression. Other degrees of parallelism can be obtained by modifying the expression continuation for #-expressions and local declarations; these degrees would be greater than the minimal one and smaller than the maximal one. One might, for instance, demand the evaluation of the output but not of the input of a process, or to evaluate only some subset of the parallel applications in a local declaration depending on the number of available processors. In order to get information of the speculative computation, we must analyze the edges of the system: if the edge from a child to its parent is labelled with <> then the child (together with all its descendants) is a speculative process because its output has not been used for the main result.

