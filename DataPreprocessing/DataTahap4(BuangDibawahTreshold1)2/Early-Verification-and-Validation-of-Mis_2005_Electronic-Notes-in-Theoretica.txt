To produce highly reliable systems it is recommended to use formal meth- ods. They refer to mathematically based languages, techniques and tools for specifying and verifying such systems. Even though there are some success sto- ries, formal methods have not yet gained wide industrial adoption - the main obstacles being the significant investment from learning a difficult technol- ogy and often a psychological resistance to mathematics. To overcome those problems, alternative approaches are now being explored such as lightweight formal methods [4] and invisible formal methods [17]. The former is a tar- geted application limited in scope and analysis to reach relevant conclusions at a minimal cost. The latter aims at providing sufficiently convenient, powerful, and useful technologies for practitioners to adopt them willingly.

The rest of this paper is structured as follows. Section 2 gives some back- ground information on KAOS and its formal semantics. Section 3 gives an overview of the functionalities supported by the toolbox. Section 4 and 5 respectively detail two mature tools: the early analyzer (mainly about verifi- cation) and the animator (mainly about validation).

Goals refer to objects which may be incrementally derived from goal spec- ifications to produce a structural model of the system (similar to UML class diagrams). Objects have states defined by the values of their attributes and associations to other objects. They are passive (entities, associations, events) or active (agents). Agents are related together via their interface made of ob- ject attributes and associations they monitor and control, respectively [9]. In the above formalization of the goal DoorsClosedWhileMoving, M oving and doorsState are attributes of the Train entity declared in the object model.

The correctness of all refinements in a goal model does not ensure that the specification is consistent: inconsistencies can occur between goals. A con- flict is a logical inconsistency between those goals. A divergence is a logical inconsistency under some (feasible) boundary condition. As opposed to goal refinement, checking inconsistencies is not a process local to a goal.

the early analyzer checks the correctness about the goal-model. In case of error, it will produce a counter-example trace which can be replayed in the animator tool. It can also be used for validation purposes in order to produce constrained animation traces.

In the incremental process of building four complementary models in parallel, errors will often occur in the formalization of the informal statements made by the stakeholders. The main purpose of the analyzer is to verify their formal consistency at an early stage of the process. Another use of the tool is to produce possible system histories for validation purposes.

whose responsibility should of course be examined. Another way is to enforce the postconditions rather that the preconditions. In fact the latter approach is documented as a well-known operationalization pattern [10] and if the analyst had looked in that library in the first place, the mistake would not have occurred. In both cases, the formal analyzer stops returning counter-examples.

The tools used are the BDD-based engine and the SAT-based engines of NuSMV [1] and the CLP engine of Oz [16]. Experiments with Alloy [7] show that it is better to use tools that provide high level input formalisms which optimize their mapping into SAT, BDD,... It is planned to use Alloy, some automatic theorem provers, and well-known theorem provers such as SteP or PVS (mainly to use their powerful decision procedures).

The different mappings replace infinite domains with finite ones (eg. Al- loy), and replace the infinite time structure with a bounded one (eg. bounded model checking). The analyst must interpret the results obtained with cau- tion. For instance, no bounded trace can be found if a counter constrained to augment indefinitely is modeled. The analyst will often foresee this because the analyzed formulas are small.

SceneBeans framework used here provides a good level of abstraction and is described in a simple XML format. It allows the designer to produce a new view and to interface it with the simulation engine in a few minutes for simple scenes (such as the train doors) to a few hours for more complex one (such as the global track view). A mapping tool helps in this process of connecting the view to the underlying model.

In the future, the early analyzer will be extended to support checks address- ing obstacles and conflicts. The Animator Mapping is also being improved and a new component for designing control panels (such as train/plane/automative cockpits) is being implemented. Other tools such as the the acceptance tests generator and the obstacle generator are in the implementation phase or being planned.

