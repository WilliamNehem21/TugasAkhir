An important application of graph grammars and graph parsing techniques is the de nition of visual languages (VLs) and the creation of VL editors [2]. The use of a parser for the analysis of diagrams allows to treat the graphical interface as a kind of extended drawing program; thus the same front-end can be used across a broad spectrum of di erent VLs with very little adaption; only the set of allowed VL symbols (boxes, arrows, etc.) must be speci ed. The diagrams are then created by drawing these symbols using \direct ma- nipulation"; the resulting drawings are analyzed by a VL parser to check the correctness of the diagram and create an abstract representation for further processing.

The main advantage of including a parser in a VL editor is that it avoids the necessity for specifying a complete set of structure-based editing operations so that the language-speci c part of the editor is kept as small as possible. This makes it possible to use an \editor generator" in combination with a class library to create editors for complex VLs from relatively short and concise syntax descriptions. DiaGen is such an editor-generator framework, which combines the parsing approach for VL editors with the transformation-oriented approach, because it also allows complex structure-based transformations on the edited diagrams (described as graph transformations on the internal graph model of the diagram [7]).

DiaGen represents diagrams internally as a labeled hypergraph consisting of \component" and \relation" (hyper) edges. A component edge corresponds to a visual symbol in the actual diagram. Every symbol has a number of \con- nector regions" where it can interact with other components. Those connector regions are mapped into hypergraph nodes which the respective component hyperedge attachs to. Finally, the syntax description can de ne arbitrary ge- ometric relations between the connector regions (most often containment and intersection) which are mapped into binary relation edges that connect the corresponding nodes.

In the simple case of the example, the ASG is almost identical to the rHGM. In general, the rHGM may also contain additional edges that cannot be parsed correctly or groups of edges that are combined into a single ASG entity. Also, for some UML elements there exist multiple alternative visualizations that lead to di erent rHGM structures, but all of them are derived from the same nonterminal type.

There are several other approaches for generating visual language editors from a formal speci cation. The ones which are based on an abstract graph model (e. g. GenGEd [1], Kogge [4]) automatically come with \built-in" abstract representations. Other tools which avoid abstract internal models (e. g. Pen- guins based on Constraint Multiset Grammars [3]) lack this immediate avail- ability of abstract models; they rather have to explicitely create external dia- gram representations by attribute evaluation.

