In this paper, we describe how to use Euler Diagrams to represent virtual directories. i.e. collection of files that are computed on demand and satisfy a number of constraints. We, then, briefly describe the state of VennFS project that is currently modified to include this new capability. In particular, we show a data structure designed to answer queries about a given Euler Diagram and its sets. The data structure EulerTree described here is based on the R-Tree (see [29]), a data structure designed for answering range queries over a family of shapes in the 2-dimensional space.

Easiness of comprehension: a hierarchy is easy to explain and easy to understand. In particular in a traditional office scenario the HFS can be put in direct relation with real world things. This is the reason for all the names used even today.

Presto. In the system proposed in [14] each resource has attached to it a variable number of user defined attributes. Once again a virtual directory is created on demand by user queries. Presto uses a data base to keep infor- mation about files managed. Presto system enables user to define whatever attribute name for files, giving great flexibility to the kind of classification.

Instead of a HFS to organize information, WinFS uses a direct acyclic graph of items (DAG). It isa set of stored items and their relationships whose physical storage is a relational database providing support to store any item hierarchy. In the intents of the developers, with this novel storage method WinFS will offer search capacities never dreamed of before in file systems. It is possible to find items according to the value of their properties and even to

Ximian Evolution [1] has vFolders. A Ximian Evolution vFolder looks like a folder but has no messages physically attached to it. Instead, a vFolder is defined by a set of criteria, like a message search. The does not have to manually enter the search criteria every time: a vFolder always contains the latest messages in all physical mail folders that match its criteria.

The application that we present here is a tool that can help the user during daily activities. Our work follows the research line that started by developing VennFS [11] that allowed users to place documents and categories on a plane where files may belong to multiple categories at once, by using well-known and intuitive Euler diagrams to represent graphically each category. We placed particular care in designing an interface that, though fully visual, asks only few and quick interactions by the user.

Creating Classifications: this task is accomplished using the intuitiveness of Euler diagrams drawn by hand by users. Sets can be subjects, topics, directories, etc. . . and all the various aspect our life can be related to, and this concept is so easy to be understood that it needs no explanation even to novice users.

The R-Tree (originally introduced by [20]) is designed to answer range queries (window queries): given a collection of objects in Rd, a range query reports all objects that intersect a d-dimensional axis-aligned query window, that is, a d-dimensional box. We will refer to the bidimensional space so d will be 2 and the objects will be isothetic rectangles. An R-Tree is a particular B-tree in which every leaf keeps an input box. Further details can be found in [29].

This data structure represents planar subdivisions, and consists of a set of vertices, a set of half-edges and a set of faces, all connected according to their adjacency in the planar subdivision. A half-edge is a directed edge representing one side of a line segment. Thus, a line segment is represented by two half-edges of opposite directions.

The doubly-connected edge list representing our rectangle subdivision has one unbounded face being part of none of the Set Nodes. This face needs not be a rectangle in itself. All other faces must be rectangle shaped and they represent the subrectangles that in turn constitute the intersection of the Set Nodes. Hence, each such face has a list of pointers keeping track of what Set Nodes it belongs to.

When we insert a new rectangle, the set of subrectangles needs to remain disjoint after the operation. Hence, it is necessary to split the intersected rectangles and the query rectangle into new subrectangles. This is done using the sweepline technique. The input of the splitting algorithm is two subdivi- sions representing the query rectangle and the set of rectangles intersecting it, respectively. The output is the new set of disjoint subrectangles.

The algorithm works in two phases. In the first phase we compute the overlay of the two subdivisions. The overlay of two subdivisions S1 and S2 is defined as the planar subdivision induced by the edges from S1 and S2. Each face in the overlay keeps pointers to the faces in S1 and S2 that contain it. Hence, after computing the overlay it is a simple task to update the Set Node pointer list of each face in the overlay.

The overlay is computed using the MapOverlay algorithm in Chapter 2.3 of [21]. The time complexity of this algorithm is O(k log k + k' log k), where k is the number of rectangles intersecting the query rectangle and k' is the number of faces in the overlay.

The overlay contains faces which are not rectangles. These must be parti- tioned further. We use a simple sweepline algorithm to find such a partition. It works as follows: the sweepline goes from left to right. At all times we impose that no vertical half-line to the left of the sweepline bounds a bounded face and has a reflex vertex as either origin or destination. If no bounded

face contains reflex vertices they are all convex which in our case implies that they are rectangular. If we find a reflex vertex, we add a vertical edge, i.e., a twin of half-edges, to the edge list making the vertex non-reflex. All updates comprise a subset of those done in the MapOverlay algorithm.

We note that adding a vertical edge splits a face in two parts. However, the face attribute remains the same, since the new rectangles belong to the same Set Nodes. The time complexity of the second phase is O(k' log k').

Another step we intend to perform is to use Euler diagrams to organize information in other contexts like bookmarks and emails, for instance. Man- aging emails and bookmarks would be different from manging generic files since, for instance, there exist easy ways of comparing two emails (e.g. words in the subject, recipient address etc. . . ), and these comparison methods could be used to automatically place elements in sets.

Johns, C. and E. Blake, Cognitive maps in virtual environments: Facilitation of learning through the use of innate spatial abilities, in: Proc. of 1st International Conf. on Computer Graphics, Virtual Reality and Visualisation in Africa, Cape Town, South Africa. 2001, 2001.

