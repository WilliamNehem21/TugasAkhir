As shown in [29,31], like separation logic, matching logic can also be used as a program logic in the context of conventional axiomatic semantics, allowing us to more easily specify structural properties about the program state. However, this way of using matching logic comes with a big disadvantage, shared with Hoare logics in general: the formal semantics of the target language needs to be redefined axiomatically and the tedious soundness proofs need to be done. Here, we take the different approach in [28,27,26], which allows us to use the operational semantics of the language for program verification as well, as shown next.

In this section we discuss how to use K in the context of program verification: Section 4.1 briefly presents the programming language we use for illustration, Sec- tion 4.2 describes how to use K for symbolic execution, Section 4.3 shows how to use K in checking matching logic formulae implication, and Section 4.4 presents abstraction patterns.

pattern can be rewritten with rules from both S and C, the verifier only uses the rules from C. In particular, only a loop without a specification is unrolled, and only a function without a specification is called. Also, if the current pattern implies that the application of an abstraction axiom would result into a more concrete pattern, the tool applies the respective axiom (for instance, knowing the head of a linked list is not null results in an automatic list unrolling).

tree data structures. For each function, the tool checks that it maintains the data structure invariant and that the multiset of elements is as expected. We mention that the AVL insert and delete programs take approximately 3 minutes together because some of the auxiliary functions (like balance) are not given specifications and thus their bodies are being executed, resulting in a larger number of paths to analyze.

9. Schorr-Waite: The Schorr-Waite graph marking algorithm [34] computes all the nodes in a graph that are reachable from a set of starting nodes. To achieve that, it visits the graph nodes in depth-first search order, by reversing pointers on the way down, and then restoring them on the way up. Its main application is in garbage collection. The Schorr-Waite algorithm presents considerable verification challenges [17,21]. We analyzed the algorithm itself, and a simplified version in which the graph is in fact a tree. For both cases we proved that a node is marked if and only if it is reachable from the set of initial nodes, and that the set of nodes does not change.

Shape analysis [33] allows one to examine and verify properties of heap struc- tures. It has been shown to be quite powerful when reasoning about heaps. The ideas of shape analysis have also been combined with those of separation logic [10] to quickly infer invariants for programs operating on lists. They can likely be also combined with matching logic in order to infer patterns.

In this paper we have presented MatchC, a matching logic verifier for a determinis- tic fragment of C based on the K framework. We have described the implementation of the key components of the verifier, and have argued their soundness based on the matching logic reachability proof system. We have evaluated MatchC on a large number of programs, some quite challenging from a verification point of view.

