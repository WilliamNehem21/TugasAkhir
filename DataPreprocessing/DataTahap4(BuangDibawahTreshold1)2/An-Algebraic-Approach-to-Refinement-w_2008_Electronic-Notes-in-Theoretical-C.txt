In the analysis and design of concurrent systems, it can be useful to assume fairness among pro- cesses. Action systems model a process by a set of atomic actions. Typically, actions are combined by nondeterministic choice, which models minimal progress among processes rather than fairness. Here we define an operator for the fair choice among a set of actions. A refinement rule for action systems with fair choice is derived and applied to the development of the alternating bit protocol. The novelty is the algebraic style in which the fair choice operator is defined and in which formal reasoning is carried out; it avoids an appeal to the operational understanding of fairness.

by contrast, the minimal progress assumption would only ensure that either one makes progress. If two continuously enabled actions are to be executed on different processors, fairness expresses that each processor is working, with- out quantifying the relative speed. If two continuously enabled actions model possible behavior of the environment, like successful and failed transmission over a medium, then fairness implies that each behavior is possible, without quantifying the probability. Fairness has become a common assumption in the analysis and development of concurrent systems. Programming theories involving fairness are well worked out, e.g. [8,10,11].

This work is on the stepwise refinement of action systems with fair choice. We define an operator for the fair choice among actions and define an action system as a loop with a body composed by fair choice, following the approach of defining an action system as a loop with a body composed by nondetermin- istic choice. In particular, we make use of strong and weak iteration constructs of [1,3,7] for defining loops and fair choice, resulting in an algebraic treatment of fairness. No appeal to operational reasoning in terms of traces of executions is needed. A theorem for the data refinement of action systems with fair choice is derived and applied to the development of the alternating bit protocol.

In the third refinement step faulty channels are placed between the sender and receiver. The sender keeps one private bit, c, that is attached to every trans- mission and flipped on that occasion, such that messages of the sender have alternating bits. Variable t is used to start and stop the data transmission. The sender becomes:

Once data transmission is started, the data channel may successfully transmit the bit and the data by copying c, s to f , p and stop; we assume that the correct transmission of the bit and the data can be detected. The channel may also keep transmitting c, s, or may loose the message, i.e. do nothing. These three possibilities are given by:

The first line states that if the concrete sender, U1, is ready to transmit, c = g , the abstract sender, T1 must be ready as well; on the other hand, if T1 is ready to transmit, then either U1 must be ready to transmit or the actions of the acknowledgement channel, U6, U7, U8, are enabled. The second line states an analogous property about the receiver. The third line is the concrete invariant and expresses what the sender, U1 and the receiver, U5, can expect: if U1 is ready to transmit, the receiver must have had acknowledged and if U5 is ready to receive, the data must have been correctly transmitted. The refinement replaces m and keeps s and x . The data channel actions and the acknowledgement channel actions modify only the introduced variables and become auxiliary actions. The resulting conditions are:

Theorem 5.3 is similar to the forward simulation of fair action systems in [4], but differs in three ways. First, the condition for the auxiliary computation in [4] is weaker as the auxiliary computation either has to terminate or has to enable and execute a main action. The second difference is that a more general mapping between abstract and concrete main actions is considered, compared to the one-to-one correspondence that is assumed here for simplicity. The third difference is that only unfair auxiliary actions can be introduced, whereas Theorem 5.3 gives the conditions for both unfair and fair auxiliary actions. The development of the alternating bit protocol relies on fair auxiliary actions being introduced for representing unreliable channels.

It would be interesting to see if strong fairness can also be treated using iteration statements. If binary fair choice were associative, the formalism could be significantly simplified. The definition of an associative binary fair choice operator has remained elusive is left as an open problem.

