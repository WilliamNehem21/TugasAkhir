In hardware designs especially, the models may in fact not be data independent according to a syntactic definition, although the conclusions from data indepen- dence still apply. For example, some resource in the design may be used for temporary storage of control information at some time and data at others, al- though whenever any value is read from that resource that finds its way to a data output, the value in the resource must have come from a data input. Data may also be transformed internally - shifted, reversed or split up.

Automatic datapath abstraction tools are described in [9] and [13]. These map a VHDL or Verilog RTL implementation model to an abstract model in some other language, which is taken as input to a verification tool. The datapath can be abstracted to a small number of elements, or to a representation in terms of unin- terpreted functions. Although such tools address the point about the need for users to analyse the design, they are targeted at specific languages, and they will not detect data independence in cases where resources are used for control information at some times and data at others.

For all these reasons, we want a way of establishing data independence from consideration of the interface behaviour of a model. There is a semantic definition in [18], although it is not proposed as a basis for checking in practice, being expressed in terms of all possible mappings from one set of data values to any other set. A very general framework for semantic definitions of data independence is provided in [12]. These definitions are formulated in terms of the operational semantics of the program. In an application to any particular instance, the definitions say things

In Section 2, we prove the sufficiency of certain semantic conditions for data independence, expressed in terms of inputs and outputs of a hardware model. These conditions are practical for checking in industrial applications. Informally, they state that any data value seen at the outputs must have been seen at the inputs; and that if two copies of the design have the same control inputs and their data outputs differ at any point, there must have been a point at which the data inputs differ in the same way as the data outputs.

We consider a hardware design with a number of input and output ports. The conditions for data to be captured at an input port or released at an output port are given in terms of the values, and possibly the histories, of control signals (including clocks, for synchronous designs). There are data input and output signals at the ports, and the control outputs have no dependencies on the data inputs.

design consistent with it, and that behaviour yields some stream of data outputs. Condition (iii) of Theorem 2.1 simply states that the possible values of the data output at any time are not influenced by input data values at later times.

We prove that, for each data capture point (i.e. for any input port, and any time when data is read at that port), there is at most one data release point (i.e. at most one output port, and at most one time when data is transmitted at that port) that is mapped to that capture point. In proving this, we can make use of the data independence already established. We can check a property saying that, for some specific data value d, if there is only one input port at which the data value read is ever d, and the value read is d precisely once at that port, then there is at most one output port at which the value d is ever transmitted, and it is transmitted at most once at that port.

For portability, we wish to avoid the use of such modelling code. It is possible to write the code in the language of the design, and combine it with the design model; but we are aiming for a flow that can fit any language of the design implementation. Instead, the results of Section 2 can be used to establish a correspondence be- tween entry and exit events for the fifo. The condition (1) in that section can be

values, and sometimes for other information, and to know that the system is data independent involves checking that if a value is read from this register and subse- quently reaches the data outputs, it must have arrived at the register by some route from the data inputs. The semantic conditions are still strong enough to imply data independence according to the intuitive notion that Definition 4.1 of [18] aims to capture, and to justify checking properties only for small finite data domains.

Syntactic checks of data independence are of course very simple, and can be done in one pass of the program text. As can be seen from Section 3.3 above, the semantic conditions can be expressed as PSL formulae that can be evaluated by checking CTL formulae of the form A[pWq], so in general the complexity of their checks is as great as that of CTL model checking - in particular, it can be exponential in the number of state variables in the model. However, in practice, checks of the conditions (1) and (2) of Section 2 can often be performed quickly, as was seen for the random number generator. If the model is in fact data independent according to the syntactic definition, then, as explained in Section 3.3, it is likely that model checking will be much more efficient than the theoretical worst case.

