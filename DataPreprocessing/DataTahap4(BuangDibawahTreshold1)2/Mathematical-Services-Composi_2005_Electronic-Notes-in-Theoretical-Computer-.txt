This paper describes the definition and the use of a plan language in the context of mathematical web services. A plan is a document intended to describe how to use different mathematical web services to solve a particular problem. A plan is like a program in which most of the function calls have to be handled by web services. A plan is a multiple-state choreography document which could be either abstract, unresolved or resolved, depending on how much of the web services involved in the choreography is known. Such a plan can be instantiated into a composition language such as BPEL or to a mathematical routine (like a Maple routine) for execution.

abstract plan is an algorithm involving mathematical functions described by ontologies or classifications such as GAMS [23]. Unresolved plans are abstract plans for which some but not all mathematical functions have been replaced by actual invocations of mathematical web services. Resolved plans are ab- stract plans for which all mathematical functions have been replaced by actual invocations of corresponding mathematical web services.

Mathematical computing has been a major branch of computer science since the early ages. Both numerical and symbolic computation brought up many highly specialized and efficient pieces of software. This section first describes motivations for this work and then proposes a possible architecture for a web service-based framework to discover and invoke mathematical packages.

Because mathematics are so fundamental, numerous packages have been de- veloped for both numerical and symbolic computation. Although created in an academic context, most of them are fully documented and regularly up- dated and some became well-known, commercial products, like Maple and Mathematica for symbolic computation, and the NAG libraries for numerical computation. On hot topics, one can find many different packages solving the same problem. For example, Macaulay [13], Gb [14], and Singular [15] offer very efficient routines to compute Groebner bases.

The primary application for web services in the world of mathematical software is to simplify point-to-point integration between systems, thereby al- lowing the use of one package from within another. Typical examples include the use of a highly specialized package from a general purpose computer alge- bra system like Maple [19] or Mathematica [29]. For example, [6] describes how to use the functions of a package called Bernina from Maple. This application, however, only scratches the surface of the true potential of mathematical web services. Service oriented computing can enable users to access agile mathe- matical processes that can adapt and respond to high level queries, through the use of loosely coupled, standards-based mathematical services. Unlike general web services, mathematical services can be organized according to the problem they are able to solve. These problems themselves can be organized as a tree structure reflecting the natural inheritance between mathematical problems.

Another motivation for the use of web services is the commercial exploita- tion of mathematical packages. A natural exploitation plan for a company would be to sell access to mathematical routines or libraries. In this context, there would be concerns such as billing and transaction (see [27] on this topic) and security (see WS-Security [16], for example). However, this topic is out- side the scope of this paper and we will mainly focus on the composition of services.

Another aspect of the issue is similar to solving problems in the context of specialized libraries or interactive mathematical systems. There exists a number of routines available, but users almost never make just one call to such routines. They rather use a language provided by the systems to combine the calls in more complete algorithms suited to their needs. Mathematical web services only offer interfaces to invoke one routine or another. We propose to get back the flexibility and usability of known interactive systems by using plans and the planning environment we setup in our architecture. A planning language would allow end-users to build programs combining routine calls. Such programs would be analyzed for optimization by the Planning Manager and executed by the Execution Manager.

flexibility: our language should be flexible enough to allow the translation into a number of target languages. As we are going to see in Section 3.3, one possibility would be to use a computer algebra system such as Maple [19] to execute plans.

The elements described above should be sufficient to function reasonably well with most mathematical services. As will be described in Section 5, a (near) future work is to experiment with several users and services to under- stand more specific needs. A current issue is to decide whether an abstract plan may contain indications stating that such or such step should be carried out by a service with given characteristics. The advantage would be to further specify a plan, the drawback is that this would introduce the notion of web services inside an abstract document.

The resolved component of a plan contains instructions to associate Service Description Language documents to each invocation statement. In the plan language, we simply add the possibility to annotate each invocation statement with the necessary contact information of services. In our architecture, this would mean that invocations are associated with Service Description docu- ments (or at least with URIs referencing such documents). Unresolved plans are plans for which not all invocation statements are annotated (an abstract plan is a special kind of unresolved plan in which no invocation statement has been annotated). A specificity of resolved plans is that one should be able to translate them into an execution language without any more manipulation. This means that a plan is also deemed unresolved when an invocation state- ment is associated with several possible services. The only exception would be when the author of the plan wishes to execute the same step in parallel by several services.

ably be handled locally (within the execution engine). Section 3.3 provides further details about local invocations. Also, the creation of a new object is typically an abstract operation that should be instantiated depending on the formalism we choose for manipulating objects.

The MONET architecture contains an Execution Manager (EM). This entity is responsible for supervising the invocation of mathematical web services. The sophistication of the EM is implementation-dependent and can range from a simple service invocation module to a secured, transaction-compliant, and plan-compliant system. The EM itself is a web service similar to the way Planning Manager and Service Matcher are web services. In our prototype, the Execution Manager receives a resolved plan as an input and should take all necessary actions to execute it.

We distinguish two possibilities to achieve this result: either the Execution Manager directly executes a resolved plan handling, as needed, concerns such as transactions, security, and so on, or it relies on a third-party composition language such as BPEL used to transform the resolved plan. An orchestration engine (e.g. BPWS4J) can then proceed with the execution. Once again, we see here the advantage of choosing an independent language: we are not tied to one standard, and the actual execution mechanism is a simple back-end that can be changed easily. One can also imagine to use execution environments that are not typical web services orchestration engines. In the context of mathematical services, a possibility would be to use Maple (or Mathematica, for example) as an execution engine: the resolved plan can be translated into the Maple language, which is a kind of planning language, and submit it to a Maple system. With a few added functions Maple can call web services, and obtain and manipulate the results.

