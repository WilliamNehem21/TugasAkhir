Modeling is widely accepted to be essential to design activity. A major benefit is the use of formal methods for analysis and predictability. In Polychrony, the tool-set of the Signal language, a component-based approach have been defined to model avionics applications. This approach uses Signal models of so-called APEX services based on the avionics standard ARINC 653. This gives access to the formal tools and techniques available within Polychrony for verification and analysis.

In this paper, we illustrate the approach by considering a small example of avionics application. We show how an associated Signal model is obtained for the purpose of temporal validation. This brings out the capability of the Signal to seamlessly address critical issues in real-time system design.

Several model-based approaches have been proposed [15] [9] [2] for the de- velopment and verification of embedded systems. They use different kinds of formalisms for the modeling and provide tools for system development and validation. While our approach aims at the same objective, its main partic- ularity relies on the use of a single semantical model, Signal [7], to describe embedded applications from specification to implementation with the possi- bility of verification and analysis. This facilitates the validation. Polychrony, the tool-set for Signal (http://www.irisa.fr/espresso/Polychrony) devel-

cated so that no fault propagation occurs from one hosted avionics function to another. This is addressed by partitioning the system. Basically, it con- sists in a functional decomposition of the avionics applications, with respect to available time and memory resources.

The underlying theory of the synchronous approach [1] is that of discrete event systems and automata theory. Time is logical: it is handled according to partial order and simultaneity of events. Durations of execution are viewed as constraints to be verified at the implementation level. Typical examples of synchronous languages are Esterel, Lustre, or Signal which is used here.

To check a Signal program, one can distinguish two kinds of properties: invariant properties (e.g. a program exhibits no contradiction between clocks of involved signals), and dynamical properties (e.g. reachability, liveness). The Signal compiler itself addresses only invariant properties. For a given program,

it checks the consistency of constraints between clocks of signals, and statically proves properties (e.g. the endochrony property guarantees determinism). A major part of the compiler task is referred to as the clock calculus. Dynamical properties are addressed using other connected tools such as the boolean model checker Sigali. Performance evaluation is another functionality of Polychrony,

destination. A message remains in a source port until it is transmitted by the channel or overwritten by a new occurrence of the message. During transmissions, channels ensure that messages leave source ports and reach destination ports in the same order. A received message remains in the destination port until it is overwritten.

(e.g. buff1, sema). These mechanisms are created on the occurrence of the input signal initialize. The presence of this signal corresponds to the initialization phase of the partition. The input Active_partition_ID represents the identifier of the running partition selected by the module-level OS 8 , and it denotes an execution order when it identifies the current partition. Whenever the

partition executes, the partition-level OS designates an active process within the partition. This is represented by its output signal Active_process_ID. It is sent to all the processes. Every process that completes notifies the OS through a special signal (e.g. end_processing1 for the process POSITION_INDICATOR), so the OS can take a decision about the next process to execute.

A process can be blocked during its execution, for instance, when it tries to send a message to a full buffer. A time counter may be initiated to wait for the availability of space in the buffer. The signal timedout produced by the partition-level OS notifies processes of the expiration of their associated time counters.

The above small example aimed to show the feasibility of describing avion- ics applications using the synchronous language Signal. Modularity and ab- straction are key features of the Signal programming. They allow for the scalability of our approach. The description of a large application is achieved with respect to a well-defined design methodology which consists in speci- fying either completely or partially (by using abstractions) sub-parts of the

An interpretation of a Signal process is a process that exposes a different view of the initial one. The structure of the interpretation process is essentially the same but its computations exhibit another aspect of its behavior. The temporal interpretation exposes the time aspect and allows to see how an implementation of a specified function will behave over time [10].

These date signals are some sort of time-stamps providing the availability times for the values of the corresponding signals in the functional specifica- tion, in respect to a global time reference. Depending on the implementation context, time can be measured using either physical time units or full clock cycles. In the first case the date signals are positive real numbers and in the second positive integers. From a cycle count integer measurement we can go on to physical time measurement by multiplying the cycle count to the cycle period.

Each operation in a Signal specification is represented by a node in the Hierarchical Conditional Dependency Graph, which is the internal represen- tation of a Signal program. To each node in the graph, a delay is associated. This delay is represented by the same data type as the data type used to represent dates and is a function of several parameters. The actual node de- lay is obtained by giving values to these parameters. The delay depends on parameters like: the operation performed by the node, data types involved, the chosen implementation, etc. Furthermore, a delay can be represented by a pair of numbers corresponding to the worst and best case delays. Since delays are represented by intervals, dates will be represented as intervals too. Com- puting these dates takes into account the processing delays. It is important to note that this date mechanism allows us to go from logical to physical time.

The temporal interpretation of a Signal specification is just a special case of a general non-functional interpretation. The non-functional interpretations are Signal processes and as such they can be decomposed into a control and a data part. The control computations are identical to those in the initial processes from which the interpretations are derived. What changes are the data computations since they extract the information related to the particular interpretation.

P computes output values (OD ) from input values (I). The computations are conditioned by activation events (H) computed in the control part (CP ). To compute the activation conditions H, CP uses Boolean input signals (Ib) and intermediate Boolean signals B computed by DP . Finally, certain outputs are output events (HO ) computed by CP . The control parts of the initial process and its interpretation are identical, but the data computations differ. The data computations in T (P ) extract the information of interest, implicit in the initial specification P .

Several successful experiments have been done on sample Signal programs. For the ON FLIGHT model, some simplifications have been made because of the complexity of used data structures. So, the cost of the accesses to those data structures and related effects is not taken into account. The cost function library currently considers simple data structures (e.g. integer, boolean, ar- rays). Others are considered as external. As a result, the current computed results are not relevant enough to be highlighted here. However, this library

