More and more aspects of concurrency and concurrent programming are becoming part of mainstream programming and software engineering, due to several factors such as the widespread availability of multi- core / parallel architectures and Internet-based systems. Besides the typical fine-grained support currently provided, however, we seek in this paper for an higher-level approach. We present simpA, a library-based extension of Java which provides programmers with agent and artifact abstractions on top of the basic OO layer, as a means to organise and structure concurrent applications. To pave the way towards identifying a true language extension for simpA, we define a core calculus of agents and artifacts, by suitabling mixing techniques coming from object-orientation and concurrency theory.

Accordingly, in this paper we present simpA, a library-based extension of Java which provides programmers with agent-oriented abstractions on top of the basic OO layer, as basic building blocks to define the architecture of complex (concur- rent) applications. simpA is based on the A&A (Agents and Artifacts) meta-model, recently introduced in the context of agent-oriented computing as a novel foun- dational approach for engineering complex software systems [18,14]. Agents and artifacts are the basic high-level, coarse-grained abstractions available in A&A (and simpA): agents are used in A&A to model (pro)-active and task-oriented components of a system, encapsulating the logic and control of such activities, while artifacts are used to model function-oriented components of the system, used by agents to support their individual activities, as well as collective ones.

Then, towards identifying a true Java language extension supporting the simpA framework, in this paper we identify a quite expressive subset of simpA, and ac- cordingly develop a core calculus of agents and artifacts. To properly join the object-oriented nature of mainstream programming languages with the concurrency aspects of agents and artifacts, this formal framework suitably mixes modelling tech- niques coming from object-orientation [7,22] and concurrency theory [3,12]. As a result, this calculus paves the way toward abstract analysis of properties concerning well-formedness (typing), safety and liveness.

The remainder of the paper is organised as follows. Section 2 describes in more details the basic abstraction layer introduced by the A&A meta-model; Section 3 describes the simpA framework and technology; Section 4 describes a core calculus providing a formal foundation for the approach. Finally, Section 5 and Section 6 conclude the paper with related works and a brief sum up.

working environment: humans work concurrently and cooperatively in the context of social activities, directly interacting by means of speech-based communication, and indirectly by means of artifacts and tools that are shared and co-used. In such systems, it is possible to easily identify two basic kinds of entity: on the one side human workers, as the entities responsible of pro-actively performing some kinds of activity; on the other side artifacts and tools, as the entities that workers use to support their activities, being resources (e.g. an archive) or instruments medi- ating and coordinating collective activities (e.g. a blackboard, a calendars, a task schedulers).

The information flow from the artifact to agents is modelled in terms of observ- able events generated by artifacts and perceived by agents (so interface controls have no return values, as found in OO interfaces). Besides the controls for trig- gering the execution of operations, an artifact can have some observable properties, i.e., elements useful to inspect the dynamic state of the artifact without necessarily executing operations on it.

piled and executed using the standard Java compiler and virtual machine, without the need of a specific extension of the Java framework (preprocessors, compilers, class loaders, or JVM patches). This choice has the advantage to maximise the reuse of an existing widely diffused platform (Java). Indeed, using the library / annotations solution to implement a language and a platform extension has some revelant drawbacks, which derive from the fact that agents and artifacts are not true real first-class abstractions for the language and the virtual machine. Accord- ingly, part of the ongoing work is devoted towards the definition and the prototype implementation of a new full-fledged language and platform called simpAL.

ordered set of arguments, either bound or not to some data object (if some is not bound, the memo is hence partially specified). A memo-space is just a dynamic set of memos: a memo is identified by its label, and only one instance of a memo can exist at a time. Each agent has internal actions to atomically and associatively access and manipulate the memo space: to create a new memo, to get/remove a memo with the specified label and/or content, and so on. It is worth remarking here that instance fields of an agent class are not used: the memo-space is the only data structure adopted for modelling agent long-term memory.

Structured activities can be described as activities composed (hierarchically) by sub-activities. The notion of agenda is introduced to specify the set of the potential sub-activities composing the activity, referenced as todo in the agenda. Each todo specifies the name of the subactivity to execute, and optionally a pre-condition. When a structured activity is executed, each todo in the agenda is executed as soon as its pre-condition holds. If no pre-condition is specified, the todo is immediately executed. Then, multiple sub-activities can be executed concurrently in the context of the same (super) activity. A structured activity is implemented by methods with an @ACTIVITY WITH AGENDA annotation, containing todo descriptions as a list of @TODO annotations. Each @TODO must specify the name of the related sub-activity to execute and optionally a pre property specifying the precondition that must hold in order to execute the todo. A todo can be specified to be persistent : in that case, once it has been completely executed, it is re-inserted in the agenda so as to be possibly executed again. This is useful to model cyclic behaviours. Todo preconditions are expressed as boolean expressions, with and / or connectors (represented by , and

; symbols, respectively) over a basic set of predefined predicates. Essentially, such predicates make it possible to specify conditions on the current state of the activity agenda, in particular on (i) the state of the sub-activitities (todo), if they completed or aborted or started, and on (ii) the memos that could have been attached to the agenda. Besides holding information useful for activities, memos are used then also to coordinate activities, by exploiting in the specification of a pre-condition the predicate memo, which tests the presence of a memo in the agenda.

activity starts, and then either delivering the drinks (deliverBoth) as soon as both the drinks are ready, or deliver just the coffee (deliverJustCoffee) if only the tea is not available after a specific amount of time. At the end of the activities, the primitive memo is used to create memos about the drinks (labelled with drink1 and drink2), annotating information related to the fact that coffee and the tea are done. In the case of makeOneTea activity, the memo tea not ready is created instead if the agent does not perceive that the tea is ready within a specific amount of time. In deliverJustCoffee and deliverBoth activities the primitive getMemo is used instead to retrieve the content of a memo.

To perform their activities, agents typically need to interact with their working environment, in particular with artifacts by means of use and sense actions as described in previous section. For this purpose, the use and sense primitives are provided, respectively, to trigger the execution of an operation over an artifact, and for perceiving the observable events generated by the artifact as effect of the execution. Before describing in details agent-artifact interaction, in next sub-section we describe how to programs artifacts.

For each operation (command) listed in the usage interface, a method anno- tated with @OPERATION and with void return type must be defined: the name and parameters of the method coincide with the name and parameters of the opera- tions to be triggered. Operations can be either atomic, i.e. executed as a single computational step represented by the content the @OPERATION method, or struc- tured, i.e. composed by multiple atomic steps. Structured operations are useful

Finally, the usage interface of an artifact can be partitioned in labelled states, in order to allow a different usage interface according to the specific functioning state of the artifact. This is realised by specifying the annotation property states when defining operations and observable properties: it describes the list of observ- able states in which the specific property / operation is visible. The primitive switchToState is provided to change the state of the artifact (changing then the exposed usage interface).

property updated("selection") is generated. The operations selectCoffee and selectTea are atomic, instead make is (can be) structured: if a valid drink se- lection is available, then two possible alternative operation steps are scheduled, timeToReleaseDrink and forcedToReleaseDrink. The first one is time-triggered, and is executed 3 seconds after triggering. The second one is executed as soon as makingStopped guard is evaluated to true. This can happen if the user agent exe- cuted the stop operation while the coffee machine was making the coffee. In both cases, step execution accounts for releasing the drink, by signaling a proper event of type coffee ready or tea ready, updating the observable properties value and switching to the idle state.

In this section we start studying a language supporting the main abstractions of the simpA framework, considering as a reference a simpA subset expressive enough to deal with powerful coordination artifacts. This calculus is conceived as a smooth extension over the object-oriented setting: while classes (and objects) are used to model data values to be symbolically manipulated, we add the concepts of agents and artifacts as coarse-grained abstractions to structure concurrent applications. Following an established tradition of papers in the object-orientation research con- texts (see e.g. [7,8]), such an extension is developed in terms of a core calculus, namely, a very small language that focuses on the few aspects of interest while ab- stracting away from unnecessary language mechanisms. This should pave the way towards establishing technical analysis results over the bigger language, such as e.g. progress, soundness, and so on [22].

To develop our approach formally we first conceive a subset of the simpA framework neglecting some of its features. First of all, we do not consider activities with agenda, namely, activities have no guard condition and start executing as soon as they are scheduled. Then, there is no explicit notion of filtering linked to sensors; in our language the use action yields an action/sensor identifier, which can be later used to perceive events. Concerning artifacts, we only model fields and operations, the latter having a guard condition; so we do not consider observable properties and operation steps.

A program is formed by a list of definitions, of classes, agents and artifacts. A class definition includes its name, a list of fields f (each with its type Ti), and a list of methods (class inheritance is not modelled). Methods have a return type T, a name m and arguments T x, and their body is just a return statement. An agent (class) definition has a name G, a list of fields representing its state, and a list of activities Act representing its autonomous behaviour. An activity has a name o, arguments, and its body is an expression, treated as a statement. An artifact (class) definition has a name A, a list of fields representing its state, and a list of operations Op representing the service it provides. An operation has a name o, arguments, a guard expression, and its body is an expression, treated as a statement.

e.g. for the Java language. On the one hand, this allows for a compact and simpler representation of syntax, on the other hand, we do this to take into account also expressions temporarily produced during computation, which cannot be expressed in a program. Basically, further constraints to be applied to a valid program in- cludes the fact that references r and s cannot appear in the surface language; that the receiver of a field access, field assignment, and activity schedule should be vari- able this; scheduling, use, and sensing can occur only in agents, whereas event generation can occur only in artifacts.

parts of the program where such a sub-expression is inserted in. When an expression matches E e), it means that e is the next sub-expression that needs to be evaluated: the idea is that in case e evaluates to v, then the whole expression E e) evaluates to E v). The way the syntax of E is structured guarantees e.g. that a receiver is evaluated before the method arguments are evaluated, and that such arguments are evaluated from left to right, and so on. For operations, K is structured so that guard evaluation proceeds until reaching value t, after that the body of the operation can be executed.

