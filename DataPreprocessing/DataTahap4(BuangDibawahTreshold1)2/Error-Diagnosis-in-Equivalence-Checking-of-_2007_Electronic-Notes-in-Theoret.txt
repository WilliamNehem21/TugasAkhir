they are manually implemented at transistor level using such artifacts as self-timed components, static and dynamic logics. These artifacts and others prevent using boolean model extraction tools on transistor level models and producing correct gate level models. Our transistor level model captures transistor level dynamic be- havior. It takes into account bidirectional transistors, charge sharing and different transistor strengths. Due to the low level implementation details of transistor level model, error diagnosis becomes even more challenging since now signal timing and transistor strengths may also cause errors.

When more than one path is enabled on a bus node, where one path is pulling it to low and the other to high, results in X at the bus node. This is called bus contention. We ask the user to anlayze the situation and possibly add constraints to eliminate bus contention.

This technique traverses the design backwards using controlling variables of a logic function. We say that a support node a of a logic function F is controlling if complementing the value of a changes the value of F . Note that since we are using a unit delay model, we need to use the values of nodes at appropriate times. We next give an outline of the Path Backtrace algorithm.

However, we can do better by using multiple counterexamples. For example, if we also used counterexample a = 1,b = 1,c = 0,d = 1, we would get L = [b; c; g; e; f ; h]. Furthermore, since there is a single error, we can take the intersection of all lists and obtain L = [b; e; g; h; f ], which contains the error location, [b; e].

This technique uses scalar forward simulation of design. It uses the list of nodes generated by Path Backtrace, then for each node checks if changing (complementing) the value of the node is observable at the output. We next give an outline of the Complementation algorithm.

In summary, for Strong Fail Diagnosis, we use Path Backtrace with Multiple Counterexamples, followed by Complementation with Dominance relation. Our experimental results demonstrate that both Weak Fail and Strong Fail diagnosis algorithms are easy to use in current verfication methodologies. Furthermore, they help in reducing the debugging time.

