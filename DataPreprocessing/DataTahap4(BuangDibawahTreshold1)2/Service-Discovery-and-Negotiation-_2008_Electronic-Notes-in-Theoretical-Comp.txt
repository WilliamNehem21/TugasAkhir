To provide formal foundations to current (web) services technologies, in [28] we have introduced COWS as a formalism for specifying and orchestrating services while modelling their dynamic behaviour. COWS, in fact, falls within a main line of research (see e.g. [9,10,24,27,21,7,11,12,25]) that aims at developing process calculi capable of capturing the basic aspects of service-oriented systems and, possibly, of supporting the analysis of qualitative and quantitative properties of services. While

The rest of the paper is organized as follows. Section 2 presents the syntax of COWS and its informal operational semantics. Section 3 shows how COWS can be used for concurrent constraint programming. Section 4 describes some simple communication protocols that allow two parties to generate constraints through synchronization. Section 5 presents the specification of a web hosting scenario, that is, in a simplified form, one of the typical SOA scenarios where SLA among organi- zations are largely employed. Section 6 introduces some variants of the concurrent constraint programming constructs presented in Section 3. Finally, Section 7 con- cludes the paper with a few observations.

COWS (Calculus for Orchestration of Web Services, [28]) is a recently defined pro- cess calculus for specifying, combining and analysing services, while modelling their dynamic behaviour. The design of the calculus has been influenced by the web ser- vices orchestration language WS-BPEL [36] and by existing process calculi. As a result, COWS integrates such features as e.g. not binding receive activities, asyn-

We first provide some insights on the constraint system used. In COWS, a con- straint is a relation among a specified set of variables which gives some information on the set of possible values that these variables may assume. Such information is usually not complete since a constraint may be satisfied by several assignments of values to the variables. For example, we can employ constraints such as

Of course, since the protocol can diverge (i.e. an invoke can synchronize infinitely often with the same receive without modifying the store), a fairness assumption is essential to guarantee progress properties: if an invoke can synchronize with many receives and at least one synchronization produces consistent constraints, then eventually this synchronization will succeed.

the store and releases it, invoke and receive activities synchronize (i.e. the new constraints are consistent with the store), the encoding of the receive reads the store and, if the value is unchanged, adds the new constraints, otherwise it restarts the terms. The encoding is divergence-free in the sense that whenever the terms are restarted the value of the store of constraints differs from that in the previous

robust protocols (that, e.g., avoid also starvation) could be defined. However, they should rely on synchronization among more than two entities at the same time (as it is permitted, e.g., by the join input of the Join-calculus [17]), that goes against our choice to reconcile expressiveness and implementability.

The operations tell c, check c and ask c are blocking operations, i.e. if the constraint c is not consistent with/entailed by the current store, the operations, and their continuation, are suspended until the constraint is consistent/entailed. Nevertheless, non-blocking variants of these operations can be defined. For example, by adding the following pattern-matching rule

During the negotiation phase, one is usually interested in satisfaction or violation of constraints. However, when the involved parties reach an agreement, one could be interested to obtain (one of) the best solution of the resulting multiset of constraints. To achieve this aim, we introduce a function getSol(C) that takes a constraint multiset C and, if C is consistent, returns a solution. Formally, in case of crisp

