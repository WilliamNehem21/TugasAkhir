In Sect. 2, we describe the Twelf system and its module system, and in Sect. 3, we describe how logics are represented in it. Our main result is the full representation of first-order logic (FOL) in Sect. 4: It comprises syntax, proof theory, model theory, and soundness proof of first-order logic, all of which use the module system to treat all connectives and quantifiers independently. In particular, the soundness is verified mechanically by Twelf. In Sect. 5, we go one step further: We discuss how to encode both Zermelo-Fraenkel set theory (ZFC) and a translation from MLTT to ZFC in LF. Thus, we can represent set-theoretical models as LF theory morphisms and reason about them within the logical framework.

Twelf signatures contain declarations of type- or object-level constants. Con- stants are declared in the form of declarations a : K or c : A, or definitions a : K = A or c : A = M . Variables x : A are typed, never kinded.

The Twelf module system permits one to use multiple named signatures that can be related via inheritance, i.e., structures, and translations, i.e., views. Readers fa- miliar with modular theory development languages such as development graphs ([2]) will recognize structures as definitional theory morphisms and views as postulated theory morphisms.

A view declaration encodes a translation between two signatures. A view occurs on toplevel and gives domain and codomain explicitly. It must instantiate all con- stants (except those that have definitions) of the domain signature with expressions of the codomain signature. This induces a signature morphism in the obvious way. A structure declaration %struct s : S = {} occurring in the signature T rep- resents an inheritance relation from S to T : It adds a copy of S to T . The copied constants are accessible by qualified names formed by prefixing the structure name. Then the declaration of a structure s induces a signature morphism from the instan- tiated signature S to its containing signature, which maps every constant c of S to

ration %include S occurring in T creates an inclusion from S to T . This is similar to a structure declaration but simpler and less expressive. If a signature is included in multiple ways, all inclusions are identified. Therefore, a symbol c included from S into T is identified uniquely by the name S..c.

For example, for propositional logic with only negation, Lsyn and Lpf could be respectively the signatures NEG and NEGPF from Sect. 2. lpf would be the morphism induced by the structure neg of NEGPF. Lmod could be a signature formalizing the two-element boolean lattice. Note that this formalization might be carried out in some other logic, e.g., first-order logic, which would have to be included in Lmod. Alternatively, Lmod could include a full axiomatization of set theory; then lmod could map base.o to the set {0, 1}.

Then we import Base, NEG and DISJ into the signature PL via the structures base, neg and disj, respectively, as shown below. This gives us an encoding of the PL syntax. In neg and disj, the assignment %struct base := base. maps the structure base of NEG and base of DISJ, respectively, to the structure base of PL. This assignment allows us to identify the copies of Base that are imported from NEG and DISJ with the copy of Base that is imported by the structure base of PL.

Thus, our type theory corresponds to intuitionistic first-order logic via the Curry- Howard correspondence. The addition of the empty type to express negation is crucial to reason about model theory. For example, without negation, it would be impossible to express the condition that models must be consistent, i.e., may not interpret all formulas as truths.

In the signature TT, we introduce a type tp for types and a type family tm for terms. The encoding uses intrin- sic typing, i.e., the intuition of the LF-type tm A is that its LF-terms encode the MLTT-terms of MLTT-type A.

present the view SoundPL; the view from FOLPF to FOLMOD is encoded in a similar way. SoundPL encodes the soundness of PL by interpreting all expressions in PLPF in terms of the expressions in PLMOD. PLPF consists of expressions that come from BasePF, NEGPF and DISJPF, which are interpreted in BaseMOD, NEGMOD and DISJMOD via the views SoundBase, SoundNEG and SoundDISJ, respectively. Then SoundPL can be pieced together as follows, where we omit the proof of the law of excluded middle for brevity.

SoundNEG interprets all the expressions of NEGPF, i.e., the structures basepf, neg and the terms notI and notE, in terms of the expressions of NEGMOD. The view SoundBase interprets BasePF in BaseMOD. This interpretation is carried over to NEGMOD via the composed morphism SoundBase basemod. Then the structure basepf is mapped to SoundBase basemod, which ensures the commutativity of the upper rectangle in the diagram on the right. The structure neg is mapped to the signature neg in NEGMOD.

The representation of models given in Sect. 3 and employed in Sect. 4 uses LF to axiomatize the semantics of models of a logic L. The signature morphism lmod interprets L-syntax in terms of the LF-signature Lmod, and the individual L-models are represented as LF-models of that signature.

This can be unsatisfactory as the L-models are still represented as set-theoretical entities. It would be more appealing if L-models could be represented as LF- signatures themselves. This is indeed possible without changing the principal fea- tures of our approach: All we have to do is to refine the signature Lmod so much that it becomes (a syntactical representation of) specific L-models.

More precisely, we can axiomatize the particular set theory in which we want to express L-models as a part of Lmod. We can do this in such a way that every choice of some free parameters in the signature morphism lmod corresponds to a specific L-model. Thus, we can represent L-models as certain LF-signature morphisms out of Lsyn.

the diagram on the right. The signatures FOL, FOLPF, and FOLMOD are as before. Here we also make the signature MLTT that is included into FOLMOD explicit. Then we axiomatize Zermelo- Fraenkel set theory in the signature ZFC and give a view I that interprets FOLMOD in set theory. By

trivial and leads to lots of significant design questions. For example, very advanced encodings have been established in Mizar ([27]) and Isabelle ([20]) employing so- phisticated machine support. Even the proof of concept that we hand-coded in LF for this paper took over a week (which we consider in fact quite an achievement) to implement and still has some gaps. We will only sketch our encoding of ZFC and refer the reader to our full encoding (see [12]) for the details.

We encode ZFC as theory of a variant of first-order logic with universe Set, namely intuitionistic first-order logic with a description operator. The latter permits to define the basic operations such as union and replacement set, whose existence is only axiomatized indirectly in the ZFC axioms. This is different from Isabelle and Mizar where these operations are primitive.

We took two developments on logical framework research to a practical test. Firstly, the module system for the logical framework LF and its implementation Twelf were designed to enhance the scalability of logic encodings ([24]). Secondly, the proof- and model-theoretical framework was given by the second author in [23].

Both were developed very recently, and our case study is the first scalability test for either one. We picked classical first-order logic and represented its syntax, proof theory, model theory, and soundness in LF. The most difficult part is the encoding of model theory and soundness, and we undertook two approaches to it that differ in the meta-language used to represent models.

We evaluate both developments very favorably. The representation of first-order logic was straightforward and made easy by the module system. All logical symbols are treated separately so that the encodings can be used to piece together different logics. The representation of model theory feels elegant and appealing. We are already working on further encodings of intuitionistic logic, higher-order logic, and description logics. The only doubt we have is about the representation of set theory: Clearly, the lack of automated proving support in Twelf will prevent scalable appli- cations. Therefore, we will investigate the possibilities of borrowing formalizations from other systems in the future. This will be supported by the logic-independent module system we designed in [22], which permits to express cross-framework trans- lations (e.g., LF to Isabelle) in terms of signature morphisms as well.

