Reo is a coordination language that can be used to model different systems. We propose a technique for symbolic execution of Reo circuits using Constraint Automata and more specifically exploiting their data constraints. This technique enables us to obtain the relations among the data passing through different nodes in a circuit and also infer coordination patterns. As an alternative to constructing the symbolic execution tree, we propose an algorithm similar to the algorithms used for converting deterministic finite automata to regular expressions. Our technique can be used for analyzing data-dominated systems whereas the model checking approach is best suited for the study of control-dominated applications. Deadlocks, which may involve data values, can also be checked. We illustrate the technique on a set of data dominated circuits as well as a non-trivial critical section problem. A tool is implemented to automate the proposed technique.

Reo [1] is an exogenous coordination language. In Reo, complex connectors are compositionally built out of simpler ones. The simplest connectors in Reo are a set of channels with well-defined behavior. Reo connectors are visually represented as circuits similar to electronic circuits and show how components are inter-connected. The emphasis in Reo is on the connectors, and the synchronization and communi- cation among components, and not on the internal behavior of components. Con- straint Automata [3,7] are introduced as compositional semantics for Reo. Using Constraint Automata (CA) we can analyze the behavior of Reo circuits.

Reo is introduced as a coordination language and it can be used in various kinds of applications. Reo and Constraint Automata are used as an ADL (Architectural Description Language) in [4], they can be used in modeling hardware and system level designs [20,21], and in modeling web services [24,25]. In these applications, Reo is generally used to show the communication and synchronization, and Constraint Automata are used to model the components. In this way, the behavior of the whole system can be compositionally constructed using the Constraint Automata of its constituents.

For analysis of Reo circuits, a model checker is presented in [13]. Our symbolic execution technique and tool constitutes a simpler yet powerful and more efficient analyzer which can be used as an alternative or extension for this model checker. When applicable, it can be used to derive the symbolic output of a circuit in terms of its input data, which can also reveal possible deadlocks/livelocks at less com- putational cost than model checking. Whereas in model checking you can express more complicated properties and pay the higher computational cost for its analysis, symbolic execution of Reo circuits can be effectively used for instance when Reo is used for modeling hardware and system design. Similar techniques can be used for slicing reductions and test case generation for Reo and CA.

loss of generality, we consider deterministic Constraint Automata, with a single initial state. We generate the regular expression of a CA, assuming the initial state as the final state [9]. For that, we define the set of regular expressions associated with CA considering how synchrony and asynchrony are both modeled in CA, and showing how data constraints can be represented in the regular expressions. Our approach relies on the manipulation of the data constraints in different execution paths.

Two main difficulties in performing symbolic execution are (1) handling com- plicated data structures and data types; and (2) dealing with a potentially infinite number of symbolic execution paths. Initially, we abstract from complicated data structures and data types as they are not regularly considered in Reo and Constraint Automata and we focus on deriving nontrivial interdependencies among data. In- stead of dealing with an infinite number of execution paths, here we traverse each cycle a certain number of times which depends on the length of the longest path between memory cells in their transitive relation ( the memory cells in each cycle are in a relation by appearing in the same data constraint), yielding a finite number of paths. This is enough to give us the relations among the elements of the input and the output data streams passing through the circuit (represented symbolically).

Contribution of the work. We provide an automated analysis technique and its supporting tool for Reo circuits based on the symbolic execution approach. Reo is used for different applications but only a few tools are provided for its analysis [15,13]. Although our technique does not support verifying temporal logic prop- erties, it provides reachability analysis and can reveal possible deadlocks/livelocks which are usually the most interesting properties for designers. The technique can also derive the symbolic output of a circuit in terms of its input data and hence the coordination patterns. This can all be done efficiently and with less computational cost than model checking. Furthermore, as our technique is based on symbolic rep- resentation of the variables and not the actual values it does not need the data domain to be finite whereas in model checking actual values of variables need to be considered. To the best of our knowledge, this is the first work which uses data constraints in CA for performing the analysis. For doing so, we define the set of regular expressions associated with CA considering data constraints.

Our work is also interesting for the symbolic execution community. We start from automata instead of code, so, we could use the clever way of generating the regular expressions and unfolding the expressions instead of building the symbolic execution tree. We propose a solution for the potentially infinite number of symbolic executions according to the semantics of Reo circuits.

The rest of this paper is organized as follows: Section 2 is a brief overview of Reo and Constraint Automata. In Section 3, we explain our approach to symbolic execution of Reo circuits. Section 4 contains a number of case studies. Related work is presented in Section 5. In Section 6, we discuss future work and conclude the paper.

Reo is a model for building component connectors in a compositional manner [1]. It allows modeling the behavior of such connectors, formally reasoning about them, and once proven correct, automatically generating the so-called glue code from the specification. Each connector in Reo is, in turn, constructed compositionally out of simpler connectors, which are ultimately composed out of primitive channels.

A channel is a primitive communication medium with exactly two ends, each with its own unique identity. There are two types of channel ends: source end through which data enters and sink end through which data leaves a channel. A channel must support a certain set of primitive operations, such as I/O, on its ends; beyond that, Reo places no restriction on the behavior of a channel. This allows an open-ended set of different channel types to be used simultaneously together in Reo, each with its own policy for synchronization, buffering, ordering, computation, data retention/loss, etc [1].

Channels are connected to make a circuit. Connecting (or joining) channels is putting channel ends together in nodes. Thus, a node contains a set of channel ends. The semantics of a node depends on its type. Based on the types of its coincident channel ends, a node can have one of three types. If all coincident channel ends on a node are exclusively source (or sink) channel ends, the node is called a source (respectively, sink) node. Otherwise, it is called a mixed node.

of transitions can refer to state memory cells only indirectly, through the relative references of the form sx or tx (as opposed to the explicit memory cell names q.x or p.x). This has two advantages. First, it makes it impossible for a transition to refer to a memory cell of any state other than its own source or target. Second, it simplifies the product operation by eliminating the need to do anything special (e.g., name substitution) when we combine synchronous transitions.

Symbolic execution is a natural extension of normal execution, rendering normal computation as a special case [12]. In the case of conventional imperative program- ming languages, definitions for the basic operators of the language are extended to accept symbolic input values and produce symbolic formulas as output. For instance, the expression on the right-hand side of an assignment statement is eval- uated, possibly substituting polynomial expressions for variables. The result is a polynomial (an integer is the trivial case) which is then assigned as the new value of the variable on the left-hand side of the assignment statement.

The state of a symbolically executed program includes the symbolic values of program variables, the program counter, and a path condition. The path condition is a quantifier-free Boolean formula over the symbolic input values; it accumulates constraints that the input values must satisfy in order for an execution to follow its particular associated path. A symbolic execution tree characterizes the execution paths followed during the symbolic execution of a program. The nodes in this tree represent program states and the arcs represent transitions between states [18].

The coalgebraic formal semantics for Reo connectors, presented in [5], assigns to any Reo connector a relation over infinite timed data streams, called its TDS lan- guage. This language can be used in symbolic execution of Reo and in obtaining a symbolic relation between input and output values of a circuit. To reason about TDS languages, we may regard Constraint Automata as acceptors for sets of timed data streams.

Our approach. In CA, instead of specific data values, we have symbolic represen- tation of input and output values and transitions show the possible relations among them. This makes the CA an appropriate basis to build a symbolic execution tool. Here, we use the data constraints for deriving the relation between input and output values.

In our technique, instead of building the symbolic execution tree, we generate the regular expression of a CA assuming its initial state as the final state of the automaton. Execution paths are derivatives of regular expressions. We unfold data constraints and show the relation among the data elements in the data streams. The transitive closure over this relation gives us the relations among symbolic input

Symbolic execution has been used for verification of programs, and the tech- niques are naturally based on building the symbolic execution tree. But in our case we are a step ahead and have the Constraint Automata instead of a the source code of program. Thus, instead of building the symbolic execution tree, we use the regular expression of the CA to obtain the set of derivatives of our interest. The purpose of presenting the symbolic execution tree here is to show the similarities of our technique with the conventional symbolic execution methods.

In a constraint automaton we may have more than one name on a transition, which means that all Reo ports corresponding to these names fire synchronously on that transition. We put these names in square brackets, [], to show their syn- chronous/atomic firing. For example, [ABC] means that A, B, and C fire atomically in any order (even simultaneously together) on one transition. In contrast, (ABC) means that A, B, and C fire one after the other on successive transitions. As such, [ABC] and [CAB] are identical to one another (and to the rest of the permutations of this set of names), while (ABC) and (CAB) are clearly different. So, the alpha- bet of our language consists of composite letters. The first component of a letter can be a name from the Name set of a CA or a bracket containing a (nonempty) set of names. The second component is the data constraint of the corresponding transition.

Step 3: Build the symbolic data stream of each output node based on the symbolic input stream of data for each derivative. In this step we traverse each regular expression to show the data stream by its elements (indexing the elements of data stream). Then, obtaining all transitive relations among these elements of streams (transitive closure), gives us the relation between output and input values. In this step, we first specify indices for each data element in the data constraints shown in the regular expression. To do this, we traverse the regular expression from right to left. Then, we obtain the transitive closure.

how these primitive operations can be structured using Reo. This approach can be used for analyzing multi-thread systems, database applications and resource sharing systems. We pick the case study of [19] as an example of a control-dominated system. It is a system consisting of two concurrent processes with a critical section that is modeled using Reo and CA. In the model for this system, there are 84 states, 284 transitions, and 127 names in the CA. For each process, an output is generated after it passes the critical section. We checked in our symbolic execution result whether this output is generated or not. We found an execution path in this system in which this output was not generated. This showed that a deadlock had occurred. Thus, we could detect a deadlock in the system without generating the whole state space, which is hence less expensive than traditional model checking.

Symbolic execution is an established technique in verification, especially in the hardware verification community. Having its roots in the seventies [12], symbolic execution rapidly grew to be one of the predominant verification technique for hard- ware designs, with many successful applications, such as [16]. With the invention of symbolic trajectory evaluation by Seger and Bryant in the nineties [8] this ap- proach has now become a component in most of the industrial hardware verification systems (e.g. FORTE [22] at Intel). As Reo has previously been used for modeling hardware systems [20,21], our approach in this paper can be compared with the pre- vious papers on symbolic execution of hardware systems, in the sense that we are also able to symbolize the relation between input and output values in a hardware design.

tem code using symbolic execution. Rather than running the code on manually- constructed concrete input, they instead run it on symbolic input. They checked the disk mounting code of three widely-used Linux file systems and found bugs in all of them where malicious data could either cause a kernel panic or form the basis of a buffer overflow attack.

We have developed an approach and a simple tool for symbolic execution of Reo circuits. We use the regular expression corresponding to the CA of a Reo circuit to derive a set of execution paths for the circuit. These execution paths are generated by traversing the CA from its initial state back to its initial state, passing each cycle only a finite number of times (depending on the relations between memory cells which can be obtained by static checking). In the regular expression we consider the data constraints as well as the names of the ports that fire in each transition. This helps us to obtain the transitive relation between the input and the output values, which is represented in a symbolic form.

In our ongoing research, we are currently working on obtaining the general ex- pression for the set of all input and output streams of a Reo circuit. We are also working on different applications amenable to our symbolic technique. We will use compositionality techniques in our symbolic execution approach.

