Shape analysis algorithms statically analyze a program to determine information about the heap-allocated data structures that the program manipulates. It is an important methods used to understand or verify programs [7,8,9,10,11,12,13,14]. Abstraction is needed if we want to do shape analysis efficiently. There are many abstraction methods, such as k-limited heap abstraction [8], shape graph and refer- ence counts [11], 3-valued logic abstraction [12].

Shape analysis can also be used to detect Memory leak. Memory leak is one of the most common errors in programs written in languages with pointers. Occurring in large, memory intensive, long-time running programs, it can exhaust the available memory and cause the programs to fail. Many models and methods are proposed to detect memory errors. In [1,2,3,4,5] an ownership model is used to detect memory errors. Hackett et al [6] uses region based method to detect memory errors. Escape

The difficulty in dealing with complex expressions lies in the fact that the value of a complex expression cannot be easily defined in the abstract shape graph (ASG). We can get the value of a basic type datum, such as an integer, by accessing the cor- responding memory. However, if we want to know the value of a pointer expression, we must access several memories along a path. In this paper, we proposed abstract evaluation path (AEP) to deal with this problem. AEP is an abstract access path of the expression. It denotes how the l-(r-)value of an expression can be defined. In other words, it shows all the possible access paths along which the value of an expression can be defined in an ASG. we call these paths evaluation paths. AEP can be used to refine the ASG to make the defining of the value of an expression easily.

C. We take a more aggressive materialization strategy in doing shape analysis. By supporting taking addresses of fields and stack variables, our method allows pointers into the middle of structures, not just the beginning of structures. Our method is also conservative, which means it may generate more shape graphs than the program really generates.

Outline. The rest of the paper is organized as follows. Section 2 gives the definition of concrete shape graph(CSG). Section 3 defines AEP and shows our algorithms of refining ASGs based on AEP. In Section 4, we give the abstract se- mantics of the statements on ASGs. Section 5 shows the results of our experiments. Section 6 lists some related work and gives the conclusion of our work.

A shape graph is a directed graph which consists of a set of nodes and edges. It is used to represent memory structures and the connectivity between them. It is different from ordinary directed graph since it may have many types of nodes, which are used to represent different data structures.

the name of the field. The node of a basic type datum has just one cell, whose name is NName.bas, where bas denotes the basic and only field of the node. The node of a composite type datum has several cells, one for each field, plus an additional one

rcell(v): cell is the basic cell of a pointer variable or the pointer field cell of a structure variable. It denotes the reachability of memory location v from cell. If rcell(v) = 1, then there is a path from cell to any memory cell of node v, which may have multiple memory cells.

typei(v): we use an integer to denote a structure type. Different memory loca- tions may have different structures. typei(v) = 1 if and only if memory location v belongs to type i. All the basic data types are classified into one type and different structures are classified into different types.

unique(v): it is only used in the definition of ASG. In order to make the nodes in the shape graph finite, some node in the ASG may denote a set of concrete nodes. For concrete shape graphs, for all addresses, v, unique(v) = 1.

Abstract interpretation [20] is a good method to deal with infinite systems; it can also be used to generate finite number of ASGs from any possible infinite number of CSGs. There are two reasons which cause the program states to be infinite: first, some variables may have infinite values, e.g. integer variables, float variables; sec- ond, the memories dynamically allocated may be infinite. Since we have introduced the abstract memory location value, the infinite values are reduced to one abstract value. A set of predicates are used to classify the possible infinite memory locations into different classes. All the memory locations in the same class should have the same value for any predicate in the set. Since the number of predicates is finite, the number of classes is also finite.

pcore = {xi, rcell, typei}, is a set of unary predicates. There are some con- straints: first, the truth value of predicate xi must be definite and there is one and only one memory location v which satisfies xi(v) = 1; second, for any node v, the truth value of typei(v) is definite. This is the set of core predicates.

The algorithm is described in Algorithm 1. There are some new functions. Every graph has a current attribute which identifies the current memory cell. Function node maps the memory cell to its node. split is used to generate a new node from a non-unique node and cut is used to delete the inconsistent edges and graphs.

The idea behind the algorithm split is simple: we just split a new unique node from a non-unique node and the new node inherits most properties of the old one. The current memory cell is transferred from the cell of the old node to the corresponding cell of the new one. Algorithm 2 shows the algorithm split. After splitting, there may be many redundant edges. We use the cut operation to delete the impossible edges and graphs.

If a unique cell has more than one output edge in graph G, then we use a graph set S to replace G. For each graph G' in S, every unique cell has at most one output edge. The total number of the graphs in S is the multiplication of the number of output edges of each unique cell. The reachable predicates are conflict in the following two conditions: (1) rcell(v) = 1, but there are no paths from the cell to v;

(2) there is a definite path (all the edges along the path have truth value of 1) from a variable cell to node v, but the corresponding reachable predicate for v has truth value of 0. The share predicates are conflict in two conditions: (1) shared(v) = 1, but there are no input edges to v.bas or just an input edge from a unique cell; (2) shared(v) = 0, but there are more than one definite input edges to v.bas.

Second, different programs may need different core predicates. The core pred- icates can be different from the definition in this paper. Actually, we add shared into the core predicate set in dealing with the elem merge program and the total number of shape graphs is greatly reduced. But if we also add shared into the core predicate set in dealing with the last two programs, the total number of shape graphs will increase.

In this paper, we present a shape analysis method which can deal with complex expressions. This method also allows pointers into the middle of structures. AEP is generated from arbitrary expression in C language and is used to refine the ASG. The semantics of a statement can be easily defined on the result shape graphs after the refinement. Memory error conditions can be checked on the ASGs. In the future, we plan to improve the efficiency of our method and provide more thorough experimental evaluations. We will also apply our shape analysis results to verify the correctness of programs in C language.

