We discuss the evolution of Praxis, a model-driven process framework, building on feedback from educational and professional applications, along the past fifteen years. We follow the evolution from Praxis first version to the current one, discussing what was introduced in each. For past and current versions, we classify model improvements, discussing their nature and rationale, derived from received feedback.

The Praxis process has evolved along those years, mostly through feedback from both course and Synergia projects. This paper describes which changes were intro- duced during those years, as feedback from process use was collected and analyzed. In section 2, we discuss the goals of process and modeling improvements, propos- ing a classification for them. In section 3, we present the evolution of a model-driven development process, oriented to support course projects, showing the improvements performed in each version, how such improvements were suggested by feedback from its application, and which kinds of change they caused. In section 4, we discuss cur-

Artifacts reorganization happens when there are structural changes in the set of process artifacts; in a model-driven framework, the most important are changes in its core models. The models in the set may change, or there may be changes in their internals. A case of special interest is model layering, where a model or model section is split in layers, such that a layer uses only elements defined in the same layer or in a layer below. Those layers may be mirrored in derived artifacts.

Version 2.0 appeared in 2003, together with the second edition of the textbook. This was the first truly model-driven version, where the analysis and design models had been improved and reorganized to hold all important technical information. The IEEE documents became model derivatives; experience had shown that they tended to be hard quite hard to use and update, for the kind of small applications developed in the course.

A layered architecture was adopted for the logical view in the design model and the application code; it used the boundary, control, and entity layers proposed by Jacobson et al. [22], plus a persistence layer which translated persistent data between object-oriented and relational representations, and a system layer, encap- sulating environment services. The process lifecycle model became closer to spiral, although the analysis model and its derived specification were still expected to be complete at the end of the second project phase.

A major difference from Version 2.0 was the introduction of a reuse framework, for artifacts related to implementation: application code, design model, and code for unit tests. This framework provided a persistence layer that used Java reflection to become completely independent from applications, following the design proposed by Ambler [1]. The reuse framework, also called Praxis, provided (mostly abstract) base classes that supported simple CRUD functions (managing persistent objects which contained primitive fields only) and CRUD with a single strong detail (man- aging persistent objects whose fields might contain collections of other objects with independent lifetime).This reuse framework was influenced by the experience with a similar framework in one of the first industrial applications projects.

Test-driven development began to be used in this version, using JUnit [39] scripts to drive and test each application layer. True system tests, acting on actual user interfaces, were not used, because the then available tool used a non-standard script language. However, they were simulated, in a somewhat contrived way, by JUnit tests that exercised fields and commands in the boundary layer. The reuse frame-

The third and current edition of the textbook reflected new or upgraded relevant software standards, such as UML 2.0 [28], CMMI [10], the 2003 collection of IEEE software standards [21], PMBoK [36] and SPEM 2.0 [29]; UML 2.0 and SPEM deeply affected modeling. Most of the practices of the Extreme Programming [7] agile methodology were adopted; however, models remained in the framework core, unlike XP and more like Agile Modeling [2].

UML 2.0 and the Rational Architect provided rich support for stereotype pro- files. In the previous version, stereotypes had the limited purpose of providing visual representations, to enhance diagrams clarity. Now the Praxis profile was developed, allowing models to use UML tagged values (called stereotype properties, in the

Fully automated functional tests were introduced, using IBM Rational Func- tional Tester, which provides Java test scripts, tightly integrated with Eclipse. To ease the use of its somewhat complex API, and provide some degree of technol- ogy independence, the test model view and code were also layered and employed reuse. A common layer, shared by all kinds of tests, holds test data, represented by classes whose instances contains test case data, with similar test cases sharing test entities.

Above the common layer, test view and code split in a black-box layer, con- taining system tests, and a gray-box layer, containing unit tests for the application entity and control layers. Boundary layer unit tests were no longer used, since, by process guideline, this layer must handle presentation only, delegating functional- ities such as field validation to the layers below. To further tame complexity and provide separation of concerns and technology independence, the black-box layer uses three layers of classes: test inspectors move data in and out of the user inter- faces; test checkers compare expected and actual results; and test procedures implement the interactions in test collaborations.

The framework stereotype profile was enhanced to ease the extraction of derived artifacts. These are useful in the professional environment, easing models use by large teams of developers, many of which not highly UML-proficient, as our experi- ence with industrial projects has shown. For the educational version, simpler data sets are extracted using BIRT, a report generator provided by Eclipse.

In most cases, implementation difficulties were found with functions that did not fit the patterns present in the Solution model and code; that is, CRUD with a single strong detail. For other kinds of detail, the sample application provided some example functions, but adapting them was much more difficult than reusing the framework. The current version provides support for multiple detail collections, including weak ones (data whose lifetime is bound by the master instance lifetime). Handling such collections builds on UML parameterized classes, in the Solution model, and Java generics, in the code.

For solution-level prototypes, it is possible to use HTML prototypes, as done for problem-level. However, it was found in former versions that a significant amount of Javascript code is needed to have a prototype with significant behavior. Reuse of prototype common elements reduces the amount of Javascript needed for each new prototype, but a different solution was tried and accepted for this version.

that into the definitive code. Some of the differences between the two versions correspond to differences between actual and simulated control and entity layers; some stem from validity checks that are too heavy for prototypes; some correspond to features that only the actual version allows being thoroughly tested; and some are code optimizations that should be done in the final code only. Differences usually amount to less than 5% of the code.

During the years where this author lectured practice-oriented courses using Praxis as the process for writing course applications, it was possible to experiment with its use as a process to develop course applications. Currently, as the author has ceased to teach regular courses, a fourth edition of the Brazilian textbook is being written, consolidating in Praxis 4.0 what was learned in its fifteen years of development.

