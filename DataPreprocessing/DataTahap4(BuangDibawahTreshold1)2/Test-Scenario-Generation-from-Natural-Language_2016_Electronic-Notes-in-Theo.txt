representations. Petri-Nets [17] are formal models based on strict mathematical theories, they provide a mathematical simplicity for the modeling and simulation of concurrent systems and the analysis of properties by the reachability tree. The translation of textual scenarios into Petri-Net models and the generation of test scenarios from these formal models are challenging topics, because the tasks involved in these processes are costly especially if we consider large systems.

This paper is organized as follows. Section 2 describes an overview of the ap- proach. Section 3 presents the language used to write scenarios. Section 4 describes the transformation from scenario into Petri-Net. Section 5 presents the test scenario generation strategy. Finally, Section 6 presents some related work to our proposal, the conclusions, limitation and some suggestions for future work.

In our proposal, each scenario sentence (imperative or declarative) is translated into a Petri-Net node (transition or place). These Petri-Net nodes are linked by arcs giving rise to a Petri-Net model. Each translated scenario defines part of the system formal specification.

models can be used in next activities of the software development process like MBT. By formally representing a system; Petri-Net models can be used as an input to the model-based testing process, automating some repetitive and time-consuming tasks such as test scenario generation or test execution. An important benefit of MBT is automatically generating test scenarios from a formal model of a SUT [18]. The automated translation of formal Petri-Net models from RNL scenario specifications overcomes the main shortcoming of MBT, which is the formal model

A scenario starts in an initial state (Context) with all necessary Resources and Actors, and must satisfy a Goal that is reached by performing its Episodes. The episodes describe the operational behavior of the situation, which includes the main course of action and possible alternatives. An Exception can arise during the execu- tion of episodes, and indicates that there exists an obstacle to satisfy the goal. The treatment to this exception does not need to satisfy the scenario goal. A scenario, pre-condition, post-condition, constraint, episode or exception can be expressed by another scenario.

The episode sentences are simple, conditional, optional or loop. Simple episodes are those necessary to complete the scenario. Conditional episodes are those whose occurrence depends on internal or external condition. Optional episodes are those that may or may not take place depending on conditions that cannot be detailed. Loop episodes can be used as repetition structures whose occurrence depends on internal or external condition. Internal conditions may be due to alternative pre- conditions, actors or resources constraints and previous episodes. External condi- tions may be provided by external actors or another scenario.

In some cases, the given scenarios could interact by non-explicit relationships, what can lead to erroneous situations such as deadlocks. An heuristic for finding non-explicit relationships is shown in [20]; two or more scenarios are likely related when they share common portions in their descriptions, i.e., they involve the par- ticipation of common actors, they access shared resources or they are executed in the same context. Two or more scenarios could interact concurrently through the following relationships:

The system under consideration is an Online Broker System [23]. The Broker Sys- tem interacts with its partner services, Local Supplier and International Supplier. The goal of the system is to allow customers to find the best supplier for a given order. A customer fills up an online order form and after submission, the system broadcasts it to the local and international suppliers. Each supplier after examining the order may decide to decline or submit a bid. A local supplier needs to add taxes to the order total, while an international supplier needs to ensure an order does not

Nodes are linked together by arcs. Transitions or active components model the activities that can occur, thus changing the state of the system; transitions are only allowed to fire if they are enabled, which means that all the pre-conditions (input places) for the activity have been fulfilled. Places or passive components (placeholders for tokens) model communication channel, resource, buffer, geograph- ical location or a possible state (condition); the current state of the system being modeled is called marking, which is given by the number of tokens in each place. Tokens model physical or information object, collection of objects, indicator of state or indicator of condition. Arcs are of two types; input arcs start from places and end at transitions, and output arcs start at a transition and end at a place.

A Petri-Net PN is derived from a scenario S as follows: We identify the event occurrences (episodes and exceptions) and their pre-conditions (or causes), con- straints and post-conditions. For each event,a transition is created for denoting the location of event occurrence. Input places are created to denote the locations of its pre-conditions, causes and constraints (They restrict but do not impede - TRUE). Output places are created to denote the location of its post-conditions. Event la- bels, condition labels and constraint labels are assigned to these transitions and places accordingly. The initial marking M0 of the PN is then created to denote the initial state, in which tokens are added into input places that represent pre- conditions, causes or constraints. Execution of the scenario begins at this initial marking which semantically means the system initial state, including the availability of all resources, pre-condition, causes or constraints. It ends at the same marking that semantically means the release of these resources, pre-conditions, causes or constraints [20].

In order to improve the accuracy of Test Scenario Generation Strategy, it is necessary to detect and fix defects in the scenarios descriptions and the resulting Petri-Nets that can hurt Unambiguity, Completeness, Consistency and Correctness properties. If defects are found, the analysis feedback is used to improve the scenario descriptions, since the identified problems can be traced to the scenarios. If no defects are found, the resulting Petri-Nets are used to derive test scenarios. Details of this analysis strategy are presented in [22].

With Petri-Nets derived from scenarios, the reachability analysis strategy can be applied next. The reachability analysis strategy generates a Reachability Tree G = (N, A) from a Petri-Net PN = (P, T, F, W, M0), which contains reachable markings as nodes and transitions as arcs (which effect the change from one marking to another by firing). From initial marking M0, we can get an overview about possible markings (states).

