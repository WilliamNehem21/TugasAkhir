In our earlier work [10,7], we proved computational soundness of a non-confluent call-by-value calculus of records similar to the one considered here. We developed and used a diagram-based proof method based on properties that we called lift and project. This approach has been further extended and generalized to a collection of abstract diagram-based proof methods in [14]. However, the system considered

2 It is possible to add hidden components to records that cannot be referenced from outside of a record (see [10]). Records then are identified up to renaming of hidden labels. However, here we focus on computational soundness of mutually recursive components which is independent from the issue of hidden labels.

Lemma 3.4 If E1{R1} = E2{R2}, where R1, R2 are redexes, then E1 = E2 and R1 = R2. If M = E1{l1} = E2{l2} then E1 = E2 and l1 = l2 and M /= E{R} for any E and R.

It follows from Lemma 3.4 that there is at most one evaluation step in any record component. For instance, if a component is of the form E{R}, i.e. it has a term evaluation redex, it may not have a label in an evaluation context.

introduced in [7]). Two elements of the same class have the same meaning (however, they may be further distinguished by supplying a context that uses them). For instance, at the term level it is reasonable to make constants 2 and 3 be in different classes since their meaning is clearly different. However, it is common to group all lambda abstractions in the same class since a function by itself is not distinguishable from any other function until it is applied.

not mean that replacing an abstraction by any other one may be considered mean- ing preserving. One can always distinguish two semantically different abstractions by considering them in a record with a term that applies the abstraction to an ar- gument. A transformation is provably meaning preserving if its results are the same no matter what other components appear in a record. Since we can assume that any abstraction bound to a label is applied to arbitrary terms in other components, transformations must preserve the actual behavior of abstractions. [7] formalizes this notion via record contexts which we do not present here due to lack of space.

Lemmas 4.1 and 4.2 guarantee that the outcome is well-defined since every record either has a unique normal form or diverges on all evaluation paths (we identify a label bound to a black hole with divergence). The outcome formalizes the notion that the meaning of a term is the result of its evaluation.

Applicability of Other Diagram-Based Methods. The lift and project method has been extended and generalized in [14]. While it is possible that a form of the approach presented there, known as lift/project when terminating (or LPT), is applicable, we have not been able to construct such a proof.

Meaning Preservation of the Term Reduction. The meaning preservation property of a term reduction can be proven using the lift and project approach with the machinery of marked redexes and residuals. The proof is similar to that for the call-by-value calculus in [7]. See [8] for details.

Meaning Preservation of Substitution. We show that substitution pre- serves the outcome of a record. A key idea of the proof is to use the efficient evaluation strategy (see Definition 4.4) to guarantee that each component is only evaluated only once, the first time it is needed.

We have proven that the call-by-name calculus of recursively-scoped records is com- putationally sound. Our system captures the essential features of mutually recursive components. We plan to study applicability of our proof method to more complex systems with possible cyclic dependencies, such as letrec calculi and more sophis- ticated systems that model modules and linking. We will also investigate how the context method compares to other methods of proving computational soundness.

