Aspects i and ii are the subject of Part II. However, it turns out that it is possible to tackle aspect iii without previous reference to i or ii. In fact, we start by developing synthetic topology of programming-language data types in Part I, without assuming any background in classical topology and without introducing any. Part III combines ideas from Parts I and II, developing non-trivial computational applications. The main new result is a computational version of the Tychonoff theorem. We also review previously known applications and explain how topology and semantics interact in program-correctness proofs.

The first few chapters of Part I explore how the fundamental topological notions of continuous map, open set, closed set, compact set, Hausdorff space, and discrete space reconcile the finite character of computers with the infinite nature of the entities one wishes to calculate with. One of the main contributions of this monograph is to explain the computational nature of the the notion of compactness. Roughly speaking, a set is compact if and only if, given any semidecidable property, one can semidecide whether it holds for all elements of the set in finite time. Surprisingly, there are infinite computationally compact sets, for example that of infinite streams of binary digits.

The computational Part I can be read independently of the mathematical Part II. Computer scientists may use Part I as a bridge to reach Part II, and mathematicians may travel in the opposite direction. The central Chapter 3 of Part I parallels the central Chapter 3 of Part II. Part III unifies the par- allel computational and mathematical developments of Parts I and II, and concludes with some applications.

As discussed in the preface, this goes back to Brouwer. This entry of the dictionary is the main topic of Chapters 4 and 6. Before that, in Chapter 3, it is made into a synthetic definition of continuity for functions between data types.

However, one can formulate objective, operational notions of observation with mathematical and computational precision in particular circumstances, as is done in Chapter 2 and studied in Chapters 3 and 4. In particular, the difference between observable and semidecidable properties is clarified in Chapters 2 and 4, which leads to a revision of the dictionary. The expansion and revision are summarized in Chapter 5.

We are particularly interested in two subspaces of the Baire data type defined above: The Baire space is the subset B of functions that map the divergent element to itself, and non-divergent elements to non-divergent elements (i.e., the Baire space consists of the strict total functions). The Cantor space is the subset C of B consisting of functions taking values 0 or 1 on all non-divergent arguments.

We say that a subspace of a data type is (relatively) Hausdorff if its Sierpinski-valued apartness map is continuous. Again, because of the presence of the divergent element, no data type is Hausdorff. However, for example, the space of natural numbers is Hausdorff, and, as we have seen in Chapter 2.4, so is the Baire space. It follows that the Cantor space is also Hausdorff, because an apartness program for a space obviously also works for any subspace. That is, subspaces of Hausdorff spaces are Hausdorff. The same argument shows that subspaces of discrete spaces are discrete.

A subset of the space of natural numbers is compact if and only if it is finite, for otherwise we would be able to solve the halting problem. The situation changes radically in the case of non-discrete spaces, but it is still not so easy to find non-trivial examples of compact spaces. For example, the Baire space fails to be compact, as we shall see below.

What is going on here is that the definition of the quantification functional is relative to what we mean by an element of a data type, so we end up with two different definitions when we specialize it to the internal and external views. The above program satisfies one of the resulting specifications, but not the other. The statement that a predicate is universally valid with respect to the external view is stronger (but often easier to prove when it holds) than the statement that it is universally valid with respect to the internal view.

would be compact, but this is absurd because the image is the space of natural numbers, which, as we have seen, is not compact. This holds for both the internal and external views of data. For the same reasons, we conclude that any continuous image of the Cantor space in the space of natural numbers is finite if we take the external view of data. This fails if we take the internal view, with a counter-example again using Kleene trees (exercise).

Exercises 3.13 Similarly, a product of two overt spaces is overt. A product of two discrete spaces is discrete. Assuming the parallel disjunction operation, a product of two Hausdorff spaces is Hausdorff (however, for many particular examples, the disjunction operation is not needed).

Proposition 3.13.2(i) below is perhaps not so familiar to topologists, but it does have a classical topological manifestation (Proposition 3.0.16). We have seen that finite intersections of open sets are open. This generalizes from finite sets to compact sets. In fact, because Open a is a data type like any other, one can speak about its compact subsets, and hence, identifying open sets with their characteristic functions, we can talk about compact sets of open sets.

It follows easily from what is known about function-space topologies that the classical notion of compactness coincides with the one given here (Lemma 1.4.1 and Chapter 2). This seems to have been first pointed out and exploited by Taylor [131] and the author independently and from different perspectives.

The Sierpinski space is a common tool in computer science, arising as the typical space of results of observations, as already emphasized by Smyth. For other kinds of computation, e.g. non-deterministic or probabilistic, one considers different spaces of results of observations [104]. Perhaps, for compu- tational applications, one should develop topology relativized to a given space

Notice that we have taken a purely operational, rather than denotational, view of data and programs in this chapter. This is because we wanted to justify the topological view of data types from first computational principles. The denotational view occurs in the proof of Theorem 4.2.1 and in Chapter 2 and is briefly introduced in Chapter 1.

In Chapter 2 we introduced a data language, for a given base programming language, in order to make sense of programs computing with data coming from the external environment. Because we have function types in the lan- guage, we have a notion of function coming from the environment. We prove that the functions that come from the environment are precisely the classic- ally continuous ones, where the notion of open set is defined relatively to the environment, rather than relatively to the programming language as in the previous chapter. The idea is that the classically open sets are precisely the observable, not necessarily semidecidable, properties. Our base programming language is PCF++ and our data language is PCF++. Human beings write

Notice that (ideal or human) observers can externally compute parallel- or by observing (the external effect of) computations of pairs of programs of type Bool. This is true for the existential quantifier as well, if we either assume that we are allowed to have access to countably many copies of the PCF black box that computes the input predicate, or else we are allowed to restart and abort computations of the black box. Hence we advocate that it is reasonable to take the observation language (or data language) to be PCF++ even if we choose our base language to be PCF rather than PCF+ or PCF++. From the point of view of recursion theory, parallel-or and the parallel existential

have argued using a domain-theoretic model of the language which is known, by mathematical means, to have this classical closure property, whereas in Chapter 3 we constructed programs to implement the operations in the count- able case (Proposition 3.4.2) and the overt case (Proposition 3.13.2(ii)). But, because in classical topology all sets are overt (Lemma 1.5.1), the closure property established via the model also holds synthetically within the data language, using Proposition 3.13.2(ii). In order to exploit the closure property implemented by this proposition, a collection of open sets has to be presented

The converse of Corollary 6.5.2 fails badly. Because we have ten fingers, we illustrate this using decimal notation, but the readers should convince themselves that the choice of base is unimportant, as long as it is an integer bigger than 1:

nected sets to connected sets, g(x) is a closed interval if x is, and hence g is well-defined, and it is clearly an extension of f is the sense of the above diagram. Moreover, direct-image formation is easily seen to preserve filtered intersections (i.e. directed joins in the interval domain), and hence g is Scott continuous.

In the classical formulation of topology, the notion of open set is taken as primitive, in the sense that all other topological notions are reduced to it. In the synthetic formulation developed in this chapter, the primitive notions are those of Sierpinski space of truth values and of continuity of maps. The fruitfulness of this change of perspective is illustrated in Chapters 3 and 4 of Part I, where the synthetic notion of continuity naturally varies in interesting ways. The reason this works is the striking fact that the Sierpinski space has

Firstly, one can avoid quantification over all spaces Y in the definition of exponentiability of X: As stated in Lemma 2.1.5, it turns out that a topolo- gical space X is exponentiable if and only if the single exponential SX exists. Moreover, in this case, the topology of Y X , for any space Y , is determined by the topologies of SX and Y as follows. For any topological space, let

We have seen that there is a bijection from the lattice of open sets O X of X to the set C(X, S) that sends an open set to its characteristic map. We transfer names of properties of topologies on C(X, S) to O X via the bijection. So, for example, a topology on O X is called exponential if the corresponding topology on C(X, S) is exponential.

Hence every locally compact space is core-compact. Moreover, among Hausdorff spaces (and more generally sober spaces), core-compactness coin- cides with local compactness. As it is well known, a careful formulation of the notion of local compactness is needed in the absense of the Hausdorff separa- tion axiom: We mean that every point has a base of compact (not necessarily open) neighbourhoods. The following is an immediate corollary.

If SX exists, then its topology induces one in 0 X via the bijection of S-valued continuous maps with open sets. We refer to this as the exponen- tial topology of 0 X (as we did in Chapter 2.5). The following proposition generalizes the fact that finite intersections of open sets are open.

there. In particular, functions and operations are generalized in such a way that they coincide with those of real numbers in the extended world. So, for instance, if yx is an exponential of real numbers calculated in the world of complex numbers which happens to be real, then it coincides with the exponential calculated in the world of real numbers. An interesting example of an application of the conservativity of the extension is the extraction of roots of cubics: There is a formula for obtaining the three roots of a real polynomial of degree three with real roots, but the formula explicitly manipulates imaginary numbers on its way to its final real result.

For the sake of completeness, we include a complete proof of Lemma 4.1.1 using quasi-spaces. An advantage of quasi-spaces is that they simplify the un- winding process described in Remark 3.0.6. Moreover, the proof of Lemma 4.1.1 becomes a triviality once the definitions and constructions are formulated. A disadvantage of quasi-spaces is that quasi-topologies are proper classes rather than sets.

To construct a quasi-space, we start with a set B of points, and, for each topological space X, we choose which functions from points of X to B we want to be continuous. But the chosen continuous maps have to interact with the existing continuous maps of topological spaces in the expected way. The details are as follows.

maps, using the axioms for designated continuous maps, those for continuous maps of quasi-spaces, and Lemma 4.2.1. In view of these facts and conven- tions, we can generally allow topological spaces not to wear their quasi-space hats without any danger of confusion.

language. From a computational point of view, this is the main topic of Chapter 1. In particular, we show that the data types of the programming language considered in Part I are densely injective spaces, and from this we conclude that the computationally defined function types of Part I coincide with the topologically defined exponentials of Part II.

be seen either as special kinds of partially ordered sets, or as special kinds of topological spaces. To move from the order-theoretic view to the topological view, one takes the Scott topology of an order, and, in the other direction, one takes the specialization order of a topology. We have already met some examples, such as the PCF types, the Kahn domain and the interval domain. We now look at these and other examples in more detail.

In programming-language semantics, the order-theoretic view is emphas- ized. For the applications we have in mind (e.g. Chapter 2), the topological view is crucial. In any case, what makes domain theory a rich subject is the interplay between order-theoretic and topological notions.

with join in U already has a member in U . If we think of U as a test, the first condition says that if something passes the test then so does anything more defined, and the second that if the ideal result of a computation passes the test then some concrete partial output of the computation already passes the test. That is, the test can be observed at a finite stage of the computation.

non-bottom arguments but map bottom to bottom, are not finite. This gives examples of finite elements which have non-finite elements below them in the information order. Notice that we defined in Chapter 3 the Baire space to be the subset of the Baire domain consisting of functions that map bottom to bottom and natural numbers to natural numbers.

Of course, this was just the beginning of work on programming-language semantics, and many more languages and mathematical models have been in- vestigated. From our perspective, the Scott model has the advantage of being intrinsically topological in nature, as Scott proved and emphasized right from the beginning. However, we observe that the synthetic topology developed in Chapter 3 is model-independent. In fact, we deliberately based the theory on operational grounds, in order to make it clear that the topology is there independently of what mathematical model one favours. This is particularly important in the absence of the parallel operations, in which case fully abstract models look very different from the Scott model.

Some historical notes on domain theory have already been given. Detailed notes can be found in [55] (see also [68] regarding function spaces). The- orem 1.9.1 was formulated and proved by Scott, but it was only published as an exercise in [54] for a long time, until it eventually appeared in [55] (see also [46]). What appeared in print first was the characterization by Scott of the injective spaces as the continuous lattices under the Scott topology [111], with the applications already mentioned above.

Theorem 1.3.1 is due to Keimel and Gierz [76]. The proof given here is due to Johnstone and Joyal [69], as are the arguments given in Section 1.11. A more direct proof of the result established in Section 1.11, which avoids the characterization of the injective spaces as the continuous lattices under the Scott topology, is contained in the reference on which Chapter 2 is based.

In this chapter we give some non-trivial examples of how topology and domain theory, with the aid of denotational semantics, can be applied to develop programs and prove their correctness. We revert to the programming language Haskell, but, as in Chapters 2 and 3, the fragment considered here can be regarded as the language PCF discussed in Chapter 4. In fact, in order to establish program correctness, we treat programs in our language as PCF programs interpreted in the Scott model, as explained in Chapter 1.15. We continue from the program fragments constructed in Chapters 2 and 3. In this chapter, all results depend on the external view of data.

would need are dependent types). For simplicity, we accept this restriction but we still allow the subspaces Qi to be different, but we remark that the dependently typed program would be literally the same as the one proposed here, with a different type signature. This is the first obstacle that we face.

