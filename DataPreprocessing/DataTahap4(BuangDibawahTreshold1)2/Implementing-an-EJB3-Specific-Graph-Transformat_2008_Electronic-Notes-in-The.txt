The current paper presents a novel approach to implement a graph transformation engine as an EJB3- specific plugin by using EJB QL queries for pattern matching. The essence of the approach is to create an EJB QL query for the precondition of each graph transformation rule. Pattern matching and updating phases of a rule application are implemented in a public method of a stateless session bean by executing the prepared EJB QL query and by manipulating persistent objects, respectively.

search plans. Sec. 3 gives an overview on the EJB3 platform and on the syntax of its query language. In Sec. 4, which is the main part of the paper, we sketch how to encode preconditions of graph transformation rules into EJB QL queries. Finally, some related work is reviewed in Sec. 5, while Sec. 6 concludes our paper.

A search graph is a directed graph with the following structure. (i) Each node of the pattern is mapped to a pattern node (denoted by a solid circle) in the search graph. (ii) A center node (denoted by a hollow circle) is also added to the graph.

in the search graph. 3 The selection of one such edge corresponds to a navigation along the pattern edge in the given direction. If the navigation target of the pattern edge has an at-most-one (arbitrary) multiplicity constraint, then the corresponding navigation edge is referred to a to-one (to-many) navigation edge, and it is denoted by an arrow with single (double) arrowhead(s).

The Java 2 Enterprise Edition (J2EE) platform defines a layered architecture for scalable, distributed application development including several Java standards and APIs. An enterprise application being developed on the J2EE platform consists of Enterprise Java Beans (EJBs) as its most fundamental building blocks represent- ing business data and functionality. An enterprise application is deployed to and executed by an application server, which provides many high-level services (such as transactions, security, persistence, etc.) beyond the execution of applications.

assoc from an already declared variable old var. In the latter case, the target class of assoc defines the type of identification variable new var. Navigation is defined by path expressions old var.assoc and IN(old var.assoc), if the navigation returns a single value and a collection, respectively.

Based on the metamodel, we generate entity bean classes by using the standard object-relational mapping of [11], which can be summarized as follows. (i) A class of the metamodel is mapped to an entity bean class. (ii) The inheritance relations between classes are maintained accordingly. (iii) Each association end with an at most one (arbitrary) multiplicity constraint is mapped to a Java attribute (collec- tion) and two corresponding property accessor (i.e., a getter and a setter) methods in the entity bean class that represents the metamodel class being located at the opposite end of the association. (iv) A Java attribute id representing the unique identifier and its two corresponding property accessor methods are added to each entity bean class that does not have a superclass.

Processing to-one navigation edges. If a to-one navigation edge of type assoc connecting node src to trg is being processed, then expressions src.assoc AS trg sup and typetrg AS trg are appended to the end of the FROM clause, and a subformula trg sup.id = trg.id is also added as a type checking constraint.

Processing to-many navigation edges. If a to-many navigation edge of type assoc connecting node src to trg is being processed, then terms IN(src.assoc) AS trg sup, and typetrg AS trg are appended to the FROM clause, and a subformula trg sup.id = trg.id is also added as a type checking constraint.

Injectivity constraints are defined for such pairs of pattern nodes where one member has a type that conforms to a supertype of the other. For each such pair nodei and nodej, we add a subformula of the form nodei.id <> nodej.id.

bedded into the pattern being processed. For each embedded NAC pattern, we add a constraint of the form NOT EXISTS (subquery), where subquery is the EJB QL query that is going to be generated for the embedded NAC pattern. Note that the NOT EXISTS constraint will be evaluated to true if and only if the subquery, which would list the successful matchings of the NAC pattern has no rows.

On the implementation level, we map each graph transformation rule to a public method of the stateless session bean representing the whole graph transformation system. One such method first executes the prepared EJB QL query, then retrieves objects and links needed in the updating phase from the result list, and finally, it manipulates persistent objects. The handling of the updating phase is not men- tioned in the current paper as we use the technique presented in [3].

Our previous experiments [3,13] show that due to the same technology and the underlying relational database, this approach (just like previous EJB3-based graph transformation plugins) is able to handle models having more than 1 million ele- ments for a performance penalty of an order of magnitude (compared to a pure Java solution) in case of smaller models. Based on these experiments, our expectation for the current approach is a slightly better run-time performance, and noticeably re- duced memory consumption in the application server compared to solutions, which use pure SQL for specifying queries. As a natural limitation of the approach, it is worth to emphasize the trade-off between portability and run-time performance when database-specific query optimizations are switched on and off. In the future, we plan to carry out experiments to confirm our expectations on both the run-time performance and memory consumption aspects of our approach.

