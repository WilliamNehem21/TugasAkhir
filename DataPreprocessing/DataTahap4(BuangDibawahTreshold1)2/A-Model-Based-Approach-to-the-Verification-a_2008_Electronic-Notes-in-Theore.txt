This paper presents an approach which supports verification and model-based adaptation of soft- ware components and services implemented using Windows Workflow Foundation (WF). First, we propose an abstract description of WF workflows, and we formalise the extraction of Labelled Transition Systems from these workflows. Next, verification and adaptation are applied using re- spectively model-checking techniques and existing model-based adaptation approaches. Last, we explain how a WF workflow can be generated from an adaptor protocol.

Software Adaptation [4,7] is a promising research area which aims at support- ing the building of component systems by reusing software entities. These can be adapted in order to fit specific needs within different systems. In such a way, application development is mainly concerned with the selection, adap- tation and composition of different pieces of software rather than with the programming of applications from scratch. Many approaches dedicated to

model-based adaptation [5,8,16,19,23,25] focus on the behavioural interoper- ability level, and aim at generating new components called adaptors which are used to solve mismatch in a non-intrusive way. This process is completely au- tomated being given an adaptation mapping which is an abstract description of how mismatch can be solved with respect to the behavioural interfaces of components. However, most of these approaches are independent of the im- plementation framework, and few of them relate with existing programming languages and platforms. To the best of our knowledge, the only attempts in this direction have been carried out using COM/DCOM [16], BPEL [6], and SCA components [19].

The remainder of the paper is organised as follows. We give an overview of WF, and we define an abstract notation for WF workflows in Section 2. We present in Section 3 a simple on-line computer sale example, and the WF components it relies on. Section 4 formalises the extraction of LTSs from WF workflows. In Section 5, we focus on the verification and adaptation of WF components based respectively on model-checking techniques and model- based adaptation. Section 6 presents the encoding of an adaptor LTS into a WF workflow. In Section 7, the contributions of our approach are compared

WF belongs to the .NET Framework 3.0, and is supported by Visual Studio 2005. The available programming languages to implement workflows in Visual Studio 2005 are Visual Basic and C #. In this work, C # has been chosen as the implementation language.

The Listen activity defines a set of EventDriven activities that wait for a specific event. One of the EventDriven activities is fired when the expected message is received. Last, the While construct defines an activity that is fired as many times as the While condition is true.

{A, S , I , F , T }. This notation is overloaded for activities: for some activity A, we define X (A)= X (awf 2lts(A)) for every X in {A, S , I , F , T }. Finally, we use new s to denote the creation of s as a new (fresh) state in the LTSs we are building. awf 2lts can be defined inductively on the structure of WF activities as follows:

Initial and final states in the LTS come respectively from the explicit initial and final states that appear in the workflow. There is a single initial state that corresponds to the beginning of the workflow. Final states correspond either to a Terminate activity or to the end of the whole workflow. Accordingly, several final states may appear in the LTS because several branches in the workflow may lead to a final state. Initial and final states are respectively

The main idea is to generate the full system using parallel composition operators available in CADP (or similar tools), and then to reason on the re- sulting system using mainly visual checking and model-checking of temporal properties. Model-checking is an automatic technique that efficiently detects subtle architectural flaws. Classical properties such as liveness or safety prop- erties can be easily formalised reusing patterns [17], and then checked against the system model (LTS) using model-checkers, e.g., Evaluator [18] which be- longs to CADP.

Given a set of component LTSs (Section 4) and a mapping (Section 5.2), we can use existing approaches (here we rely on [8]) to generate the adaptor protocol automatically. This automation is crucial because in some cases, the adaptor protocol may be very hard to derive manually.

The last step in our proposal is to generate an abstract workflow from an adaptor protocol. Formalising the function lts2awf is quite tough, especially because cycles in the adaptor LTS have to be encoded with While activities which must preserve the LTS behaviour. Therefore, as a first attempt, we give in this section some guidelines for this encoding.

a cycle in an LTS is translated using a While activity. If several cycles loop on a same state, it corresponds to a single While activity. However if a cycle in the LTS contains another (local) cycle, this latter will also be translated as a While activity nested in the outmost one.

and Popescu [6] outline a methodology for the automated generation of adap- tors capable of solving behavioural mismatches between BPEL processes [1]. In their adaptation methodology they use YAWL workflow as intermediate language. Once the adaptor workflow is generated, they use lock analysis techniques to check if a full adaptor has been generated or only a partial one (some interaction scenarios cannot be resolved).

In [6], the authors chose BPEL. Both BPEL and WF languages allow to design Web services, but WF can also be used to implement any kind of software component. Their respective platforms make the implementation easier thanks to their workflow-based graphical support, and the automated generation of most of the underlying code (XML+Java in BPEL, using Java Application Server included in Netbeans Enterprise, and XML+C# in WF). In this work, we have focused on WF because it is an interesting alternative to BPEL that has not been studied yet. In addition, as a long term purpose, we want our proposal to benefit to the wide number of people that use the

As regards verification of component-based systems, recent approaches have been dedicated to the verification of software components specified us- ing LOTOS, LTSs and synchronisation networks [2,3]. These works present a method and a tool intended to application developers, to build behavioural models of Fractal components on which properties can be verified using CADP. In the Web Service area, different works have been dedicated to verifying Web service description to ensure some properties of systems [10,11,21,22]. Sum- marising these works, they use model-checking to verify some properties of cooperating Web services described using XML-based languages (DAML-S, WSFL, BPEL, WSCI). Accordingly, abstract representations are extracted from Web service implementations, and some properties may be ensured us- ing ad-hoc or well-known tools (e.g., SPIN, LTSA). Last, Mouakher et al. [20] start with a description of components using UML class and state diagrams that they encode into the B method to use its associated theorem prover, namely Atelier B or B4free, so as to perform compatibility checks. In a sec- ond step, they specify adaptors in B, and address their correctness.

This paper has presented an approach to verify WF components, and in case they cannot be directly composed, we have sketched how an adaptor protocol can be generated, and encoded into a new WF component. We have illustrated the application of our proposal in practice on a simple yet realistic example. This work is promising because it demonstrates that software adaptation can be of real interest for widely used implementation platforms such as the .NET Framework 3.0, and can help the developer in building software applications by reusing software components or services.

