We present a novel abstraction framework for heap data structures that uses graph grammars, more precisely context-free hyperedge replacement grammars, as an intuitive formalism for efficiently modeling dynamic data structures. It aims at extending finite-state verification techniques to handle pointer-manipulating programs operating on complex dynamic data structures that are potentially unbounded in their size. We demonstrate how our framework can be employed for analysis and verification purposes by instantiating it for binary trees, and by applying this instantiation to the well-known Deutsch-Schorr-Waite traversal algorithm. Our approach is supported by a prototype tool, enabling the quick verification of essential program properties such as heap invariants, completeness, and termination.

Another grammar-based approach to heap abstraction is presented in [13]. How- ever, it only supports tree data structures. In contrast, the expressivity of hyperedge replacement grammars does not only allow us to define abstractions for tree-shaped data, but also for strongly connected structures such as cyclic lists [23].

Verification of the Deutsch-Schorr-Waite tree traversal algorithm has already been considered in [7,15]. We thought it to be an interesting example for proving the practical feasibility of our approach and for comparing our results with others. For more details please consult Section 4.

Thus our approach is unique in that it offers a new, descriptive way for specifying abstractions on a wide range of heap data structures. It supports dynamic memory allocation (entailing unbounded heap sizes) and destructive updates. In addition it is easily extendable to concurrent programs with dynamic thread creation along the lines of [16].

Thus hyperedges, which are separate objects in the graph, are mapped to se- quences of attached vertices. The connections between hyperedges and vertices are called tentacles. We will not distinguish between isomorphic copies of a hypergraph. Two hypergraphs H1 and H2 are isomorphic if they are identical modulo renaming of vertices and hyperedges. A hypergraph H is called substantial if VH /= [ext H] or

Clearly our abstraction function only abstracts heap parts that are consistent with the grammar (e.g., that are binary trees). This, however, does not mean that the Juggrnaut framework is unable to handle inconsistencies, i.e., parts in the heap that violate the data structure definitions (for our tree example this could for example mean a back-hyperedge from a leaf to the root). These parts remain concrete while other heap parts are abstracted.

The Juggrnaut framework has been implemented in a prototype tool that we are employing to verify properties of pointer-manipulating algorithms. It explores the abstract state space exhaustively and can be used to evaluate LTL-formulae on the generated state space. In this paper we will focus on a variant of the Deutsch- Schorr-Waite (DSW) traversal algorithm, which traverses a binary tree by means of destructive pointer manipulation without using a stack [25]. It has already been verified in [15] and [7]. The authors of [15] prove various properties of the algorithm like structural invariance, correctness, completeness and termination while [7] con- centrates on pointer safety and shape invariants. In this section we will demonstrate that the Juggrnaut tool is able to verify these properties based on the binary tree grammar introduced in the previous section.

Employing the LTL model checker integrated into our tool we can now verify completeness and termination of the DSW algorithm. Due to the more complex situation the state space is now much larger than before but its generation still takes less than 5 minutes. When the state space exploration is finished, however, we can verify the LTL-formulae above in 10 and 21 seconds, respec- tively.

stating that every concrete heap cell is at the same position in the tree after program termination. The second line represents the induction basis. To verify this formula we need an extended marking that also keeps track of the successors of x by intro- ducing two additional auxiliary variables xl and xr. Except for this modification it works the same as the single marking from Def. 4.1.

We have presented the Juggrnaut framework for the analysis and verification of pointer-manipulating programs operating on dynamic data structures. The ab- straction mechanism is parametrized via a hyperedge replacement graph grammar that models the data structure(s) used in the program. We have shown how heap states can abstractly be represented and how abstract state spaces can be generated. Our theoretical results have been implemented in a prototype tool which allows the exploration of abstract state spaces and the evaluation of LTL formulae.

