One of the questions which comes up when using embedded domain specific languages is to what extent we can analyze and transform embedded programs, as normally done in more conventional compilers. Special problems arise when the host language is strongly typed, and this host type system is used to type the embedded language. In this paper we describe how we can use a library, which was designed for constructing transformations of typed abstract syntax, in the removal of left recursion from a typed grammar description. The algorithm we describe is the Left-Corner Transform, which is small enough to be fully explained, involved enough to be interesting, and complete enough to serve as a tutorial on how to proceed in similar cases. The described transformation has been successfully used in constructing a compositional and efficient alternative to the standard Haskell read function.

A template Haskell library which generates the values of type Grammar a and library code which combines such values at run-time to form a complete gram- mar. Out of this combined value the desired read function for the composed data type is constructed, again by library Haskell code. This whole process is described in the aforementioned paper [12].

[2], but is also more efficient (O(n2), where n is the number of terminals and non- terminals in the grammar). Here we will start from an improved version formulated by Robert C. Moore [7], which we present in a more intuitive form. Both his tests, using several large grammars for natural language processing, and our tests [12], using several very large data type descriptions, show that the algorithm performs very well in practice.

For each (mapM ) non-terminal (A) the function rules1 visits each (mapM ) of its productions; each visit results in new productions using rule2a and rule2b. They are added to the transformed grammar by the function insert . The productions result- ing from rule2a are returned (ps), and together (concat ) from the new productions for the original non-terminal A. The left-corners cache is reset when starting with the next non-terminal:

Note that the functions rule2 and insert are mutually recursive. They apply the rules 2a and 2b until no new left-corner symbols are found. The structure of the typed implementation we present in section 4 closely resembles the untyped solution above.

The type Ref is a generalized algebraic data type [10]. The constructor Zero ex- presses that the first element of the environment has to be of type a. The construc- tor Suc does not care about the type of the first element in the environment (it is polymorphic in b), and remembers a position in the rest of the environment.

The LCT is applied in turn to each non-terminal (A) of the original grammar. The algorithm performs a depth first search for left-corner symbols. For each left-corner X a new non-terminal A X is introduced. Additionally a new definition for A itself is added to the transformed grammar.

In the untyped implementation we simply used strings to represent non-terminals. In the typed solution non-terminals are, however, represented as typed references. The first time a production for a non-terminal A X is generated, we must create a new entry for this non-terminal and remember its position. When the next pro- duction for such an A X is generated we must add it to the already generated productions for this A X : hence we maintain a finite map from encountered left- corner symbols (X ) to references corresponding to the non-terminals (A X ). This

This function takes the original grammar and a left-corner symbol x as input. It yields a transformation that takes as input a Ref -transformer from the original to the new (transformed) grammar and a production for the non-terminal A X , and stores this production in the transformed grammar. If the symbol x is new (m x returns Nothing ), the production is stored at a new index (using newNontR) and the function rule2 is applied, to continue the depth-first search for left-corners. If we already know that x is a left-corner of a then we obtain an index r to the previously added to the non-terminal A X , and add the new production at this position. The function extendA X returns the TrafoE that performs this update into the environment:

The function rules1 is defined by induction over the original grammar (i.e. it iterates over the non-terminals) with the second parameter as the induction parameter. It is polymorphically recursive: the type variable env' changes during induction, starting with the type of the original grammar (i.e. env ) and ending with the type of the empty grammar (). The first argument is a copy of the original grammar which is needed for looking up the productions of the original non-terminals:

We have shown how complicated transformations can be done at run-time, while having been partially verified statically by the type system. Doing so we have used a wide variety of type system concepts, like GADTs and existential and polymorphic types, which cannot be found together in other general purpose languages than Haskell. This allows us to use techniques which are typical of dependently typed systems while maintaining a complete separation between types and values. Besides this we make use of lazy evaluation in order to get computed information to the right places to be used.

Implementing transformations like the left-corner transform implies the intro- duction of new references to a collection of possibly mutually recursive definitions. Previous work on typeful transformations of embedded DSLs represented as typed abstract syntax [3,2,4] does not deal with such complexity. Thus, as far as we know, this is the first description of run-time typed transformations which modify references into an abstract syntax represented as a graph instead of a tree.

