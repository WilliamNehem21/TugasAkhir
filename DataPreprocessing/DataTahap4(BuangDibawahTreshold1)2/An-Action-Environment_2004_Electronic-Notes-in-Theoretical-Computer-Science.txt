Some basic programming constructs (e.g., conditional statements) are found in many different pro- gramming languages, and can often be included without change when a new language is designed. When writing a semantic description of a language, however, it is usually not possible to reuse parts of previous descriptions without change.

Doh and Mosses [11] proposed a flatter modular structure for ASDs, with the description of each construct being a separate module. This new structure allows a complete language to be described simply by listing the names of the modules for the included constructs, and fully supports explicit reuse of parts of semantic descriptions. Doh and Mosses formulated their modules in ASF+SDF [10], and used the ASF+SDF Meta-Environment [6] for checking them.

The approach of Doh and Mosses was feasible, but the direct use of ASF+SDF carried a considerable notational overhead. In this paper, we in- troduce a new action semantic description formalism, ASDF, which has been designed specifically for giving reusable descriptions of individual language constructs. We also report on the Action Environment, a new environment supporting use and validation of ASDF descriptions. The Action Environment has been implemented on top of the ASF+SDF Meta-Environment, exploiting recent advances in techniques for integration of different formalisms [5], and in- heriting all the main features of the Meta-Environment. This was feasible due to the open architecture of the Meta-Environment. The Meta-Environment has a component-based architecture which allows an easy connection of new components in a fairly easy manner. In order to transform the ASF+SDF Meta-Environment into the Action Environment, a number of new compo- nents had to be defined, and plugged into the Meta-Environment. The most important ones were the components that took care of translating ASDF into ASF+SDF. In the future, further ASDF-specific components, such as a type- checker, interpreter, and compiler, are to be connected.

The development of ASF+SDF specifications is supported by an interactive integrated programming environment, the ASF+SDF Meta-Environment [6]. This programming environment provides syntax directed editing facilities for both the SDF and ASF parts of modules as well as for terms, well-formedness checking of modules, and visualisation facilities of the import graph and parse trees. The environment offers all kinds of refactoring operations at the specifi- cation level: renaming of modules, copying of modules, etc. Furthermore, a li- brary of predefined primitive data structures, e.g., Booleans, Integers, Strings, Lists, Sets, etc., is available. The library contains also a growing collection of grammars of programming and specification languages, e.g., Java, C, CASL, SDF itself, etc.

Action Semantics (AS) is a hybrid of Denotational Semantics and Opera- tional Semantics, and combines the best features of both approaches. As in a conventional denotational description, inductively defined semantic functions map programs (and declarations, expressions, statements, etc.) composition- ally to their denotations, which model their behaviour. The difference is that here, denotations are actions, and expressed in Action Notation (AN), which is itself defined operationally (originally [18, App. C] using Structural Opera- tional Semantics, later [19] in a more modular style).

The inherent modularity of ASDs comes from the design of AN, not from their explicit division into named modules. For instance, applications of ac- tion combinators remain valid (and meaningful) when the actions that they combine are enriched with new facets of behaviour; and similarly regarding the data processed by actions. The original version of AN [18, App. B] was rather large, but the revised version, AN-2 [15], is much more economical, and the size of the AN-2 kernel notation is comparable to that of the notation used in the monadic style of denotational semantics (e.g., as used in [16]).

with abstract syntax, auxiliary semantic entities, and definitions of semantic functions. The abstract syntax module had a submodule for each sort of con- struct (expressions, statements, etc.), and similarly for the semantic functions; the submodules for the auxiliary entities were similarly focused on particular sorts of data. The implementation of a previous environment for AS based on the ASF+SDF Meta-Environment, the ASD Tools [9], relied on this structure to distinguish between the different kinds of submodules.

We have previously used plain ASF+SDF for writing ASDs, as described in Section 3. The advantage of using ASF+SDF was that it allowed ASDs to be prototyped using the Meta-Environment. Furthermore other tools, like an action interpreter, action type-checker, etc., could be connected to the Meta- Environment. However, using ASF+SDF for writing small modules describing single language constructs was not optimal, and this prompted the develop- ment of ASDF. The main problems with using ASF+SDF were related to the

We are planning to implement support for working simultaneously with ASF+SDF and ASDF modules in the Action Environment such that full language descriptions are supported. Future plans also include integrating different tools into the Action Environment. Integrating an existing action evaluator will allow us to evaluate programs written in a language that we are designing. An action compiler will turn the environment into a compiler gen- erator. Integration of an existing type-checker for action semantic functions will give us a better check of the well-formedness of the ASDF modules, and thereby the correctness of the ASD of the language. All in all, the Action Environment combined with other tools should provide a particularly useful environment for developing semantic descriptions and documenting the design of programming languages.

The kernel of the Meta-Environment is completely language independent. It consists of the software coordination architecture, the ToolBus [3], which takes care of all the communication between the components that make up the Meta-Environment. The ToolBus allows a full separation of coordination and computation, it is a programmable software bus where the coordination between the components is formally described using a Process Algebra based formalism. The computation is performed within the connected components, which can be implemented in any programming language. The exchange of data between the components is based on a representation format, ATerms [4], specially designed for representing tree-like data structures. This formalism provides maximal subterm sharing and efficient linearisation operations.

Adding a layer involves some implementation effort. Of course, the compo- nents themselves have to be implemented. In a number of cases it is necessary to write ToolBus scripts, but the kernel Meta-Environment also provides a powerful button language, which can be used to connect new components and functionality. The button language enables a flexible way of adding buttons and icons to the GUI and adding buttons to the various types of editors.

The Abaco system [20] is an AS tool for programming language designers. The main components of Abaco are an algebraic specification compiler, spec- ification editors, action libraries, action editors, and a GUI. Furthermore, it offers a help system, an action debugger and facilities to export specifications to readable output. The main component is the algebraic specification com- piler, which provides syntax checking of specifications and interpretation. The Abaco system and the Action Environment have a strong resemblance, but the Action Environment offers more flexibility in adding external components by means of openness of the underlying architecture.

The action semantics of individual constructs can be presented with an object-oriented perspective [8]. Then the introduction of each syntactic sort and its corresponding semantic function is given as a class definition; the syntax of an individual construct and its action semantics are defined in a subclass that extends the class defining the sort of the construct. The use of conventional object-oriented class definitions does not allow as much to be left implicit as in ASDF, but otherwise the collections of class and subclass defi- nitions are directly comparable to collections of modules in ASDF. However, tool support for the approach has not yet been provided.

In this paper, we have presented ASDF, a new formalism for action semantic descriptions supporting reuse of descriptions of individual constructs. We have also reported on the Action Environment, a new environment supporting the use of ASDF, and explained how it is implemented on top of the ASF+SDF Meta-Environment. Two of the authors have already carried out an initial case study in the use of ASDF and the Action Environment, providing ASDF modules for all the basic constructs underlying Core ML (submitted for pub- lication).

