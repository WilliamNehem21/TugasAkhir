The Component-interaction automata language [5,15] was designed for modelling of component interactions in hierarchical component-based software systems. It captures each component as a labelled transition system with structured labels (to remember components which communicated on an action) and a hierarchy of component names (which represents the architectural structure of the component). Such features allow the language to model component interactions in fine detail while the language is still generally usable for several variations of component- based systems (with different synchronization strategies for instance). The essential definitions are briefly reminded in this section.

Lemma 5.1 can be also applied to replacement of many automata with just one automaton, one automaton with many, or a set of automata with another set. This is because a set of automata can be considered as a virtual composite automaton consisting of all (reachable) transitions of the complete transition space, as it was studied in Lemma 4.5. This idea can be applied to the following propositions too.

In this section, we focus on another interesting issue that can be regarded using a similar concept. It is the problem of independent development of components with certainty that they can be safely reused in any system where their implementation is compliant to the specification stated by their environment. The solution is based on the definition of a relationship between component specification and implementation that would assure this. Such specification-implementation relation moreover allows developers to design systems as compositions of specifications and then just search for appropriate implementations. Note that the independent implementability can be regarded as the substitutability of component implementation for its specification and hence to a certain extent, we may use the results of Section 5.

The systems with asymmetrical interpretation of input and output actions, as an output may be initiated anytime when an input needs to wait for a counterpart, are often called non-blocking systems. However, not all systems are non-blocking. Blocking systems, where both input and output are blocked in case a counterpart is not ready, are also of high interest. Majority of specification languages for com- ponent interactions focus on either the blocking strategy (Tracta [12], Wright [3]), or non-blocking strategy (Interface automata [9], SOFA Behavior protocols [14]). The Component-interaction automata [15] respect both as they are designed to model a variety of synchronization strategies.

Another approach that is worth mentioning was studied in [7,6] by Chaki et al. This work focuses on component substitutability directly from the verification point of view. The aim of the work is to provide an effective verification procedure that decides whether a component can be replaces with a different one without violating system correctness.

