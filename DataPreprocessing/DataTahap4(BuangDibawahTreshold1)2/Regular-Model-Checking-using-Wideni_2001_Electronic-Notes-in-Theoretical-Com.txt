In this paper, we consider symbolic model checking of safety properties of linear parametrized systems. Sets of con gurations are represented by regular languages and actions by regular relations. Since the veri cation problem amounts to the computation of the reachability set, we focus on the computation of R ( ) for a regular relation R and a regular language . We present a technique called regular widening that allows, when it terminates, the computation of either the reachability set R ( ) of a system or the transitive closure R of a regular relation. We show that our method can be uniformly applied to several parametrized systems. Furthermore, we show that it is powerful enough to simulate some existing methods that compute either R or R ( ) for each R (resp. ) belonging to a subclass of regular relations (resp. belonging to a subclass of regular languages).

Many protocols dealing with distributed systems are de ned in a parametrized way. It is then important to be able to model check these protocols in their parametrized version, i.e., independently of the number of processes in the sys- tem. The problem of verifying these parametrized systems being undecidable [2], we must either identify decidable subclasses [11,12,10], or provide semi- algorithms for which termination is not guaranteed. In this work, we restrict ourselves to the model checking of safety properties of linear parametrized systems and propose a semi-decision procedure that solves this problem.

Several works have been done in this direction [8,4,3,5]. In particular, Ab- dulla et al.[1] have introduced a class of unary regular relations 2 for which they characterize R by a nite transducer. In [7], we have identi ed a sub- class of regular languages called Alphabetic Pattern Constraints (APC) which can naturally be used to model parametrized systems such as mutual exclu- sion protocols. We have provided an algorithm that computes R ( ) for every APC language and every semi-commutation relation R (i.e., a relation cor- responding to a set of rewriting rules of the form ab ! ba).  This kind of

existing constructions of either R or R ( ) for each R (resp. ) belonging to a subclass of regular relations (resp. belonging to a subclass of regular lan- guages). Indeed, we prove that it simulates the construction of R  presented in

Outline. In the next section we present the main contribution of this paper: the regular widening techniques. An application of our method to the veri cation of the Burns protocol and a brief description of our tool prototype are given in Section 3. In Section 4 we show that the widening can simulate the computation of R given in [1], and prove that it computes R ( ) for every APC language  and every semi-commutation relation R.

access the critical section is represented by a token that the processes pass from the left to the right. The state of a process is then a if it has the token, and b if not. In the beginning, the leftmost process has the token, the initial con gurations are then represented by the expression = ab . The action that consists in passing the token from the left to the right can be repre- sented by the relation R = copy( )(ab; ba)copy( ) where for each L 2  , copy(L) denotes the set f(x; x) 2 (   ) j x 2 Lg. Let us try to compute the reachability set R ( ) of this system. It can be seen that for each k  0, Rk( ) = bkab , and thus there exists no index k such that Rk+1( )    Ri( )

In this section, we describe a new technique, called regular widening, that allows the automatic computation of an upper approximation of the e ect of the iteration of a regular relation an arbitrary number of times. This mechanism is based on the comparison of and R( ) and on the detection of some patterns that will be added at each application of R and which will nally produce loops in the limit language. To show the intuition, we will present gradually di erent widening principles: the rst one is the most elementary and can be used only in the cases where R and  are such that R can be applied in a unique position in . The second widening principle is useful when contains several positions where R can be applied, but R can change only one position at a time. Finally, the last principle, which is an extension of the two previous ones, is the most general and can be applied to di erent classes of systems.

each step, the e ect of the application of R is the addition of a \ " in the middle and we add 1: : 2 to the set of reachable states. We continue the application of R to the new set until convergence. At the end, if this procedure terminates, we are sure that the computed set is an upper approximation of R ( ) since all we have done is adding  1:	2. We will show later how this

 bab , we detect the addition of the letter b to the left of   and compute b ab . Notice that we have computed the exact set R (ab ) = b ab . We can see that the intersection of the reachability set with the bad con gurations (a + b) a(a + b) a(a + b) is empty. We have thus shown, using widening techniques, that the Token Ring Protocol is correct. We will see in Section 3 that the widening principles presented in this section allow the model checking of numerous mutual exclusion protocols.

In this paper, we extend the previous widening principle so that we could compute R ( ) (or an upper approximation of it) if we detect several growths between and R( ). Indeed, the applicability of the last widening principle depends on both  and R, since the situation  = 1: 2 and R( ) = 1: : 2 may occur only when R can be applied in a unique position in as it is the case in the previous example. Let us consider for instance  = a ba and R = copy( )(a; c)copy( ), then R( ) = a ca ba + a ba ca . Our widening principle cannot be used here since there are two di erent growths (the under- lined parts) due to the fact that R can be applied either to the left or to the right of b (i.e., there are two possible positions in where R can be applied). Thus, we need a more general widening principle.

valid anymore. Take as an example R = copy(c + e) (a; c)copy( )(b; d) + (a; e)copy( )(b; f ) copy(d + f ) and  = a b , then R( ) = ca b d + ea b f . We can see that our above principle is not applicable. We need then to strengthen it.

Obviously, the e ect of R is always to add one \c" to the left and one \d" to the right or, one \e" to the left and one \f " to the right. It follows that R ( ) is the set fw 2 (c + e) a b (d + f ) j jwj = jwj ^ jwj = jwj g, where jwja denotes the number of occurences of the letter a in the word w. Since we are restricted to regular languages (so that we could easily test inclusions and compute unions and intersections), we can consider as an upper approximation of R ( ) the regular language (c + e) a b (d + f ) .

 0 = r Ri1 ( ); Ri2 ( ) to the reachability set and continue our exploration by computing Ri2 +1( 0). If it is already included in the reachability set then we are done and the computation terminates, otherwise, we check whether the widening can be applied, :: :etc. For instance, consider R = copy(c ) (b; c)+ (a; c) copy(a ) and = ba , then R( ) = ca , and R2( ) = cca , we see that between and R( ) no extrapolation can be done whereas between R( ) and R2( ) we can extrapolate and obtain R+( ) = c+a .

We have implemented our widening principle in a tool based on MONA [14]. For the time being, only the elementary principle has been considered. Regular languages (resp. regular relations) are represented by nite automata (resp. regular transducers) using the library of MONA. This tool has been used to model check in a fully automatic way several mutual exclusion protocols, namely the Burns, the Dijkstra, the Szymanski, the Bakery and the Token Ring Protocols.

Proof We only sketch the proof idea (see the full version of the paper [20] for the complete proof). We compute the transducers of R, R2, R3 and R4 successively. We detect several growths between R3 and R4. Our new widening principle yields exactly the transducer R given in [1].

De nition 4.3 Let   be a  nite alphabet.  An atomic expression over is either a letter a of  or a star expression (a1 + a2 +  + an) , where a1; a2;::: ; an 2 . A product p over  is a (possibly empty) concatenation e1e2  en of atomic expressions e1; e2;::: ; en over . An Alphabetic Pattern Constraints (APC) over  is an expression of the form p1 + + pn, where p1;::: ; pn are products over . A single semi-commutation relation is a rela- tion of the form copy(  )(ab; ba)copy(  ). A semi-commutation relation is a

In the following, we are going to show that the widening techniques are able to compute the closure of APCs under semi-commutations. To obtain exact results, we use widening with test (3). The proof can be found in the full version of the paper [20].

We have described a technique called regular widening that allows, when it terminates, the computation of an upper approximation of the reachability set of a linear parametrized system. More precisely, our technique allows the computation of an upper approximation of either R or R ( ) for a regular relation R and a regular language . We have shown that our method can be uniformly applied to several parametrized systems. Moreover, we have shown that our technique is powerful enough to simulate several existing construc- tions of either R or R ( ) such as those presented in [1] and [7].

