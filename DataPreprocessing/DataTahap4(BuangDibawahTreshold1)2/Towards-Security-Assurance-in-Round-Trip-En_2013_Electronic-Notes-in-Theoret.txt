essential component to ensure that sensitive information is secure, uncorrupted, and available. Therefore, it is very important that access control becomes a first-class concern of the software development process. Overall, the general problem that motivates this research is: the need of a process for secure software engineering that incorporates access control at every stage in the software development process [39].

At the code level, a very important issue is security assurance [40]. In the context of this research, security assurance means to ensure that the code correctly implements the access control from the design. A correct implementation means that the application behaves exactly as the policy intends, allowing subjects to access application resources only if allowed by the rules in the access control design. In support of security assurance, previous work of the authors include a process to formally prove consistency between access control policies and the code that implements them [40]. The above proofs provide security assurance based in the assumption that models are the main development artifact. This premise is valid in some Model-Driven approaches, where designers create an access control policy, then code is automatically generated to implement the policy and the code is not further modified [29].

The remainder of this paper details the approach. Section 2 explains the essential concepts of the CincoSecurity module [24], which will be used as a case study to illustrate the approach. Section 3 details the proposed approach, formalizing the essential concepts and theorems for security assurance. Section 4 uses a case study based in the CincoSecurity module to develop round-trip security assurance proofs. Section 5 describes some related work. Section 6 concludes this paper.

To illustrate the proposed approach, this paper uses the CincoSecurity module as a case study to prove round-trip security assurance. The CincoSecurity module was developed by one of the authors [24] to provide access control enforcement for Java EE applications. CincoSecurity extends the standard access control capabilities of Java EE [47] with Seam [48], providing: enhanced use case implementation and modularization, fine-grained roles, resource protection, security profiles, session and authentication services.

In Round-Trip Engineering, designers create models of the system and, using a code generator, automatically create the code that implements those models. In addition, programmers can modify the generated code. Finally, a reverse engineering process parses the modified source code to re-generate the models [29].

To address this problem, the proposed approach is to enhance the typing rules of the target programming language to include automatic checkings for any rule imposed by the access control model and the security library. These typing rules should only allow modifications to the code that yield valid access control models. From these extended typing rules, one can provide security assurance in a round- trip environment, by formally proving that the generated code and models satisfy certain consistency properties.

In a round-trip engineering project, there are several essential elements: models that represent the system, mappings from models to code (code generators), code that implement the models, and reverse engineering mappings (to generate models from code). In addition, models have a set of constraints that assure that the model is valid, which are usually verified by the CASE tool utilized to create them. For instance, a constraint over a UML class model is that there must not be two methods with the same name and parameters in a class.

Definition 4.10 specifies a round-trip scheme that uses the CincoSecurity module. The code generation function takes as input a model with operations and a policy, and outputs an implementation with operations and Restrict annotations (see Section 2 for more details about these annotations). For simplicity, the text inside Restrict annotations only has the essential information of the role and operation. All of the additional syntax is removed to reduce the complexity of the example. Analogously, the reverse engineering mapping takes as input an implementation using CincoSecurity and outputs a model.

Models must satisfy a set Kcs of constraints, which ensure that all of the per- missions in an access control policy reference existing operations in the model. Similarly, the implementation must satisfy three typing rules. The first two are abstractions of typing rules found in Java: Rule (6) indicates that there must not be duplicate operations in the implementation, Rule (7) indicates that annotations must reference an existing operation (method) in the implementation. Rule (8) rep- resents an extension to the typing rules of Java, to ensure that any implementation using CincoSecurity yields only valid models when performing reverse engineering. This rule indicates that the string of every Restrict annotation must include a role name and and operation name, and the operation name must correspond to the operation referenced by the annotation.

that it is correct. Theorem 4.13 is the application of Theorem 3.7 to prove correct- ness of the scheme of Definition 4.10. To facilitate the proof, Lemma 4.11 proves correctness for the code generation mapping gcs and Lemma 4.12 proves correctness of the reverse engineering function recs.

There are several works that incorporate access control into software. At the design level, UMLSec [28], AuthUML[6], Doan et al. [17] propose extensions to UML to model different aspects of RBAC, MAC, or both. Song et al. [45] and Mouheb et al.

[25] proposes an approach for model synchronization based in triple-graph grammars (TGG) [42]. Similarly, Anjorin et al [8] synchronizes models and code using triple- graph grammars, and maps grammars to meta-models. Anjorin et al approach uses TGG at the model level and the meta-model TGG is automatically derived from the TGG of the model-level. However, this relies on the assumption that the abstract syntax tree meta-model is fixed [8]. This assumption is not valid in an MDE environment, where it is necessary to generate code for multiple languages and platforms [30,31,35].

This paper proposed a formal proof of correctness for access control models and code in a round-trip environment. Its applicability was illustrated in a case study using the CincoSecurity module. From the case study one can infer that the pro- posed approach is applicable for code generation and reverse engineering mappings, provided that models and code are sufficiently abstracted.

The future results of this work are expected to benefit code generation and reverse engineering by improving safety in the definition of round-trip engineering schemes. A reduction in the loss of information in the mappings is expected, to comply with the correctness conditions. Moreover, since the extended typing rules are associated to code, they can be incorporated into standard IDE tools. Automatic typing rule verifications in these tools are expected to reduce the probability of errors, thus improving the overall round-trip process.

