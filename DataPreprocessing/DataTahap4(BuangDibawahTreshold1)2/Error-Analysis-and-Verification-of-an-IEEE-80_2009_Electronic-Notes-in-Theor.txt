In this paper, we use the general hierarchical methodology proposed by Akbar- pour [2] for the formal modeling and verification of DSP (Digital Signal Processing) designs, to verify an implementation of the IEEE 802.11a physical layer OFDM modem [25] using the HOL theorem prover [9]. The verification is performed at all levels of abstraction starting from real, floating-point, and fixed-point number systems down to Register Transfer Level (RTL) hardware implementation. For the purpose of verification, both the design specification and implementation are mod- eled in formal logic and then mathematical theorems are proved for correctness. We were able to find a bug in the modulation block where the constellation used in the implementation did not follow the IEEE standard specification. Besides, we derive new expressions for the round-off error accumulation while converting from one number domain to the other and carry out a formal error analysis of the OFDM modem in HOL.

work. Section 3 describes details of the OFDM modem implementation to be veri- fied and the methodology used for verification. Section 4 describes the verification of RTL blocks of the OFDM system. Section 5 describes the error analysis of the OFDM modem and its formalization using HOL. The last section concludes the paper and provides hints for future work directions.

There are numerous research work done on the design and implementation of the IEEE 802.11a physical layer. Although no significant work is done about using theorem proving for the verification of the OFDM or part of the system, we still mention some important implementations of OFDM systems. In [8], a coded OFDM system was developed using the TMS320C6201 processor for telemetry applications in the racing and automotive environment. In [30] the authors developed a wire-

the result is bounded to a certain amount. He also reported on an error in the hand proof mostly related to forgetting some special cases in the analysis. This error analysis is very similar to the type of analysis performed for DSP algorithms. The major difference, however, is the use of statistical methods and mean square error analysis for DSP algorithms which is not covered in the error analysis of the mathematical functions used by Harrison. In this method, the error quantities are treated as independent random variables uniformly distributed over a specific in- terval depending on the type of arithmetic and the rounding mode. Then the error analysis is performed to derive expressions for the variance and mean square error. In another work, Huhn et al. [17] proposed a hybrid formal verification method combining different state-of-the-art techniques to guide the complete design flow of imprecisely working arithmetic circuits starting at the algorithmic down to the register transfer level. The usefulness of the method is illustrated with the example of the discrete cosine transform algorithms. In particular, the authors in [17] have shown the use of computer algebra systems like Mathematica or Maple at the algo- rithmic level to reason about real numbers and to determine certain error bounds for the results of numerical operations.

rithm have long been analysed using traditional mathematics and simulation. For instance, Tran-Thong and Liu [31] presented a detailed analysis of roundoff error in various versions of the FFT algorithm using fixed-point arithmetic. Jackson [20] analysed the roundoff noise for the cascade and parallel realizations of fixed-point digital filters. Liu and Kaneko [24, 21] presented a general approach to the error analysis problem of digital filters and FFT algorithm using floating-point arithmetic and calculated the error at the output due to the roundoff accumulation and input quantization. Error analysis is traditionally validated by comparing such theoretical results with experimental simulations.

The design flow chosen for the OFDM modem implementation under study starts from the floating-point modeling. For this OFDM modem design, the environment used for floating-point modeling is the Signal Processing Worksystem (SPW) from Cadence [5]. The second step in the design flow is fixed-point modeling and simulation. The environment used for this purpose is the Hardware Design System (HDS), which is a set of libraries from SPW. Then VHDL codes are generated automatically for the whole system using HDS also. But, for some blocks like FFT/IFFT there was no HDS counterpart and those were imported from the Xilinx Coregen Library. Some of the VHDL codes were prepared manually [25]. After VHDL code generation, these blocks are synthesized in Synopsys Design Compiler targeting FPGA as the hardware for implementation.  Finally, the

In this section we describe the verification of the RTL blocks of OFDM using HOL according to the methodology described in Section 3. The whole design is segmented into different blocks and then modeled using HOL. The resulting model is in turn set against an ideal specification and the HOL tool is used interactively to prove its correctness. In the following sections we will describe in details the verification of QAM, DQAM, serial to parallel (S/P) and parallel to serial (P/S) blocks. For the blocks described below, the corresponding abstract models, HOL models and

The function SUC takes a natural number and returns the consecutive natural number. So, SUC 0 will return 1. And, BIT x input chooses a particular bit positions from input defined in x. Now, we can state that our goal as - for all input

We use only built in tactics. The REPEAT GEN TAC tactic removes all the uni- versal and existential quantifications. Next, ARW TAC is a tactic defined using a rewriting tactic RW TAC using simpset [16] arith ss. This defined tactic is used to rewrite the the goal with the specifications and proved theorems as shown in the code segments above. We name this last proved theorem as qam imp spec correct. Having proved the correctness of qam mod2 imp and qam imp using the theo- rems qam imp spec correct and qam mod2 imp spec correct it can be concluded that the QAM is formally verified. The implementation conforms the specification given in the standard.	Following a similar approach we have proved the correctness of

Modeling of the S/P block in HOL is done in a different way than what we have seen in Section 4.1. The modeling is not exactly one to one mapping because a VHDL PROCESS is involved here. In fact, a PROCESS never terminates itself, and it can only be controlled using WAIT statements and sensitivity lists. After executing the last statement, a PROCESS will be suspended only to be resumed later on an event in the sensitivity list. This last behavior poses a difficulty in modeling it in HOL due to non-termination problem. Higher order logic is a logic of total function and it does not allow the definition of any partial function. But, there are exceptions which motivates us to define our specification for S/P in a simpler way without resorting to complex definition. For example, the following is a total and non-recursive function that uses the expressive power of HOL [16]:

The function FUNPOW is a tail recursive function from the theory arithmeticThe- ory to define function iteration. The above function does a case analysis on the iterations of function g. The finite ones return the first value at which P holds and the infinite ones are mapped to a constant named ARB that holds all the arbitrary values. ARB is a way to convert partial-functions into total functions in HOL. But, using ARB will only complicate our model without any added benefit. A VHDL PROCESS is more than a simple loop and we have no cases to deal with infin- ity rather we only have finite sets of statements to be dealt with infinitely. This discussion is to justify why we did not use certain features of HOL to model our

Apparently a simplification of the corresponding VHDL code but a little analysis will support its correct functionality. From the code, the variable cnt is a natural number whose type is defined as num; out parallel is a bool word and input is of bool type. The implementation takes three arguments where cnt is defined to keep track of the time or bit index which is a model of the signal count. The

The main purpose for using formal verification was to find bugs in the design. We did not find any bug in the blocks. But, some comments are in order. Namely, for the QAM block, it is given in the standard that the input for a 64-QAM mod-

the standard is followed exactly, then this issue might have resulted in a bug in the design. But, the standard gives some flexibility to the designers in order to have more precise results from the IFFT block, as explained before in Section 4.1. As, we were aware about it at the time of verification, we constrained the implementation using the proper number of bits. The same comments are applied to the DQAM block. For the rest of the blocks we did not find any issue like this.

terval insertion and guard interval removal. The reason is that the RTL codes for those blocks were not available for the design at hand. The guard insertion block in the transmitter side has a portion of its behavioral code but the whole code mostly contains port-mapping [3] to the IP blocks. In general, the whole design contains many IP blocks and thus the verification of the design in its entirety is not practical using any theorem-proving tool like HOL. Still, this chapter demonstrates the scope and feasibility of formal methods in a comprehensive way in parts of the OFDM RTL blocks.

The error analysis done above covers the OFDM rounding error analysis thoroughly between different number domains. To establish the complete theory of error anal- ysis we proved three main theorems with the help of formalized real and imaginary part of FFT-IFFT expansion and also the theorems related to the error for arith- metic operations. All definitions were derived heavily from existing theories, e.g., realTheory, boolTheory, ieeeTheory, floatTheory, fxpTheory, wordTheory, etc. There is a very strong relationship between mathematical models and their formal coun- terpart which might have been observed above. The definitions built on top of established theories in turn helped to build the FFT and IFFT components; which build the theory for the FFT-IFFT combinations. Then this theory is extended and the operators are overloaded for establishing the real, floating-point and fixed-point counterparts of the design using the floatTheory and fxpTheory.

a system. But, HOL strongly checks the type of the terms and functions entered into the system. This particular constraint also makes it very difficult to make simple mistakes in defining wrong theorems thus also answers partially the concern mentioned in the previous paragraph. Still, if any user wants to trick the tool to generate proof arbitrarily, he/she has to use oracle [15] mechanism that enables arbitrary formulas to become elements of the thm type. By use of this mechanism, HOL can utilize the results of arbitrary proof procedures. To avoid unsoundness, a tag is attached to any theorem coming from an oracle. This tag is propagated through every inference that the theorem participates in and if falsity becomes de- rived, the offending oracle can be found by examining the tags component of the theorem. A theorem proved without use of any oracle will have an empty tag, and can thus be considered to have been proved solely by deductive steps in the HOL logic. Thus, the tool ensures its security against misuse.

This paper is mainly concerned to demonstrate the use of formal verification tech- niques, here theorem proving, to verify an implementation of an OFDM modem based on the IEEE 802.11a physical layer standard for wireless communication. The OFDM design is fairly complex and some important design blocks were cho- sen for verification purposes. We formally modeled and verified the RTL blocks such as QAM, DQAM, S/P, and P/S against the corresponding specifications in the standard. We were able to find a bug in the QAM modulation block which implementation was diverted from the constellation provided in the IEEE standard specification.

