We present the design and implementation of a framework for interchangeable distributed algo- rithms. The algorithms are drawn from the set which includes mutual exclusion, deadlock detection and agreement protocols, and we have implemented several examples of the first tonsiswo of these. Algon cts of a library of algorithms, a framework for incorporating them into a new or existing system, and a tool for evaluating comparative performance. In this way, much of the complexity related to distributed systems can be isolated in its own component level and the programmer can choose from among different algorithms in the same class based on performance in a given applica- tion. Incorporating many algorithms in a single framework was made possible by the observation that algorithms in a given class, e.g. mutual exclusion, almost always expose the same methods. These methods interface with an Algon scheduler which maintains state and provides convenient hooks for the application to invoke the services of the algorithm.

In this paper we describe the structure of Algon in detail, with a distributed deadlock detection algorithm as the case study. We then extend the notion of separation of concerns by creating an addition layer in Algon, underneath which the middleware that runs on each node can be interchanged, for example from Java-RMI to CORBA. Challenges in the re-tooling of the system, related to multiple inheritance, exceptions and the automatic generation of stubs and skeletons in our implementation language, Java, were overcome in novel ways. Algon has the potential to be a framework with a long life, as it can adapt to new middleware, such as .NET.

Many programmers have been trained to develop on workstations and find the complexity of the distributed paradigm hard to handle. Middleware technolo- gies hide much of the detail involved in achieving language interoperability and simplify maintenance, but they also introduce easily missed complexities that isolated systems seldom exhibit [7]. In addition to the normal cognitive and abstract nature of the programming activity itself, concerns in a distributed environment include non-determinism, contention and synchronisation issues [12]. Programmers may be faced with a need to guarantee distributed mutual exclusion, to achieve distributed termination, or to detect deadlock, for exam- ple. There already exists a rich base of research from the 1980s and 1990s for solving such problems. A range of algorithms has been classified according to their function and each algorithm achieves the expected result in a different way and with different performance characteristics. However, the exact im- plementation of the algorithms in a particular programming language is often left unspecified [26,27]. The programmer is therefore faced with

responsibility and control. Separation of concerns also allows the programmer to decompose software into smaller, more manageable parts that are easier to keep up to date with evolving needs [18]. This technique has been applied to other aspects of distributed applications [6], and to separating algorithms from parallelism [29] but not as yet to distributed algorithms.

Section 2 describes the architecture and general design rationale of Algon. Section 3 describes how the Algon framework has been used to make different kinds of algorithms available. Section 4 describes the mechanisms used to make the middleware level interchangeable. Section 5 explains how Algon is used to support decisions about algorithm choice. Section 6 considers related work, and Section 7 concludes.

The Algon system aims to directly support monitoring of the system. The developer needs to be able to monitor system activity from a central point. It is necessary to provide the developer with a central display and control interface so that he/she can not only observe but also directly control activity in the system.

The failure of the AlgonNameServer during system setup will cause the system to fail but failure after the initial setup will not affect the system in any way. We are aware that this single point of failure may be seen as a weakness in the system. It is, as is common in distributed systems, necessary to weigh up the advantages of having a dynamic registration mechanism with a single point of failure against a static inflexible failure- resistant naming system. We felt the former to be the better design choice. It is a relatively simple matter to replicate the AlgonNameServer, and this will be done if the need arises.

The whole Algon distributed layer and associated components have been de- veloped with the philosophy that if an exception is caught the system will try to continue to function regardless so as to not interfere with the functioning of the application. Algon will therefore run with reduced Algon functionality in order not to sabotage the continued running of the controlling application. The following section shows how the Algon principles have been applied to incorporate distributed deadlock-detection algorithms.

and zero or more optional resources, RSi. The Scheduler used for this algo- rithm is different from the Scheduler used for the Mutual Exclusion algorithms because of the specialised functionality that each Scheduler has to support. The Scheduler for deadlock detection algorithms is called the DDScheduler.

The algorithms and techniques that have been developed for use in distributed systems have been traditionally divided into five classes, namely mutual exclu- sion algorithms, deadlock detection algorithms, agreement protocols, resource management techniques and failure recovery techniques [26]. An algorithm is placed in one of these classes based on the effect which the algorithm achieves. Examining the implementation of the algorithms in a specific class reveals an interesting feature: they all expose the same methods. For example, the algorithms in the mutual exclusion class expose the methods enterCritical- Section, executeCriticalSection, and leaveCriticalSection. Deadlock detecting algorithms all expose the detectDeadlock method. By virtue of this feature, we can abstract away from the implementation details of all the algorithms in a class by having them all conform to one clean interface. This also simplifies the process of replacing the implementation that an application uses, without changing the application itself.

An attempt to make the remoteness of the invocation transparent is bound to fail, however, because of the very real difference in the failure semantics of local and remote invocation. The programmer is therefore forced to make pro- vision for possible failure of distributed components of his/her system, or the network linking him/her with that system, for remote invocations. Java forces the programmer to do this by ensuring that java.rmi.RemoteExceptions are thrown by all methods in a class which will be used remotely.

In order to explain the problems experienced in making the system middle- ware-independent we will expand upon the inheritance structure of Algon algorithms in Section 4.1, then discuss the difficulties in Section 4.2 and end off by introducing the AlgonRmic tool, which simplifies the process for the programmer, in Section 4.3.

system the specialisations of the Algorithm class also extends the java.rmi.server.UnicastRemoteObject and Remote classes. This ensures that the algorithms can have stubs generated for them and that the stubs can be distributed via the java.rmi middleware infrastructure. However, if we want to make the system middleware independent we can no longer have a java.rmi-specific implementation at such a high level in the system. We need rather to become middleware-specific at as low a level as possible and to generalise the upper inheritance structure.

exception, or a subclass of that exception [16]. On the other hand, a method in a subclass cannot throw an exception unless its superclass method throws an exception of the same type. This feature has both advantages and disadvantages. On the one hand it is valuable to know what exceptions could be thrown by the methods of a Java class. On the other hand, the current restrictions prevent programmers from easily adapting systems in response to evolving needs.

There is a way to work around this problem. We cannot change the fact that the java RMI middleware-dependent algorithm throws a RemoteException. Therefore we have to ensure that the the Ment interface (which the algorithm implements) throws an exception of type Exception, which is a supertype of RemoteException. Exception is also a supertype of all other exceptions thrown in Java so that it will also act as a supertype for exceptions thrown by any Java-based middleware system. The implication of this is that the middleware-independent Algorithm has to catch and process exceptions for each of the Ment interface methods. This is not an unrealistic expectation, since the algorithms are essentially distributed components, and this fact will cause them to fail occasionally for different reasons. It is as well if the Algon system accommodates this reality of distributed systems.

Since the place holder classes (such as RmiMentAlgorithmImpl) are es- sentially middleware-dependent proxies for the actual algorithms, they are generated by a tool for java.rmi called AlgonRmic. For an interface such as Ment, AlgonRmic compiles the interface, and runs rmic on it so that the stubs and skeletons are ready for use by any algorithm implementing that interface.

Classifying Algon in order to draw comparisons with related work is not trivial. It has some similarities to reflective systems, and certainly applies separation of concerns techniques. It is also a very specialised programmer tool. A reflective system typically reasons about itself, and then acts upon itself based upon such reasoning [15]. This definition has been applied fairly loosely to

identifying the specification of concerns and allowing the programmer to specify each concern in a separate object. This can be done using prox- ies at compile-time [22] or by using reflection at runtime [30]. Another approach is the definition of aspects and the use of aspect-oriented pro- gramming [8,9]. Aspects are designed to address cross-cutting concerns across code. An aspect weaver then merges the aspect with the code to generate code where the concern is dealt with in a uniform way [21]. Zhang and Jacobsen have applied this to middleware architecture [31].

ing innovative for its time, Garf has two shortcomings: it was implemented in Smalltalk which limits its applicability, and it does not attempt to offer a choice between different implementation techniques. Algon addresses dis- tribution issues, as does Garf, but from an algorithmic perspective. Rather than providing a library of functions to be used blindly, Algon recognises the differing nature of distributed systems and offers programmers the capacity to tailor their systems accordingly.

In the development of the Algon framework, we have implemented three popular algorithms for achieving distributed mutual exclusion and for detect- ing deadlocks. These, however, form a very small subset of the algorithms proposed in the domain of distributed computing. Future work will include the implementation of a representative number of algorithms and techniques from all the aforementioned categories.

We have also outlined a technique for allowing interchangeable middleware. We have reason to believe the we will be able to extend the techniques out- lined to other types of middleware as well. This work is ongoing. Thereafter we will extend the performance visualisation interface, currently tailored to reflecting algorithm performance, to assist in judging the performance impact of a specific middleware on an application. We also envisage a C# version of Algon in which CORBA can be interchanged with .NET or any other future middleware system. The lessons learnt through this research include practical aspects of software composition, the impact of language features on system design and issues associated with evaluating complex systems at runtime.

