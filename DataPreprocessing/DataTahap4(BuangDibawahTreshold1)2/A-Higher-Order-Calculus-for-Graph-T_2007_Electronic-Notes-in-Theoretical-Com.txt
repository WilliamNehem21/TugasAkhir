Rule-based transformations of graphs have been used in many areas of computer science, including the specification and development of software systems, the defini- tion of visual languages, the implementation of programming languages (see [5,25]). The notion of interaction, which can be seen as a particular kind of graph trans- formation, has been used to model concurrent systems [23], to give a semantics to (linear) logic proofs [11], as a programming discipline [17], and as an implementation technique for functional languages [3]. In each case, a syntax and an operational semantics (a calculus) has been defined, often independently.

Another aspect where the higher-order syntax presents advantages is for struc- turing and modularizing programs defined by graphs (or nets). Hierarchical defini- tions are very useful in the framework of graph rewriting [4], and the same techniques can be exported to interaction nets using the higher-order syntax. In particular, the operation that combines two interaction nets to produce a new net where one or more edges have been connected together (the analogous of application in functional programming) is currently a meta-operation. We show how to internalize it using the higher-order language, and give examples where this technique is used to write modular programs. Once we have the ability to model the combination of nets, it is straightforward to express a notion of higher-order interaction nets, where a net depends on another net. As with functional programming, this technique can be used to write recursive nets: nets which depend on themselves.

Organization. Section 2 briefly reviews CRSs, graph and term-graph rewriting, and interaction nets. Section 3 introduces the syntax of our higher-order systems, and Section 4 shows how to represent graph and term-graph rewriting systems, interaction nets, interaction systems and non-deterministic nets. In Section 5 we then go on to define different sets of higher-order rules. Section 6 contains a simple example of application. We conclude the paper in Section 7.

The metavariables in metaterms can be thought of as holes that must be instan- tiated by terms. In other words, rules act as schemes defining a reduction relation on terms. Formally, to define the rewrite relation we have to consider a notion of substitution using substitutes and valuations.

Note that left-hand sides of rules may contain patterns of the form Z(t) where Z is a meta-variable and t a term. This will allow us to write contextual rules (such as the optimization rules in Section 5). The Context-sensitive Reduction Systems defined in [14] allow this use of metavariables.

Proof Nets of Linear Logic. The encodings of proof nets in interaction nets that can be found in the literature are of two kinds: either boxes (which are nets containing nets) are defined by agents which contain a proof net as label, therefore we need an infinite set of agents in the system (see for instance [18]), or a first-order encoding of binders is used to model the box and its contents, and this can be done with a finite number of agents (see for instance [21]). In the first case, the Dereliction Cut Elimination step is performed in one rewrite step, using an infinite rewrite system, whereas in the second case it is performed in several steps using a finite system.

We have shown a higher-order rewrite framework which can express several systems of graph reduction. The power of the framework can be seen for the particular case of interaction nets, where we can write a program together with its evaluator, all in the same language. We see two main uses of this framework. First, as a tool for the design and implementation of graphical languages: the language, its semantics and metaoperators, can all be defined using the same language. Second, as a tool for adding structure to graphical programs: the higher-order features can be used to write hierarchical systems, and to name and reuse different components of the program.

