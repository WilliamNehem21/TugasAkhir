software components, where each component can in turn be composed of other sim- pler components. The encapsulation here means that the programmer only needs to know what each component does (the semantics), without worrying about how this is done (the implementation). Object oriented languages such as Java [16] are based on this concept, allowing the definition of flexible, extensible, and reusable software components, thus saving time and avoiding errors in the final program.

A declarative debugger starts when the user finds out some unexpected behavior while testing a program, i.e. an initial symptom. Then the debugger builds a tree corresponding to the computation that produced the initial symptom. Each node of this tree corresponds to the result of some subcomputation, and has a fragment of program code associated, namely the fragment of code needed for producing the result. The children of a node correspond to the results of those subcomputations that were necessary to obtain the parent result. In particular the root of the tree corresponds to the result of the main computation. The user navigates the tree looking for a node containing a non-valid result but whose children produced valid results. Such a node is considered a buggy node and its associated fragment of code is pointed out as erroneous because it has produced a wrong output result from the correct input results of its children.

In this paper we apply the idea of declarative debugging to the object oriented language Java. Starting from some erroneous computation, our debugger locates a wrong method in the debugged program. The task of the user during a debugging session is reduced to checking the validity of the results produced by some method calls occurring during the computation. Thus, our tool abstracts away the details of the implementation of each method, deducing the wrong method from the intended semantics of the methods and the structure of the program.

The idea of using declarative debugging out of declarative programming is not new. In 1989 N. Shahmehri and P. Fritzson presented in [13] a first proposal, further developed by the same authors in [5]. In this works a declarative debugger for the imperative language Pascal was presented. The main drawback of the proposal was that the computation tree was obtained by using a program transformation, which limited the efficiency of the debugger. The differences of our approach w.r.t. these earlier proposals are:

Modern languages such as Java offer new possibilities for implementing the declar- ative debugger. In our case we have based the implementation of our prototype on the Java Platform Debugging Architecture (JPDA) [7]. JPDA has an event- based architecture and uses the method-entry and method-exit events in order to produce the computation tree. The result is a much more efficient tool.

A more recent related work [6] presents a declarative debugger for Java that keeps information about most of the relevant events occurred during a Java computation, storing them in a deductive database. The database can be queried afterwards by the user in order to know the state of the program (variables, threads, etc.) in different moments of the execution in order to infer where the bug is located. The main difference between both proposals is that our debugger concentrates only on the logic of method calls, storing them in a structured way (the computation tree) which allows the debugger to deduce the wrong method from the user answers.

In the next section we present the application of the ideas of declarative debug- ging to the case of Java programs. Section 3 introduces the idea of using a test-case generator in order to reduce the number of questions that the user must answer before finding the bug. In Section 4, we discuss the limitations of our prototype. Finally the work ends presenting some conclusions and future work.

We start by defining the structure of the computation trees used by our debugger. Since the aim of the tool is detecting wrong methods in Java programs, each node of the tree will contain information about some method call occurred during the computation being analyzed. Let N be a node in the computation tree containing the information of a method call for some method f . Then the children nodes of N will correspond to the method calls occurring in the definition of f that have been executed during the computation of the result stored at N . For example, consider

This structure of the computation tree guarantees that a buggy node, i.e. a non- valid node with valid children, will correspond to a wrong method and that therefore the proposed debugging technique is correct. However checking the validity of a node in a Java computation tree is far more complex than for instance in a functional language. This is because apart of returning results, methods in object-oriented languages can change both the caller object and the parameters states. All this information must be available to the user at the moment of the debugging session in order to detect the validity of the nodes. Hence the information stored at each node of our computation trees will be:

As we have seen, some of the questions that occur during a debugging session can be very complex. Notice however that the same questions will occur implicitly during a debugging session using a normal trace debugger. Moreover, the use of the declarative debugger facilitates the debugging process by allowing the user to compare the input and output values of each attribute and parameter modified in a method call. The directed navigation also helps by reducing the number of questions to those nodes with a non-valid node (5 questions out of 23 nodes in the example). Two additional features of the tool can be used to further reduce the number of nodes that the user needs to check before finding the erroneous method:

GlassTT is based on a symbolic Java virtual machine (SJVM) and a system of constraint solvers. The SJVM executes the Java byte code symbolically. The input parameters are understood as a kind of logic variables whose values are not yet known and which will be described by constraints which appear during the symbolic computation when a branching instruction is encountered. In this case the SJVM will check with the help of a system of constraint solvers which alternatives remain valid. These alternatives will be tried one by one using a backtracking mechanism. The SJVM contains in addition to the heap and frame stack of the usual Java virtual machine some components which are known from abstract machines for logic programming languages such as the Warren Abstract Machine (WAM) for Prolog [2,17]. In particular, it provides a choice point stack and a trail. These components

Let D1,. . . , Dn be the sets of def-use chains corresponding to the previous n calls of the considered method, and let D be the set of def-use chains covered by the considered call to that method. Analogously, let E1,. .., En be the sets of edges of the control-flow graph covered by the previous n calls of the considered method, and let E be the set of edges covered by the considered call to that method. These pieces of information give us a couple of options, how to combine them. Depending on how conservative we want to be, we can infer that a considered call works properly, if

Another limitation of our prototype is that it only indicates a wrong method rather than the buggy statement in that method. We could switch to a trace debugging mode for finding the error more precisely. However, a well-designed program should not contain long methods. Thus, it should not be a problem to find the erroneous line in the indicated method.

Moreover, there are some difficulties when debugging event-driven computations. Methods such as actionPerformed are not called directly from main or some other own method but implicitly from the event-processing mechanism. We can only record and process the computation tree below the call to such a call-back method. Surprisingly, our prototype is useful for debugging non-terminating computa- tions, too. Here, the user must abort the program and the debugger will show the partially constructed tree. Some of the nodes will not contain a result, but others will and they can be used for debugging. Something similar happens, if the program

