Advances in technology, such as networking and parallel processing, have enabled the development of distributed and concurrent systems. Most of these systems consist of subsystems, which can be independent or autonomous. In some cases, there is a need to allow a subsystem, who is sending a message, to continue with its tasks without waiting to determine what happened to the message. All these give the whole system an asynchronous characteristic.

channels (without losses or delays) used in the theory are not present in real systems. Therefore, testing tools need to handle systems with imperfect channels. In the same way, if some subsystems rely on external choices, tools for testing those subsystems need to handle non-determinism.

Our practical approach aims to make testing theory accessible to practitioners. To address this goal we, first, bring the system under test (SUT) and the testing tool to work together in an on-line approach. Although this approach is present at some extent in available tools, we have extended capabilities already present in these tools to make this approach to work in black-box testing environments. This is, we deal mostly with available interfaces rather than internal workings of the system. Second, we extend existing tools to implement theoretical knowledge on how to handle asynchronous communications. We deal not only with communication delays but also communication losses which are less common in the literature. Finally, we rely on abstract models to drive the testing process.

The rest of this paper is organised as follows. In section 2 we describe a small sys- tem that serves as a running example to clarify the concepts we introduce through sections 3 and 4. Section 3 introduces notations and definitions for event struc- tures used to model asynchronous distributed systems. In section 4 we describe the process that allows asynchronous testing of distributed systems, and in section 5 we present details of a particular implementation of this process by using existing testing tools. Then, section 6 shows an example of testing a more complex asyn- chronous distributed system. Finally, a brief description of related work and our conclusions are shown in sections 7 and 8.

This system is asynchronous in the sense that the sender does not need to wait for the receiver to accept or reject a file. The sender can send a file and then another one before he observes any action executed by the receiver. Such behaviour can also be represented into a graph by interleaving the actions related to each of the files being transferred.

Different kinds of event structures have been defined in the literature derived from the classical ones introduced in [10] and [16]. The particular event structure model that we consider was introduced by van Glabeek and Plotkin in [14] and has been adapted to suit our purposes. Before we define this event structure, some preliminary concepts need to be introduced.

In distributed systems we can easily distinguish different components of the system because of their location. As mentioned before, in general, we can assume there exist two parts in these systems. There is one part whose actions we can control and there is another part whose actions we can only observe. We have described before a behavioural model that describes events that occur in both parts of the system.

we also cannot produce beforehand a list of actions to be executed because some ac- tions will become enabled (or not) depending on the (non-deterministic) responses of the other part of the system. Thus, we define two algorithms, test generator and execution observer, which run in parallel during the testing process. Both ex- ecute independently but communicate (and synchronise if necessary) by accessing two global structures, a queue Qc of controllable events and a set So of observable events.

SmartMBT takes as input a labelled transition system that specifies the behaviour of a software system. The testing process is driven by the model. The model provides the testing tool with a set of enabled actions calculated from its current state. Usually, every action in a LTS model will be available for execution sometime. As we discussed before, that is not the case for asynchronous systems. There exist observable actions, which the SUT executes independently, usually in response to other actions. These actions should not be executed by the testing environment, therefore should not be included in any set of enabled actions. However, they should be part of the model because they actually update the state of the SUT (and of the model). We included a mechanism that allow the modeller to tag observable actions, and the tool to recognise them.

This module is completely new in the testing tool. It has the ability to observe which (observable) actions have been executed in the SUT, usually in response of actions executed by the generator. This module implements our execution observer algorithm. It runs into a separate thread and is activated each time an action comes through the communication channel. Controllable actions are discarded because the generator retains the responsibility of updating the state of the model in this case. Observable actions are processed exactly as in the algorithm. This module relies in an extension of the client module which is explained next.

In this paper we have shown our extensions to existing testing tools to allow auto- mated testing for asynchronous systems. This extensions are based on sound theory available in the literature. We have shown via an example that these extensions can handle real systems such as an implementation of the FIX protocol. We believe that our choice of event structures as the underlying model jointly with an on-the- fly approach for test case generation and execution is a step forward preserving concurrency in asynchronous testing.

