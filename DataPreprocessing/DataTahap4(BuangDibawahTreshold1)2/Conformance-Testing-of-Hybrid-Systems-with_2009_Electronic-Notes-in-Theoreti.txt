In this paper we focus less on test case generation but more on test execution and conformance checking. The test case generation part can be found elsewhere [4,3,5]. To prove the applicability of our approach we further present a case study. In this case study the conformance relation is used to show that mutants of a Simulink model can be detected using the automatically generated test cases.

Next, Section 2 motivates our work by a running example of a hybrid system. Section 3 introduces to the AI-technique of qualitative reasoning and to the corre- sponding qualitative models. In Section 4, we formalize the conformance relation between qualitative models and hybrid implementations. Then, in Section 5 we discuss our test case generation and execution technique, including the mapping between the abstract and the concrete domains. Section 6 covers experiments of the case study. Finally, in Section 8 we relate to our work, draw the conclusions and give an outlook to future work.

When modeling systems using QR one abstracts the domain of continuous, real valued variables of a system to the domain of points and intervals. A point, called landmark, is a boundary between intervals. An abstract domain is called quantity space (QS). For instance when we consider the temperature of water from a quali-

The tool Garp3 supports the building and inspection of QR models. Its foundation is Qualitative Process Theory [9]. A detailed description of the functions can be found in the user manual [2], and there is an elaborate user guide [7] for building QR models.

An initial version of a conformance relation between QR models can be found in [5]. It is based on the input/output conformance relations by Tretmans in [21]. QR models as abstractions of continuous systems are strongly responsive, i.e. for every input exists an observable output, hence there is no need to deal with quiescence

S. For the third input trace [1], [3] the last input i1 = 3 is not specified in S. Due to implementation freedom the behavior following unspecified inputs is not considered by the conformance relation. For I2 we get I2 after [1], [2] = s1, s2 . However, the outputs out( s1, s2 ) of I2 are not a subset of out(S after [1], [2] ). Hence I2 is not qrioconf S.

Test cases have to be controllable, i.e. the tester has no choice between different inputs that can be applied to the implementation or between applying an input or observing outputs. In previous work we used this form of input controllability which leads to several test cases per CTG. In Section 5.2 we discuss why an adaptive input selection is preferable, in our case. Since inputs and outputs are coupled and occur alternately we only have to deal with the selection of inputs.

For offline test case generation we need envisionment simulation, i.e. the sim- ulation of all possible futures starting from an initial scenario.  This can lead to quite big state spaces. In order to deal with the state space explosion prob- lem the simulation engine can be constraint to produce fewer possible futures. Another option is to state additional constraints between quantities that reduce ambiguities. For instance in a two-tank-system the information that one tank is higher than the other can be expressed by a constraint between landmark values: Tank1.Height > Tank2.Height.

The approach also allows specifications to be approximations rather than ab- stractions. Consider a QR model M1 that is a direct abstraction of an underlying continuous system M0. Then we can remove constraints (relations) from M1 and the resulting model will still be consistent with all behaviors that can occur in the models below it, i.e. M0 and M1.

In behavior traces of a QR TS inputs and outputs are coupled. In order to stay within the specified domain of the QR TS inputs cannot be selected independently of outputs between state transitions. Otherwise the probability increases that an input trajectory leads out of the specification and to inconclusive verdicts. Hence when we leave a state because of an inconsistency with one of the inputs or outputs we filter the set of successor states due to states that are consistent again. By removing states that are output-consistent but not consistent with the inputs the filtering also resolves input conflicts. Because the Complete Test Graph (CTG) contains no controllability conflicts we can extract only one test case from it which is the CTG itself. In order to test different system behaviors one has to write according test purposes and simulate the system with different initial scenarios.

Due to the nondeterministic behavior of the implementation obtained test cases are transition systems with possible loops. The implementation can decide which branch in the test case is taken next and how many iterations a loop is run through before taking a transition which exits the loop. A test case has two types of final states: accept and inconclusive states.  A third type, which is not represented

explicitly, is the fail state. It can be reached from any state that is not final by completing the inputs with unexpected outputs. In an accept state the behavior of interest has been observed and from an inconclusive state the test purpose can never be satisfied.

The repeat-until loop from line 16 to line 24 sends inputs to the implementation and observes outputs from the implementation. We stay in the current state as long as there is no valid successor and the applied inputs and outputs are consistent with the current state. The boolean functions inputInvariant(s) and outputInvariant(s) check the consistency between abstract and concrete trajectories. We are looking for a path through the test case by taking transitions as soon as they become possible. The function getSuccessor(s) checks the set of outgoing transitions for valid successors. It returns states that are consistent with the current inputs and outputs with the preference of states that are not inconclusive. This enables us to find longer traces that may hit an accept state. Depending on the reached final state the test case execution yields the verdicts: (1) pass for an accept state, (2) fail if execution leads to a state that is not reachable from the current state, (3) inconclusive for an inconclusive state. If a test case has cycles and an execution

Reactis [19] is a common test generation tool for Simulink models. It produces test cases regarding certain coverage criteria on the Simulink model. Test cases can be used to ensure conformance of a source code implementation or to validate the behavior of the model itself.

The selection of test cases for hybrid systems is addressed in [14]. The idea is that a test case with certain parameters has many test cases with slight changed parameters in its neighborhood which all show the same qualitative behavior. The work deals with the generation of test cases based on coverage metrics.

We presented an approach to model and simulate the behavior of the continuous variables of hybrid systems with QR methodologies. We used abstract, qualitative models as test models to check whether a given concrete implementation is a valid refinement under the qrioconf relation. This provides a means, e.g., to validate the correctness of environmental simulations. We use Matlab Simulink as imple- mentation language and generate offline test cases due to defined test purposes or according to coverage criteria. We demonstrated our approach on a small example and were able to detect faults introduced in the implementation of the example. To our knowledge, our work is the first in applying QR-techniques to the testing of hybrid systems.

