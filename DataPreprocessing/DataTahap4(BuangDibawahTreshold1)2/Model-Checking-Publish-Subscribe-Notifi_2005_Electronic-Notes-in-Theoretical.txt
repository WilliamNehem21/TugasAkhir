tems) [1,10]. Groupware is typically classified according to two dichotomies, viz. (1) whether its users work together at the same time (synchronous) or at different times (asynchronous) and (2) whether they work together in the same place (co-located) or in different places (dispersed). This is called the time space taxonomy by Ellis et al. [10]. In this paper we deal with think- team, which is an asynchronous and dispersed groupware system. Other ex- amples include electronic mail, workflow, collaborative writing systems, and the version-control systems often used in software engineering to coordinate the changes made by multiple programmers to the same program.

Some important design issues in groupware systems are data sharing, user awareness, and concurrency control. In this paper we address these issues in the context of thinkteam. More precisely, we use model checking to formalise and verify a number of properties specifically of interest for the correctness of groupware protocols in general, i.e. not limited to the context of think- team. In recent years there has been an increasing interest in the use of model checking for the formal verification of (properties of) groupware [3,17,21] and publish/subscribe (pub/sub) systems [6,7,12,20].

In this paper a pub/sub notification service is added to the protocol under- lying thinkteam. More precisely, the service which think3 proposed to add actually is more refined than the one described above. All users subscribed to a document are notified whenever a user extracts this document from the repository for editing purposes. Furthermore, as soon as the user finishes edit- ing and publishes the document in the repository, this causes an update on this document to all users that are subscribed to it. Hence not only those holding a read-only copy of the document recieve up-to-date information on its status, but all users that are registered for the specific document.

Then there are some new features that concern the pub/sub notification ser- vice. A user can subscribe (unsubscribe) to a file by sending the CC a register (unRegister ), whereas a user is registered automatically as the result of a get. If a user is subscribed to a certain file, then she receives a notify whenever another user extracts this file from the vault. Similarly, she receives an update whenever another user inserts (publishes) a file in the vault.

Promela specifications can be model checked by Spin against correctness properties specified as LTL formulae [16]. Spin converts the Promela processes into finite-state automata (FSA) and on-the-fly creates and traverses the state space of a product automaton over these FSA, in order to verify the specified correctness properties. There are several ways to formalise correctness prop- erties in Promela, two of which we use in this paper. First, we add assertions to a Promela specification and verify their validity by running Spin. Secondly, formulate LTL properties and test their validity against the Promela spec- ification, possibly enriched with specific labels identifying relevant points of process executions, by running Spin.

Next to the abstractions described in Section 2.3, we have made several assumptions in our specification in order to reduce the size of both the state space and the state vector, which is used by Spin to uniquely identify a system state. The most important assumptions are as follows.

In [3], several correctness criteria that groupware protocols must satisfy have been formulated, covering both safety and liveness properties. Clearly some of these properties, such as those regarding the locking-based concurrency control mechanism, should also be satisfied by the thinkteam protocol. However, the thinkteam protocol must also satisfy some specific properties that are related to the pub/sub notification service. The set of properties which we intend to address in the forthcoming sections is as follows.

Unique lock/file. The second property states that at any moment in time and for every file, only one user may possess a lock on that file. Given a file, the CC may thus have granted at most one lock for it. In the thinkteam protocol this means that at any moment in time, only one user may have extracted file 0 through a checkOut. To verify this property we add the basic assertion assert(writeLock == false) to the specification of the CC pro- cess when it is about to grant a lock to a user by sending her a checkedOut. We then let Spin run a verification on assertion violations. As a result, we verify whether it is always the case that the boolean variable writeLock is false (indicating that no user currently has a lock in its possession) the moment in which the CC is about to grant a user a lock by setting writeLock to true and sending checkedOut to this user. In about 3 minutes Spin concludes that the above basic assertion is never violated, which proves that the property is valid.

Keep file locked. The fourth property states that a lock on a file is not released as the result of a checkInOut . In the thinkteam protocol, the CC may thus not change the value of writeLock (which is true) as the result of a checkInOut , i.e. the checked out file remains checked out/locked. To verify this property we add the basic assertion assert(writeLock == true) to the specification of the CC process after it has updated the vault by sending it a checkIn (as the result of a checkInOut received by the user) and before it updates the users of this fact. We let Spin run a verification on assertion violations and thus verify whether it is always the case that writeLock is true the moment in which the CC is about to update all registered users of the fact that the user that currently has a file in its possession, has published an intermediate version of it in the vault. In some 3 minutes Spin concludes that this basic assertion is never violated, proving that the property is valid.

where doneLab is doneNotify or doneUpdate. We also ran verifications of anal- ogous versions of these LTL formulae for the other users. Stated differently, we verify whether it may be the case that a user receives a notify (update) without currently being registered for the file these messages refer to. It takes Spin just over twenty minutes to conclude that the above formulae are valid.

A further desirable property of any groupware system in general and the think- team protocol in particular is that its users cannot be denied a service forever. A user should, e.g., always be able to get a file if she so wishes. To verify this property, we augment the specification of the User with the label todoGet directly before the statement by which the user may send a get to the CC (and we recall that directly after this statement we put the label doneGet).

Similar to the cyclic behaviour described above, it can be shown that a user is not obliged to ever return a file to the Vault which she has checked out. In the thinkteam protocol, a user is simply never forced to undertake any action whatsoever. Such behaviour is similar to that discussed in Section 4.2 for the case of releasing a lock and is dealt with in a similar way in thinkteam by means of a superuser or system administrator which can, e.g., force certain users to eventually return files to the vault.

In this paper we show that verifications of the Promela specification of the thinkteam protocol are very well feasible with the current state of the art of available model-checking tools such as Spin. Moreover, the results show that the concurrency control and awareness aspects of the thinkteam protocol completed with a pub/sub notification service are well designed. We have seen, however, that the thinkteam protocol does not oblige a user to ever return a file she has checked out to the Vault. In thinkteam this situation is dealt with by

CC. A different solution would be to try and reduce the possibility of losing messages by sending redundant copies of each notify and update to the user, thereby reducing the chances of these actions not reaching their destination. The latter solution would create much overhead, though. This is a topic worth further investigation, in particular because the specific human interactions inherent to groupware protocols make this problem different from the well- studied issue of message loss in network protocols.

