A holistic approach to modelling embedded systems is advocated: Many aspects of a system should be analysed in isolation to keep the task manageable, but they often influence each other during integration in a way that the desired system becomes unrealisable. A tool-supported approach that aims at integrated models of different concerns based on formal methods is suggested to solve this problem. This approach uses Creol, which is a language designed for object-oriented modelling of distributed systems. We report on ongoing work on the design and the implementation of tools that support modelling, validation, and verification. We focus on sensor networks, which are distributed system that consists of many embedded devices with tight constraints on computational power, energy availability, and timeliness. The described tools are a compiler that performs static checks and optimisations, an interpreter that defines a formal semantics, and a prototypical LTL model checker. This supports seamless development with formal methods.

Object-oriented programming is regarded as the leading paradigm for concurrent and distributed systems and is recommended by the RM-ODP [20]. It is popular for modelling real-time embedded systems [16]. Model-driven engineering, pushed by the increasing maturity of modelling languages and tools, is becoming more established among software designers and developers [32]. Traditional ad-hoc system models are supplemented with new formalisms like SysML [40] or other architecture description languages.

because these systems are composed of many components that collaborate to per- form their function. The system is expected to perform reliably and for a prolonged time, despite the resource constraints on computational power, energy, and mem- ory. As a result, the models and the design of such a system must integrate these concerns on both the local level of every device and the global level of the whole network: functionality, timeliness, power consumption, memory use, and more.

We plan to add linguistic features to integrate more properties into the model. If such properties are expressed declarative at a high level of abstractions, we expect that they will not interfere too much on other aspects. We worked on integrating timing aspects into the modelling language and provide analysis for these aspects.

Reasoning about multi-threaded programs in a setting with synchronous method calls is highly complex [1]. Verification considerations suggest that all methods should be serialised, but synchronous communication gives rise to undesired and uncontrolled waiting, and possibly deadlock. This limitation is severe in a dis- tributed setting this. Delays and instabilities may cause undesired waiting. A diverging method even blocks the evaluation of other method activations, which makes it hard to combine active and passive behaviour in the same object. Non- blocking (asynchronous) message passing gives better control, but does not provide the structure and discipline inherent to method calls.

Classes are the primary structuring mechanism in Creol. Classes support mul- tiple inheritance. Classes are not types, instead classes are typed by interfaces. An interface is used to regulate what methods an object exports and what objects may access its methods.

by e, and comma-separated lists of variables by v. The await c statement behaves like skip, if c holds when the statement is executed, and otherwise the process is suspended until c holds (await synchronisation). The release statement will yield control to other processes unconditionally. The choice statement S1  S2 chooses non-deterministically between S1 or S2, if both do not suspend and suspends only if both S1 and S2 would suspend.

3 We chose a functional expression language, because evaluation of expressions should not have any side effects, as in C and Java. The language is first-order (i.e., without lambda abstractions), because higher- order languages allow to encode objects in the functional sub-language. This way, we have a strict separation between computations, expressed by functional expressions, states, represented by objects, and coordination, as expressed by statements.

The example shows that concurrent activities can be easily expressed in Creol. Moreover, the await statements coordinate both activities in a very high-level way. The log is only appended to if there is room and it is pruned when it is full.

Developing Creol models is supported by a compiler that translates a model into a run-time syntax used by an interpreter formulated in Maude [25] (see Section 5). The result can be simulated or analysed in Maude. The design and implementation of the compiler is standard [3]: The compiler front-end contains the parser of models written in Creol. The result of the front end is an abstract syntax tree represent- ing the input. Analysis steps and transformations steps identify errors and insert auxiliary statements needed for resource management in the interpreter.

Standard data flow analysis is used to insert free statements, which are used to release resources that are no longer needed. Especially in a distributed system such annotations greatly reduce the overhead of distributed garbage collectors and the amount of allocated resources. For many examples this analysis allows us to disable garbage collection altogether.

Maude provides a model checker [12] that enables the verification of LTL properties of rewriting systems. A natural idea is to use state-space exploration to verify properties of Creol models. This allows rapid prototyping of transformations and semantic optimisations: how can the rewriting system be optimised to use less resources and how can the input program be adapted to make model checking feasible. Our current approach is not efficient, because we do not analyse a program represented in Maude but an interpreter executing that program.

We need to define abstractions which help to reduce the state space of the sys- tem we want to verify. Some abstractions can be formalised in the RL specification. These abstractions will be applied to all programs. Other abstractions and optimi- sations are computed by the compiler (see Section 4).

Models in Creol describe infinite state systems, because the interpreter identi- fies calls uniquely. Even finite state systems exhibit a huge state space, because communication is asynchronous and unordered and scheduling is non-deterministic. Therefore, the rewriting system has to be adapted for model checking.

An assertion must hold in every processor release point, e.g., whenever an await or release statement is executed. However, the model checker checks states between these release points, in which an assertion need not hold. For example, executing choice statements is represented by a rule, because it is not deterministic, and gives rise for a new world in the Kripke structure. Therefore, the program is augmented with a Boolean variable that indicates when the assertion has to hold and the assertion is conditional on the value of that variable.

Partial order reduction techniques effectively eliminate choices by choosing one rep- resentative computation. Transactions are usually applied to linearly ordered se- quences of statements and partial order reduction techniques do not apply in such situations. We believe that partial order reduction is a useful technique which ap- plies to a much larger range of models and should therefore be implemented as part of the model checking algorithm and not as a transformation of the Creol model. We expect the largest benefit of partial order reductions in a reduction of the non- determinism between different objects. This cannot be expressed on the level of classes.

The changes to the interpreter are not specific to a model. All models bene- fit from these changes. And since the tight link between the adapted interpreter and Creol is preserved, model checking still provides counterexamples in terms of statements and states of Creol itself. Note that although transactions abstract from intermediate states, these intermediate states can be recovered by using the search command and the original interpreter.

Although these changes are sufficient to ensure the intended behaviour of syn- chronous calls, a rapid growth of the process queue can be observed for recursive calls. We address this problem by introducing compiler optimisations, e.g. tail-calls are optimised. This technique does not cover all (recursive) synchronous calls and is thereby more a program optimisation than an interpreter enhancement, although the interpreter has to be adapted to provide facilities to cope with tail-calls.

The intuitive meaning of a constraint is to accept at most L calls to a method of F before any occurrence of a call to a method in E. Such specifications can be translated into a Streett automaton, where the number of states are an upper bound to the queue size. In addition, they define a fair scheduling, which further reduces the number of states analysed, since not all possible orderings of events are considered.

Formal automata models have been used to analyse protocols and channels. The properties of communication media are usually modelled as automata, too. For example, Nancy Lynch models communication media by processes in [29]. A lossy channel is modeled by a process that randomly drops messages. In contrast to these approaches, which apply ad-hoc techniques to model various kinds of links and networks, our modelling language fully integrates a set of primitives to describe dynamically evolving network topologies.

applied to model and analyse advanced wireless sensor network algorithms, using, e.g., Monte Carlo simulations for performance evaluation for networks with up to 800 nodes. Our work complements this approach by emphasising sensor functionality and behavior. However, we intend to investigate how their techniques for simulation may apply in our setting.

KOOL features single inheritance, object creation, encapsulation, communica- tion via message sends, and concurrency. KOOL objects communicate by means of their class signature whereas Creol objects communicate by means of designated interfaces. Compared to Creol KOOL is missing the concept of a cointerface and multiple inheritance.

The holistic approach advocated in this paper expresses itself in the use of one formalism for modelling all aspects. Multiple inheritance is used as a composition mechanism that integrates different functional aspects. Non-functional aspects are not yet represented in our approach, but especially memory aspects are addressed in part with the model checking experiments. Especially, the tail-call optimisation and the use of static analysis to simplify memory management are important aspects.

The tools described in this paper are currently used in the Credo project. Initial experience points to some short-comings: Interpretation and model checking in Maude exposes the runtime syntax with the program annotations to the modeller, which makes it hard to relate the executed model to the original model. This problem is aggravated by the lack of proper output routines in Maude, which makes it difficult to present the program state in a more Creol-like manner to the modeller. The setup helps us to separate many concerns: The compiler implements all static checks and the resulting model is type safe. There is no need in the interpreter and model checker to validate the type correctness of the executed model. This

Using Maude for model checking and adapting the interpreter for model checking has a certain overhead during model checking. We can only check quite small models with currently available computational resources. This makes the need for a direct instantiation of the model into the interpreter apparent, which allows faster and more efficient model checking. This may make some state space reduction techniques available, e.g., partial order reductions. Others benefit the concrete application, too, and will be provided as model transformations.

network, perform analysis of these models and develop these with the help of tools that support formal methods into implementations that run on a real device. The relatively small memory of a device makes model checking of these devices feasible. Still, compositional methods are needed to reason about the global method, which also need to be developed.

