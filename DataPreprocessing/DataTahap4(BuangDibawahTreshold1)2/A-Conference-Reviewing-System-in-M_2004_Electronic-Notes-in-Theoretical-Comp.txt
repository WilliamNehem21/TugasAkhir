A useful way of presenting a new language is by means of complete examples that show the language features in action. In this paper we do so for the Mobile Maude language, an extension of Maude that supports mobile computation. We implement an ambitious wide area application, namely a conference reviewing system, an exam- ple described by Cardelli as a challenge for any wide area language to demonstrate its usability.

The popularity of the Internet has brought much attention to the world of distributed applications development. Now, more than ever, the network is being viewed as a platform for the development of cost-effective, mission- critical applications.	Mobile code and mobile agents [12,11] are emerging technologies that promise to make it very much easier to design, implement, and maintain distributed systems. Mobile agents may reduce the network traffic,provide an effective means of overcoming network latency,and,perhaps more important,help us to construct more robust and fault-tolerant systems, thanks to their ability to operate asynchronously and autonomously of the process that created them.

Mobile Maude is described in Section 2. Section 3 includes a description of the conference reviewing system, and a detailed explanation of our Mobile Maude implementation. Section 4 discusses some related work. In Section 5, we present some conclusions and future work.

We will present now the Mobile Maude primitives used in the application. There are three kinds of communication between objects.	Objects in- side the same mobile object can communicate with each other by means of messages with any format, and the communication may be synchronous or asynchronous. Objects in different mobile objects may communicate when such mobile objects are in the same process and when they are in different processes; in these cases, the actual kind of communication is transparent to the mobile objects,but such communication must be asynchronous,and mes- sages must be of the form to_:_, where the first argument is the identifier of the addressee object, and the second argument is the message contents, a value of sort Contents built with free user-defined syntax (see, for example, 

In the go message,the mobile object indicates the process where it wants to go. Sometimes, a mobile object wants to reach another object, but it only knows the identifier of the object it wants to catch up, not the process it is in. In this case,the go-find message can be used. When this message is used by an object M, it takes as arguments the identifier of the mobile object that M wants to reach,and the identifier of a tentative process where it may be.

to the program chair (7), who collects the submissions (8) and assigns them to committee members, by instructing each submission form to generate a review form for each assigned member (9, 10). Each review form then finds its way to the committee member it has been assigned to (11, 12), who may decide to review the paper directly, to refuse it, or to delegate it to another reviewer. The review forms keep track of the reviewers they have passed by, so that they can find their way back when completed or refused,allowing each reviewer to check the work of its subreviewers. Eventually, a review is filled

In order to simplify,we have minimized the information contained in mes- sages, and we are not encrypting them. However, it is assumed that all mes- sages are encrypted. Such an encryption could be easily added by using en- crypt and decrypt functions as in [6].

In addition to the identifiers of the conference chair and the program com- mittee members,a program chair object needs to keep information about the reviewing process, and a way to collect the final papers to compose the pro- ceedings. The reviewing information consists of a set with the identifiers of the authors whose papers have been accepted but whose final papers have not been received yet and information regarding each of the submissions. This information is given by a term of sort SubmInfo,which is an alias for the sort Tuple(Name,Mid,Paper,Set(Tuple(Mid,Score)),Int). That is, for each submission it is stored the name,identifier and paper of the (contact) author, the results from the referee reports and the number of rounds. The informa- tion on the refereeing of each paper is stored in the review forms,the program chair only keeps the identifier of such a review form and the score provided by it for the given paper. In case of disagreement,the program chair declares the paper unresolved and sends the review forms back to the reviewers. After three rounds without agreement, the program chair will take a decision. The final versions of the accepted papers are kept in the proceedings attribute.

A reviewer object may decide to review a paper assigned to it directly, or to send it to another reviewer. The review form must keep track of the chain of reviewers so that it can find its way back when either completed or refused, and so that each reviewer can check the work of its subreviewers. In case there is no agreement on the scores for a paper, a review form must go back to its reviewer. Objects of class ReviewForm have two attributes of sort List(Mid). The attribute chain contains initially the identifier of the program committee member assigned to it,and all the successive subreviewers are added to this list. When the paper is finally reviewed, the form finds its way back by extracting the identifiers from the list in a last-in-first-out manner. Nevertheless,instead of discarding these identifiers,they are included in the list in the attribute chain-back,so that it can follow its reviewing path again if necessary. As submission forms,review forms need to distinguish the different states in which they can be. They do so with an attribute state of sort ReviewFormState which may take values inactive, towards-reviewer, back, unresolved-towards-reviewer,and unresolved-back.

The review forms are created with newo messages. The create-review-forms operation is in charge of generating these newo messages,one for each review form to be generated. Note that the identifier of the program committee member that the review form will try to reach after its creation is put as the first of the identifiers in the chain of reviewers.

When a review form gets to the process of the reviewer it was looking for, which would be a program committee member in the first place, it sends a review message to the given reviewer and waits for an answer. The review message includes as an argument the set of the reviewers it cannot delegate on, including all the reviewers it has passed by before, and which should not be used again in order to avoid loops, and those who have already rejected the review. The function listToSet returns a set with the elements of the list given as argument.

When the program chair has all the referee reports for a submission, it must be resolved. If the reviews are in agreement,then the paper is accepted or rejected. Otherwise, that is, if the reviews are in disagreement, the pro- gram chair declares the review forms unresolved,and sends them back to the members of the program committee to which the submission was assigned. After three review rounds,the program chair resolves the submission deciding what the majority of the reviewers decided.

If the reviews are in agreement or the number of rounds reaches the limit, the program chair creates a report form that will find its way back to the author and sends termination messages to all the review forms related to this paper. If there is an agreement then the decision function returns the agreed score, otherwise the majority decides. In case of disagreement with an even result then the paper is accepted.

When an accepted paper report form reaches an author, it sends a congrat- ulations message and it transforms itself into a final submission form, which will ask the author for the final version of the paper. Notice how we model the transformation of an object of class ReportForm into an object of class FinalSubmForm. The fact that such inner object keeps its identifer makes that what at some point is a report form mobile object becomes a final submission form mobile object.

The paper [14] presents a solution closer to ours,using the concept of active (mobile) documents. It uses the PageSpace architecture, a design paradigm for Web-based applications that are composed of autonomous agents perform- ing their duties regardless of their physical positions. This architecture is instantiated with a coordination language with mobility facilities. It follows the MUD (Multi User Dungeon) metaphor, a cooperative interactive envi- ronment shared by several people to socialize and interact. It is based on the concepts of rooms,items and players (or users) which relate with our concepts of processes and mobile objects.

