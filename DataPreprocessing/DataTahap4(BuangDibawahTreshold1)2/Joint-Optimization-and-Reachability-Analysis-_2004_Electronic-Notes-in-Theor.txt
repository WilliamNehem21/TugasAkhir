In this section, we illustrate how to model optimization problems using graph transformation systems with time. For a motivating example, we discuss (a slightly modified version of) a job-shop scheduling problem, the Personaliza- tion Machine example discussed in [8]. The example is a simplified version of a case study carried out within the AMETIST project.

matching a specific pattern with another graph. In graph transformation with time [3], a time attribute is a logical clock (typically) with non-negative integer values that can be attached to nodes. The time attribute has a distinguished role to define how the time progresses in discrete steps in a consistent way.

In the guard, we check the existence of nodes and edges of corresponding types (such as, e.g., convCell[cc1] and myCell[p1][cc1]), and attribute conditions (such as personalized[c1] == true). The state variable updates remove the pers hold edge and create a new conv hold edge, moreover, they update the time variable according to the conditions of GTSs with time.

Whenever a new solution is found, i.e., in the error transition(s) of the reachability property, the cost (time) of the execution path (i.e., the variable prev time) is compared with the best cost so far. If prev time is smaller then we have found a better solution, so the variable best cost is decreased and the trace is saved. The following piece of Promela code represents a reachability property reach prop stating that each card c1,

