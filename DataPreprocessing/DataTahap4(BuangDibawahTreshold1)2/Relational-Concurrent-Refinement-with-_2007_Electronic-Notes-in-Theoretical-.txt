Refinement in a concurrent context, for example, as found in a process semantics, takes a number of different forms. Typically this is based on a notion of observation, for example, which events a system is prepared to accept or refuse. Concurrent refinement relations include trace refinement, failures-divergences refinement, readiness refinement and bisimulation.

An alternative model is found in a process algebra where differing process se- mantics induce different refinement relations. For example, in CSP one could use trace refinement, failures refinement or failures-divergences refinement [17]. In CCS, bisimulation is typically used [16], whereas in LOTOS reduction, extension and con- formance are defined [3]. A survey of many prominent refinement relations is given in [20]. These relations are often motivated by the description of an idealised ma- chine by which one manipulates the system and observes its behaviour. Different concurrent refinement relations arise by varying the functionality of this machine.

In order to understand the nature and structure of refinement, as well as provide a means to combine specification languages and their development methodologies, it is necessary to understand the correspondence between data and process refine- ments. Work relating the two paradigms includes Josephs [15], He [14], Woodcock and Morgan [22], Bolton and Davies [5,6], Derrick and Boiten [2,12] and Schnei- der [18]. That due to Josephs [15], He [14], Woodcock and Morgan [22] defines a basic correspondence between simulation rules and failures-divergences refinement. The more recent work of Bolton and Davies [5,6], Derrick and Boiten [2,12] and Schneider [18] investigates a direct correspondence between the relational model and process semantics, and includes a specific consideration of input and output which introduces some subtleties.

The purpose of this paper is two-fold. First, we survey this existing work linking relational models of refinement to their process algebraic counterparts. Second, we extend these results (and, in particular, [12]) by showing how the effect of internal operations can be incorporated into the relational model.

This particular result is due to Schneider [18]. A version in a blocking model is due to Bolton and Davies, where the process semantics induced is a singleton-failures model. Derrick and Boiten [12] show what additional observations are needed to induce failures-divergences refinement, and derive corresponding simulation rules.

The paper is structured as follows. Section 2 highlights crucial elements of the background material, refering to other sources for the full details. Section 3 surveys work on relating refinement in relational and process semantics. Section 4 provides the extension of the blocking model to internal operations, and we conclude in Section 5.

A contrasting view of refinement is that offered by a process algebraic description of a system. There, instead of a relation over a global state being representative of a program, the traces of events (in essence, a record of all terminating programs) are recorded. There are a number of semantic models for CSP, each of which induces its own refinement relation.

however, the effect of calling an operation outside its precondition is not now diver- gence but, since we are in the blocking model, simply inability to perform any event associated with that operation. This thus correctly reflects the intended meaning to the blocking model. For ADTs with deterministic outputs (or no input/output) the following is shown.

event. In the process QA the lower stop is being used to represent non-termination of the operation. With this corresponding process analogous results are derived (i.e., data refinement corresponding to singleton as opposed to failures-divergences refinement). This non-blocking translation differs in key aspects from that defined by Schneider. In particular, the use of Chaos and stop to model non-termination seems a less natural embedding of non-blocking than using explicit divergence.

Non-blocking model As no operation is blocked, every trace is possible: those that arise in the blocking model, and any others following divergence. There are no refusals beyond those after a divergence, as no operation is blocked, it either gives a well-defined result or causes divergence. There are now, however, divergences, which arise from applying an operation outside its precondition.

We have seen that in both the non-blocking and blocking models it has been neces- sary to place additional restrictions (i.e., observations) on the standard definition of data refinement in order that failures-divergences refinement is achieved in a process semantics. Why this is is perhaps best illustrated via an example.

These results extend [12] by considering the explicit presence of internal events in the blocking model. Further work in this area includes extending the results to the non-blocking model, as well as the full consideration of input and output and the effect that the extra subtleties introduced have upon the results derived above. This will be the subject of an expanded version of this paper [1].

