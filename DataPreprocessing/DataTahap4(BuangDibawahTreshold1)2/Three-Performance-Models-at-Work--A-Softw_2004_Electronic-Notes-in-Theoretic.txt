The validation of software performance since the very early phases of the lifecycle is a crucial issue in complex software system design. Nowadays in the software development practice, the percentage of time and effort allocated to this task is still too small to avoid performance bugs, which are late to discover and hard to fix. This is due both to the short time to market and to the special skills needed (and often lacking in the development team) to effectively accomplish early performance validation.

Software architecture represents a system abstraction that may support the validation and the pre- dictive analysis of system performance. Different notations/languages are available for representing software architectures under a performance viewpoint. In this paper we focus on performance issues of software architectures and we analyze different performance model notations from a software designer perspective. Goal of the paper is to speculate, through a simple case study, on the descrip- tive power of three largely used performance model notations and their suitability to gain feedback at the architectural design level.

With the growing complexity and size of modern distributed software systems the need of tools to support design decisions is becoming a critical issue. Independently of the software process, the early design phases may heavily affect the software development and the quality of the final software product. Therefore inaccurate decisions at early phases may imply an expensive rework, possibly involving the overall software system.

1. Being at the architectural level, the techniques to produce alternatives may affect either the components or the communications between them. The techniques we are interested to are the ones closely affecting the components and their workload, which essentially may fall in three categories: splitting, merging and duplication.

Merging means to distribute the set of services provided from an under- loaded component over a set of existing components. For example, let us suppose that the utilization of each component 6 is among the indices ana- lyzed in the performance assessment step, and let us suppose that one com- ponent utilization is under a certain threshold (e.g., 40%). In this scenario

Duplication of a component trivially means to create one or more new oc- currences of the same component. This type of technique may be used every time the component can not be split, for example because it is a minimal component (i.e. it provides only one basic service) or because of some design constraints that force the software structure.

The software system we consider is called XML translator (XT). It auto- matically builds an XML document from a text document with respect to a given XML schema [24]. The text document has a fixed structure to allow the automatic identification of its specific parts that are then emphasized by using the XML tags defined in the given XML Schema.

In this section we present the SPA, GSPN and QN models of the case study (XT) introduced in Section 2.2. At the end of each model description we report specific considerations about the tool used as well as general thoughts about the notation.

SPA and GSPN are extensions of, respectively, Process Algebra (PA [15]) and Petri Net (PN [18]), that introduce features to model timing and proba- bilistic aspects of software systems. PA and PN are well-known notations used to model behavior of different types of systems. In the following we assume readers familiar with PA, PN and QN basics [15,18,14].

Note that mu1 and mu2 are intrinsic parameters of the software system (i.e. they depend on the internal design of the software components), whereas lambda models the types of users and p the types of documents to be processed. All of them assume the same meaning, independently of the notation adopted to model the system. So, they will be used as reference values to

The complexity of our model would be lower by using extended notations, but this would mean also a higher PN skill in the software designer that we want instead to keep minimal. However, the choice of adopting such a powerful PN tool (i.e., HiQPN) leaves open the possibility, in future, of considering more complex and demanding models.

queue length (i.e. average number of documents waiting to be processed) and the throughput (i.e. average number of documents processed per time unit) of each software component building up the XT system. We study the index trends while growing the number of XT users.

We like to remark that the complexities of the model evaluation processes may sensibly differ from each other, and they may also introduce some ap- proximation errors in the index values. It is out of the scope of this paper to compare the model notations along this dimension, because many other factors would enter into the picture (e.g. product forms, solution tool features).

distant from commonly used design notations, in the early software lifecycle phases there is a natural correspondence with architectural concepts. 8 Easi- ness to model holds medium also for SPA and GSPN even though they may be considered notations familiar to software designers. Their drawback is that as soon as the system architecture becomes more complicated the complexity of the models sensibly increases.

Generalized Stochastic Petri Nets result difficult to resize. Let us consider, for example, the users issue. In order to modify the number of considered users the sub-net corresponding to the user has to be singled out, duplicated and suitably connected to the network. Stochastic Process Algebras and Queueing Networks are instead easy to resize. In SPA it is sufficient to compose new user (process) instances in parallel, and in QN only an input parameter needs to be changed.

The motivations for the experiment presented in this paper come from the work in the field of software performance and software architectures we carried on in the last few years. The three performance model notations (and their variants) we presented, have been and are largely used. Normally the choice of one of them, as basis of a performance validation approach, is due to several factors which do not consider the user/software-designer perspective. The aim of our experiment was to look at these model notations in order to assess their suitability to support software designers. From the reported results we do not intend to induce general assessments on this field, due to the limitations of the case study and the experimental setting. We rather aim at setting a framework for a campaign of significant experiments in this direction.

whatever level of detail. Several automated methodologies have been recently introduced for QN [4] but, to our knowledge, do not yet exist complete method- ologies for GSPN and SPA. In order to make performance analysis widely used, future research must focus on the automatization and engineering of existing approaches which integrates standard behavioral modeling with performance model generation, and on the availability of user-friendly frameworks to carry on the analysis.

