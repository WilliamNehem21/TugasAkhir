In Section 2 we recapitulate the conventional parser combinators and inves- tigate where the problems mentioned above arise. In Section 3 we present dif- ferent basic machinery which adds error correction; the combinators resulting from this are still very short and may be used for small grammars. In Section 4 we show how to extend the combinators with the (demand driven) compu- tation of look-ahead information. In this process we minimize the number of times that a symbol is inspected. Finally we present some further extensions in Section 5 and conclusions in Section 7.

If we extend the combinators from the previous section to keep track of the farthest point in the input that was reached, the parser returns that value only after backtracking has been completed. Unfortunately, we have by then lost all context information which might enable us to decide on the proper error correcting steps. So we will start by converting our combinators into a form that allows us to work on all possible alternatives concurrently, thus changing from a depth-first to a breadth-first exploration of the search space. This breadth-first approach might be seen as a way of making many parsers work in parallel, each exploring one of the possible routes to be taken.

This is a special type that is not allowed by the Haskell98 standard, since it contains type variables b and result that are not arguments of the type Parser. By quantifying with the forall construct we indicate that the the type of the parser does not depend on these type variables, and it is only through passing functions that we link the type to its environment. This extension is now accepted by most Haskell compilers. So the parser that recognises a value of type a combines this value with the stack of previously found values which will result in a new stack of type b, which in its turn is passed to the continuation as the new stack.

corresponding tails. An End node represents the end of a sentence. The :|: nodes corresponds to nodes that are both a Choice node (stored in the left operand) and an End node (stored in its right operand) 3 . Notice that the language ab|ac is represented by:

In our final solution we will merge these two approaches. We will compute Sents fragments on which we base the decision how to proceed with parsing, and use the continuation based parsers to actually accept the symbols. Since the information represented in the new data structure closely resembles the information stored in a state of an LR(0) automaton, we will use that termi- nology. So instead of building the complete Sents structure, we will construct a similar structure which may be used to select the parser to continue with.

(:|:) this corresponds to the situation where we either may continue with using further symbols to make a decision, or we will have to use information about the followers of this nonterminal. This will be the only place where we continue with a possibly non-deterministic parsing process. It corresponds to a shift-reduce conflict in an LR(0) automaton.

The function mkparser interprets a Look structure and pairs it with its corresponding Realparser. The function mkparser constructs a function choose that is used in the resulting Realparser to select (choose input) a Realparser p) making use of the current input. Once selected this parser p is then called (p r st e input). So the function choose, that is the result of the homomorphism over the Look structure, has type Input -> Realparser a.

This definition seems to be horrendously costly, but again we are saved by lazy evaluation. Keep in mind that these Look structures are only being used in the function mkparser, and are only inspected for the branches until a Found or Reduce node is reached. If the grammar is LL(1) this will only be one step! As soon as mkparser has done its job the whole structure may be garbage collected.

In this case the check that it is present and the error correcting behavior can be skipped. So all we have to do is to take a single symbol from the input, incorporate it into the result, and continue parsing. We record the successful step by adding an OK-step.

Computation of a full look-ahead may be costly, e.g. when the choice structures that are computed become very large, and are not used very often. In such cases one may want to use a non-deterministic approach. For this purpose dynamic versions are also available that have the efficiency of the backtracking approach given before.

can be extended to incorporate the accumulation of any further needed infor- mation; examples of such kinds of information are the name of the file being parsed, a line number, an environment in which to locate specific identifiers, etc. In that case the state should at least be able to store error messages, and recognized symbols. Extra combinators have been introduced in the library to update the state.

the number of times a symbol is inspected may be more than once: where a bottom-up parser would have a shift-reduce conflict we basically pursue both paths until a difference is found; if the grammar is LR(1) this implies we are inspecting one symbol twice in such a situation. We feel that in all practical circumstances this is to be preferred over the construction of full LR(1) parsers, where the number of states easily explodes. It is the relatively low number of states of the LR(0) automaton, and thus of our approach, that makes the LALR(1) handled by Yacc to be preferred over LR(1). Besides that has our approach the advantage of smoothly handling also longer look-aheads when needed. The lazy evaluation takes nicely care of the parallel pursuit for success that would be a nightmare to encode in C or Java.

