This then is our motivation for investigating refinement for UIs, to make sure that what we implement is what we intended. We want all of the guarantees of correctness for the UI that we have for the rest of the system. We therefore need some structured and formal way of transforming our designs into implemented UIs, that is we need a refinement process.

This reflects the incremental approach to system implementation we refer to as stepwise refinement [15]. Irrespective of what the intermediate steps are (paper designs, mock-ups, partially functioning UIs, full implementations etc.) we want a way of maintaining correctness. This approach to UI refinement is different from that proposed in works such as [6] and [11] in that we are not starting from a single system specification which formalises the UI behaviour as one part of the system, but rather extending traditional UI design methods in a non-traditional, formal manner.

This paper consists of two parts. We start by examining some traditional notions of refinement to see how conceptually they may be applied to UI designs. We will use this as the basis for an informal description of UI refinement and show via some small examples how this may be applied. In the second part we will look at how

Different refinement methods exist for different formal languages, but generally they can be categorised by a common understanding of what the underlying princi- ples of refinement are. We are interested in how these general principles may apply to the concept of UI refinement. That is, how well do they fit with our intuitions about what refining UIs (and UI designs) actually is? We next look at some prin- ciples of refinement individually to consider their suitability as principles for UI refinement.

Usually when we talk about substitution we are considering observable be- haviours of systems in terms of either input/output traces, or interaction with other parts of the system, i.e. behaviour devoid of any notion of visual appearance or cognitive awareness of differences. For UIs, however, such visual and cognitive dif- ferences are important; if we substitute one UI for another and they are visually different then the user (who in this case is a real person and not some computer process) will be able to tell that the substitution has taken place. Rather than con- sidering substitutivity we consider the principle behind this concept, namely that of considering programs as contracts.

Through a refinement process our descriptions become less abstract as we add more information, i.e. we become more precise about how data is stored or how operations are carried out. This must be done in a manner which avoids inconsistency, so by making more precise decisions about data and operations we must preserve previous correct interactions. The new version should therefore be a specialisation of the previous, more abstract one. Formally, information change must be monotonically increasing (or a least non-decreasing).

Another way in which our UIs may become less abstract is in their appearance. We may describe in more detail exactly where the widgets are located and what appearance properties they have (shape, colour etc.), so our description becomes more precise.

A PIM on the other hand shows the dynamic behaviour between different states of the UI. It consists of a finite state automaton with a relation between states and component PModels within a presentation model (a PModel is a component description of one part of the UI). When the PIM is in a particular state it indicates that the UI represented by the presentation model related to that state is currently active, and all behaviours of that presentation model are available to a user.

In order to maintain our contract with the customer the new UI needs to at least provide all of the functionality of the previous UI (and any new functionality has to be consistent with the old). We start by considering the system functionality of the UI, that is the S Behaviours. If we provide a UI which enables a user to interact with the system in n ways, then any replacement UI must at least provide the same n ways of interacting. In fact, we make a stronger statement than that and say that it must provide exactly the same n ways to interact. We will discuss this shortly.

This concept relates to the position and style of the widgets as well as the overall layout appearance (such as background colours, window size etc.). These are the low-level details of the UI which are not included in the presentation model and so we cannot use these, or PIMs, to check that a UI is more defined than some other UI. However, in cases where the only refinement said to have taken place is that of defining appearance, we can check, via the presentation model and PIM, that this is really the case.

There are some things we have identified as being desirable for UI refinement which relate to parts of the UI not covered by the models. For example, visual aspects of making appearance less defined (by deciding on colour schemes, appear- ance styles etc.) cannot be checked using presentation models or PIMs. The formal models are concerned with behavioural aspects of UIs, types of widgets of UIs (by which we mean their category) and dynamic movement within the UI, which de- termines availability of behaviour. If we wish to create a formal definition of UI refinement based on our existing models we must accept that there will be some limitations.

We could argue that those things which we cannot test for are not important considerations, and that the functionality of a UI is the same regardless of whether its background is blue or yellow for example. However, we are mindful that usabil- ity considerations are important, and these are things which may be affected by aesthetic decisions. We accept that these remain outside of our work and maintain our belief that our methods should be used in conjunction with more traditional de- sign methods, which includes usability testing designed to ensure we do not reduce usability.

(by which we mean from outside of the chart and for our considerations we can imagine this to be the user) and responded to by the chart. The set of signals given in the rectangle at the right hand side of the chart (which in this example is empty) represents the output interface. Only signals in this set will be visible outside of the chart. The rectangle at the bottom of the chart contains the set of signals which the two parts of the composition can use to communicate with,

