The set of operations in state-of-the-art graph transformation tools allows one to conditionally create and remove nodes and edges from input graphs. Node attributes can be initialized or updated with information from other attributes, parameters or constants. These operations appear to be too restricted for expressing model refinements in a concise manner. More specifically, graph transformation lacks an operation for copying subgraphs (multiple connected nodes, including their attributes) to a new location in the host graph. This paper presents a case study that illustrates the need, a syntax and an informal semantics for such an operation. It also discusses how the operation was integrated in an existing graph transformation language. Finally, it indicates how our ongoing effort towards the implementation of a model transformation language based on graph transformation makes optimal reuse of evaluation code for existing language constructs.

A model can be defined as a simplified representation of a part of the world, named the system [17]. Model repositories are databases with specialized support for storing and retrieving models. Their main functionality consists of serializing their data into standard model exchange formats (like XMI [13]), and exposing a query and transformation API (like OCL [11] and JMI [5]). Any program with the purpose of creating or changing models can be called a model transformation. The purpose of this paper is to extend graph transformation such that model transformations can be programmed at a high level of abstraction while the low-level APIs of mainstream model repositories are interfaced by means of compilers.

transformation to formalize the model transformation that defines this generation process in Section 2, the need for a copy operator becomes obvious. Section 3 presents the syntax and semantics of the proposed copy operator as an extension to Story Diagrams [15]. Additionally, the section briefly compares two approaches for extending an existing Story Diagram engine. The next section refers the reader to related work while the paper concludes with a summary of the contributions and lessons learned.

The CM2RM transformation contains a reference to one Model (defined in pack- age org.omg.uml.modelmanagement ) while such a Model can be transformed by many CM2RM transformations. The Model class, its association to the contained UML Model Elements (UmlClass, UmlPackage, State, ...) and other concepts from

The behavior of the cmClasses2rmEntities method can be modeled in two phases. Firstly, the transformation needs to look up some meta-information for robustness modeling in the UML. Secondly, the classes are copied from the conceptual model to the robustness model and they are marked as entities by decorating them with the proper meta-information. Each of these steps can be implemented as a primitive

Creating a link is a standard graph transformation operation. In the UML profile for SDM one needs to specify a link between the nodes that need to be connected and label it with the < <create> > stereotype. Obviously the name of the link and the name and cardinality of the association ends need to conform to an association between the types of the node. Otherwise, the resulting graph would not conform

Therefore, current development is focussed on a model-to-model transformation approach that leaves the code templates unchanged. Story Diagrams are used to transform models conforming to the profile discussed in Section 3.1 into models conforming to the SDM profile without the copy operator. The generated Story Diagrams realize the behavior of the copy operator by means of a traceability meta- model and the introduction of additional stories and control structures. The com- plete transformation is still complex but thanks to the use of an intermediate layer and the modularity mechanisms of Story Diagrams, the complexity can be decom- posed into manageable parts. Apart from the facilities for manageing the transfor- mation complexity, the model-to-model transformation approach is promising due to portability opportunities:

Java appears to be promising but the validation of this work is still in progress. This work builds upon the case study from Hoffmann [4] by considering the attributes and links from syntax nodes within method bodies in more detail. We are evaluating whether or not the use of control structures such as a Story Diagram < <loop> > leads to more complex rules than those making use of graph variables.

