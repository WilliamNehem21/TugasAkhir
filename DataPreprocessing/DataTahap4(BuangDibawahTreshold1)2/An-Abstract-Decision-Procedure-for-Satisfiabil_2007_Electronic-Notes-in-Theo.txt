The theory of recursive data types is a valuable modeling tool for software verification. In the past, decision procedures have been proposed for both the full theory and its universal fragment. However, previous work has been limited in various ways. In this paper, we present a general algorithm for the universal fragment. The algorithm is presented declaratively as a set of abstract rules which are terminating, sound, and complete. We show how other algorithms can be realized as strategies within our general framework. Finally, we propose a new strategy and give experimental results showing that it performs well in practice.

Recursive data types are commonly used in programming. The same notion is also a convenient abstraction for common data types such as records and data structures such as linked lists used in more conventional programming languages. The ability to reason automatically and efficiently about recursive data types thus provides an important tool for the analysis and verification of programs.

Perhaps the best-known example of a simple recursive data type is the list type used in LISP. Lists are either the null list or are constructed from other lists using the constructor cons. This constructor takes two arguments and returns the result of prepending its first argument to the list in its second argument. In order to retrieve the elements of a list, a pair of selectors is provided: car returns the first element of a list and cdr returns the rest of the list.

which indicates whether a given term was constructed using that constructor. As an example of the more general case, suppose we want to model lists of trees of natural numbers. Consider a set of three recursive data types: nat, list, and tree. nat has two constructors: zero, which takes no arguments (we call such a constructor a nullary constructor or constant ); and succ, which takes a single argument of type nat and has the corresponding selector pred. The list type is as before except that we now specify that the elements of the list are of type tree. The tree type in turn has two constructors: node, which takes an argument of type list and has the corresponding selector children, and leaf, which takes an argument of type nat and has the corresponding selector data. We can represent this set of types using the following convenient notation based on that used in functional programming languages:

There are three main contributions of this work over earlier work on the topic. First, our setting is more general: we allow mutually recursive types and multiple constructors. The second contribution is in presentation. We present the theory itself in terms of an initial model rather than axiomatically as is often done. Also, the presentation of the decision procedure is given as abstract rewrite rules, making it more flexible and easier to analyze than if it were given imperatively. Finally, as described in Section 4, the flexibility provided by the abstract algorithm allows us to describe a new strategy with significantly improved practical efficiency.

Finally, another approach based on first-order reasoning with the superposition calculus is described in [5]. This work shows how a decision procedure for a recursive data type can be automatically inferred from the first-order axioms, even though the axiomatization is infinite. Although the results are impressive from a theoretical point of view, the scope is limited to theories with a single constructor and the practical efficiency of such a scheme has yet to be shown.

It is not difficult to see that the problem of determining the satisfiability of an arbitrary set of literals is NP-complete. The problem was shown to be NP-hard in [12]. To see that it is in NP, we note that given a type completion, no additional splits are necessary, and the remaining rules can be carried out in polynomial time. However, as with other NP-complete problems (Boolean satisfiability being the most obvious example), the right strategy can make a significant difference in practical efficiency.

that the greedy splitting strategy can be improved in two significant ways. First, the simple Split rule should be replaced with the smarter Split 1 and Split 2 rules. Second, these rules should be delayed as long as possible. We call this the lazy splitting strategy. The lazy strategy reduces the size of the resulting derivation in two ways. First, notice that Split 1 is only enabled when some selector is applied to u. By itself, this eliminates many needless case splits. Second, by applying the splitting rules lazily (in particular by first applying selector rules), it may be possible to avoid splitting completely in many cases.

