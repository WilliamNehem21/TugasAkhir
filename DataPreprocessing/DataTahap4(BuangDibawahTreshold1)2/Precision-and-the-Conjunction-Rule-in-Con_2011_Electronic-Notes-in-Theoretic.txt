We achieve this using the concept of a semantic proof that annotates program points in the code of a thread with descriptions of its local state (Section 4.1). Unlike the standard interpretations of Hoare triples, the interpretation in terms of semantic proofs is quite intentional. The definition of a triple being valid does not abstract away all the internal syntactic structure of the command or proof, while the standard interpretations are given solely in terms of the extensional meaning of the command and pre- and post-condition assertions. This use of an intentional definition is an acknowledgement that the intuitive reason for the unsoundness of the conjunction rule with imprecise resource invariants is crucially about proofs, not denotations of commands. In particular, imprecise resource invariants allow the two premisses of the conjunction rule to make conflicting choices about how to partition the state. It is these different choices of state partitioning in different branches of the proof that lead to problems, but the partitioning in question is irrelevant to the operational behaviour of the command.

Technically, to prove the soundness of concurrent separation logic, we define a thread-local interpretation of every thread in the program as a semantic proof. A formalisation of the Separation Property (Lemma 4.2) connects the thread-local interpretation to a standard interleaving operational semantics (Section 3). We then define the notion of validity of Hoare triples for commands with respect to this interpretation and prove the soundness of all the proof rules (Section 4.2). Despite not tracking a partitioning of the state, the thread-local interpretation is strong enough to establish that provability of a program in concurrent separation logic implies that the program is data-race free (Section 5).

The original concurrent separation logic also considers nested parallel composi- tions and explicit lock declarations. The restricted form of programs chosen here simplifies the formal development and makes the underlying ideas more explicit. Our results have been extended to dynamically-allocated locks and dynamically- created threads (see [8]), which are more general constructs than lock declarations and parallel compositions.

Locks are treated in the logic as follows. When a thread acquires a lock, it receives the ownership of a part of the state satisfying the resource invariant of the lock (Acquire). Before releasing the lock, the thread must re-establish the corresponding resource invariant. After the lock is released, the thread relinquishes

As we explained in Section 1, the core of our proof of soundness consists of establishing the Separation Property [12]: at any time, the state of the program can be partitioned into that owned by each thread and each free lock. The following lemma formalises the property in the case where the local states of threads are defined by their semantic proofs. This establishes a correspondence between our thread-local interpretation and the operational semantics of Section 3.

We now proceed to prove the soundness of the rules Frame, Disj and Conj. To this end, we show that we can construct semantic proofs for the conclusions of these rules from semantic proofs for their premisses. This is essentially a semantic counterpart of a proof that these rules are admissible in the logic including the global Acquire and Release axioms, i.e., that a derivation using these rules can be converted into a derivation that does not use them. By using semantic proofs instead of derivations in our proof system, we avoid having to deal with the syntactic form of the proof rules in the logic and the control-flow constructs in our programming language.

Our use of semantic proofs is inspired by program analyses based on abstract interpretation [5], which compute mappings from program points to elements of an abstract domain denoting sets of states. Proofs of soundness for such analyses rely crucially on the intentional information provided by the mappings. In fact, our proof of the Separation Property (Lemma 4.2) is almost identical to the proof soundness of a program analysis for inferring resource invariants in concurrent separation logic we have previously developed [9]. The aim of this paper has been to argue that the approach based on semantic proofs is also useful in proving the soundness of program logics and to demonstrate the corresponding techniques in a clean setting. In this paper, we presented our results for a simplistic programming language.

However, we have also applied our approach to more expressive languages, including dynamic lock allocation and deallocation, dynamic thread creation and first-order procedures; see [8]. Additionally, we have applied it to prove the soundness of a logic for verifying preemptive OS kernels [10], which establishes a form of refinement. From our experience, the approach provides a low-cost way of proving the soundness of complicated concurrency logics.

