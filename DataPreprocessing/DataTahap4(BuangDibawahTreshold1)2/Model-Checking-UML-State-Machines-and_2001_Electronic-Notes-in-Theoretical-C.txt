Besides model checking, HUGO also supports animation and the generation of Java code from UML state machine models, based on the same structure of im- plementation. Our aim is to ensure the correctness of the generated code with respect to the properties verified from the PROMELA model. The present version is still somewhat limited in this respect because guards and statements have to be expressed in the respective host languages (PROMELA or Java), and because the model checker lacks some of the constructs that are supported by code generation. The structure of this paper is as follows: section 2 introduces the relevant UML notations. The translation of state machines to PROMELA is explained in section 3, whereas the verification of collaborations is described in section 4. Section 5 gives

Incorrect. The two join transitions evaluate the results of the concurrent validations. If an incorrect PIN has been entered and the card is valid, the counter of invalid PIN entries is incremented; however, if the counter has exceeded a maximum value, the card is invalidated and the transaction aborted. In contrast, if a correct PIN has been entered, the counter is reset to zero.

Every state of a state machine is modeled by an individual PROMELA process. For every state machine, two additional processes serve to dispatch events stored in the event queue and to handle transitions. Communication among the processes that are associated with a single state machine occurs via unbuffered channels, whereas the event queue is modeled as a buffered channel.

A state machine maintains an array of its states and two queues of pending ordinary and completion events. The length of the event queue is set to the constant eventQueueCapacity, which can be increased if SPIN reports a channel overflow. In case of a synchronous call event, the sending machine includes its id with the event and waits for a notification from the receiving machine along channel chan- SCDone, indicating that the call event has been processed. The array sm holds the data for all state machines of the model.

Because different state machines communicate exclusively by message passing, their internal operations cannot interfere with each other. We take advantage of this observation by having such internal operations execute atomically, guarded by a global semaphore (cf. the macros enterMutex and exitMutex in the code fragment below). The semaphore is released after the execution of an RTC step and whenever events are generated during the execution of actions. This strategy leads to a significant reduction of the number of states that SPIN needs to generate

Completion. A completion event is raised when a state completes all its internal activities, as follows: a simple state completes internal activity when both its entry action and its activity (if present) have terminated. A non-concurrent composite state completes when its active substate is a final state and its activity has termi- nated. Finally, a concurrent composite state completes when all its regions have completed and its activity has terminated.

to arrive at a clear structure of the translation whose correctness should be jus- tifiable by inspection, and to be able to adapt easily to changes in state machine semantics, as can be anticipated for the forthcoming version 2.0 of the UML. A programming approach to implementing operational semantics should also make it easier to support the full range of UML constructs. For example, although HUGO presently does not support choice states (as does none of the other encodings), it is obvious how they can be implemented, while they pose non-trivial problems for encodings based on static pre-computation.

The format of extended hierarchical automata has been very popular to define the semantics of Statechart variants [3,5,6], and Latella, Majzik, and Massink [3] have provided a semantics for a behavioral subset of UML state machines, imple- mented in PROMELA. However, activities, entry and exit actions, completion events and transitions, history states, and context are missing in their paper; transition ef- fects may only generate new events. Moreover, this approach does not directly support the verification of collaborations, as it is limited to a single state machine. We have not been able to compare their model checker with HUGO because it ap- pears to be no longer available.

We have noticed a few ambiguities in the semantics of UML state machines as described in [8]. For example, the semantics is vague about completion tran- sitions with several concurrent source states; we consider such a transition to be enabled when completion events have been generated for all of its source states. Similarly, it is not clear to us what the semantics prescribes in case the guards of all completion transitions leaving a given state are false when the completion event is being handled. Our implementation consumes the completion event without fir- ing any completion transition. If completion events could be marked as deferred events, the user would be able to indicate that the event should be reconsidered later. Moreover, the semantics does not clearly specify when a composite state with an

