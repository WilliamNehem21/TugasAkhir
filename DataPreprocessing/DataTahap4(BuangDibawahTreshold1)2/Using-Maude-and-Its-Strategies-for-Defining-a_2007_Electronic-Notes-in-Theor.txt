Haskell is a lazy language, i.e. it adopts normal order evaluation, avoiding re- peated computations by sharing reductions. The lazy approach restricts the ex- ploitation of parallelism because expressions are evaluated only under demand. Therefore, Eden overrides the pure lazy approach, combining a non-strict functional

The rest of the paper is organized as follows. First we present a brief introduction to Maude; for a complete treatment we refer the reader to the Maude manual [3]. Section 3 gives an overview of Eden and implements its kernel syntax, while Section 4 is devoted to the operational semantics and its implementation in Maude. In Section 5 we extend our framework in order to be able to obtain measures from the computations. The last section presents our conclusions and outlines future

When evaluating the expression E1#E2 inside a process p, a new child process q is created together with two communication channels. The child is fed with the value of E2 via the input channel by its parent process p. Process q evaluates E1 E2 and returns the result (to its parent) via the output channel. The following diagram illustrates this:

We define in Maude the syntax of the kernel of Eden given above. We use sorts and subsorts to represent the different syntactic categories and their relations. Having different sorts allows us to concrete the patterns used in rewrite rules by using (Maude) variables of the most appropriate sort. We have sorts for ordinary variables (Std), for channels (Cha) and for the union of both sets (Var). We also use two sorts for distinguishing between expressions that are in weak head normal form (Whnf) and those that are not (NonWhnf). Both are Eden expressions (Exp).

properties. Finally, the process constructor has four arguments: a string corre- sponding to the process identifier; a heap; and two counters: one represents the number of children of this process and the other indicates the maximum number used to build new variables (incremented when renamings are needed because of the generation of new variables). There is also a union operator   (with empty syntax) for building systems.

that applies the strategy -par-> to each process in a system. This strategy is recursive and it terminates when the rest of the system (represented by the variable S:System below) is empty. The strategy =par=> receives as argument the variables corresponding to the threads returned by the function ET applied to the whole system. Strategy -par-> is called with the set of evolvable variables of process P, calculated by function inters.

blocked if there is some dependency on values that have to be communicated. The function nf (needed free) collects the dependencies derived from the free variables. Let us consider again the expression given as example in Section 3. After the application of the (let) local rule, the resulting heap is the one shown in the left-

mentation where to experiment different alternatives by selecting the appropriate definition of the functions nf and ET. These functions can be defined in different ways, thus obtaining different semantics for Eden. In the present implementation we have put each definition in a different Maude module. By instantiating the module defining the semantics rules with a module with a concrete definition of nf and a module with a concrete definition of ET, we obtain a complete specification of Eden.

First of all, the term being rewritten is extended with the actual values of the measures. One possible way to do that is by means of a set of attributes together with their values. One of these attributes contains the Eden system (Sys), that will be rewritten by the semantics rules shown in the previous sections. Here we show some examples of attributes.

Then, rewrite rules have to be defined to describe the modification of these measures. For example, the following rule addPC increments by one the number of processes, and the rule addET updates the total work that has been done as well as the maximal thread parallelism. These updates are determined by the variable CardET that will be instantiated by a strategy.

Finally, we need to modify the strategies in order to apply these rules together with the semantics rules. We show below two of these new modified strategies. Strategy =pc=> now applies rule addPC after applying rule pc (process creation). And strategy ==> updates the values of measures MaxPar and Work using the number of evolvable threads computed by expression size(ET(S:System)).

