This paper shows how a domain-specific semantics for object models can be used to support the develop- ment of transformations that reflect a particular implementation strategy. The semantics captures model constraints and domain assumptions in terms of abstract data types, and a transformation is correct if and only if it corresponds to a data refinement. The transformations represent development steps, involving the completion of method descriptions, and validity checks, addressing issues of definedness and consistency. The paper shows how compositions of transformations may be used for the automatic generation of working systems from formal, object-oriented designs.

The paper begins with a brief account of object modelling, and an overview of Booster, a formal, object-oriented language that will enable a concise exploration of the issues explored in this paper. In Section 3, we present a semantics for object models, sufficient for the analysis of global constraint information. In Section 4, we show how this semantics may be extended to reflect assumptions about the domain of application, expressed as an implementation strategy for postconditions.

We present a correctness criterion for model transformations: a transformation is correct with respect to a particular implementation strategy if and only if it corresponds to a data refinement within the extended semantics. In the final section, we examine two particular aspects of the semantics: the distinction between classes and components, and the treatment of inheritance. We discuss related work in the domain of formal methods, and outline possible directions for future research.

Object-oriented modelling languages support the presentation of a design in terms of an object (or class) model, describing the features of each class of objects, and the associations between them. A constraint language can be used to specify pre- and postconditions for operations, and invariant properties for classes and associations. Any further description of operations is usually given in terms of code, written in the target language of the implementation.

The declaration of an association can be extended to give the name of a matching association in the opposite direction; this is an economical means of expressing symmetry properties. For example, the declaration of supervisor within Student includes the information that supervisees is the name of the matching association within Staff, and vice versa. This captures exactly the property described at the beginning of this section.

An association has a target type and a multiplicity, which may be optional, mandatory, or many. It may be connected to a matching association in the opposite direction by naming that association as its mirror : this provides an economical means of specifying the basic form of association invariant. The multiplicity of the two associations will determine the nature of the underlying relationship.

for the assignment x .a := e to establish the condition y .a = e should be simply two different ways of referring to the same object, then the weakest precondition true, and this is the condition obtained from the above calculation. If, on the other

As an example, consider the method assign defined in the context of Staff, and inherited by the subclass TA. The subclass includes the additional invariant that the assigned supervisor should not be a reference to the current object. It does not seem appropriate to insist that the TA.assign method should be allowed when called with argument this, just because the method Staff.assign would be available in the same circumstances.

The semantics presented in this paper can be extended to allow the comparison of object models with different class structures, by adding a notion of encapsulation at the component level. Provided that models MA and MB present the same collection of classes, attributes, and methods to the environment, we can use the theory of data refinement to compare their semantics. In this way, we may provide formal support for the notion of refactoring proposed by [7].

as a series of model transformations; the final method specification is translated directly into functions in C, using library calls to access a data store component (generated using the C libraries of the B toolkit). Each transformation could be proved correct with respect to the strategy presented in this paper: outline proofs for the treatment of basic association invariants are presented in [22]. One of our objectives in developing the next version is to make proofs of correctness more straightforward.

