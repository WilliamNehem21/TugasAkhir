A series of papers recently addressed the need of synthesizing a LTS out of the reduction semantics of e.g. a calculus. The most successful technique so far has been proposed by Leifer and Milner with the so-called relative pushout (RPO) [15], which captures in an abstract setting the intuitive notion of minimal context into which a process has to be inserted, in order for allowing a reduction to occur.

In this paper we exploit the graphical encoding for MAs, proposed in [12], to distill a LTS on (processes encoded as) graphs. This LTS is then used to infer a set of rules defined on the processes of the MAs calculus, and we compare it with the alternative solutions proposed so far, discovering many similarities (thus confirming the hints provided by the ingenuity of the researchers), yet with a few substantial differences, as articulated in the concluding section. Since we are interested in LTS defined over processes, we provide a comparison with the only two works presenting a LTS on MAs processes, namely, those proposed in [16,23].

This paper is organized as follows. Section 2 briefly recalls the MAs calculus. In Section 3 we introduce (typed hyper-)graphs and their extension with interfaces, while Section 4 presents DPO rewriting on graphs with interfaces as well as the BC technique for distilling a LTS. Then, in Section 5 we recall a graphical encoding for MAs processes that has been introduced in [12]. A graph transformation system for MAs that simulates process reduction is defined in Section 6. Section 7 presents a LTS for graphs representing MAs processes, obtained by means of the BC synthesis mechanism. Section 8 introduces a LTS defined over processes of the MAs calculus and obtained from the LTS over graphs. Finally, Section 9 concludes the paper.

It seems noteworthy that three rules 3 suffice for recasting the reduction seman- tics of mobile ambients. That is possible for two reasons. First, the closure of reduction with respect to contexts is obtained by the fact that graph morphisms allow the embedding of a graph within a larger one. Second, no distinct instance of the rules is needed, since graph isomorphism takes care of the closure with respect to structural congruence, and interfaces of the renaming of free names.

In this section we apply the BC synthesis mechanism to Ramb in order to obtain a LTS for graphs representing MAs processes. We first show some examples of rewriting steps with BCs, then we use some pruning techniques (proposed in [4]) in order to obtain a simpler presentation of the derived LTS. This presentation is then used in the next section in order to define a LTS directly over MAs.

In the second case no transition is possible. Indeed the graph G+ is the whole graph G in parallel with a fresh ambient w having inside a capability in n, but the pushout complement of J > G > G+ does not exist, because n is restricted and thus it does not belong to the interface J . Intuitively, this means that no ambient from the environment can enter inside a restricted sibling ambient n.

E.2. However reasoning on the synthesized LTS is still hard (this is usually the case when working with derived LTSs, as pointed out in [2] and [3], where the authors state that an SOS presentation of the synthesized LTS would be desirable). In order to simplify this reasoning, we introduce a set of minimal transitions that allow us to derive all and only the transitions of the (pruned) synthesized LTS.

The rule CoOpen instead models an environment that opens an ambient of the process. The rule InAmb enables an ambient of the process to migrate into a sibling ambient provided by the environment, while in the rule In both the ambients are provided by the environment. In the rule CoIn an ambient provided by the envi- ronment enters an ambient of the process. The rule OutAmb models an ambient of the process exiting from an ambient provided by the environment, while in the rule Out both ambients are provided by the environment.

Moreover, the label and the resulting graph of the borrowed transition for G are obtained from the label and the resulting state of the minimal transition of D, respectively. Therefore, for each minimal transition we obtain an inference rule: the conditions in the premise correspond to the necessary and sufficient conditions for performing a transition from a graph G, while the label and the resulting process are obtained from the label and the resulting state of the borrowed transition, respectively. Since the labels of the LTS over graphs obtained by the BC mechanism represent minimal graph contexts enabling a graph production, then also the labels of our LTS over processes represent minimal process contexts enabling a reduction.

interface J contains all the nodes of JDopen , we conclude that n must belong to J , that is, n must bea free name of P . This represents the premise of the rule Open. Starting from the label J > F < K of the BC transition we now obtain the label of the process transition. By observing the shape of F , which contains all the items of FDopen , we can say that the process context is composed of the ambient n. Moreover, the context F is glued to G through J , which contains the free names of P and the nodes of JDopen , i.e., the name n and the nodes representing the roots of the graph G (which models P ). Since these two nodes represent the roots of the graph F (which models ambient n), we conclude that the label of the process transition

In this paper we exploit the graphical encoding for MAs, proposed in [12], to distill a LTS on (processes encoded as) graphs. We then use this LTS in order to infer a LTS directly defined on the processes of the MAs calculus. For the sake of simplicity, we considered a graphical encoding for MAs without communication primitives, as well as without recursive expressions. A graphical encoding for the whole calculus could be obtained by tackling both communication primitives and recursive processes along the lines of the solution in [4]. Once the graphical encoding for the whole calculus has been defined, the technique presented in this paper could be applied in order to obtain a LTS for the whole MAs calculus.

Beside the presentation of a succinct LTS for mobile ambients, our work is a relevant case study for the theory of reactive systems [15]. As already pointed out in the introduction, BC rewriting and bigraphical reactive systems [19] are both instances of this theory. This paper, together with [4], shows that the BCs approach is quite effective in deriving LTS for process calculi.

In the minimal transition Dout1 two ambients are borrowed from the environment. The first one has name m (i.e., the name from which the process want to exit), while the second has a fresh name n. This transition corresponds to the rule

In the minimal transition D'	the name n belongs to the process (it occurs inside the graph Dout' ) but, since the node n occur in JD'		, it should appear in the interface J , i.e., it must be free. Thus, this

Analogously to the substitution of process variables, our composition does do not capture bound names. Consider e.g. the bound name n of H < K. It does not appear in the interface K and thus, for all graph with interfaces K < I' > J ' (representing possible substitutions), it can not be identified with any name of I'.

