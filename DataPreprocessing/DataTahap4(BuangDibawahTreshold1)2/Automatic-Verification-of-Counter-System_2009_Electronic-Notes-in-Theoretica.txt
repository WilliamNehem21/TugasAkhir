Indeed, the final termination property is undecidable in the general case, and one has to consider some strong hypotheses to automate its verification. This ter- mination problem is classically solved by exhibiting a ranking function; it has been actively studied in the last three years in the context of code analysis for imperative programs containing loops with integer variables. In this context, [15] presents a complete method for the synthesis of linear ranking functions on the restricted class of single path loops. This result has been recently extended in [7] to (single path) nested loops and is implemented in the tool TERMINATOR [8], devoted to the anal-

ysis of C code for hardware device drivers. A complementary approach is presented in [14]. A semi-algorithm based on region graphs is proposed; it applies to exclusive multiple-path loops and is implemented in the PONES tool, devoted to the verifi- cation of Java programs. [6] synthesizes linear ranking functions for a larger class of systems: Integer-variable loops with multiple paths with non-exclusive guards. The synthesis is based on an enumeration of all linear functions (represented as Presburger formulas). The method is complete (if such a linear function exists, the procedure will eventually exhibit it), however, this work does not consider parame- ters.

From this result, we derive a procedure to automatically synthesize either Presburger-definable ranking functions or LPDS-definable ranking functions. The procedure will enumerate potential ranking functions and check them. The proce- dure terminates if and only if a Presburger-definable or a LPDS-definable ranking function exists. The proposed approach is used to verify a final termination prop- erty of the protocol ZCSP. The method extends the aforementionned works since our hypothesis are as general as [6] (which are larger than [14] and [7]), and the class of ranking functions we synthesize is larger than [6].

Protocol ZCSP (for Zero-Copy Secure Protocol) is a communication protocol imple- mented in the MPC parallel computer [10]. In essence, ZCSP protocol is a variant of BRP protocol that has been extensively studied (for instance, see [1]). In ZCSP several messages may be emitted before the respective acknowledgments are re- ceived; the acknowledgements may be received out of order; emitted messages have to be stored up to the reception of their own acknowledgment and those of their predecessors. This storage induces a greater complexity than BRP.

Proof. (sketch) The abstraction represents an overapproximation of the set of be- haviours of ZCSP: files are represented as counters and bounds on files are relaxed. Moreover, messages are now atomic. This coarser representation does not miss any interleavings since in ZCSP, packets of a given message are sent atomically. 

This last result may suggest to enumerate (fairly and efficiently) all Presburger functions and to test whether every Presburger function is a ranking function. This strategy will find a ranking function if there exists one Presburger ranking function. In the other case, the computation will not terminate. In particular, it may exist a non-Presburger ranking function.

We denote by FLP DS the set of LPDS functions. For example, f (x) = ci.x + dj with ci in Zk[p]C and dj in Zk[p] is a LPDS function. Let us remark that every (integer) linear function with a polyhedral convex domain is a LPDS function without parameter. The converse is obviously false.

n = 0. We prove that s ranked at 0 has all its successors in F inal: TS is deadlock- free, hence s has at least one successor s'; assume s' not being in F inal, then s' is associated with a rank given by f (s'), and by definition of the ranking function, f (s') < f (s); as the co-domain of f is N, this is a contradiction. It follows that every successor of s is in F inal, and s |= AF Final.

