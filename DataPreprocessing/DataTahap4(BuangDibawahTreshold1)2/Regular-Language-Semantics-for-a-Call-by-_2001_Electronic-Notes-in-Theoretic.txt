to make proofs less prolix and more formal. While a wieldy and accessible calculus that captures the full power of games may be unattainable, calculi for restricted yet non-trivial subsets of game-based models are very handy. They illustrate the game semantics in an applied setting, making the subject more accessible to those who find its abstractness daunting. But, more impor- tantly, such calculi can actually serve as a foundation for a new and practical approach to program analysis, predicated on solid theoretical results. A simi- lar avenue of research, but as applied to static analysis, is explored by Hankin and Malacaria [8,9].

The reader is not expected to be familiar with game semantics in order to understand this article. Also, it is not possible to condense such a rich topic in a few pages, but good and comprehensive introductory material is available [3]. The specific games model used to interpret Foil and on which we base the present regular language model is the one developed by Abramsky and McCusker [5,1]. In this section we will only introduce some of the key intuitive concepts of game semantics, especially as applied to call-by-value games.

represented by a game, but by a family of games. A strategy interpreting a term has two distinct stages, a protocol stage in which one of the members of the family is selected, followed by a play in the selected game. Intuitively, this mirrors the fact that, in call-by-value, all arguments are evaluated exactly once before the body of the function is evaluated. Accordingly, free identifiers can have only one value throughout the evaluation of a term. In contrast, call- by-name allows identifiers to correspond to different values at various points in the evaluation.

A regular-language representation of the game semantics of Foil is defined as follows. With types we associate games, represented as regular languages over an alphabet denoting the moves. With terms we associate strategies, represented as regular languages over the disjoint sum of the alphabets of the types of the free identifiers and the term itself.

The semantics of if is directly specified in the games semantics. Looping in game semantics is defined as an abbreviation using the recursion combinator. A general recursion combinator is not specified in this treatment, but the fixed point can be calculated by hand; the semantics of while above is the result of that calculation.

We have presented a games-based regular language semantics for an imperative language with first order procedures using call-by-value function application, with arrays and variables passed by-reference. The model is obtained directly from the game semantic model [5,1] by working out the details of the category- theoretical presentation and by observing that much of the games apparatus (justification pointers, etc.) is unnecessary in handling the present language subset.

