We describe the design and prototype implementation of a combination of theorem prover interface technologies. On one side, we take from Proof General the idea of a prover-independent interaction language and its proposed implementation within the PG Kit middleware architecture. On the other side, we take from IsaWin a sophisticated graphical metaphor using direct manipulation for developing proofs. We believe that the resulting system will provide a powerful, robust and generic environment for developing proofs within interactive proof assistants that also opens the way for studying and implementing new mechanisms for managing interactive proof development.

Proof General is a generic interface for interactive proof assistants, built on the Emacs text editor [4,7]. It has proved rather successful in recent years, and is popular with users of several theorem proving systems. Its success is due to its genericity, allowing particularly easy adaption to a variety of provers (primarily, Isabelle, Coq, and LEGO), and its design strategy, which targets experts as well as novice users. Its central feature is an advanced

version of script management, closely integrated with the file handling of the proof assistant. This provides a good work model for dealing with large-scale proof developments, by treating them similarly to large-scale programming developments. Proof General also provides support for high-level operations such as proof-by-pointing, although these are less emphasised.

Proof General provides an advanced implementation of script management which synchronises file editing between the proof assistant and editor in a two- way communication. Files are used to store proof scripts, representing parts of developments. If the user completes processing a proof script file, Proof General informs the prover, if the prover reads another file during processing, it will inform Proof General, and similarly for undo operations at the file level. Technically, Proof General is implemented mostly in Emacs Lisp, interfac- ing with other Emacs packages, notably including X-Symbol [37] for displaying mathematical symbols. A considerable effort has been made into making it easy to adapt Proof General to new proof assistants, and it is possible to

To address the limits of the existing Proof General model, and particu- larly of the Emacs Lisp implementation, Proof General (PG) Kit has been designed [5,6]. The central idea is to use the experience of connecting to diverse provers to prescribe a uniform protocol for interaction. Instead of te- diously adapting Proof General to each prover, Proof General calls the shots, by mandating a uniform protocol for interactive proof, dubbed PGIP, which each prover must support.

IsaWin is the instantiation of a generic graphical user interface called Gen- GUI for the Isabelle proof assistant. It provides a more abstract, less syntax- oriented interface to Isabelle (and related provers), based on the visual metaphor of a notepad [24]. All objects of interest, such as proofs, theorems, tactics, sets of rewriting rules etc. are visualised by icons on a notepad, and manipu- lated there using mouse gestures. More complex objects such as proofs can be manipulated by opening them in a separate sub-window. IsaWin offers self- contained history support, proof-by-pointing, dependency management and session management.

appearing in its pop-up menu and whether (and how) it can be opened into a separate sub-window. The interface also keeps track of dependencies, i.e. if one object is used as an argument to construct another object, and if objects are changed or outdated, all dependent objects are outdated as well.

For us, the experience with GenGUI and IsaWin has shown that the im- plementation of an interface as an add-on to the proof assistant, even in the same programming language, can leads to a less modular architecture, which makes the interface difficult to reuse. It also makes the interface less robust: if the prover diverges or returns a run-time error, the interface diverges or stops as well. For these reasons, not many different adaptations of GenGUI exist, and in comparison with Proof General, GenGUI has not fully delivered on its promise of genericity.

The spirit of Proof General Kit is to use lightweight protocols to connect together a range of components used for conducting interactive proof. Com- ponents are loosely coupled, and may be run on different machines. The specifics of the design are intended to work with existing theorem provers. Thus, where some of our design decisions appear fairly conservative, this is because we want to allow a gradual migration of existing theorem provers to

We expect that the other components have no access to the proof assistant other than via the mediator. The other components may have direct access to the theory store, but (especially in case of write access) this must be carefully sanctioned by the mediator. This separation allows the mediator to organize the synchronization messages needed for interactive development, for example, maintaining a set of locked files.

Proof development proceeds by traversing the fundamental states, building up proof scripts along the way. This incremental development model is an abstraction of what occurs in a typical prover, based on the current model used in Proof General. Some provers may not implement all of this (for example, some provers do not know anything about files; others identify theories and files), and some provers may provide richer notions (for example, nested proofs or generic proofs) which are not captured in PGIP.

The ideas behind the PG Kit system architecture have been outlined above. The architecture is described in more detail elsewhere [6,8], including XML schemas (written in RELAX NG [32]) for the PGIP and PGML languages. This section describes our prototype implementation of the design.

Events contain PGIP messages. To model PGIP faithfully in Haskell, we use HaXML [36]. From a given DTD, HaXML generates a series of Haskell datatypes, one for each element, along with functions to read and write XML. The advantage is that the type security given by the DTD extends into our program, making it nearly impossible to send messages containing invalid XML, and detecting the reception of invalid XML immediately. The broker does further validation on the messages, but it tries to be a robust as possible;

Display message events (DispMsg) contain messages to be displayed, such as a new proof assistant state, error or warning messages. Display events are generated by the event broker from proof response events, or as an answer to user input (e.g. trying to browse beyond the end of the history).

To allow for the possibility of divergence, we must be able to interrupt the prover. Presently, the prover is run in a child process on the same machine, so we can use signals. For a distributed setup where the prover may run on another machine, we will need provision to transmit out-of-band interrupt signals, for example by running the prover as child process of the process listening on the actual socket.

All display engines, even such seemingly different ones like Emacs and PGWin, serve to visualise display messages originating mainly from the event broker. Crucially, display messages and user input may refer to earlier messages. For example, in later proofs users will usually want to use theorems they have proven earlier.

In order to subsume different display engines in a uniform framework, we use the notion of an object as introduced by the generic graphical user interface (see Sect. 3 above). An object is anything the system needs to keep track of: most prominently, theories, theorems and ongoing proofs, but also auxiliary objects such as tactics, rewrite rules, and so on. Objects are typed. Types comprise basic types (such as theories, theorems, and proofs), and prover-definable types (such as the auxiliary objects, which vary from prover to prover). Each display must visualise at least the basic types, but may not

Notice that implementing a notion of object within the interface allows us to keep context information with objects which specifies dependencies: ef- fectively, a position within the linear PGIP protocol. This means that the user can switch between open proofs, for example, by selecting objects with the mouse. Behind the scenes the theory might be switched by aborting the currently open proof and closing its theory and file, before opening the file and theory of the newly selected proof. This is why displays must support outdat- ing and updating operations on objects: if an earlier definition is undone, or an ancestor theory is retracted, all dependent objects will be outdated by the broker, and marked as temporarily unavailable in the interface.

At present, we have implemented one main display component, PGWin. It is described further in Section 6 below. There is also a control display which can launch other displays. Work is underway within the present Emacs version of Proof General to also support a PGIP and Lisp interface to Emacs

The other piece needed for our prototype implementation is some proof as- sistant itself. By design, we want to interface with existing theorem provers with minimal effort, but recognising that they will need some customization. An experimental effort to PGIP-enable Isabelle/Isar [38] has been under- taken, with the help of the Isabelle development team. The implementation consists of a 500-line extension to the existing Standard ML module for inter- facing with Proof General that is already supplied with Isabelle. There have

This paper has described the concepts underlying the synthesis of the Proof General and IsaWin interfaces into one combined interface. The new interface has an event-based architecture based on the PG Kit, and consists of several components communicating in the PGIP proof protocol. The implementation of a first prototype of the PG Kit architecture has led to a many clarifications and extensions of the PGIP protocol; more are planned. The system comes with a new user interface, which allows a mixed graphical and textual interac- tion, combining the advantages of both Proof General and IsaWin. Moreover, the open architecture opens the way to more easily implementing new inter- action mechanisms, and developing a truly generic high-level interface.

The OMEGA prover [9] started as a framework to integrate different auto- matic provers. It has developed into MathWeb, which uses the XML format OMDoc [20] as an exchange language, and the ActiveMath [27] project, which is a learning environment based on OMDoc. OMEGA has a user interface, LOUI, but it is not generic in our sense; MathWeb uses style sheets for visual- isation. Nonetheless, the system architecture is not unlike ours: components

Prosper [15] uses another approach to interoperability, aiming at connect- ing different automated proof tools together: at the core of the system an LCF prover kernel is used to guarantee logical consistency. Tools are wrapped up as components, using the Prosper Integration Interface. Although this is a more logic-centred view, with an emphasis on the exchange of proofs and theorems, there are interesting similarities to our architecture: again, a light-weight cus- tomised middleware architecture implemented in a functional language and a central broker component with provers (and other tools) connected by loose coupling.

