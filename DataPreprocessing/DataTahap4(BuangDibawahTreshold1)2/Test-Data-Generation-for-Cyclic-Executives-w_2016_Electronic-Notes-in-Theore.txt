Controller software components in the automotive domain implement real-time reactive systems with C Code which are often automatically generated from Simulink/Stateflow (SL/SF) [27] models that are based on the cyclic executive model [2,24]. The cyclic executive model decomposes a component into cooperating non-preemptive periodic tasks which operate in an execution loop. Every iteration step of the executive loop consists of three phases: the reading of inputs from the environment, the computation of outputs which are also the state of the controller, and the transmission of the outputs to the environment.

In order to solve the test generation problem we adapt the approach based on bounded model checking, solvers and slicing in a framework that integrates two off-the-shelf renowned tools: Frama-C [16] and CBMC [11,23]. The adaptation includes: (a) a specialised slicing engine for cyclic executives which uses the slic- ing plugin of Frama-C and (b) a test generation engine built on top of CBMC. We present experimental results for two industrial powertrain software components comparing our framework with CBMC alone. Results show that slicing of cyclic ex- ecutive systems is effective and enhances test generation for complex controllers by reducing computation time. We use several code metrics, including the number of acyclic paths, to evaluate the complexity of code hampering model-checking based test generation engines. We also use these metrics to show the importance of slicing in our approach.

As a running example, we consider a cyclic executive system specified with two input variables: y1 and y2, five output variables: x1, x2, x3, x4 and x5; and two tasks: taskA 2p00 and taskB 3p00 which are executed every 2 and 3 time units, respectively. So, the system have three frames, F1 = taskA2p00.taskB3p00, F2 = taskA2p00 and F3 = taskB3p00. Frame F1 is executed at time 0 and then every 6 time units. Frame F2 (resp. F3) is executed every even (resp. multiple of 3) time units which is not a multiple of 6. Listing 1 presents the skeleton of C code for these tasks.

Model-checking [12] verifies that systems are satisfying properties and generates a counterexample when systems fail to satisfy them. Counterexamples are system execution traces which include valuation of variables. This paper applies the well- known model-checking based test generation principle [20] and reduces the test data generation problem for cyclic executive systems to a model-checking problem for safety properties. The safety property forbids a system under test to reach a target.

Evaluating and reducing the complexity of code that CBMC analyses is substantial for boosting the test generation. Based on the workflow of CBMC, we suggest eval- uating code complexity with the following metrics. We refer to [29,37] for detailed presentations of the metrics.

In our test generation framework, we propose a slicing engine for cyclic execu- tive systems which use the slicing plugin of Frama-C as a back-end. Frama-C is an open source static C code analyser augmented with many plugins like the program dependency graph and the slicing plugin. The slicing plugin of Frama-C reduces the code by using over-approximations of the values of the variables at every statement along with the control and data dependencies between statements. The dependen- cies are represented with a collection of dependency graphs; one for each function in the code [19,21]. Statement m is control-dependent on statement n if n is a decision-statement; then the function will execute m for one of the truth-values of the decision, and the function will not execute m for the other truth-value. State- ment m is data-dependent statement n if the value of a variable v can be modified

Frama-C proceeds as follows [30,21] to slice a function with respect to slicing criterion C. First, it identifies the observable statement where the slicing criterion is evaluated. Then, it deletes the statements which do not occur in any paths of the dependency graphs from the entry statement of the code to the observation statement; this operation proceeds in the graph of every function called between the entry statement of the code and the observation statement. Finally, generate the reduced code by projecting the dependency graph on the remaining statements. The slicing algorithm of Frama-C which uses the value-analysis plug-in of Frama- C is interprocedural and flow, path and context sensitive [35,4], i.e, the order of execution of statements, feasible paths and call-sites matter for code reduction.

This plugin from Frama-C outputs code corresponding to its internal represen- tation. One of the modification performed by Frama-C is to separate decisions in atomic conditions resulting in supplementary conditionals and goto instructions. The result from the execution of the program is exactly the same, but we will see in Section 4 that it can have undesirable effects in some cases.

Our slicing engine for cyclic executives augments the code with the slicing crite- rion, limits 5 the lengths of the paths that the slicing plugin of frama-C will analyse, and reduces the instrumented code with the slicing plugin of Frama-C. Indeed, if the length of the execution paths is not bounded, the path-sensitive slicing plugin of Frama-C will remove the unbounded loops (e.g the main executive loop) because the execution paths of infinite lengths within these loops are unfeasible; the sliced code will not be correct for the test generation. In our framework, the tester bounds the length of the execution paths; it is recommended to use the same bounds as for the test generation with the bounded model-checker CBMC.

As a first attempt to generate tests, we applied CBMC solely on the original code we received from our industrial partner, instrumented as described in Section 3.1. Experts of the powertrain component estimated that the delays for reaching each of the five targets defined with variable G Enum9 do not exceed 60 time units while the delay for reaching G Bool4 = 1 does not exceed 120 time units. So, we use these delays to set the bound for unrolling the main loop of the scheduler. The other loops in the code are all bounded explicitly and CBMC can unroll them automatically.

The second case study, as the first one, is designed as a cyclic executive and has also been obfuscated. The code has four tasks Init1, Init2, FXXX HF and FXXX LF. The first two are called in this order at the beginning of the execution while FXXX HF is called every 50 ms and FXXX LF is called every 1000 ms. The precise scheduling time of these functions is irrelevant to our analysis so time is simplified by using time limits instead. Therefore, FXXX HF is called every time unit while FXXX LF is called every 20 time units. The code has 87 output variables

A counter-intuitive result can be observed for this case study. Indeed, it takes more time for CBMC to reach targets on the automatically sliced version of the program than on the original code. However, the manual slice of the program inspired by the results of Frama-C performs better than the original code. Metrics for this example were also calculated but they are not shown due to the high number of functions. Observations are the same as in the first case study : metrics and computation time are closely related and the automatic slicing which is slower than the original code for this example exhibits metrics indicating a higher complexity. We believe this is due to the modifications performed by Frama-C prior to its analysis. CBMC seems to need more cpu time when dealing with code under this form.

Most of model-checking or symbolic execution techniques reduce test genera- tion to a SAT/SMT problem. The main difference between model-checking and symbolic execution techniques relies on the method for constructing the formulas. Model-checkers build the formula by translating the whole code without exploring the execution paths while symbolic execution tools like KLEE [7] merge pieces of formulas derived by successive exploration of the execution paths. The complexity of the techniques for building the formulas depends on the features used in code and loop unrolling is usually unavoidable. However, some more recent work [22] addressed the issue of loop unrolling.

So, a test generation approach based on bounded model checking, solvers and slicing was developed and implemented in various frameworks which integrate off- the-shelf tools [36,9,34,8,28]. The scalability of such frameworks in case studies is often characterized in terms of the number of lines of code (LOC) of controllers [9,34,8], however, model-checking engines are more sensible to the number of vari- ables, assignments, decisions and execution paths than to LOC. This is especially the case for engines which reduce the model-checking problem to a satisfiability of propositional logic formulas built from variables in code. Indeed, path explosion is

Our main contribution is a framework for generating test cases that are reaching target states in cyclic executive systems. Our framework is composed of a code slicing engine and a bounded model-checking test generation engine. Both engines instrument code prior to the analysis with Frama-C and CBMC. Results from two case studies show that our framework can be efficiently used in an industrial context and can relieve testers from tedious tasks.

Results also show that the use of slicing can help to reduce computation time or even make the difference between a failed search and a successful search in the context of embedded industrial systems. Therefore, slicing makes the code more amenable to model-checking based techniques. Code metrics were used to describe the complexity of the code and better understand the effect of slicing. However, code preprocessing done by the slicing tool used in this analysis caused problems when the amount of removed code was less important. Indeed, code modifications done by the tool would increase test generation time. Nonetheless, we consider slicing to be useful for our specific problem statement. Performing a slicing without code modifications proved better than the original code for all targets in the two case studies. We think that our observations on the importance of slicing are suited for symbolic execution which suffers from the very high number of paths to explore [25]. We believe that the proposed test generation framework can be used in produc- tion and it can be augmented with automatic techniques for revealing unbounded loops and over approximation of their bounds. We also plan to study the possibility

to exploit user knowledge including intermediate targets to solve the most difficult targets. Moreover, computing SAT/SMT formulas on each analysis is time con- suming and not efficient when targets rely on the same variables and are reachable within same maximal execution duration. Pre-processing and saving parametrized formulas for different targets may help in accelerating the test generation. Future work goes in this direction; we are exploring abstract interpretation and symbolic execution techniques.

