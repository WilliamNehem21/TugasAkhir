Introducing levels distinguishes between the different uses of concurrency and communication in a single system. For example, within a host there might be several applications, represented by areas at level app; or between host and net there could be a subnet level. Communication between two threads within an application will typically have a very different character to that between two hosts on a network, and a total order of levels allows us to express this concisely.

Definition 2.3 A process P is well-formed at level l if for every top-level agent m[Q], level m <1 l, and Q is itself well-formed at level m, recursively. An agent l[P ] is well-formed if P is well-formed at level l.

A single name may have several disjoint local areas within its scope. It is also possible for a name to occur outside any local area of the right level; in this case it can only be treated as data, not used for communication. We shall see how the operational semantics, and later the proposed type system, enforces this behaviour.

The type service for finger and daytime expands to (string @net )@host . This means that the channels can be used only for host -level communication, but the values carried will themselves be net -level names. The host -level commu- nication is between Inet and Finger or Daytime; the net -level communication is the response sent out to the original enquirer, in this case machine Carp.

The local area calculus provides a reasonable setting to explore the use of names that are known globally but act locally. We have given an operational semantics and proved that it correctly captures this intuition. Illustrative examples include an internet service protocol and a pair of distributed agents.

