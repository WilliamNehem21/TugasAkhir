We want to demonstrate the proposed modularization in source level and compiler correctness. For that we use two examples which t together. In section 2 we sketch an industrial project on the veri cation of a safety-critical expert system. Its correctness proof has actually been checked by the ACL2 theorem prover [24]. Safety can be proved by a technique which we call (veri-

rements for realistic correct compilation. Section 4 will yield a mathematical framework which enables us to precisely de ne compiler correctness by preser- vation of source program correctness. In particular, we will sketch a mecha- nical proof of preservation of partial correctness for a toy compiler in ACL2 (section 5). The role of toy examples is crucial in order to nally succeed, and we will give some comments in section 6. We will end up with some lessons learned and some wishes for theorem provers used in software veri cation.

For simplicity, we just consider relay groups that contain terminals, connectors (wires, soldering points etc.) and relay contacts as elements. Diodes, resistors and capacitors are left out. The generated test-plan consists of conduction and isolation tests. Note however, that relay contacts are part of relays, so can not be switched independently, and the test-roboter can only measure between terminals (outside connectors). Since later the certi cation is supposed to be performed automatically, the generated test-plan and hence the Relais Master is safety critical. We need the following guarantee:

We cannot go into much detail of the program and the proof. The checker is a Lisp program. Inputs are s-expressions representing C and T (as in the above example). C is a graph with nodes for every element, T is a set of either conduction or isolation tests between two terminals in a given state of the relay contacts.

Runtime result veri cation [13,35] is strongly related to program checking [4], and our case study is an application in the eld of testing safety critical devices. However, our main focus is on veri cation of the checker program that guarantees correctness of the test case generator (the Relais Master expert system). In contrast to e.g. [20], where test case generation is based on model checking, our approach does not rely on particular techniques used in the expert system itself. Classical veri cation and also model checking might well

As a compiler constructor, we can not relieve the application programmer from the burden to prove applications correct. We cannot guarantee correct- ness of implementations for incorrect source programs. Actually we have to construct the compiler without any knowledge about the intended meaning of source programs. On the other hand, a compiler can not preserve every

It is an important observation, that we can exactly characterize correct implementation by preservation of relative correctness [37], which generalizes Floyd's and Hoare's notions of partial respectively total program correctness. Let f 2 ( D   * D   ) be a program semantics and let P   D and Q   D be predicates, i.e., subsets of regular data. f is called (relatively) correct with respect to (pre- and post-conditions) P and Q, h P i f h Q i for short, i 

Relative program correctness generalizes the classical notions of partial or total program correctness. In order to see this, let f 2 ( Di * Do ) be an original unextended program semantics and let P  Di and Q  Do be pre- and post-conditions. f is called partially correct w.r.t. P and Q ( fP g f fQg for short), if f (P )   Q, i.e., if the following holds for f : Whenever the

precondition P holds for an input d 2 Di and if f (d)  Do is de ned, then any d0 2 f (d) ful lls the postcondition Q. And f is called totally correct w.r.t. P and Q ([P ] f [Q] for short), if f additionally is guaranteed to be de ned on any d 2 P , i.e., if f is partially correct w.r.t. P and Q and the domain domf

resting, that we actually have to prove the de nedness of the source code se- mantics and the correctness of the result of machine execution simultaneously as well. The reason is the conditional. The de nedness properties of the con- ditional inductively depend on the value of the condition. The conditional needs not be strict in both alternatives, and will not be for instance in re- cursive de nitions. The conditional has actually been the challenging case to

In a sense, our example above is a toy example compared to the work necessary for the veri cation of realistic compilers for practical source programming languages and real target processors [17]. Our source language is very small, and the abstract target stack machine code is unrealistically abstract and far away from the ugly reality of real world processors. In that sense, [10] only presents an exercise. But the proof is an interesting exercise, and it contributes to realistic compiler veri cation in two important respects:

In the PVS proof we use structural operational semantics and inductive re- lations to formalize partial functions. It is interesting, that we can essentially reuse the proof idea and overall proof structure of the ACL2 proof presented here: The PVS proof also is by combined structural and computational induc- tion. In our opinion, this is a good news with respect to proof engineering.

Software veri cation can succeed, although it is often considered hard or even impossible |in particular for large and complex systems. Mechanical proof support can help nding proofs (and errors). It may help to redo (or reuse) proofs after slight modi cations. And it might establish correctness. But in the latter case we depend on the prover. Its positive results, i.e., the successful proofs, should in principle be understandable and/or checkable, manually or by trusted proof checking programs. Otherwise we would leave a serious gap in the mechanically supported process of correct software construction and proof documentation.

The second wish is a bit more technical. Compiler veri cation deals with programming language semantics, and very often programs mean partial func- tions. In ACL2 we modeled them by error strict total functions, which is kind of tedious and always calls for an additional justi cation. Similarly in PVS we use inductive relations, which are also a bit tedious to handle. In both cases we need informal meta-arguments to justify the formalization. Although we know about the problems, we sometimes wish to have a logic of partial functi- ons, and a supporting theorem prover which is as usable and elaborate as the provers we used so far.

[2] R. Bartsch and W. Goerigk. Mechanical a-posteriori Veri cation of Results: A Case Study for a Safety Critical AI System (Abstract). In Lina Khatib, editor, Proceedings AAAI Spring Symposium on Model Based Validation of Intelligence MBVI'2001, Stanford, CA, U.S.A., March 2001.

[7] E.M. Clarke and E.A. Emerson. Design and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic. In D. Kozen, editor, Proceedings of the Workshop on Logics of Programs, volume 131 of Lecture Notes in Computer Science, pages 52{71, Yorktown Heights, New York, May 1981. Springer-Verlag.

U. Ho mann, H. Langmaack, H. Pfeifer, H. Ruess, and W. Zimmermann. Compiler Correctness and Implementation Veri cation: The Veri x Approach. In P. Fritzson, editor, Proceedings of the Poster Session of CC '96 { International Conference on Compiler Construction, pages 65 { 73, IDA Technical Report LiTH-IDA-R-96-12, Link ping, Sweden, 1996.

[13] W. Goerigk, Th. Gaul, and W. Zimmermann. Correct Programs without Proof? On Checker-Based Program Veri cation. In R. Berghammer and Y. Lakhnech, editors, Proceedings ATOOLS'98 Workshop on \Tool Support for System Speci cation, Development, and Veri cation", Advances in Computing Science, Malente, 1998. Springer Verlag.

[15] W. Goerigk and U. Ho mann. Rigorous Compiler Implementation Correctness: How to Prove the Real Thing Correct. In D. Hutter, W. Stephan, P. Traverso, and M. Ullmann, editors, Applied Formal Methods - FM-Trends 98, volume 1641 of Lecture Notes in Computer Science, pages 122 { 136, 1998.

[34] S. Owre, J. M. Rushby, and N. Shankar. PVS: A Prototype Veri cation System. In Deepak Kapur, editor, Proceedings 11th International Conference on Automated Deduction CADE, volume 607 of Lecture Notes in Arti cial Intelligence, pages 748{752, Saratoga, NY, October 1992. Springer-Verlag.

