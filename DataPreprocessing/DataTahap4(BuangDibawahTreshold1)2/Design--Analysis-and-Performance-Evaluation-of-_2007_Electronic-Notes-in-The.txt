Wireless Sensor Networks are considered as very large systems comprised of small sized, low-power, low-cost sensor devices that collect detailed information about the physical environment. Each device has one or more sensors (e.g. light, heat, movement, chemical presence, etc.), embedded processors and low-power radios, and is normally battery operated. Examining each such single device individually, might appear to have small utility. The realization of Sensor networks however, lies in using and co-coordinating a vast number of such devices and allows the implementation of very large sensing tasks. The system is deployed in areas of interest (ranging from homes to inaccessible terrains, disaster places, etc.) making them smart spaces where fine grained monitoring services and applications can be provided [1].

Group key establishment can be either centralized or distributed. In the first case, a member of the group is responsible for the generation and the distribution of the key. In distributed group key establishment all group members contribute to the generation of the key. Clearly, the second approach is suited for sensor networks because problems with centralized trust and the existence of single point of failure can be avoided. In our paper, we consider distributed group key establishment protocols [5,10,14,28] which can be applied in dynamic groups (where members can be excluded or added) and provide forward and backward secrecy. Moreover, all these protocols are based on the Diffie-Hellman key exchange algorithm [13] and constitute natural extensions of it in the multiparty case.

We conducted a comparative performance evaluation of our protocol with the GDH.3 protocol [28] for various network topologies using both experiments and simulation. The experimental study demonstrates the feasibility of implementing our protocol in real sensor network devices while the simulation study highlights the advantages and disadvantages of each approach given the available technology and the corresponding efficiency (energy, time) criteria. Overall our protocol manages to evenly distribute the energy dissipation among the sensor devices, leading to better energy balance.

follows. Let A and B be two entities that wish to share a secret key. Both A and B generate a pair of public/private key (kA, QA) and (kB, QB) respectively. Then A sends QA to B and B sends QB to A. A computes S = kAQB and B S = kBQA, where S is now their shared secret key. The only weakness of this algorithm is that there must be an authentication process between A and B so that there is a guarantee that every entity is who he claims to be. In the group key protocols that will be described in the next section, we assume that there is such an authentication between every two members of the group.

In the first stage every group member Mi generates a random secret value ki. The M1 participant selects a point P and sends to M2 the point Q1 = k1P which is its public key and can be used by M2. Then M2 sends to M3 the point Q2 = k1k2P (which is the public key of M2) and so on until the protocol reaches member Mn. The point Qn is the shared secret key and is calculated by Mn.

Handling JoinGroup Events. When a new member Mn+1 wants to join a group, it must first be authenticated by the base station and get an ID and then contact the group leader (via the nearest group member Mu and through the virtual tree structure) a JOIN<Mu, Mn+1> message. The group leader replies by sending the old group key Qn (again via the tree structure). Then Mn+1 generates a random value kn+1, computes the new group key Qn+1 = kn+1Qn and sends it back to the group leader. Finally, the group leader sends an UPDATE message to all group members, again by using the virtual tree. The need to contact the group leader is necessary in cases of more than one nodes joining the group simultaneously, in which case, the group leader delays the UPDATE message until all new nodes have joined.

Handling LeaveGroup Events. In the case that a member Mu leaves the group, the group leader generates a random value kn and computes a new group key Qn = knQn. Then, as in the case of the JoinGroup event, it informs all group members about the new shared by sending an UPDATE message using the virtual tree. However, since the removal of the old member will disrupt the tree structure, the children of

Given the above running times for performing the necessary cryptography op- erations, we continue by conducting a comparative evaluation study on the per- formance of GDH.3 and our protocol via simulation. The experimental evaluation is conducted with Power-TOSSIM [25] that simulates the wireless network at the bit level, using TinyOS component implementations almost identical to the MICA2 CC1000-based radio stack. In this set of experiments, the amount of time spent ex- ecuting instructions is not captured by TOSSIM. We generated loss rates from vari- ous different physical topologies of wireless sensor networks using the LossyBuilder tool provided by TOSSIM [21]. The transmission range of the devices was set to 50

