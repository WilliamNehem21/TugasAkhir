Computing in the modern world is characterised by diversity and rapid change. Science of computing is no exception, where we have diverse activities and theories dealing with different subject matters and using different approaches. All the more so there is a value in seeking a general theory of computing which can, among others, offer a common mathematical footing on which we can unify and integrate these diverse scientific theories and engineering disci- plines. Such a general theory is expected to act on science and engineering of computing as basic physical theories have acted on natural sciences and engi- neering, in spite of a different nature of computing from physical phenomena (on this difference we do not extend further here; except noting the complexity

method would particularly be successful. Theory of domains and denotational semantics, initiated by Scott and Strachy [45], is a forerunner of this approach. These different approaches compensate each other: without ambient gen- eral algebraic theories, the understanding of specific structures would be a limited one; but a general algebraic theory may as well become most effective when combined with a powerful concrete structure. Different presentations of a core theory may as well be extended to a general algebraic universe, gaining in both richness and applicability; and the former may suggest an alternative, useful presentation of a general algebraic universe which would help its deeper understanding. In fact, any general theory, however powerful, can give only one way of abstracting computational phenomena: other abstraction would always be possible, and the interplay among different mathematical abstrac- tions will enrich our scientific understanding. Thus distinct directions may as

The process on the left-hand side, which offers two choices, sends to the con- tinuation c two names, z1 and z2; then it waits with these names. If z1 is invoked, then P1 becomes active: similarly for z2 and P2. On the other hand, the process on the left-hand side, which selects information, receives two new names after the initial invocation, then selects the first one by outputting to it. As a result we obtain the following reduction:

which is of course not correct from the viewpoint of untyped processes, since z2 is still available for invocation: but, in typed processes. because we expect that the environment obeys the choice protocol, z2 will never be invoked, hence z2.P2 will be safely garbage collected, justifying the reduction. Since this justification depends on the typing of the process, we may add an annotation as, for example: (z1.P1 & z2.P2), which, as an untyped process, is still the same

Channel types are similarly extended, allowing each vector to be finite or infinite and each type to be of a finite or countably infinite height, with the same well-formedness conditions as before. A sum type can have an infinite domain; so is an action type in general. Using infinitary processes and types, the typing rules are given precisely as before, reading each rule as a constraint on each full subtree of a process.

Well-bracketing means, simply put, the parentheses match properly when writ- ten using the notations [, (, ) and ], taking the justification into consideration (e.g. [ can only be closed by ] which it justifies). We can now define an innocent strategy.

By innocence and contingency completeness, an innocent strategy is precisely characterised by a partial function from odd-length legal player views to next actions (if any). Such functions are called innocent functions. An innocent function uniquely defines an innocent strategy and vice versa. In essence, contingency completeness says that a strategy is always ready to receive any legal input; innocence says that a strategy always reacts in the same way in the same context (where the sameness in both instances takes the notion of

Example 4.2 Let 1 be the empty arena. An innocent strategy from 1 to B is that which returns true after the initial move (the latter justifies the former); another returns false; and the third one returns nothing. These respectively correspond to the three constants, the truth, the falsity, and the undefined, which are all and the only inhabitants of the boolean type. An innocent function from B to B starts from the root of the co-domain, and returns true immediately at the co-domain. This is a constant function of value true. Another innocent function of the same type would, after the initial action at the co-domain, asks at the domain, receives true (resp. false) then outputs false (resp. true) at the co-domain, defining the negation.

