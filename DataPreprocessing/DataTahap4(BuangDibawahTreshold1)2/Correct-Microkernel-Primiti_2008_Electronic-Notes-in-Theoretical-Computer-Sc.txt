Correctness guarantees for computer systems is a hot research topic. Since there are a lot of examples when the correctness of separate computer components has been successfully established, the formal verification of an entire industrial-size system is being brought to the forefront. In [8] Moore, the head of the famous CLI project, proposes the grand challenge of whole computer system pervasive verification.

microkernel, (iv) a simple operating system, and (v) an exemplary user applica- tion. Pervasive formal verification of the whole system is attempted. The process is supported by a variety of computer aided verification tools, both interactive and automated, in order to minimize the possibility of errors induced by verification engineers.

This work relates to the problem of operating system microkernel correctness. A microkernel is the minimal kernel which, basically, provides no operating system services at all, but only the mechanisms necessary to implement such services. The mechanisms include process and memory management, address spaces, low-level IPC, and I/O. Usually, they are implemented in the form of primitives, microkernel routines which provide this functionality to the upper layers. Since every service of an operating system makes use of primitives, the correctness of the latter becomes of special importance.

In the current paper we discuss the correctness issues of primitives of an academic operating system microkernel. We describe how the methodology for the system software verification developed in the frame of Verisoft is successfully applied to primitives implemented in C with inline assembler. We outline the correctness criteria of microkernel primitives. Stating the correctness theorems we show what it means that a primitive fulfills these correctness criteria. We sketch a general idea how such theorems are proven. In a case study we elaborate on particular for the example details of specifications and proofs.

The microkernel implements the Communicating Virtual Machines (CVM) [3] model which defines the parallel execution of concurrent user processes interact- ing with a kernel. According to the model the microkernel is split into two logical parts: (i) the abstract kernel which provides an interface to a user or an operat- ing system and could be implemented in a pure high-level programming language, and (ii) the lower layers which implement the desired functionality stated in the beginning of Sect. 2. The implementation of the low-level functionality necessarily contains assembler portions because processor registers and user processes could not be accessed by ordinary C variables. By linking the two kernel parts together the concrete kernel, a program which can run on a target machine, is obtained.

discuss the correctness of primitives. They are implemented in the C0 program- ming language [7], a slightly restricted C, with inline assembler parts. In brief, the limitations of C0 compared to standard C are as follows. Prefix and postfix arith- metic expressions, e.g., i++, are forbidden, as well as function calls as a part of expressions. Pointers are typed and do not point to local variables or to functions. Void pointers and pointer arithmetic are not supported. The size of arrays has to be statically defined.

(ii) a hard disk [5], and (iii) C0 machines [7]. Having them, we sketch the CVM semantics and give its correctness criteria. For details cf. [6]. Memories of physical and virtual machines are conceptually organized in pages of P machine words.

The computation is possible in two modes: user and system. In user mode a memory access to a virtual address va is subject to address translation. It either redirects to the translated physical memory address or generates a page fault in- terrupt which signals that the desired page is not in the physical memory. The decision is made by examining the valid bit v(pm, va) maintained by the memory management unit of the physical machine. When on, it signals that the page storing the virtual address va resides in the main memory, elsewise, it is on a hard disk.

The global memory of a C0 machine c is c.lms (0). The top local memory frame is denoted by top(c)= c.lms (c.rd ). A memory frame first includes the parameters of the corresponding function. A variable of a machine c is a pair (m, i), where m is a memory frame and i is the number of the variable in the frame. By va(c, i)= (top(c), i) we denote the i-th variable of the current function context.

no interrupt occurs it boils down to the step of the virtual machine cvm.up[pid]. Otherwise, the kernel dispatcher is invoked and the kernel computation starts. The kernel dispatcher handles possible page faults and determines whether a primitive f is meant to be executed. In case it is, the parameters of the primitive pf are extracted by means of the system call mechanism. The specification fS is applied

The implementation c is related to the CVM model by means of linking. We use the formal specification of the linking operator link(cvm.ak, c)= k. It takes two C0 machines encoding the abstract kernel and the implementation of its lower layers, respectively, and produces the concrete kernel k, also a C0 machine. We state that the concrete kernel k correctly runs on the physical machine pm by means of the C0 compiler consistency relation (cf. Sect. 3.2).

The correctness criteria for the user processes is hidden inside the memory virtu- alization relation. This simulation relation, called the B-relation, specifies a parallel execution of the user processes cvm.up on one physical machine pm. In order to specify the B-relation, let us first give a notion of a process control block (PCB). The PCBs are C0 data structures permanently residing in the memory of the underly- ing physical machine. They store the information about visible registers of all user processes. Thus, we are able to reconstruct user virtual machines from the contexts stored in the PCBs. The function virt(pid, pm, hd)= vm yields the virtual machine for the process pid by taking the register values from the corresponding PCB fields. The memory component vm.m of the built virtual machine is constructed out of the physical memory and the data on the hard disk depending on where a certain memory page lies:

We use Isabelle/HOL theorem prover as the basis for the verification environment. All the concepts and their semantics listed in Sect. 2.3 were formalized in Isabelle by the colleagues in the Verisoft project. The source code of the primitives is automatically translated by a tool into the C0 small step semantics in Isabelle.

In our experience it is inconvenient to prove such theorems directly. We rather create several separate lemmas of the same form but speaking about the code in different semantics. For example, if a primitive contains a number of assembler instructions wrapped both from the beginning and the end in C0 code, we create three lemmas: one for the C0 part before assembler, next for the assembler portion, and, finally, for the remaining C0 part. This simple idea is easily scalable to arbi- trary combinations of C and assembler. We prove such lemmas by applying C0 and inline assembler semantics. The crucial point is the construction of a consistent C0 machine after the assembler part execution. We proceed as described in Sect. 3.2.

As an application of the developed approach we show how we establish the correct- ness of the copy primitive 4 . It is intended to copy n words from a process pid1 at address a1 to a process pid2 at address a2. In the context of an operating system it is widely used to implement process management routines, as well as IPC. The correctness is justified by the instances of Theorems 4.1 and 4.2, where f = copy, and pf = pcopy = pid1, pid2, a1, a2, n.

The specification of the primitive has to reflect the changes on (i) the user processes cvm.up of the model, (ii) the concrete kernel k, and (iii) the underlying physical machine pm. Of course we do not specify just the same conditions in terms of each modified machine because they are interconnected through the simulation relations. We define the desired result on a sufficient level of abstraction. Nevertheless, there is a number of necessary properties, mostly of technical nature, that could be expressed only in terms of the implementation machines k and pm.

The  result  of  copyS  is  welldefined  only  if  the  preconditions precopyS (cvm.up, pid1, pid2, a1, a2, n) are satisfied.  Otherwise, the same trick as with C0 machines is used. The model state space Ccvm is extended with a single

claims the value of the result variable of the call. Next, it describes the changes in the physical memory of the updated machine pm'. Recall that a virtual address va of a process pid is translated to the physical one by means of the function pma(pid, va). Then, the step-by-step changes over the physical memory are:

The proof proceeds by applying the respective semantics to the code statement by statement. In order to prove the loop, i.e., lemma v, we formally specify the ranking function r(n, a1, a2)= i, s.t. r(0, a1, a2) = 0 which counts the number i of the remaining loop iterations. The lemma has an inductive fashion with the step of the

