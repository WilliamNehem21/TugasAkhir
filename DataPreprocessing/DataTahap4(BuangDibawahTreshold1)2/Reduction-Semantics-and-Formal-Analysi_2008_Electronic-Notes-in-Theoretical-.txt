At present, the reliability of web-related software is poor, to say the least; and formal analysis is one of the most effective ways to increase the quality, reliability, and security of webware. For example, formal specification and model checking analysis of Internet Explorer has uncovered many, previously unknown, types of address-bar and status bar spoofing attacks [8]. There is however, a substantial gap between the level of the formal specifications readily amenable to analysis, and the low level implementations of webware in conventional languages. This gap can be narrowed by the use of model checkers for conventional languages such as Java or C, which may be a reasonably practical way, though hard to scale up, to verify legacy

The paper is organized as follows. Section 2 discusses related work and presents preliminaries on Orc, rewriting logic, and Maude. The reduction semantics is then presented in Section 3. Its further refinement into a distributed object-based se- mantics and the verification of an online auction case study are covered in Section

Several Orc semantics have already been given. A precise but informal operational semantics for Orc was given by Misra in [21]; we consider this as the standard against which the success of any formal operational semantics should be measured. A formal SOS asynchronous operational semantics has been given by Misra and Cook in [22]; but since this asynchronous semantics allows some undesirable be- haviors, a refinement of the asynchronous semantics into a synchronous semantics, distinguishing between internal and external actions was also given in [22]. Differ- ent denotational semantics of Orc for reasoning about identities and algebraic laws about the language [13,14], and for formally analyzing dependencies in program execution [25] were also proposed. Moreover, encodings of Orc in Petri nets and the join calculus that reveal some of the subtleties of the semantics of the language were given in [5]. Most recently, Ian Wehrman et al. [27] proposed a relative-time operational semantics of Orc by extending the asynchronous SOS relation of [22] to timed events and time-shifted expressions.

Orc is a theory of orchestration, proposed by J. Misra [21], to model the smooth integration of web services. The Orc model is fairly minimal, yet powerful enough to express a wide range of computations [22]. Orc is based on the abstract notion of sites and the composition of the services they provide. A site is a basic service that provides a computation of some kind. For instance, CNN (d) and BBC (d) are sites that return the news for the given date d, and add (x, y) is one that returns the sum of its arguments. Sites are assumed to exist, and the computations they provide constitute the data processed by Orc expressions. A site, when called, produces at most one value. When a site responds to a call with a value v, the site is said to publish the value v. Moreover, site calls are strict, in the sense that a site call cannot be initiated before its parameters are bound to concrete values.

The program implements a prioritized site call. Site M is given priority over site N , in that a response from M , if received within one time unit, would be the value published by the expression. Otherwise, either value published by M or N is published.

Rewriting logic [16] is a general semantic framework that unifies in a natural way a wide range of models of concurrency. In particular, it is well suited to both give formal semantic definitions of programming languages, including concurrent ones (see [15,20] and references there), and to model real-time systems [24]. Furthermore, with the availability of high-performance rewriting logic implementations, such as Maude [10], language specifications can both be executed and model checked.

Clock: The clock field (clk : cm) maintains a discrete time global clock modeled using the domain of natural numbers (m is a natural number). We shall see later in Section 3.4 how the clock field is used to give the timed semantics of Orc.

into the message pool as a result of a site call, it is converted into the message [self , app(M, C, rand ), hn], which represents a potential response back to self , a reference to the current expression. The operator app(M, C, rand ), whose defini- tion depends on the site M , associates a pseudo-random delay to responses from remote sites. Once a response from M is returned, the site return rule may fire.

The distributed Orc auction program auction presented here was inspired by the Orc auction example given in [22]. The program uses a few expression declarations that we briefly describe first (a detailed discussion of the program and the following analysis can be found in [2]). The two main declarations are PostingDecl and BiddingDecl. PostingDecl defines an expression Posting(S) that gets items that are available to be advertised from the seller site list S, which is given below 7 .

The Bids expression collects bids in rounds, each lasting for one time unit. In each round, the maximum bid is computed and published by the site MaxBid , and then used as the minimum bid for the next round. The Collect expression (declared by CollectDecl shown below) returns a list of bidding pairs of the form (bid, bidder ).

along with six site objects: (1) a seller site object whose name is seller 0; (2) three bidder site objects (named b0, b1, and b2); (3) a site object for the auction site, which manages the bidding process; and (4) a site object for the MaxBid site. In auction, we assume that seller 0 has two items t1 and t2 for sale and that bidders follow different bidding strategies. For simplicity, we assume no communication delays, and allow enough clock ticks for program completion.

