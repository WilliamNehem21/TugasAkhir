Static Single-Assignment (SSA) form is an efficient intermediate representation used in virtual machines and modern compilers. It provides data flow information that simplifies the implementation of standard program optimisations such as constant propagation, dead code elimination, and partial redundancy elimination. Constructing SSA form involves the computation of graph relations such as dominance, and non-iterated and iterated dominance frontier. Although there exist efficient graph algorithms for these relations, the al- gorithms are elaborate to implement. In this paper we introduce a new approach to compute the dominance relation, the dominance frontiers, and the iterated dominance frontiers based on Boolean matrix calculus. We implemented our approach in an optimising backend for LCC bytecode and compared its performance with the state-of-the-art approaches. We use the Spec95 benchmark suite for our experimental evaluation.

Matrix D is the bit representation of the dominance frontier [10]. I.e., the vector- matrix multiplication svD computes the dominance frontier for subset Sv. Matrix M is the dominance relation represented as a matrix. If element mij in M is set to one, node j dominates node i; otherwise it is set to zero.

In our new approach we compute iterated dominance frontiers based on matrix calculus. For an implementation a simple binary matrix calculator is needed that is able to compute transitive closures of binary matrices and extended transitive closures. The transitive closure operations can be implemented as simple recur- rences until the result stabilises. However, more advanced techniques exist in the literature.

dom(u) \ {u}.  The dominance relation has been extensively studied in the past [27,23,6,2,15,14].  There exist some linear-time algorithms in the litera- ture [6,2,15,14]. Although they are asymptotically linear, some of the approaches have high linear constants [2], and are not practical to implement.

The experiments for the new approach and the state-of-the-art approaches were conducted on a Linux platform with 1GB RAM and a 2.0GHz CPU, running Fedora Core 2. The experiments were compiled and run with Java SDK 1.5.0. As a benchmark suite we used the Spec95 integer benchmark programs.

The experimental results indicate that our algorithms have a cubic time- complexity. However, this result goes in line with our theoretical considerations of our unified approach. A better algorithm for finding transitive closures (instead of performing a simple recursion) would improve the performance significantly. Note the implementation effort of our approach is minimal because only a simple binary matrix calculator needs to be implemented. Our approach has the smallest LOC( lines of code) in all three cases.

