Secret sharing resolves the tension between the availability and the secrecy of a secret by distributing a secret to multiple servers in such a way that it is disclosed only if some of these servers are compromised. One particular scheme is (n, t + 1) secret sharing, defined by the operations split and reconstruct. Split generates from a secret a random set of n shares, called a sharing, while reconstruct obtains the secret from any subset of a sharing with more than threshold t shares.

This first protocol assumes a benign environment. It is an asynchronous pro- tocol that has no bound on either the server speed, the message delay, or the local clock drift. Its goal is to proactively replace one sharing of a secret, col- lectively held by n servers, with another sharing of the same secret. A sharing is produced during one run or instance of the protocol and destroyed during the next run. To know the secret an adversary must obtain enough shares of a sharing to reconstruct it. Thus, the window of vulnerability is the duration

To abstract the replication from the secret-sharing part of the protocol terms of sort AId are used to represent one or more concrete objects, which are identified by terms of sort Oid. Above, all is used to represent all the servers. Abstract messages will be translated into messages to concrete objects by the replication meta-object.

is introduced. An A2C-Map is a mapping from AId to SetOfOids. The mes- sages of the protocol have associated a MsgType;a QuorumMap maps a MsgType to a quorum, a MachineInt. A RespRecognizer is a set of pairs consisting of an expected response, of sort Message, and a SetOfOids identifying those that have sent that response. a2c-map and responses-quorums depend on the pa- rameters n and t of the system; response-recognizer is initially empty, and it is built and modified as messages move up and down.

The link adversary can eavesdrop on links, while the server adversary gets ac- cess to local information of a crashed server. Since PassiveServerAdversary is not a subclass of ActiveServer it may not impersonate its victim. A server compromise is modelled by a rule that replaces the meta-tower representing the server by a PassiveServerAdversary object with the state of the server at the time of the crash.

This second version of the protocol assumes that a coordinator too may crash and be vulnerable to a passive server adversary. A coordinator p and a server p are regarded as processes of the same host; one is compromised if and only if the other is. Under this assumption there must be at least t + 1 coordinators, each of which may initiate a run.

The protocol is modified so that one of the competing runs succeeds in in- stalling a sharing. Only the specification of the base layer needs to be modified. Servers act as coordinators, yet both roles are kept as independent as possi- ble. A coordinator in this protocol is of the class ActiveCoordinatorServer, a subclass of ActiveServer and ActiveCoordinator. A sharing label must now identify the coordinator of the run that generated it, and sharing-label, that of the current sharing, replaces current-version-number. Server has an extra attribute, finished, to store the latest finished message received, which ends a run. When a server receives a message from a coordinator of a competing run, it will forward the stored finished message in response. When a coordinator receives a finished message it aborts its run, and for- wards the message to all servers. One special rule is needed to handle the case when a coordinator has ended or aborted its run and is informing itself, as a server, to end its run.

The next version of the protocol defends against active link adversaries. These can insert, modify, delete, reorder or replay messages. The most difficult against which to defend is the deletion of messages. This section sketches very briefly elements of the specification of this version.

servers-shares(Conf) is the set of all shares and subshares held by active servers; adversaries-shares is the analogous set for adversaries. There are three representations for sharings, depending on whether a sharing was obtained from a split; from the refreshment process; or was installed at the end ofa run. all-secrets transforms a set of secrets by recursively recovering secrets from sharings.

The availability and secrecy correctness criteria of the APSS protocol are violated if there exists some run of the protocol in which at some point the servers cannot recover the secret or the adversaries can. Maude is a reflective language that supports an arbitrary number of metalevels. Any specification can be meta-represented at the next metalevel, and thus manipulated from it. In particular, Maude can be used to specify strategies, specifications to control the rewriting process. This section considers some of the properties of the specification of the APSS protocol. It motivates and describes a strategy that exhaustively generates all computations of a specification with such properties, which can be used to formally analyze the protocol by searching for runs that violate the availability or secrecy property.

Both protocols assume a benign environment in which adversaries may only access local information from crashed servers. Under this assumption encryption is unnecessary. Thus, the search space may be reduced somewhat by having initial states with two-meta-object towers, with no encryption meta- objects.

The behavior of the replication layer is described by four conditional rules. Two consume upward-moving messages; two, downward-moving messages; and in each pair the condition of one rule is the negation of the condition of the other. Thus, any message consumed by a replication meta-object deter- mines a unique transition. The application of a replication rule may produce zero or more messages to be exported up, down or in both directions, enabling out and down transitions, with the out transitions enabling in transitions by other replication meta-objects. In an APSS instantiation of the parameterized replication layer only the Filter attribute may have its value changed. It is implemented as a set of tuples. An upward-moving message may add a new tuple to the filter. A downward-moving message may replace a tuple, just to change a component that is a count of downward-moving messages. Since im- porting attributes (in and up) are multisets, and downward-moving messages may only change the value of a count, internal transitions of a meta-object are incomparable.

The availability and secrecy properties are predicates on the state of the secret- sharing layer. Therefore, the computation tree that needs to be explored is the one whose nodes are states of the secret-sharing layer. The transitions of the replication layer should be hidden.

Given a state of the secret-sharing layer, a child in the computation tree is obtained by the application of an internal secret-sharing rule, or the immedi- ate delivery of a message sent, which hides the replication transitions. Since the replication layer is Church-Rosser, it is convenient to use the function meta-rewrite of the predefined module META-LEVEL. This function takes a Module M , a Term T and an integer n, and uses a default, fair strategy to obtain a Term T '. For n = 0, the resulting T ' cannot be further rewritten. In order to provide meta-rewrite with an appropriate module for this purpose the specification is modified as described below.

Some versions of the asynchronous proactive secret-sharing protocol have been described. The specification has been factored into three layers: secret- sharing, replication and encryption. A general parameterized layer for the replication of messages and collection of quorums of responses was instanti- ated for an (n, t) instantiation of the APSS protocol. A strategy that exploits the structure of the specification to reduce the search space was developed.

Thousands of complete runs of length 40 are found, none shorter. Since the period of vulnerability is the duration of two consecutive runs, a search tree should be at least of depth 80. Thus, further ways of reducing the space search will be sought. This work was done using Maude 1.0.5. Continuing work will exploit the more powerful features of newer versions of Maude in better analysis techniques and a more complete specification of the protocol.

