Real-Time Maude 2.1 is an extension of Full Maude 2.1 supporting the formal specification and analysis of real-time and hybrid systems. Symbolic simulation, search and model checking analysis are supported for a wide range of systems. This paper gives an overview of the tool and documents its semantic foundations.

In earlier work we have investigated the suitability of rewriting logic as a semantic framework for real-time and hybrid systems [10,14]. The positive results obtained were then used to build a prototype Real-Time Maude tool [13,10] based on an earlier version of Maude. This prototype showed that real- time system specifications of considerable generality and practical interest, falling outside the scope of the known real-time decision procedures, could be fruitfully executed, and analyzed by search and model checking [10,12].

2.1 implementation [5], especially its efficient built-in support for search and LTL model checking, and Full Maude 2.1, have provided a good basis for both simplifying the specification of real-time and hybrid systems, and for develop- ing a well-documented [11] and efficient tool, Real-Time Maude 2.1, that we present in this paper.

At present, designers of real-time systems face a dilemma between expres- siveness and high assurance. If they can specify some aspects of their system in a more restricted automaton-based formalism, then high assurance about system properties may be obtained by specialized model checking decision procedures, but this may be difficult or impossible for more complex system components. In that case, simulation offers greater modeling flexibility, but is typically quite weak in the kinds of formal analyses that can be performed. We view Real-Time Maude as a tool that provides a way out of this dilemma and complements both decision procedures and simulation tools. On the one hand, Real-Time Maude can be seen as complementing tools based on timed and linear hybrid automata, such as Uppaal [8], HyTech [7], and Kronos [15]. While the restrictive specification formalism of these tools ensures that inter- esting properties are decidable, such finite-control automata do not support well the specification of larger systems with different communication models and advanced object-oriented features. By contrast, Real-Time Maude em- phasizes ease and generality of specification, including support for distributed real-time object-based systems. The price to pay for increased expressiveness is that many system properties may no longer be decidable. However, this does not diminish either the need for analyzing such systems, or the possibility of using decision procedures when applicable. On the other hand, Real-Time Maude can also be seen as complementing traditional testbeds and simulation tools by providing a wide range of formal analysis techniques and a more ab- stract specification formalism in which different forms of communication can

The motivation behind having eager and lazy rewrite rules was to model urgency by letting the application of eager rules take precedence over the application of lazy tick rules [14]. This feature was supported in Real-Time Maude 1. The ability to define frozen operators in rewriting logic [3] means that it is no longer necessary to explicitly define eager and lazy rules. Instead, one may define a frozen operator

This technique should make unnecessary any explicit support for eager and lazy rules at the system definition level to model urgency. In addition, the lazy/eager feature has not been needed in any Real-Time Maude application we have developed so far. Real-Time Maude 2.1 therefore does not provide explicit support for defining eager and lazy rules.

where x is a variable of sort Time (or of a subsort of Time) which does not occur in {t } and which is not initialized in the condition. The term u denotes the maximum amount by which time can advance in one tick step. Each variable in u should either occur in t or be instantiated in cond . The (possibly empty) conditions cond and cond ' should not further constrain x (except possibly by adding the condition x =/= zero). Tick rules in which the time increment is not given by the match are called time-nondeterministic. All other tick rules are called time-deterministic and can be used e.g. in discrete time domains.

or with time bounds of the form < r or with no time limit. The model checker in general cannot prove a formula correct in the presence of time- nondeterministic tick rules, since it then only analyzes a subset of all possible behaviors. If the tool finds a counterexample, it is a valid counterexample which proves that the formula does not hold. Time-bounded model checking is guaranteed to terminate for discrete time domains when the instantaneous rules terminate.

Real-Time Maude is designed to take maximum advantage of the high per- formance of the Maude engine. Most Real-Time Maude analysis commands are therefore executed by first transforming the current timed module into a Maude module, followed by the execution of a corresponding Maude command (at the Maude meta-level ). The actual transformation of a timed module de- pends on the Real-Time Maude command to execute. This section defines the

The two tick rules model the effect of time elapse on a system by increas- ing the clock value of a running clock according to the time elapsed, and by leaving a stopped clock unchanged. Time may elapse by any amount of time less than 24 - r from a state {clock(r )}, and by any amount of time from a state {stopped-clock(r )}. To execute the specification we should first specify a time sampling strategy, for example by giving the command (set tick def 1 .). The command (trew {clock(0)} in time <= 99 .) then simulates one behavior of the system up to total duration 99. The com-

99. Since the reachable state space is finite when we take the time sam- pling into account, we can check whether a state {clock(r )}, with r > 24, can be reached from state {clock(0)} by giving the untimed search command (utsearch {clock(0)} =>* {clock(X:Time)} such that X:Time > 24 .). The command (utsearch [1] {clock(0)} =>! G:GlobalSystem .) can show that there is no deadlock reachable from {clock(0)}. Finally, the command (utsearch [1] {clock(0)} =>* {clock(1/2)} .) will not find the sought- after state, since it is not reachable with the current time sampling strategy.

The reachable state space from initState is infinite since the time stamps and clock values may grow beyond any bound, and since the state may contain any number of old messages. Search and model checking should be time- bounded to ensure termination. The command (set tick def 1 .) sets the

