An algorithm to deal with the problem of finding a formula of minimal quan- tifier rank that distinguishes two sets of structures over an arbitrary vocabulary is presented in [14]. An important part of this algorithm is the use of Hintikka formulas. As this algorithm works for arbitrary finite relational structures, it runs in exponential time. A general system for learning formulas defining board game rules uses this algorithm. These results are also used in reduction finding [13]. In [23], the authors define a variation of the problem in [14] which considers samples of classified strings.

MS and ES because necessary and sufficient conditions for a winning strategy of the players in an EF game on these classes are provided in the literature [15]. For DULO, we show our result on a characterization of the winning strategies for both players. We use these characterization results on EF games in order to design an algorithm to find a sentence of minimal quantifier rank which is consistent with the sample. Also, for MS, ES, and DULO, the EF-similarity can be computed in polynomial time in the size of the structures. Using these results, we show that our algorithm runs in polynomial time in the size of the sample. Therefore, this result improves the one in [14] for MS, ES, and DULO. We expect that our results can be adapted to other classes such as trees and strings with a built-in linear order relation.

A new logical framework to find a formula given a sample, also with a model- theoretic approach, can be found in [10,9]. In this framework, the input is only one structure, and its elements are classified as positive or negative. The problem is to find a hypothesis consistent with the classified elements where this hypothesis is a first-order formula in [10] and a monadic second-order formula in [9]. Also, [9] only considers strings as the input structure. The first main difference is that, in our approach, a sample consists of many structures classified as positive or negative. Second, the algorithm in [10] assumes that the quantifier rank is fixed while we

Another logical framework for a similar problem is Inductive Logic Programming (ILP) [20,21,3]. ILP uses logic programming as a uniform representation for the sample and hypotheses. Therefore, due to the fundamental difference between the framework of ILP and our approach, there is no direct relationship between ILP and our work. Then, techniques used in the framework of ILP cannot easily be applied in our approach.

EF games provide information about the similarity between structures. If two structures A and B are not isomorphic, then there is an r such that the Spoiler has a winning strategy in Gr(A, B). The notion of EF-similarity below represents this information about similarity.

vocabularies, the problem of determining whether the Spoiler has a winning strategy in Gr(A, B) is PSP ACE-complete [22]. Fortunately, it is possible to do better for EF games on MS, LO, and ES. In what follows, we show the case for EF games on MS and ES. For details of the results on these classes see [15].

Besides the importance of EF games on a specific class of structures to our frame- work, we also use Theorem 2.8, Theorem 3.1, and Theorem 2.9 to define the distin- guishability sentences. These sentences are defined based on the conditions charac- terizing the winning strategies for the Spoiler on MS, ES, and DULO.

Theorem 2.5. The first step is to show that the conditions characterizing winning strategies for the Spoiler can be expressed by first-order sentences of size polynomial in the size of the structures. This result is important in order to guarantee that our

In the following, we prove some properties of our algorithm. First, we show that it returns a sentence that is consistent with the sample. After that, we show that it returns a sentence of minimal quantifier rank. Then, we prove that the running time of our algorithm is polynomial in the size of the input sample.

Finally, we plan to extend our approach to other logics such as monadic second- order logic. Regular languages are exactly the languages definable in monadic second-order logic over strings [1,16]. An algorithm which returns monadic second- order sentences consistent with a given sample of strings can be used in the problem of finding a model of a regular language consistent with a given sample of strings [12,25].

