Refinement is conventionally used to effect a demonstrably-correct development from an abstract specification. Emergent systems present an interesting challenge in terms of demonstrably-correct development, because there is a discontinuity between the global and local system descriptions. This is a position paper, exploring some aspects of the challenge in relation to the traditional model of refinement.

We use the example of a cellular automaton (CA) producing gliders. A CA is perhaps the simplest of the commonly-studied emergent systems, in that its operational environment is completely determined by its representation and a single update rule. This provides a starting point for consideration of development issues, from which our position can be developed.

The paper starts with a brief review of classical refinement. We then de- scribe a model of emergence, illustrated by a CA; we highlight issues relating to the specification of emergent systems. On this basis, we examine meanings of refinement for emergent systems, before exploring reasons for the mismatches between classical refinement and emergent systems development. This allows us to examine how emergent systems development might proceed, and where it might exploit at least some of the ideas of classical refinement.

In describing a system, low level component agents have behaviours and interactions expressed in some language C ; the high level global behaviour is expressed in some language A. The system displays emergence if there is a fundamental discontinuity between the languages A and C (a similar definition is made by eg. [13]). For example, each agent in a flock might be described as moving towards a locally perceived centroid, whereas the global behaviour of interest is the velocity and size of the entire flock [12]. It is this discontinuity of description language that offers a challenge to conventional refinement.

One of the simplest emergent systems to study is a CA. In this paper, we model a CA in separate components, namely a cell (with a state, update rules and a set of neighbours) and the representation of the collection of cells. This has the advantage of moving the CA closer to other forms of emergent system, in which the representation (of a 2 or 3 dimensional space of various form and content) is clearly separable from the active entities (ants, termites, boids).

The cell becomes part of a CA (a cellular array of finite state automata) when it and its neighbours are located in some discretised space. Convention- ally, the state of each cell is represented by colour or shading. At this point, some visual patterns may be apparent, but nothing is happening.

The non-determinism of the glider specification is reduced by refining the region in a way that facilitates representation of movement, ie by introducing something relative to which motion would be perceived. A common approach is to use a discretised spatial representation that allows quantification of loca- tion. For example, a regular or irregular grid allows some form of co-ordinates to be used to record the shapes and relative motion of gliders.

There are a number of terminating sub-computations within the continuous emergent system. Taking an interpretation that sees finalisation as the mecha- nism that provides something from a component to the whole (by analogy with classical subsystems), finalisation can be applied to each sub-computation. For example, a cell updates at a time step. The finalisation ensures that the new state is passed to the representation. The finalisation of the representation at the completion of one (collective) update ensures that the whole changed representation is revealed instantaneously.

In expressing the components of a CA, we note that each level (system, repre- sentation, cell) expresses, in some sense, a derivative of the next. Thus, a cell is one-dimensional; the representation introduces a multi-dimensional space; and the system introduces the time dimension. In the representation, each cell gains a location; in the system, blocks of cells appear to have velocity.

However, classical refinement is also a process of trial and error (though some formalists try to convince us otherwise). Despite neat published illustra- tions, the reality is an iterated guess-work, guided crucially by the experience of the guessers. Text books are notorious for tweaking the abstract specifica- tion so that refinement is clean. Retrenchment [2] acknowledge that in reality clean refinement is rarely possible, whilst forward-and-backward refinement to an invented intermediate state provides a trial-and-error approach when there is no easy direct route from the (real) abstract specification to the re- quired concrete model. The authors have also investigated (to various levels) refinement patterns [17], template-based refinement [1], and evolutionary ap- proaches to proof and refinement.

