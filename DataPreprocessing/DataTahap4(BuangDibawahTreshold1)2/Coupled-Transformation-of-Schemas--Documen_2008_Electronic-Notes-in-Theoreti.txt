techniques can be used to transform automatically composed conversion functions as well as other value-level operations. These additional transformations enable optimization of conversion functions and migration of queries. Section 5 discusses how two-level transformation can be made constraint-aware, in the sense that con- straints on transformed types can be propagated and introduced during type-level transformation. We discuss related work in Section 6. In Section 7 we summarize the contributions of the 2LT project and we indicate avenues of future work.

Similar coupled transformation of data types and corresponding data instances are involved in the scenario of data mapping [31]. Such mappings generally occur on the boundaries between programming paradigms, where for example object models, relational schemas, and XML schemas need to be mapped onto each other for pur- poses of interoperability or persistence. Data mappings tend not to be evolutionary, but rather involve fully automatic translation of entire data structures, carried out during system operation.

In the first transformation step, the nested type X is transformed by transfor- mation T1, witnessed by to1 and from1. To pull the nested transformation to the level of A itself, the map operator associated to F is applied, which results in the transformation F T1 (where we once more overload the symbol F ) which converts FX into the intermediate type FX'. The witnessing conversion functions are lifted to Fto1 and Ffrom1. This is an example of structural composition of two-level transformations.

When developing a framework for two-level data transformation, the challenge arises to drive composition at the value level by composition at the type level. In other words, from a compositional specification of the transformation of one type into another, it should be possible to derive compositional specifications of the value-level transformation functions that convert between values of these types. Moreover, the derivation should be dynamic, in the sense that the target type of the type-level transformation can not be assumed to be known before hand, but is only arrived at by actually carrying out the transformation. Likewise, the types of the derived conversion functions, as well as their compositional specification are computed dynamically.

type-safe manner by judicious use of dynamic types. Using this approach, value- level transformations are statically checked to be well-typed with respect to the type-level transformations to which they are associated, and well-typed composition of type-level transformation steps induces well-typed compositions of value-level transformation steps. The approach will be reviewed in Section 3.

Firstly, the dynamically computed compositions of value-level functions resulting from two-level transformations fulfill the task of converting source values into target values and back. But they do not necessarily perform this task in the best possible way. In particular, these functions may include redundant intermediate steps and may not perform their steps in optimal order. Thus, a further challenge arises to post-process conversion functions after composing them, in such a way that conversion steps are reordered and fused and more optimal conversions are derived. Secondly, data processing operations may exist on the source type of a two-

Generally, schema definitions consist of a structural description augmented with con- straints that capture additional semantic restrictions. For example, SQL database schemas and XSD document schemas may declare referential integrity constraints, grammars include operator precedences, VDM specifications contain datatype in- variants. When a data schema is transformed, the corresponding constraints must also be adapted.

In [1], we showed that constraint-awareness can be built into our framework for two-level transformation in a straightforward manner. In this approach, constraints are represented in a similar manner as data conversion functions and queries. Un- like these data processing operations, the functions that represent constraints are embedded into representations of types. The approach is explained in more detail in Section 5.

In this section, we explain how data refinement theory, combined with typed strate- gic term rewriting can be used to provide an initial framework for two-level trans- formation [15]. This initial framework addresses the first challenge of two-level transformation (formulated in Section 2.1) of driving composition at the value level by composition at the type level.

Firstly, we need to define a datatype to represent types. The instances of this datatype, i.e. the type representations, will be subject to rewriting. Else- where [15] we discuss how such representations can be defined by a generalized algebraic datatype (GADT), following a well-known technique [43,24]. In Haskell syntax, this GADT is defined as follows:

Thus, a rewrite rule consumes a representation of type a, and returns a triple, embedded in monad M . The monad is used to represent partiality (success and failure of rewrite rules). The triple contains a representation of type b into which a is refined, as well as the two witnessing functions to and from that convert be- tween a and b. Thus, a rewrite rule does not simply transform values into other values, as is the case in normal rewrite systems. Rather a rewrite rule is defined as a transformation of one type representation into another, witnessed by value-level transformations. The universal quantifier expresses that rewrite rules are polymor- phic in a, i.e. they can be applied to representations of any type. The existential quantifier expresses that the target type of the refinement is computed dynamically,

are function composition and the identity function. Apart from these, every type constructor, such as binary product, disjoint sum, lists comes with its own asso- ciated set of operators. The laws for these operators describe properties such as associativity and commutativity, but also expansion and cancelation properties.

Here, M is again a monad. Thus, rewrite rules are basically monadic functions on point-free representations, additionally parameterized with a type representation. This additional parameter of rules is used for type-directed rewriting, i.e. it allows us to create rewrite rules that decide their applicability on the basis of the type of their input expression.

A constraint on a datatype can be modeled as a unary predicate, i.e. a boolean func- tion which distinguishes between legal values and values that violate the constraint. To associate a constraint to a type, we will write it as a subscript:

Atanassow et al show how canonical isomorphisms (corresponding to laws for zeros, units, and associativity) between types can induce the value-level conversion functions [4]. They provide an encoding in the polytypic programming language Generic Haskell involving a universal representation of types, and demonstrate how it can be applied to mappings between XML Schema and Haskell datatypes. Beyond canonical isomorphisms, a few limited forms of refinement are also addressed, but these induce single-directional conversion functions only. A fixed strategy for nor- malization of types is used to discover isomorphisms and generate their correspond- ing conversion functions. By contrast, our type-changing two-level transformations encompass a larger class of isomorphism and refinements, and their compositions are not fixed, but definable with two-level strategy combinators. This allows us to address more scenarios such as format evolution, data cleansing, hierarchical- relational mappings, and database re-engineering.

On the level of problem statement, a basic difference exists between lenses and two-level transformations or refinements. In refinement, a (previously unknown) concrete representation is intended to be derived by calculation from an abstract one, while lenses start from a concrete representation on which one or more abstract views are then explicitly defined. This explains why some ingredients of our solution, such as representation of types at the value level, statically unkown types, and combinators for strategic rewriting, are absent in bi-directional programming.

Several systems have been developed for performing program transformation in calculational form using fusion laws. Among these, MAG [37] and Yicho [25] are prominent, but both are targeted towards Haskell programs written in the pointwise style. In order to cope with fusion laws for generic recursion patterns both resort to advanced higher-order matching algorithms. We do not need such techniques

sions, which was used to optimize expressions resulting from a program transfor- mation tool that translates pointwise Haskell code into point-free style. The main improvement of our approach is typing: we can use type representations to guide the rewriting process and rewrite rules are guaranteed to be type-safe. In his intro- ductory book to Haskell programming [8], Bird presents a functional calculator that can also be used to simplify point-free expressions. Unfortunately, the expressions are not typed and, likewise to MAG, it uses a fixed rewriting strategy, which makes it difficult to apply in our scenarios.

A notion of XML Functional Dependency (XFD) was introduced by Chen et al [12], based on path expressions. Mapping algorithms are provided that propagate XFDs to the target relational schema and exploit XFDs to arrive at a schema with less redundancy. Davidson et al [20] present an alternative constraint-preserving ap- proach, also using path expressions. In contrast, our constraints are not restricted to relational integrity constraints. We have expressed constraints as point-free func- tions, which can be converted automatically to and from structure-shy programs including path expressions [19].

Barbosa et al [6] discuss generation of constraints on relational schemas that make XML-relational mappings information preserving, i.e. isomorphic. Non- structural constraints on the initial XML schema are not taken into account. Con- straints and conversion functions are expressed in (variations on) Datalog, which can be (manually) rewritten to normal form in a mechanical way.

Our approach so far has been limited to a number of fundamental type construc- tors, sufficient for modeling relational databases and most constructs found in XML schemas. However, a number of further constructs for data type construction would be desirable to include, such as mutual recursive datatype definitions, inheritance, and parametric polymorphism. These enhancements would enlarge the scope of 2LT to data formats such as grammars and object-oriented data models.

At the level of behaviour, the 2LT project has focussed on point-free functional programs as conversion functions, queries, and constraint definitions. For these programs, calculation laws are readily available and highly developed. However, it would be desirable to include other kinds of behavioural descriptions. For ex- ample, structure-shy query specifications as found in XPath have been shown to be amenable to calculation by converting them to and from point-free structure- sensitive programs [19]. Also, point-wise functional programs, as well as imperative programs with side effects need to be brought within scope. This would allow the application of the 2LT approach to more general model-transformation problems.

A particularly interesting challenge, would be to extend the 2LT approach to components and services. The challenge here would be to formalize and support the coupled transformation of components such as clients and servers, in such a way that wrapper and glue components can be introduced automatically and to some extent fused into the various components. Techniques that might be employed to meet this challenge include refinement of co-algebras, automata, and other component models. This avenue of elaboration could for example find application in evolution of web services.

