For non vital software, Verification and Validation (V&V) is a rather informal process usually performed by the software engineer himself. But Critical systems cannot escape a full assessment process by a third-party expert. Indeed, standards prescribe the organisational independence level between the different teams involved in the development. The assessor has to evaluate the full development process from the system level to the embedded software. Note that, being legally liable in case of damages caused by the system, the assessor will refuse commissioning of the system under evaluation, if he/she has any doubt regarding the safety/security/reliability demonstration. For these reasons, developers of critical systems have the greatest interest in easing the assessment process of their products and particularly the verification of the life-cycle compliance with the prescriptions of the standards.

The rest of the paper is organised as follows. We present the textual specification of the voter in section 2. We sketch the main characteristics of FoCaL in section 3. Section 4 presents assessment needs for a safety critical development and their instantiation in the FoCaL tool, written like a Software Quality Plan would be. We detail the modelisation of the voter in section 5. We finally conclude and present further works in section 6.

Sensors may exhibit various kinds of errors like bias offset, scale factor, or tran- sient faults due to sensitivity to spurious or environmental factors (temperature, pressure,... ), that is, transient faults. Redundancy is one of the major techniques used to guard safety critical systems against such transient faults. There exist many kinds of redundancies, depending on which characteristics (safety, reliability or both) should be privileged for the system. Roughly speaking, each redundant component performs the same work and, when one fails, the others detect it and go on providing the service.

Usually, a voter is used to elaborate the output from the input values given by the redundant components. Voters are used, for example, for temperature acquisition by multiple sensors in a boiler, or elaboration of the emergency brake signal of a train from several computer replicas. . . The basic principle of a voter is to compare its input values according to a given consistency relation, and then to output one value depending on predefined rule. There are two parts in a voter:

Currently, FoCaL can be seen as still a prototype of an Integrated Develop- ment Environment (IDE), for a language providing high level mechanisms such as inheritance, late binding, redefinition, parametrisation, etc. Confidence in proofs submitted by developers relies on formal proof verification. This support language was formally described and studied [6,5,22].

The method introduced by the keyword rep, exposing the data representation of values of the species. This type is called the carrier type. Available types are roughly: type variables, ML-like types (with restricted polymorphism) and species carrier types (i.e. the carrier of a species can depend on the carrier of other species). This method is mandatory and can be explicitly given or obtained by inheritance. It may be undefined (i.e. be just a type variable) along some inheritance stages but will have to be defined once and only once in the final inheritance branch (ie. collection).

As properties must be proved, at latest before the collection level, a strong effort is done to have automated tools collaborating with FoCaL in order to get these proofs automatically done by theorems provers. FoCaL is designed to be open to whatever kind of such provers: it currently supports Zenon [17] which is an automated theorem prover developed by D. Doligez [18]. When Zenon succeeds, it produces a Coq proof term. Moreover, some experiments have been done with the rewriting based prover CiMe [15,16]. These external provers are dedicated to some specific kinds of proofs and may discharge the developer from making proofs by hand.

As said in the introduction, the life-cycle of critical software is based on a 5 steps V-cycle similar to the V-cycle of classical software development cycle. The main difference is that it is submitted to a traceability analysis by an independent verifica- tion team after each phase while another independent validation team performs the software testing. This implies that the boundary between each life-cycle phase must be clearly identified when a unique formalism is used along the whole development. As presented in section 3, a FoCaL model is made of species which are used to describe all the phases of the cycle. Properties can be expressed as first-order formu- lae, a choice which is recognised as a good compromise between the expressiveness of the logic framework and its ease of use. Indeed FoCaL is intended to be used not only by computer researchers or mathematicians, but also by smart engineers with

Currently FoCaL provides no syntactical categories to distinguish between the different stages of a life-cycle and we are not sure that such distinctions will be beneficial for engineers as they could perhaps add too much rigour. Instead, we propose to provide species templates dedicated for each phase of the development life-cycle. Since each phase addresses a different view of the system, these templates will be defined by the kind and the forms of methods (declarations, definitions, properties, proofs) which should be used (or not) during the considered phase. They will help to identify clear boundaries between phases, which is mandatory for the verification process.

For critical software, the design should follow design rules. These rules are guide- lines to apply in order to achieve and ease the safety demonstration and description of all constraints coming from the hardware supporting the software (built-in-tests to perform, hardware performance and reliability. . . ) or pre-existing software (Op- erating System, COTS. . . ).

Obviously, industrial projects rarely start from a blank page. It is usual to reuse external components (middleware, operating system primitives, COTS. . . ). For this reason, FoCaL provides a way to make these external components available in the model. However, a safe development cannot on one hand simply assume that such components are safe, and on the other hand cannot prove their properties as these COSTS are usually black boxes. Our solution, in term of methodology,

FoCaL is strongly connected to the Coq proof assistant [14] since it acts as its final assessor. Coq is a well established system already used in the industrial and academic domains [13], which allows to put enough confidence in its verifications. The use of a formal demonstration checker acting as an assessor of the proofs avoids having to perform these verifications by hand and especially prevents errors during these verifications. The choice of using Coq obviously implies that any automated prover collaborating with FoCaL must be able to provide as output a Coq proof trace.

Species Sp voter presents the signature of the vote function, the functional re- quirements of vote and the constraints that imported components must respect for the voter to be proved. Here we force the imported comparison function comp value representing the consistency law to be symmetric. This avoids the need to consider all comparisons combinations.

Ten years after its birth, the language is now mature enough to add enhance- ments, and to bring stability and openings to external tools. A complete rewriting of the tool is currently performed to improve compilation and to facilitate inte- gration of new features. Some other system paradigms (like synchronous features, higher-order parametrisation, certified C back-end. . . ) are currently studied, always keeping in mind that the produced software must be assessed by an independent authority before its commissioning.

