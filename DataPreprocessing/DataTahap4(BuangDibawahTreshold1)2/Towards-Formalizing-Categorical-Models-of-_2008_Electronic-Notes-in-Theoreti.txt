of well-typed terms is defined. The constructive meaning of this is not obvious, at least if we use constructive type theory itself as the metalanguage. The functions in this theory are all total, so partial functions need to be encoded as total func- tions, and this will have formal repercussions. Another example is the treatment of the inductive-recursive definitions which are needed in certain model construc- tions and normalization proofs. Although such definitions are constructively valid [12,13,14,15] most authors rely on their interpretation in set theory [23,3,1,2] and this also has formal repercussions.

dependent types. It is important to point out that Agda does not itself force the user to define only well-founded data types and terminating functions, although at a later stage such termination and well-foundedness checkers will be available. Cur- rently it is up to the user to make sure that a specific logical discipline is followed and to explain and justify this discipline.

However, it is cumbersome to work in monomorphic type theory since one has to manipulate large expressions. Therefore Agda allows you to suppress certain arguments when they can be inferred from the context. We call such arguments implicit. For example, whenever the function id gets a second argument a, Agda tries to infer the first argument A, which is the type of a. The user can inform Agda that the first argument of id is such an implicit argument by enclosing it in braces:

ject of C, and a context comprehension. Above we have outlined the type theoretic definition of a category and of the category Fam. The type-theoretic definition of a functor is well-known [18]. Furthermore, it is clear what a terminal object is type-theoretically, and we can express the structure of context comprehension type-theoretically. All this leads to the definition of cwf inside type theory (i.e. the notion of internal cwf), although we do not have room to display the details.

Categories with finite limits can be formalized as categories with terminal objects and pullback. (A category with terminal objects and pullbacks has all finite limits.) As a type-theoretic structure a pullback is a function that given three objects and two arrows constructs an object, two arrows, proofs of commutativity of the square, and a proof of the universal property. Here is the formalization in Agda.

However, it is important to remark that this inductive definition falls outside the standard schema of mutual inductive definitions in constructive type theory [10]. Nevertheless, we believe that it is a constructively meaningful definition. As part of our investigation we plan to generalize the schema in [10,15] to cover that schema, and also to provide set-theoretic semantics by extending [9].

