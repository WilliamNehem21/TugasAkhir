perspectives or analyses for discovering or checking formal properties of gram- mars. In other current work we are addressing the former kind of functionality by developing integrated development environments for attribute grammars including the application of program slicing methods to facilitate viewing [18]. The present paper focuses on the second class of functionality: formal analysis of attribute grammar properties [3]. Of course, evaluator generators have to analyse various formal properties of the input grammar to verify that an evaluator can be produced or to produce a correct evaluator (e.g., attrib- ute dependences, circularity). We are interested in providing analyses that

Rather than modify existing attribute grammar systems to add extra feed- back, we have chosen an approach based on an off-the-shelf formal methods tool. Formal methods can provide an expressive platform for describing soft- ware properties and assertions about them. The properties and assertions are independent of particular programming notations, so front-ends can be written to enable the analysis tool to be used with different languages. For many problems a formal methods tool can be used to achieve an effective implementation with much less effort than modifying an existing generator. This strategy also maintains the modularity of the overall system because the generator can focus on its task and the auxiliary tools can provide support for peripheral problems.

Our method is based on formal relational models as supported by the Alloy model finding and checking tool [6]. Section 3 summarises the relevant capabilities of Alloy and discusses its suitability for the class of problems we are addressing. A crucial aspect of the tool is its capability to provide counterexamples to illustrate violations of assertions.

eral and properties of the specific grammar under analysis (Sections 4.1 and 4.2). In our example, the general properties include the fact that all grammars have a single root non-terminal and that non-terminals are related by parent and child relationships which are inverses of each other. Grammar-specific properties include the identity of the root non-terminal and the parent relationship between non-terminals as implied by the pro- ductions of the grammar.

Scalability is an important issue for formal models of software. An approach based on formal methods is no use if it cannot handle realistic inputs. It often turns out that the key to controlling scalability is to make sure that the model specification is not overly specific. For our example, this means that we must be careful not to try to model complete ASTs. Rather, we model paths through ASTs, which allows models to omit non-terminals that do not occur on the path being modelled. Section 5 evaluates the performance of our analysis on an attribute grammar that specifies the semantic analysis for a subset of Pascal and presents further modifications that significantly improve performance.

processor generation system [4]. LIDO 1 is descended from the ALADIN lan- guage that was the specification language in the GAG system, a predecessor of LIGA [8]. LIDO and ALADIN have many features in common with the main difference being that LIDO only provides a general prefix-style for expressing computations whereas ALADIN was a full-featured functional programming language. Most notably, both of these languages have the INCLUDING con- struct which is at the core of the main example problem addressed in this paper.

LIDO supports other remote attribution constructs. CONSTITUENT(S) is similar to INCLUDING except that it creates a dependency between a symbol and one or more other remote symbol below the current symbol in the tree. The CHAIN construct creates a chain of dependent values which are threaded throughout all the symbols in a depth-first left-to-right order through the tree. These constructs have similar static checks that could be analysed in a similar way to the INCLUDING problem illustrated in this paper.

Proof assistants (also known as theorem provers), guide users through a series of logical deductions relating to their software specification. Systems comprising complex data types can be described quite elegantly, using the mathematically-based languages of proof assistants. In particular, infinite structures such as trees pose no particular impediment to these techniques.

The level of automation available with different proof assistants varies, but ultimately either an assertion is proved or a point is reached where no further deductions can be made. If the proof is concluded successfully then a great deal of information about the problem is established and one may have much confidence in the result. However, if a proof cannot be completed, then the technique provides very little additional information about the problem that may help the developer progress with the development of the software. The cause of the problem may be in the software under development, but it could also lie with the proof tactics themselves. In general, successful use of a proof

Like proof assistants, model checkers in general can verify the correct- ness of a system however in contrast to proof assistants, model checkers do not provide much additional information about a correct software descrip- tion. However they can usually be used without developer intervention and can identify counterexamples to illustrate the falsity of assertions. Counter- examples can provide significant assistance during the software development process because they point to specific circumstances in which desired proper- ties of the software fail to hold. For our purposes, counterexamples are crucial because they form the basis of providing better feedback to an attribute gram- mar developer.

Instead, we have based our work on the Alloy tool 2 which provides some of the advantages of both of the two types of formal methods described above [6]. The Alloy specification language uses a first-order relational logic, is declar- ative and is based on the formal specification language Z [17]. Unlike Z, Alloy specifications can be analysed automatically in much the same way as a finite-state machine specification can be analysed by a model checker. Just like model checkers based on finite-state models, Alloy provides counterexamples

This section briefly introduces the Alloy specification language by way of a simple model specification of families. This example is loosely based on sample code supplied with the Alloy distribution. We will introduce Alloy notations informally since in most cases they correspond closely with well-known con- cepts of logic and mathematical relations. The Alloy manual contains a full description of the specification language syntax and semantics [6].

When presented with the model specification and this assertion, Alloy generates models that satisfy the specification and checks that the assertion is true in each of these models. It is important to appreciate the difference between facts and assertions. Facts specify constraints that models must obey to conform to the specification. Alloy will not consider models that do not satisfy the facts. Assertions specify properties that we expect to hold but may not actually hold for some models.

example, we must restrict the size of the Person class; in other words, we must specify the maximum number of people in a model that is to be checked. For this specification the assertion fails on some models with a Person class having scope of just three. The counterexample generated by Alloy is the obvious one: Person 0 is the parent of both Person 1 and Person 2, and Person 1 and Person 2 are spouses of each other. Armed with the knowledge that the existing constraints are not sufficient, the developer can add additional constraints to the specification to ensure that this situation is not allowed.

The techniques described in this section are independent of the particular attribute grammar notation. They have been embodied in an Eli-specific tool that translates LIDO attribute grammars into Alloy specifications. Thus the analysis process is completely automatic. We evaluate the approach in the Eli setting in the next section.

GGraph defines all of the relationships between non-terminals. For the INCLUDING problem we need to be able to talk about particular paths in this graph. The following specification builds on the GGraph signature, adds no relations, but adds a fact that restricts the path models to those where each symbol has at most one child. For any single GGraph instance there will be potentially many GPath instances representing all of the different paths from symbols to the root.

g. Then we specify that program is the root of g. Then the child relation is defined by enumerating its constituent pairs as given by the context-free grammar; for example, the pair (program,pen blocks) is in the child relation because of the production program ::= pen blocks.

When presented with the model specification from the previous two sec- tions and this assertion, we can ask Alloy to search for models that conform to the specification but violate the assertion. We use the following Alloy check statement to constrain the scope of the models to include no more than five symbols since there can be no more than five symbols in a path from any symbol to the root of this grammar. Also, we only use one GGraph instance because it can be shared between all paths.

We have also extended the reachability fact to include the possibility of reach- ing a symbol via the inheritance relationship. This makes sure that class symbols are connected to the rest of the model. The definitions of GPath and Symbol remain as before.

A slight complication arises due to the fact that Alloy may choose to omit any of the symbols from the model of a particular path. Only the symbols that are actually on the path need to be in the model. However, if one of those symbols inherits one or more class symbols, then we must make sure that these class symbols are also in the model. Otherwise, we are not able to properly model the situation where an INCLUDING refers to a class symbol that is inherited onto an ancestor symbol. For the example, we need the following extra constraints which specify: 1) that if there is a D in the model then there must be a Q too, and 2) that if there is a D in the model then every path should have the inheritance relationship between D and Q.

Our main evaluation has been performed on a grammar that performs semantic analysis for a subset of Pascal [19]. The grammar has 52 productions and uses 68 tree symbols and 25 class symbols; the class symbols come mostly from library modules. There are 36 INCLUDING constructs in the grammar. We ran our experiments on an Apple Powerbook G4 with 1 GHz processor and 1GB RAM running Mac OS X 10.2.6.

We timed the analysis of the correct Pascal subset grammar in order to determine worst case times. 7 Our current measurements show that it is pos- sible to analyse all 36 of the INCLUDINGs in about 20 minutes of user time with a scope of 10, or 34 minutes with a scope of 15. (The two different scopes produce the same results.) These times benefit significantly from the decision described in Section 4.2 to limit each symbol class to hold at most one atom. Without this restriction a full analysis with scope 10 takes over 20 hours.

We expect our approach to be most useful once a problem with a specific INCLUDING has been diagnosed by some other method (e.g., via a message from LIGA). Thus, a more realistic use case is to analyse just one INCLUDING at a time. We examined the individual INCLUDINGs in our test case and

Only modelling erroneous INCLUDING constructs. Our current model specifications incorporate the whole grammar and assertions for every INCLUDING. A better strategy is to target the models towards solving only those INCLUDINGs that are triggering LIGA errors. We expect to see diagnosis times for a problem with a single INCLUDING in the order of ten seconds for grammars of reasonable size.

More accurate setting of the scope of the model. At present we use a fixed scope for all grammars. A better approach would be to calculate the maximum scope needed for a specific grammar so that we can guarantee that no counterexample is missed but limit the redundant work that must be done. In the INCLUDING case, this would be a measure of the longest possible non-recursive path.

Bill Waite consulted on the general problem of grammar analysis and the issue of scope in typical grammars. Ilya Shlyakhter and Alan Fekete provided insight into the appropriate use of the Alloy model specification language. Dom Verity consulted on various aspects of logic.

