In this paper, we will concern ourselves with only the goal independent analysis of pure constraint logic programs. This decision permits us to develop a semantics, and an analysis, that is independent of implementation technol- ogy. For a discussion of the issues of this paper related to goal-dependent analysis, see Schachte [2]. Our semantics is also independent of the choice of a constraint domain.

we would like our semantics to conclude that there are two solutions for p/1, one indicating that 1 is a solution and the other that any term is a solution. Including (xv) would only allow the more general solution, thwarting analyses which would need to know that 1 is also a solution. To extend this example, an analysis for definite freeness would need to know that even if p/1 is invoked with its argument unbound, it can succeed with its argument bound. A determinacy analysis would need to know that p/1 may have two solutions, and so would not be determinate when its argument is unbound. We do not discuss such analyses in this paper but we do want our framework to allow them.

Finally we may define the abstract semantics of a program. Naturally, the definition is written subject to the choice of a precise abstraction, as specified in Definition 3.4 . All of the constructs of the abstraction are notionally parameters to the abstract semantic functions below, but we do not specify them as such to keep the definition manageable.

graphs, closely related to rational trees, are used to approximate infinite and- or trees. Nilsson [16] replaces the use of and-or trees with context vectors, which associate a set of possible substitutions with each point in the program. This neatly avoids any difficulties with infinite and-or trees.

Gallagher et al. [19] present a goal-independent analysis framework based on a declarative semantics. This technique is based upon a pre-interpretation of the program, that is a mapping from the function symbols of the program to a (possibly different) domain. The domain to which they map the function symbols of the program fills the role of the abstract domain, and the pre- interpretation mapping serves as a representation function.

