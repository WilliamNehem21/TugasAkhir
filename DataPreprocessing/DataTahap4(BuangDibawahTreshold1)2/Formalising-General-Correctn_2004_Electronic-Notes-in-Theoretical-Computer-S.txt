Typically one models a command (or program) as a function acting on the ma- chine state. A deterministic command which must terminate can be modelled as a function returning simply a single new machine state. A deterministic command which may or may not terminate could be modelled as a function which returns either a new state or nothing, representing the idea that a non-terminating command returns no result. However if we represent a non- deterministic program as a function which returns a set of new states, then this leaves us without a way of representing non-termination as one of several possible outcomes.

Stating the frame of a command does not contribute to a description of what the command does, so we can show, for example, that two commands behave the same way, without considering their frames. The work in this section proceeds on this basis. Note that the results are therefore subject to the proviso that two abstract commands are in fact distinct if their frames differ. We think the relevant proofs about frames would be quite straightforward.

From these definitions, we proved the following more direct characteriza- tions of these three notions of refinement. It is worth noting that the char- acterization for general correctness is simpler than the other two although it is defined in terms of both of them; this no doubt explains how general cor- rectness semantics often seems simpler than either partial or total correctness semantics. Also, the general correctness relation is anti-symmetric, unlike either total or partial correctness.

"totcref ?A ?B = (ALL st. ?B st <= ?A st | NonTerm : ?A st)" "partcref ?A ?B = (ALL st. ?B st <= insert NonTerm (?A st))" "gencref ?A ?B = (ALL state. ?B state <= ?A state)" gencref_antisym = "[| gencref ?A ?B; gencref ?B ?A |] ==> ?A = ?B"

Here f (x:=E) is Isabelle notation for the function that is like f except that its value at argument x is E. The first of these results relates substitution for a variable in an expression to assignment to that variable in the state. The second expresses that if two syntactic expressions have the same meaning, then the results of making the same substitution in the two of them also have the same meaning. (Thanks to Dunne for pointing out the need for this result).

We are now in a position to define assignment and prove its properties. We define assignv and assigne for the assignment, to a variable, of a value and a (semantic) expression respectively. We also define assignvs for the assignment of values to a set of variables.

names primed. For this purpose we want somewhat different definitions of @ and of A, involving a set of logical variables x', one for each program variable. So again we use a second state function primed, which gives the values of these logical variables, and A will depend on both state functions.

