Narrowing generalizes rewriting by performing unification at non-variable po- sitions instead of the usual matching. The essential idea behind narrowing is to symbolically represent the transition relation between terms as a narrowing relation between terms. Specifically, narrowing instantiates the variables in a term by a B-unifier that enables a rewrite modulo B with a given rule and a term position.

The narrowing relation on terms is extended to reachability goals by narrowing only the left-hand sides of the goals, while the right-hand sides only accumulate substitutions. The idea is to repeatedly narrow the left-hand sides until each left- hand side unifies with the corresponding right-hand side. The composition of the unifier with all the substitutions generated (in the reverse order) gives us a solution of the goal.

While this general procedure gives us weak completeness, for it to be useful in practice we need effective narrowing strategies that drastically cut down the search space by expanding only relevant (or necessary) parts of the narrowing tree. We discuss this topic in Section 6.2.

This defines a backwards narrowing strategy where we discard any protocol state in which the intruder has to learn some term in the grammar L, since this would lead to a useless backwards search path. For more details see [20] and Section 7.1.

Verification of many security protocol properties can be formulated as solving reach- ability problems. For instance, verifying the secrecy property of a protocol amounts to checking whether the protocol can reach a state where an intruder has discov- ered a data item that was meant to be a secret. In this section we show how the strong completeness of narrowing for topmost rewrite theories, together with the grammar-based strategy explained in Section 6.2.2, can be exploited to get a generic and complete procedure for the analysis of such security properties modulo algebraic properties of the cryptographic functions.

rl s(X) <+> Y <+> 0 <+> W <= s(H) => X <+> Y <+> 0 <+> W <= H . rl 0 <+> s(Y) <+> 0 <+> W <= s(H) => 0 <+> Y <+> 0 <+> W <= H . rl 0 <+> 0 <+> 0 <+> s(W) <= s(H) => 0 <+> 0 <+> 0 <+> W <= H . rl 0 <+> 0 <+> 0 <+> 0 <= H => true .

rl 0 <+> 0 <+> 0 <+> s(W) <= 0 => false . rl s(X) <+> Y <+> 0 <+> 0 <= 0 => false . rl X <+> 0 <+> s(Z) <+> W <= 0 => false . rl 0 <+> s(Y) <+> Z <+> 0 <= 0 => false .

Finally, the specialized program is obtained from the resultants using a mapping from terms to terms in order to simplify the resulting program (see [2] for details). Our work can be quite useful for PE applications for several reasons. First, efficient narrowing strategies such as natural narrowing can avoid combinatorial explosions while constructing the narrowing tree, which is the main danger in PE algorithms. Second, it can be applied, much more generally than previous PE techniques, to rewrite theories having non-functional semantics, an area where, to the best of our knowledge, PE techniques have not yet been applied. Third, as illustrated by the PE example below, it can result in smaller, more effective

We show below how partially evaluating programs using more effective narrow- ing strategies can result in smaller and more effective specialized programs. This was recently illustrated in [3] using the needed narrowing strategy [6]. That is, any narrowing strategy performing better than others can give better specialized programs (under some restrictions not discussed here), as shown in the following example.

Example 7.4 Consider the rewrite theory of Example 7.2. Such program is left- linear and constructor-based. Indeed, it is also orthogonal but many rewriting and narrowing strategies behave badly and cannot provide a unique normal form. Now, consider the input t = (X + Y) <+> 0 <+> s(s(s(0))) <+> W <= s(s(0)) for which the program above is to be specialized. Clearly, the specialized program should always evaluate to false, regardless of what the rest of the input is. Fur- thermore, t can be rewritten to false without ever instantiating the variables X, Y and W, as follows:

