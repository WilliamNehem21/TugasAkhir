Metamodelling is an activity that attracts attention of the research community dealing with the Model- Driven Development (MDD). To be reusable in different MDD approaches a metamodel should be unaware of being extended by another metamodel. This property of metamodel is called obliviousness. This paper shows that current techniques implementing metamodels do not maintain obliviousness when some elements of the extended metamodel and the elements of the original model have association relations. Three different approaches to reuse of metamodels are analyzed. One of the approaches uses traditional object-oriented techniques. Two other approaches use aspect-oriented techniques. The paper shows that the third approach, which considers relationships as first-class citizens at the implementation level by using relationship aspects, guarantees obliviousness of metamodels.

Catalysis method [7] introduces two mechanisms of metamodel reuse: the package extension and the package template mechanism [4]. In this paper we focus on the package extension mechanism. Metamodel MMA extends metamodel MMB if MMA spe- cializes MMB. Thus, any of the elements of the MMA metamodel has a relationship with any of the elements of the MMB metamodel. This mechanism allows defining the MMA and MMB metamodels separately, and merging them together. In order to improve reuse of metamodels it is important to maintain the obliviousness, i.e. the unawareness of MMB about MMA.

We have analyzed three different approaches to implementation of metamodels in order to understand if they maintain the obliviousness of metamodels. The first approach uses inheritance to make the original metamodel oblivious so that the problem is solved with traditional object-oriented techniques. The second and third approaches are based on aspect-oriented techniques [9,10]. The second ap- proach introduces inter-type declarations, while the third one treats the relation- ships in metamodels as aspects [23]. In this paper we show that the third approach guarantees obliviousness of metamodels which facilitates metamodel reuse.

This paper is structured as follows: section 2 introduces the main metamodelling concepts. In section 3 the Eclipse Modelling Framework for implementing models and metamodels is presented. Section 4 presents the problems that arise when metamodels are extended. Section 5 analyses three different approaches to extension of metamodels. Section 6 draws conclusions from the analysis.

The MOF-based ones. The MOF [20] is the metamodelling framework proposed by the Object Management Group (OMG) to define other modelling frameworks. The MOF specification is vendor and language independent. With the MOF specification, the OMG has standardized a set of mappings that specify how a specific technology represents and manages meta-data. For instance, XMI [21] is a XML representation for model interchange between tools, while JMI [25] is an abstract syntax definition for meta-data in Java applications. Some repositories that implement the JMI interface are: MDR from NetBeans [17] or NSMDF [18] from NovoSoft. The Coral Metamodelling Framework [24] has the hard coded MOF, although other different metamodels can be installed. Coral is not based on Java, but on Python.

The Ecore-based ones. Ecore is the metamodel included in the Eclipse Mode- lling Framework (EMF) [3]. It is different from MOF. EMF is a low-cost tool to obtain the benefits of formal modelling and Java code generation and it is language-dependent. The functionality of EMF is similar to MDR.

EClass models a class. It has an attribute called name to store the name of the modelled class. It has composition relationships with EAttribute and ERefer- ence. The cardinality of the composition means that an EClass can have zero or more attributes and zero or more references.

EReference models one of the two ends of an association between classes. It has two attributes: name and containment. The attribute containment is true if the association end represents a composition relation. Finally, EReference has an association with EClass. This relation models the target type, that is, the class which is at another end of the association.

We use Java interfaces to define the core model. For each class of the model an interface is defined. For each attribute and for each reference contained in the class, a standard get() method is declared in the interface. With this information the EMF generator will deduce the model attributes and references. The Java interfaces and the get() methods are annotated in order to help the EMF generator to deduce

If we define the Ecore model using annotated Java, we will just be in charge of writing the interfaces and the get() methods (if needed). Afterwards, the EMF generator will complete these interfaces with more annotations and set() methods. Furthermore, it will generate the implementation classes and all the extra code needed.

The Generalization class models the extend and implements relationships between classifiers (classes and/or interfaces). An instance of this class represents an inheritance relationship between a subtype and a supertype. It can also represent the relationship between a class and an interface.

Feature is also related to Type and Classifier. The first relation is an as- sociation while the second one is a composition relationship. From the point of view of Feature there is no difference between these two relationships: there are two get() methods (getOwner and getTypefeature) with an opposite annotation. This annotation refer to the name at the other end of the association. The differ- ence between these two kinds of relationships is specified in the classes Type and Classifier, respectively. The Type interface will have a get() method named getFeatures while the Classifier interface will have a get() method (getMem- ber) with an extra annotation (containment=true). This containment annotation has the composition semantics.

Therefore, if we apply the same approach to all the relations between the classes included in both packages, we have four new classes in the com.metamodel.java2 package. Although this approach is simple, it has an inconvenience: our aspectj metamodel implementation is tangled with a set of implementation classes.

The third approach is related to the treatment of relatioships as first-class citizens. Although relationships are treated as first-class citizens at the modelling level, the same treatment is not maintained at the implementation level. At this level, the implementation of relationships is hand-crafted and spread across the objects which participate in those relationships. It has been proposed in [23] to model these relationships as separable, crosscutting concerns.

This paper has presented a problem that arises when trying to extend a metamodel with relationships different from inheritance. In this case, the original metamodel is not oblivious because it should be modified in order to implement the extension. Three different approaches to solve the problem have been investigated. The first approach is based on the inheritance mechanism of traditional object-oriented languages. Although it is a simple approach, it allows for extension of the new metamodel with different virtual classes which are only needed for implementation.

The third approach treats relationships as first-class citizens at the implemen- tation level. The relationships are defined as aspects. The Relationship Aspect Library (RAL) [23] has been taken as an example, but this library should be ex- tended to deal with more kinds of relationships. Moreover, the RAL library allows the definition of only one relationship between to classes, which is not sufficient for metamodelling.

In a future work we intend to adapt the RAL library to our needs. This implies the solution of some problems that the RAL library has, such as the naming problem arising when two different relationships are defined between two classes. It also implies the necessity of the definition of various kinds of relationships within the RAL library. We also plan to add these new aspect oriented features to current modelling and metamodelling frameworks.

