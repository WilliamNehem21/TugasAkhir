An important issue of the service oriented approach is the possibility to aggregate, through programmable coordination patterns, the activities involved by service interactions. Two different approaches can be adopted to tackle service coordination: orchestration and choreography. In this paper, we introduce a formal methodology purposed to handle coordination among services from the perspective of a global observer, in the spirit of choreography models. In particular, we address the problem of verifying compliance and consistency between the design of service interactions and the choreography constraints.

The web service protocol stack (e.g. WSDL, UDDI, SOAP) provides basic sup- port for the development of service-oriented architectures by exploiting facilities to publish, discover and invoke network-available services. The service protocol stack has been extremely valuable to highlight the key innovative features of the service oriented computing approach.

Most of the current development methodologies and standards are focused on composition of services. Two different approaches can be adopted: orchestration and choreography. In the orchestration, an intermediate component, the orches- trator is responsible to arrange service activities according to the work-flow plan. This strategy provides a local view of the participants. From the other hand, the choreography model involves all parties and their associated interactions providing a global view of the system. Relevant standard technologies have emerged to model

neighbors, namely the subscribers that are directly connected. This corresponds to a local view of coordination. In this paper, we introduce a formal methodology for the SC & JSCL framework with the aim of managing coordination among services from the perspective of a global observer in the spirit of choreography models. In particular, we address the problem of verifying compliance and consistency between the design of service interactions and the choreography constraints.

scribers). Notice that notifications are not anonymous, namely subscription relates both the event topic and the publisher. Therefore, components behave as reac- tive agents that declare the set of event kinds they are interested in together with the associated tasks to perform for their handling (reactions), and the set of target components for the notification delivery (flows). The calculus provides two different kinds of reaction: the lambda reactions and the check reactions. Lambda reactions are activated independently from the signal session, while check reactions handle signals belonging to a well defined session. Lambda reactions, once installed, remain persistent in the component interface, the check reactions, instead, once executed, are removed from the component interface.

The calculus provides two primitives to allow a component to dynamically change its interface: the reaction update rupd (R) .B' and the flow update fupd(F ).B'. The former installs a new reaction R in the interface part of the component and the

the signal and the target component name a. The last operator allows one to extend the scope of dynamic topics within networks. Hereafter, we assume that components are uniquely identified by their names. Hence, we will always consider well formed networks, namely networks where components with the same name are not allowed.

To conclude this section, we introduce a black-box semantics of NCP, in the form of a bisimulation relation. Honda-Tokoro [16] and Amadio et alia [1] have studied bisimilarity for asynchronous calculi. We use these results (in particular, the directed HT labelled transition systems from [1]) to define our bisimulation semantics.

In this paper we have extended the SC & JSCL framework with a choreography model: the NCP calculus. We have presented an encoding from the design language (SC) to the choreography language in order to verify whether an SC network respects a global NCP policy. This is done via bisimulation checking.

Some research efforts have addressed the problem of relating choreography and orchestration. For instance, the notion of simulation conformance has been consid- ered [4,19]. The methodological idea of providing separated languages to describe the global and local view of service coordination has been also considered in [5]. However, our framework introduces some new notions, like multi-layered networks and multi-party sessions.

