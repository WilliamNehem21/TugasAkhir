5 We do not expect that all of the problems can be addressed completely by the use of formal methods. For example, problems of human error and those posed by malicious intent are very different in nature, but can both arise from simple design flaws. Our focus is on verification of design steps.

The Single Transferable Vote (STV) model on which we build this case study is regarded as a good democratic election process. However, it incorporates a complex, not necessarily determinisitic, tabulation (counting) procedure. In 2003, Farrell and McAllister [8] reported on how a subtle change in the implementation of the STV rules can lead to major changes in the results returned.

We note that the quota cannot be calculated without knowing the number of valid votes, and so its correct calculation is dependent on the notion of validity being correctly implemented. This notion is non-trivial as the STV election process allows voters to register support for more than one single candidate, by placing candidates in a preferred order. Thus on each vote, a candidate may or may not have an associated preference.

Informally, a vote is considered valid if and only if it shows a unique first pref- erence. The means of specifying this property depends, of course, on a notation for representing a vote. Consider a constituency where there are three candidates: A, B and C, say. We could choose to represent a vote as a string of characters taken

In practice, with simple designs such as a simple vote interface, developers often see no need to progress to layer 3. In the designs that follow in the remainder of this section, we follow a rapid-prototyping approach that never progresses to the 3rd layer of rigour. In Section 5 we show how the B method and tools can be used to fully support layer 3 in this verification process.

This pressCandButton method is dependent on two other methods: buttonEnabled for checking if the button being pressed is actually enabled (has not been pressed before), and lastPref for finding out the value of the last prefer- ence selected. The buttonEnabled behaviour is straightforward to implement, and left as an exercise for the reader. The lastPref method, as implemented below, examines all the preferences and deduces that the largest current preference value must have been the last preference made. We note, for future reference, that this is a correct (but inefficient) implementation of the design.

The refinement of an event B model [2,4] allows one to enrich the model in a step-by-step manner. Refinement provides a way to construct stronger invariants and also to add details to a model. It is also used to transform an abstract model into a more concrete version by modifying the state description. This is essentially done by extending the list of state variables (possibly suppressing some of them), by refining each abstract event into a corresponding concrete version, and by adding new events. The abstract state variables, x, and the concrete ones, y, are linked together by means of a gluing invariant J (x, y). A number of proof obligations ensure that: (1) each abstract event is correctly refined by its corresponding concrete version, (2) each new event refines skip, (3) no new event takes control for ever,

In this more concrete EachVoteAtOnce model, STATE is an enumeration set which contains two values: voting to represent a voting system that is open, and finish to represent when the voting is closed. The variable st contains one of these values, elector is the subset of ELECTOR recording the electors who have already voted, vt is the variable which contains these votes, and cvt is its cardinal. All votes in vt are valid. The event One Vote models the vote of a single elector in one shot

One voting is an enumeration set which contains three values: no elec when no electors are voting, start when the a new elector e starts to vote, and valid when the elector e pushes the button to validate their vote. The variable sto contains one of these values. Variable e contains the current elector, vt is their current vote which is modified when a candidate button is pushed, and n is the preference number of the chosen candidate.

empty and so v is a valid vote. Remark also that we have no condition on n in the guard of the event Button cand. When a candidate is not in the codomain of v we are sure 10 that n < nbc.

We have demonstrated the use of the formal method B in guaranteeing a simple safety property of an interface to an e-voting machine. We demonstrated that guaranteeing validity of votes recorded not only helps in the formal verification of the voting process, but also has an important role to play in making the machine more secure. This is the first step in developing a generic framework for the design of secure interfaces which could be proved to satsify various safety-related properties. It is our goal to try and formulate such a framework as a set of formal design patterns much like those proposed by Abrial when using B to verify properties of control systems [3]

[18] which could benefit from further formal verification using our approach. This is planned for future work. Furthermore, we are currently using B to prove the correctness of an actual storage mechanism which claims to offer tamper-evident, history-independent and subliminal free data structures [16]. After this we aim to use B to prove safety properties concerned with the tabulation of votes, and so verify all layers in a typical voting architecture.

