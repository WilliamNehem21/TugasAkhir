We employ constraints to declaratively specify the rules of a type system. Starting from a constraint based formulation of a type system, we introduce special combinators in the type rules to specify in which order constraints may be solved. A solving strategy can then be chosen by giving a particular interpretation to these combinators, and the resulting list of constraints can be fed into a constraint solver; thus the gap between the declarative specification and the deterministic implementation is bridged. This design makes the solver simpler and easier to reuse. Our combinators have been used in the development of a real-life compiler.

Volpano and Smith [23] showed how security analysis can be specified as a type and effect system (type system for short). Security analysis aims to reject programs that exhibit unsafe behaviour, i.e., when sensitive information may be copied to a location reserved for less sensitive information. Therefore, it is considered to be a validating program analysis, and the implementer must not only implement the analysis, but also provide sensible feedback in case the analysis fails. Providing this feedback can be a time consuming and arduous task.

To provide good feedback one may investigate the kinds of mistakes programmers make and use that information to construct a heuristics that can help in finding what is the most likely source of a mistake, cf. [6] which does exactly that for the domain of Haskell programming. In this case, the user has knowledge only of the program from which the inconsistent set of constraints was derived. Error messages and hints must therefore always be phrased in terms to the source program. Moreover, a mistake made in a Haskell program might be corrected with a small modification on the part of the user, although such a small correction can change the set of constraints in a significant way.

In the constraint programming community there is quite a large body of work devoted to explaining inconsistencies in sets of constraints, cf. [17]. In contrast with our situation, the user is typically given a set of constraints, and needs to, often interactively, find a valuation for the variables that make it consistent, and delete some constraints in case of over-constrainedness. Moreover, the work tends to be of a general nature, applying to different domain areas. This makes the results more generally useful, but also less tailored to our particular domain.

Phrasing and implementing domain-aware heuristics is quite an undertaking and by its nature largely language and analysis specific. Therefore, it would be nice to have a more generic solution to the generation of feedback that can be more easily reused for different analyses, or even different programming languages. If needs be, heuristics can then be added later on as a refinement. Furthermore, while a compiler is being built, it is usually not known what a good solving strategy might be, so we would like to avoid making decisions that determine the solving strategy, and indirectly the feedback provided by the compiler, until it has been completed and experimented with.

In this paper, we describe a framework that can be used by compiler builders to accomplish exactly this. To illustrate it, we show how the framework can be used in the context of type inferencing the polymorphic lambda calculus, i.e., we consider an analysis of the underlying types of, e.g., a Security Analysis [23]. There is nothing in our development, however, that makes assumptions about the analysis or the programming language involved. The work is implemented as part of the Top framework [4] and has been used in the construction of a real-life compiler, the Helium compiler for Haskell [8].

The paper is structured as follows. After a section on motivation and applica- tion, we need some preliminaries to introduce types and constraints on types. We then consider a variant of the Hindley-Milner type system [15,1] which uses assump- tion sets and sets of constraints. In Section 5 we introduce a modified type system

blame on the type of f . The difference between what is reported as the source of the problem is due to a different strategy in solving constraints: Hugs uses a bottom-up approach to solving constraints: first the subexpressions, then the whole expression, while GHC proceeds in a top-down fashion. Objectively, there is no reason to prefer one over the other; it is largely a matter of taste on the part of the programmer. The main advantage of our approach is that with little effort both (and many more) strategies can be provided in a single implementation and that the programmer can himself choose which strategy suits him best. If the compiler by the nature of its implementation easily allows different constraint solving orders, we can experiment with several such traversals, see what they come up with, and use that information to come up with a better diagnosis of the problem. The design of our framework naturally allows this.

We now discuss the main lines of our approach. Consider any type and effect system, say Security Analysis [23]. Separate the type and effect system into two different parts: a declarative specification in terms of constraints that need to be satisfied (notationally close to the usual type deduction rules), and a solver for the kinds of constraints used in the specification. The analysis process then becomes a matter of traversing the abstract syntax of the program, generating the constraints for the program and feeding the constraints to the solver, so that it can decide whether the constraints are consistent. Put differently, a program analysis is per- formed by interpreting a program written in a constraint language. In that case, the specification describes the mapping from the source program to the constraint language, and the solver is an interpreter for that language.

Before constraints are solved, a particular solving strategy is chosen by selecting a semantics for the ordering combinators, ensuring that a list of constraints results that can be fed into the solver. Operationally, the ordering process is a third phase that takes place between the generation of constraints in the abstract syntax tree and solving the constraints. The important point here is that different strategies can be used without changing the compiler.

That the solving process imposes a certain bias is implicit in the side conditions for the generalization and instantiation constraints. To solve an instantiation con- straint, the right hand side must be a type scheme and not a type scheme variable. This implies that the corresponding generalization constraint has been solved, and the type scheme variable was replaced by a type scheme. When we solve a gener- alization constraint, the polymorphic type variables in that type are quantified so that their former identity is lost. Hence, these type variables should play no further role, which is exactly what actives determines.

Before we actually discuss our combinators in detail, we give by way of example a specification of the Hindley-Milner type system [15] formulated in terms of con- straints. Such a type system is the basis of a type and effect based analysis, e.g., Security Analysis [23], in which annotations are attached to the types, and con- straints between the annotations need to be satisfied in order for the program to be valid for the analysis.

Typically, the constraint tree has the same shape as the abstract syntax tree of the expression for which the constraints are generated. A constraint is attached to the node N where it is generated. Furthermore, we may choose to associate it explicitly with one of the subtrees of N . Some language constructs demand that some constraints must be solved before others, and we can encode this in the constraint tree as well.

should be considered before the constraints in Tc2. The typical example is that of the constraints for the definition of a let and those for the body. When one considers the rewrite rules for our constraint language in Section 3, this is not necessary, because the solver can determine that a given generalization constraint may be solved. However, this gives extra work for the solver, because it must essentially search the set for constraints that may be solved. By insisting that the constraints from the definition are solved before the generalization constraints, we can omit to verify the side conditions for the instantiation and generalization constraints altogether and thereby speed up and simplify the solving process considerably.

The first argument [a ] corresponds to the constraints belonging to the node itself, the second argument [([a ], [a ])] contains pairs of lists of constraints, one for each child. The first element of such a pair contains the constraints for the (recursively flattened) subtree, the second element those constraints that the node associates with the subtree. Note that if we did not have both and o, then a treewalk would only take the constraints associated with the node itself, and a list containing the lists of constraints coming from the children as a parameter.

This tree walk puts the recursively flattened constraint subtrees up front, while preserving the order of the trees. These are followed by the constraints associated with each subtree in turn. Finally, we append the constraints attached to the node itself. In a similar way, we define the dual top-down tree walk:

which infers tuples from right to left, while most other constructs are inferred left- to-right. It also allows us to emulate all instances of G [12], such as exhibiting M-like behavior for one construct and W-like behavior for another. Of course, we could generalize flatten even further to include other orderings. For example, a tree walk that visits the subtree with the most type constraints first.

Folklore algorithm M [10], on the other hand, is a top-down inference algorithm for which we should select the topDown tree walk. Spreading with this tree walk implies that we no longer fail at application or conditional nodes, but for identifiers and lambda abstractions. We note that the Helium compiler [8] provides flags -M and -W to mimic algorithm M and W respectively, showing that our combinators can indeed be used to give control over the constraint solving order to the programmer. Other strategies can be provided easily; that is simply a matter of associating a treewalk with a particular compiler flag.

Spreading type constraints gives constraint orderings that correspond more closely to the type inference process of Hugs [9] and GHC [3]. Regarding the inference pro- cess for a conditional expression, both compilers constrain the type of the condition to be of type Bool before continuing with the then and else branches. GHC con- strains the type of the condition even before its type is inferred: Hugs constrains this type afterwards. Therefore, the inference process of Hugs for a conditional expression corresponds to an inorder bottom-up tree walk. The behavior of GHC can be mimicked by an inorder top-down tree walk.

same comparisons. For a type incorrect program, Lee and Yi proved that algorithm M considers the least number of constraints before finding an error, and algorithm W the most [11]. They actually advocate using something in the middle: algorithm M complains too soon (and therefore gives little context in its error message) and algorithm W too late. In practice, however, the differences are hardly noticeable, and we believe that spending a bit more time to come up with a better judgement of the problem easily outweighs the extra expense. Note also that in our particular situation, the programmer can choose the order he prefers, and therefore either choose a slower or faster solving order. This is an additional, albeit somewhat accidental, feature of our work.

We use our framework in the Helium compiler and experience shows that con- straint generation and re-ordering only take up a small amount of time. The com- piler is not much faster or slower than other compilers for Haskell. It is certainly fast enough for interactive program development with an IDE.

A soundness proof for a program analysis typically has two parts: first prove the logical deduction system sound with respect to the semantics of the programming language, and then prove the correctness of the algorithm with respect to this deduction system. The soundness of the algorithm then follows by transitivity. In this section we sketch the main steps in conducting such a proof for the type system we have described above. At the end of this section we reflect back on this and indicate how one would proceed in a slightly different but maybe more usual scenario.

a constraint tree, (2) uses an arbitrary treewalk to flatten the tree into a list of constraints and then (3) proceeds to solve these in the order in which they are listed, returns the most general solution for the constraints in the constraint tree. The crucial realization is now that our choice to solve the constraints from a let definition before those of the corresponding let body, ensures that we never block on the side conditions of the rules for the generalization and instantiation constraints. This ensures that we obtain the most general solution if we solve the constraints in the listed order and justifies leaving out those side conditions from the solver, as long as we use a solving order that follows from a valid interpretation of the combinators. Soundness then follows from Theorem 3.1.

If there is no other analysis to relate to, a soundness proof must be constructed from scratch. Note that in such a proof, the ordering combinators play no role of importance, so they do not add to the complexity of the proof. Since such a proof needs to conducted anyway, we are no worse off than without the combinators.

We are not the first to consider a more flexible approach in solving constraints. Algorithm G [12], presented by Lee and Yi, can be instantiated with different param- eters, yielding the well-known algorithms W and M (and many others) as instances. Their algorithm essentially allows to consider certain constraints earlier in the type inference process. Our constraint-based approach has a number of advantages: the soundness of their algorithm follows from the decision to simply perform all unifi- cations before the abstract syntax tree node is left for the final time. This includes

unifications which were done during an earlier visit to the node, which is harmless, but not very efficient. Additionally, all these moments of performing unifications add complexity to the algorithm: the application case alone involves five substitutions that have to be propagated carefully. Our constraint-based approach circumvents this complexity. Instances of algorithm G are restricted to one-pass, left-to-right traversals with a type environment that is passed top-down: it is not straightfor- ward to extend this to algorithms that remove the left-to-right bias [24,14].

Sulzmann presents constraint propagation policies [21] for modeling W and M in the HM(X) framework [22]. First, general type rules are formulated that mention partial solutions of the constraint problem: later, these rules are specialized to obtain W and M. While interesting soundness and completeness results are discussed for his system, he makes no attempt at defining one implementation that can handle all kinds of propagation policies.

In this paper we have advocated the introduction of a separate constraint ordering phase between the phase that generates the constraints and the phase that solves constraints. We have presented a number of combinators that can be used in the type rules to specify restrictions and, contrarily, degrees of freedom on the order in which constraints may be solved. The freedom can be used to influence the order in which constraints are solved in order to control the decision which constraint will be blamed for an inconsistency, and ultimately, what type error message may result. The restrictions can be used to simplify the solver, so that side conditions do not need to be checked. This may also simplify proofs of correctness, which should follow from the interplay between the use of ordering combinators and the solver. These proofs of soundness should consider all possible solving orders allowed by the ordering combinators.

The combinators we described are only the beginning. Once the realization is made that the ordering of constraints is an issue, it is not difficult to come up with a host of new combinators, each with their own special characteristics and uses. For example, combinators can be defined that specify that certain parts of the constraint solving process can be performed in parallel, guaranteeing that the results of these parallel executions can be easily integrated.

