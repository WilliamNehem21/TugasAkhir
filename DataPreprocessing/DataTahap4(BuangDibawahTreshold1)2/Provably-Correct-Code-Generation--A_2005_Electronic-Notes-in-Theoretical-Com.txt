Provably correct compilation is an important aspect in development of high assurance software systems. In this paper we present an approach to provably correct compilation based on Horn logical semantics of programming languages and partial evaluation. We also show that continuation semantics can be expressed in the Horn logical framework, and introduce Definite Clause Semantics. We illustrate our approach by developing the semantics for the SCR specification language, and using it to (automatically) generate target code in a provably correct manner.

Assuring the correctness of the compilation process is an important considera- tion in construction of reliable software. If the compiler generates code that is not faithful to the original program code of a system, then all our efforts spent in proving the correctness of the system are futile. Proving that target code is correct w.r.t. the program source is especially important for high assurance systems, as unfaithful target code can lead to loss of life and/or property. Considerable research has been done in this area, starting from the work of

Those that treat the compiler as just another program and use standard ver- ification techniques to manually or semi-automatically establish its correct- ness. These techniques typically employ known mathematical techniques such as induction proofs, axiomatic semantics, etc. They may also use the- orem provers or advanced reasoning systems to semi-automate the process. The weakness of this approach is that part of the process is manual and may introduce errors. Another weakness is that each compiler developed for each language has to be separately proved correct.

Those that generate the compiler automatically from the mathematical se- mantics of the language. Typically the semantics used is denotational. Con- siderable research was done in the 70s and 80s to automatically generate compilers from the semantic definition of a language. The automatically generated compilers, however, have not been used in practice due to their slowness and/or complexity of the code generated.

Those that use program transformation systems to transform source code into target code. This approach is related to the previous one and expresses the operational semantics of the language as term rewriting rules. These term rewriting rules can be treated as a specification for a compiler, and can be proven correct. Target code is automatically obtained by applying these term-rewriting rules to the source code. The disadvantage in this approach is that specifying the compiler operationally can be quite a lengthy process. Also, the compilation time can be quite large since a term-rewriting system will be used for executing these rules.

mantics [5] which possesses both an operational as well as a denotational (declarative) flavor. In the Horn logical semantics approach, both the syntax and semantics of a language is specified using Horn logic statements (or pure Prolog [26]). The semantics can be viewed dually as operational or denota- tional. Taking an operational view, one immediately obtains an interpreter of the language L from the Horn-logical semantic description of the language

of P, provided the partial evaluator is correct. The correctness of the partial evaluator, however, has to be proven only once. The correctness of the code generation process for any language can be certified, provided the compiled code is obtained via partial evaluation.

In this paper, we further develop the Horn logical semantics approach and show that continuation semantics can also be expressed in Horn logic. Moreover, we also show that in Horn logical semantics not only the syntax but also the semantics can be expressed using the definite clause grammar notation. The semantics expressed in the DCG notation allows for the store argument to be naturally hidden. We also show that continuation semantics expressed as DCGs can be partially evaluated w.r.t. a source program to obtain target code in a provably correct manner. We illustrate this in the context of the SCR (software cost reduction) method for specifying embedded real-time systems. We assume that the reader is familiar with denotational semantics, partial evaluation, logic programming, Prolog and definite clause grammars ([25,14,26] are good references for these topics).

Third, non-deterministic 5 semantics can be given to a language w.r.t. re- sources (e.g., time, space, battery power) consumed during execution. For example, some operations in the semantic algebra may be specified in mul- tiple ways (say in software or in hardware) with each type of specification resulting in different resource consumption. Given a program and bounds on the resources that can be consumed, only some of the many possible seman- tics may be viable for that program. Resource bounded partial evaluation [1] can be used to formalize resource conscious compilation (for example, energy aware compilation) [28] via Horn Logical semantics.

using jumps. Though, the compiled code generated is in Prolog syntax, true machine code is only a few simple steps away. The code generation process is provably correct, since target code is obtained automatically via partial evaluation. Of course, we need to ensure that the partial evaluator works correctly. However, this needs to be done only once. Note that once we prove the correctness of the partial evaluator, compiled code for programs written in any language can be generated as long as the Horn-logical semantics of the language is given.

Note that in the code generated, the update and access operations are pa- rameterized on the memory store (i.e., they take an input store and produce an output store). Of course, real machine instructions are not parameterized on store. This problem can be solved by using the DCG notation for expressing the valuation predicates as well.

So far we have modeled only direct semantics [25] using Horn logic. It is well known that direct semantics cannot naturally model exception mechanisms and goto statements of imperative programming languages. To express such constructs naturally, one has to resort to continuation semantics. Continua- tion semantics are also easily modeled in Horn Logic in the DCG format. In

We do not give details due to lack of space. More details can be found else- where [27]. However, we give below the continuation semantics of the subset of Pascal considered earlier after extending it with statement labels and a goto statement. Note that the syntax trees are now represented as a list of com- mands. Each command is represented in the syntax tree as a pair, whose first element is a label (possibly null) and the second element is the command itself. Only the valuation functions for commands are shown (those for expressions, etc., are similar to the one shown earlier).

The code for find label/3 predicate is not shown. It looks for the program segment that is a target of a goto and changes the current continuation to that part of the code. Consider the program shown below to the left: The result of partially evaluating the interpreter obtained from the semantics w.r.t.

We have applied our approach to a number of practical applications. These include generating code for parallelizing compilers in a provably correct man- ner [5], generating code for controllers specified in Ada [15] and for domain specific languages [8] in a provably correct manner, and most recently generat- ing code in a provably correct manner for the Software Cost Reduction (SCR) framework. In the rest of the paper, we show that Horn logical semantics can be practically applied; we apply it to the domain specific language of SCR, discussed next.

The grammar of SCR consists of five sections (type definitions, constant definitions, variable declarations, assumptions and assertions, and function definitions). User-defined data types are listed in the type definitions section. There are two types of user define data types: (i) enumerated type and (ii) integer type associated with a range. Variable declarations can include four types of variables: monitored variables, controlled variables, term variables and mode classes. The assumptions and assertions section contains predicates describing relations between variables, i.e., each assumption or assertion is a logical formula. The violation of an assumption indicates that the input does not obey the assumed environmental constraints. If an assertion is violated, it means that the specification does not satisfy a property that is was expected

injection is represented as a controlled variable called SafetyInjection. Each sensor represents an input. The hardware interface between the control sys- tem software and the safety injection system serves as output. A mode class Pressure and a term Overridden help make the specification of the safety injection system concise. Pressure has three modes: TooLow, Permitted, and High. A drop in water pressure below a constant Low causes the system to enter mode TooLow; an increase in pressure above a larger constant Permit

causes the system to enter mode High. The term Overridden is true if safety injection is blocked, it is false otherwise. An example of a condition in the specification is WaterPres < Low. Two examples of events are the input event event@T(Block=on) (the operator turns Block from off to on) and the conditioned event @T(Block=On) WHEN WaterPres < Low (the operator turns Block to on when water pressure is below Low). The program corresponding

The Horn logical semantics developed for SCR immediately provides us with an interpreter on which the program above can be executed. Further, the interpreter was partially evaluated w.r.t. this program using the Mixtus system, and compiled code was obtained. The partially evaluated code gen- erated that corresponds to the safety injection system is shown in Appendix

Even though our respective experiments have been done on different ma- chines, the machines are comparable in speed. As can be noticed, the time taken to generate code in our case is considerably better. Note that we did not optimize the semantics at all to make it more amenable to partial evaluation as that would have reduced the readability of the semantics.

Considerable work has also been done in using term rewriting systems for transforming source code to target code. In fact, this approach has been applied by researchers at NRL to automatically generate C code from SCR specification using the APTS [21] program transformation system. As noted earlier, the time taken is considerably more than in our approach. Other approaches that fall in this category include the HATS system [29] that use tree rewriting to accomplish transformations. Other transformation based approaches are mentioned in [17].

