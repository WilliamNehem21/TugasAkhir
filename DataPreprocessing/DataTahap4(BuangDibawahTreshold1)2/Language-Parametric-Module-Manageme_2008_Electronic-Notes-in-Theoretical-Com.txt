An integrated development environment (IDE) monitors all the changes that a user makes to source code modules and responds accordingly by flagging errors, by reparsing, by rechecking, or by recompiling modules and by adjusting visualizations or other information derived from a module. A module manager is the central component of the IDE that is responsible for this behavior. Although the overall functionality of a module manager in a given IDE is fixed, its actual behavior strongly depends on the programming languages it has to support. What is a module? How do modules depend on each other? What is the effect of a change to a module?

We propose a concise design for a language parametric module manager: a module manager that is parame- terized with the module behavior of a specific language. We describe the design of our module manager and discuss some of its properties. We also report on the application of the module manager in the construction of IDEs for the specification language Asf+Sdf as well as for Java.

The long term goal of our research is generation of Integrated Development Environ- ments (IDEs) for programming languages and domain specific languages. This is a classical topic, with a traditional focus on the generation of syntactic and semantic analysis tools [10, 15]. In this paper we instead focus on generating the interactive behavior of IDEs.

The basic functionality of a module manager is to provide access to the modular structure of the source code of a software project. This modular structure is differ- ent for each language. Apart from their pure syntactic appearance, the meaning of modules and module dependencies differs per language. For instance, the include mechanism of the C preprocessor does not coincide with a C namespace; files are simply concatenated one after the other. The Java import mechanism, however, does coincide with the namespace of a compilation unit; a class can be made in- visible outside the compilation unit it is defined in. Another example: Java has wildcards in import statements, a feature that is not present in C. The module semantics of a language is an important aspect of its syntax and semantics that is essential from the viewpoint of IDE construction. Large applications may even contain circular module dependencies: consider the processing of a text document containing an embedded spreadsheet that in its turn contains a text document, the syntax definition of a language in which statements can contain expressions but expressions may contain statements as well, or various design patterns that result in circular module dependencies.

In Section 2 we define the functionality of a module manager and its underlying data model. Section 3 gives an overview of the architecture of our implementation of such a module manager. In Section 4 we highlight the efficient implementation of the modal logic. Section 5 describes the case studies in which we applied our module manager to construct various IDEs. Section 6 summarizes our conclusions.

We will now present all notions that play a role in our approach: the basic repre- sentation (Section 2.1), the mapping of languages concepts (Section 2.2), module attributes (Section 2.3), name spaces (Section 2.4), events (Section 2.5), module predicates (Section 2.6), and the API of the module manager (Section 2.7). In Section 3 we will descibe module predicates in more detail.

Directed graphs are an obvious representation for programming language modules and their interdependencies. We identify the nodes of a graph with the modules of a program, and the edges of the graph with the dependencies between the modules of a program. Each node has a unique name and a collection of attributes. Each attribute has a unique name within the scope of the node, and an arbitrary value. Dependencies are anonymous but they do have attributes that allow the distinction between different types of dependencies.

So far, we have only introduced a generic data structure for storing and retrieving transient information about modules. In order to schedule actions we need rules to select actions for execution. Examples of actions are compiling a compilation unit, or extracting an outline of a Java class, alerting the programmer about a certain error, or decorating a package view with versioning pictograms. The rules of the module manager should trigger these actions at the appropriate times.

The listener or observer design pattern [9] is a simple method for decoupling coordination from computation. A computation, or action, registers itself as a listener, and the coordinator triggers the action at certain moments. The module manager allows registration of listeners to attribute change events, module existence events and dependency existence events such that an action may be triggered on any change in the data model. Note that actions may influence the state of the module manager, triggering new actions. Since we do not assume anything about the actions, there can be no a priori guarantee that such a process would terminate, not deadlock, or even be deterministic.

The information that needs to be propagated through a module dependency graph is language specific, even IDE specific. So, the module manager must provide some way of making information propagation programmable. For this we introduce module predicates. These are inspired by attribute grammar systems [16] and modal logic [2]. Both formalisms provide a programmable way of distributing information over the elements of a complex data structure. An example of a module predicate for a C IDE is linkable. A C compilation unit is linkable when it contains a main function and all of its dependencies have compiled correctly.

The module manager may also contain any kind of generic graph manipulation algorithms for the benefit of IDE actions. Operations like transitive closures of dependencies, reachability analysis, inversion, clustering, coloring and exports to graph visualizations are obvious candidates for inclusion in the module manager. Keeping the processing of these data as well as the data themselves as close as possible to the module manager will increase efficiency.

We will use a simple language for expressing the conditions for triggering events. This language needs at least the Boolean operators, some operators for inspecting the attributes of modules, and some operators to refer to the children of modules. The idea is to evaluate these conditions in every module, and send an event to the IDE when the value of a condition changes. We will label each condition with a name in order to be able to identify it, and call it a module predicate.

The operational semantics of the conditions is defined as follows. Each condition is evaluated for every module M . Every module has an attribute environment E that maps attribute names to attribute values, and a set of children K. The notation we use is ME. An evaluation function eval reduces a condition to either true or false. It defines an operational semantics for the standard Boolean conditions (which we leave out for brevity), and an operational semantics for the conditions A = V , C and C:

Evaluating a condition containing the or operator leads to the recursive application of the given condition C to the children of the current module, but evaluation differs in the way the result is aggregated. For , the condition must hold in all children. For , the condition must hold in at least one of the children. Note that evaluating and implies computing the transitive closure of the child relation among modules and that this definition of eval does not terminate on cyclic dependency graphs. A terminating definition of eval can be obtained easily by remembering the result of an earlier visit. Otherwise this definition terminates because it is a recursion over a finite expression tree, and no updates are done in the module environments while eval is computed. We will present a terminating (incremental) evaluation algorithm in Section 4.

The definition of the operators  and  resembles tree traversal mechanisms, such as found in ELAN [3], Asf+Sdf [4], Stratego [18], JJTraveler [19] and Strafun- ski [12]. However, since we are in the domain of modal logic and not in the domain of either functional programming or term rewriting, the resemblance is rather co- incidental. The main difference between modal logic and tree traversals is that in modal logic the other operators of the language do not perform arbitrary computa- tion but compute truth values using Boolean operators, which is at a higher level of abstraction. Another difference is that these logic operators operate on (possibly

The following examples illustrate how certain properties of modules can be described by a combination of attributes and predicates. In these examples we use attribute names S for module state and T for module type. They serve to show the flexibility of these rules since many different kinds of action triggering policies can be expressed using this simple formalism.

at least recalculate the truth values of all predicates that indeed have changed (i.e., the implementation should be correct ), while it should avoid waisting time on cal- culating module predicates that will certainly not change (i.e., the implementation should be incremental ).

Algorithm 1 shows an incremental predicate evaluation algorithm in pseudocode. The evaluation is started by the procedure UpdateAttribute that initiates the value change of an attribute in the pivot module. The recursive procedure Eval- uatePredicates recalculates the values of all predicates that are directly or in- directly dependent on the value of the changed attribute. Note that the previous value of each module predicate pred is maintained in the module environment as pred.name thus enabling the detection of value changes with respect to the current value of pred.condition. The function EvaluateCondition computes the value of a given condition by recurring over its structure. The algorithm starts at the pivot, evaluates all module predicates, and works its way up the module dependency graph detecting the other modules that are affected.

Although attribute grammars can have cyclic attribute dependencies, the graph that holds the attributes is a tree. Our tool distributes attributes on any graph, but the computed attributes can not have cycles. Furthermore module predicates are limited to the computational power of modal logic allowing extensive static consistency checking.

The Asf+Sdf Meta-Environment uses the module manager to keep module states up to date and to store other information such as graph properties, paths, and mod- ule names. Since Asf+Sdf modules can introduce user-defined syntax it is helpful to treat the Sdf part and the Asf part of a module separately. The remainder of this section describes the use of the module manager in Asf+Sdf focusing on its use for Sdf.

normalizer specification consisting of 75 modules. For the Java IDE case we used the source code of JSPWiki [11], which consists of nearly 38,000 lines of Java code in 228 source files and 192 libraries. In both IDEs a pivot module has been chosen in such a way that as much modules as possible were influenced by its changes. The profile run is done by editing the pivot module and causing an error. This error propagates through the import graph, evaluating all predicates and finally

The proposed module manager is fully language parametric and allows express- ing module semantics in a suprisingly concise way. Module predicates can be used to propagate information through the module dependency graph. This information is IDE-specific and can be used to give feedback to the user or trigger other actions. After a change in one of the modules due to editing, module predicates can be re- computed very efficiently. Based on this positive experience we will further explore the application of this approach to other languages and IDE-features.

