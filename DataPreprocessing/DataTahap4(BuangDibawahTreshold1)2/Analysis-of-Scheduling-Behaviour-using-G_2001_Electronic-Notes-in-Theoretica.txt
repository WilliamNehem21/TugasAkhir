A method for dynamic, automated analysis of the behaviour of real-time programs under different scheduling algorithms is presented. Each scheduling algorithm is defined by a generic timed automaton which can be instantiated with data for a particular set of tasks. The resulting network of instantiated timed automata can be analysed automatically in the model-checker Uppaal, to ensure correctness prop- erties are satisfied. Various scheduling metrics can also be calculated. We assume that data such as worst case execution times, periods, deadlines and priorities have been pre-calculated for each task. In this paper we present generic specifications for uniprocessor scheduling using the immediate ceiling priority protocol (ICPP) and the earliest-deadline-first (EDF) algorithm and analyse the behaviour of a mine pump controller implemented in Ada95 under each scheduling algorithm.

To analyse programs, rather than specifications, we must consider how they will be scheduled for execution in an implementation environment. Since the 1970s the problem of analysing possible schedules for a given set of tasks under a particular scheduling strategy has been an active research topic. Rate monotonic analysis [12] and its extensions provide conservative analysis of the schedulability of a particular set of periodic tasks. Such predictions are safe (if RMA predicts tasks are schedulable, then they will be schedulable in an implementation), but may be pessimistic (RMA may predict tasks can not be scheduled, when the implementation is in fact schedulable).

formulae, is that it is relatively cheap to apply. A system can also be analysed by implementing it and measuring task execution times. The implementation method is expensive to perform because a system must be implemented before it can be analysed and there is always an uncertainty whether the worst case execution time has been observed.

Each of these dynamic analysis methods share the disadvantage that gener- ating the timed automata model of scheduled tasks is complex, and thus time consuming and prone to error. We have attempted to reduce that cost by in- troducing generic automata to represent the behaviour of a typical task under a particular scheduling strategy. Generic timed automata are timed automata templates that can be instantiated with parameters. Program statements are abstracted to time consuming actions represented by time spent in automaton locations. Scheduling strategies are defined by guards and synchronisations which govern the transitions of the automaton. For each task of the pro- gram to be analysed, the timing of program statements, priorities, periods and deadlines are passed as parameters to the generic task automaton. Prop- erties of the scheduled program can then be analysed automatically using a model checker to explore all possible behaviours of its set of tasks.

The main contribution of this paper is to show how different scheduling strategies can conveniently be defined by generic timed automata and that these generic automata can be used to analyse properties of a set of tasks under different scheduling strategies. We focus on the activity of analysing scheduled behaviour of a set of tasks. Our method for dynamic analysis of schedules uses timed automata and the model checker, Uppaal. We assume that code execution times, task periods, deadlines and the timing of any triggering events are pre-calculated.

From the point of view of scheduling analysis, a task can be in one of three possible states: ready to run, running or waiting. Initially each task will be in its ready state. Under certain conditions it can change from ready to running, then either from running to ready again if pre-empted or from running to waiting once execution has completed. The task returns from its waiting state to being ready to execute when triggered by a period or event. This is the most general form of the model. Some states may be irrelevant for certain strategies. For example, under round robin scheduling and also in earliest deadline first there is no wait state and tasks alternate between running and ready states only.

In recent versions of Uppaal [10], an automata template can be defined using parameters for any of its constants, clocks, data variables and synchro- nisation channels. A network of automata can then be constructed by instan- tiating parameterised automata with actual parameters. Process parameters can include arrays of data variables [10].

We explain our method by introducing generic models for two contrasting scheduling strategies: ICPP and EDF. In both cases we assume a single pro- cessor is used. In ICPP scheduling we assume tasks with a fixed period. Task overheads such as context switches, entry and exit times of protected opera- tions, entry and exit times for processing of delay statements, timer interrupts and rescheduling times are included in the execution times. Jitter on clocks is not considered.

Exactly one task is always executing because we include an idle task as well as the program tasks. If a task in location run has not finished all mymax of its atomic actions it can either re-enter run if all tasks of higher priority are inactive or enters the location ready if a task of higher priority is active. From location ready the task can return to run once all tasks of higher priority have become inactive. After a task completes execution of all its mymax atomic actions, it makes itself inactive by entering location wait until its period triggers the task again and the task automaton returns to its ready state to await being scheduled to run again.

Whenever a task starts running another task has to stop running. When a task starts running it has to take the transition ready -> run. These tran- sitions are synchronized by change!. Therefore another task has to take a transition synchronized with change?. This is only possible on the transi- tions runready -> ready which immediately follows run -> runready and runwait -> wait which immediately follows run -> runwait. It follows if one task is entering state run from state ready, another task has to stop run-

In fact, we add that condition as invariant on the ready state. Should a particular instantiation not be schedulable, the model-checker Uppaal will alert the user that a deadlock arises. In this case, new deadlines must be chosen until the set of tasks is schedulable. Adding the invariant is safe because it does not introduce any new behaviours except a possible deadlock.

In [8] we assume a scheduler based on the Ravenscar [4] where task com- munication is possible via protected objects and not via rendevous : the model introduced in this paper is extended with protected objects. We suggest ev- ery protected object is modelled by an automaton. A task calls a protected object by synchronization with the corresponding automaton. The synchro- nization takes part when the value of mycounter of an automaton TaskEDF or TaskICPP has certain values (the time when the protected object is called).

We can, however, use several techniques to reduce the state space and thus reduce the model checking time. In our example we assumed an ideal clock checked every millisecond. This is ideal but not realistic. In realistic systems one could expect a check each 10 milliseconds. This coarser time grain could be modelled by dividing all times in our example by 10. Second, we could combine our model with scheduling theory by calculating some response times of tasks with functional analysis and integrate these results in our model.

