During the execution of a Composite Web Service (CWS), different faults may occur that cause WSs fail- ures. There exist strategies that can be applied to repair these failures, such as: WS retry, WS substitution, compensation, roll-back, or replication. Each strategy has advantages and disadvantages on different ex- ecution scenarios and can produce different impact on the CWS QoS. Hence, it is important to define a dynamic fault tolerant strategy which takes into account environment and execution information to ac- cordingly decide the appropriate recovery strategy. We present a preliminary study in order to analyze the impact on the CWS total execution time of different recovery strategies on different scenarios. The exper- imental results show that under different conditions, recovery strategies behave differently. This analysis represents a first step towards the definition of a model to dynamically decide which recovery strategy is the best choice by taking into account the context-information when the failure occurs.

During the execution of a CWS, different faults may occur that cause a WS fail- ure. However, a fault-tolerant CWS is the one that, upon a service failure, ends up the whole composite service (e.g., by retrying, substituting, or replicating the faulty WS) or leaves the execution in a safe state (e.g., by rollbacking or compensating the faulty WS and the related executed WSs). In this sense, fault tolerant CWS becomes a key mechanism to cope with challenges of open-world applications in dynamic changing and untrusted operating environments to ensure that the whole system remains in a consistent state even in the presence of failures [23].

Several techniques have been proposed to implement fault tolerant CWS exe- cution. In some works, transactional properties of component WSs (e.g., retriable, compensable or not) are considered to ensure the classical ACID (all-or-nothing) properties in CWSs [13,11,6,15,9,4]. In this context, failures during the execution of a CWS can be repaired by backward or forward recovery processes. Backward recovery implies to undo the work done until the failure and go back to the ini- tial consistent state (before the execution started), by roll-back or compensation techniques. Forward recovery tries to repair the failure and continue the execution, using retry and substitution, for example. In previous works, we presented our solutions based on backward and forward recovery [8,10].

However, backward recovery means that users do not get the desired answer to their queries, besides roll-back techniques that claim for logs in persistent storage to enable recovery after a re-start, reboot, or crash. The need for synchronous logging slows down the execution speed during normal operation and the reliability of these mechanisms depends on the reliability of the storage. Forward recovery could imply long waiting times, due of the invested time to repair failures until users finally get the response.

Focused on that need, in this paper we present a study to analyze the impact on the CWS total execution time of different recovery strategies in different sce- narios. We focus on backward, forward, and replication recovery techniques. The experimental results show that recovery strategies behave differently under different conditions. This analysis represents a first step towards the definition of a model to dynamically decide which recovery strategy is the best choice taking into account the execution state when a failure occurs, context-information, and the impact on the QoS.

The remainder of this paper is organized as follows. Section 2 briefly describes the most important concepts related to fault tolerance in CWS. In Section 3 we characterize the CWS and the environment in terms of execution time a the basis of our study. The experimental study is presented in Section 4. Section 5 presents relevant related works. Finally, our conclusions and future work are presented in Section 6.

The execution control can be centralized or distributed. Centralized approaches consider a coordinator managing the whole execution process [20,26]. In distributed approaches, the execution process proceeds with collaboration of several participants without a central coordinator [4,1]. On the other hand, the execution control could be attached to the WS [13,15] or it could be independent of its implementation [9]. Some execution engines, such as the IBM framework BPWS4J 4 or the open source Orchestra 5 solutions actually execute CWS specified with BPEL4WS in a centralized fashion and the execution control is attached to WSs.

Logic faults. Logic faults are specific to different WSs and are caused by error in inputs attributes (e.g., bad format, out of valid range, calculation faults) and byzantine faults (the WS still responds to invocation but in a wrong way). Also, various exceptions thrown by the WS to the service users are classified into the logic-related faults. It is difficult for the execution engine to identify such type of faults.

In previous researches in the field of supporting reliability and fault tolerance in WS composition, only low level programming constructs such as exception handling (for example in WSBPEL) were considered. Exception handling normally is explic- itly specified at design time, regarding how exceptions are handled and specifying the behavior of the CWS when an exception is thrown. This approach is normally used to manage logic faults, which are specific to WSs.

More recently the reliability and fault tolerance for CWS have been handled at a higher level of abstraction, i.e., at the execution flow structure level such as workflows or graphs. Therefore, technology independent methods for fault-tolerant CWS have emerged, such as transactional properties and replication.

Backward recovery: it consists in restoring the state that the system had at the beginning of the CWS execution; i.e., all the effects produced by the failed WS and the previous executed WSs before the failure are semantically undone by roll-back or compensation techniques.

for synchronous logging slows down the execution speed during normal operation and the reliability of these mechanisms depends on the reliability of the storage. Forward recovery could imply long waiting times because of the invested time to repair failures until the users finally get response. They can be difficult to ensure the retriable property to all WSs.

QoS criteria describe non-functional WS characteristics (e.g., execution time, price, reliability). The QoS values can vary for a single WS during its lifecycle. Hence, there exist several techniques to keep these values of the QoS parameter as most as possible updated. Particularly, execution time estimation for WSs can be done with analytic, simulation, or test based techniques. In [14], there are proposed methodologies based on a two-factorial analysis and a Gaussian majorization of previous service execution times, enabling the estimation of a WS execution time. In [16], the performance of WSs at different levels (i.e., user level, network level, hardware resource level and software design level) is analyzed. The user level is the one corresponding to the execution time of the WS, which is calculated by

the mean value during a certain period by invoking the actual WS. There is also research in the estimation of the execution time for CWSs. In [25], a time estimation method for CWSs is proposed based on mining historical execution information of the component WSs in the dynamic environment. It takes into account the WS execution time and the network transmission time.

Definition 3.7 Elapsed Real Execution Time for a WS. Let wsi be a com- ponent WS in a CWS, the Elapsed Real Execution Time for wsi, denoted as WS elapsed timei, refers to the real invested time since the CWS starts its ex- ecution, from ni, until wsi is invoked.

Definition 3.9 Real Executed Time for a WS. Let wsi be a component WS in a CWS, the Real Executed Time for wsi, denoted as WS executed timei, refers to the real invested time since the wsi was invoked until wsi finished successfully or unsuccessfully.

WS executed time represents the actual execution time invested in the ex- ecution of a component WS. If the component WS finishes successfully, its WS executed time will be the real execution time. In contrast, if the component WS fails, it will represent the time from its invocation until the time when the failure happened.

Additionally, even if this model is designed to respond to silent faults, it could be used to ensure the QoS at the execution time of the CWSs, not only in presence of failures. If the execution conditions are tested before/after the execution of each component WS, a decision for backward recovery could be made if QoS will be violated. Imagine a part of the CWS execution takes much more time that the estimated in a way the total estimated execution time is overcame, in which case the execution has to be halted (a compensantion could be necessary).

We automatically generated 10 CWSs by using the composition process pre- sented in [6], from synthetic datasets comprised by 800 WSs with 7 replicas each one, for a total of 6400 WSs. These 10 CWSs have 9 or 10 component WSs. All WSs, including replicas, have different QoS values. In particular for experiments, we consider the following QoS parameters:

Note that in our experiments, results were not impacted by the homogeneity level. Similar results and conclusions were obtained from both cases. This experi- ence can represent another benefit to mention of our model: it is independent from how heterogenous is the execution environment. We plan to test our model with more exhaustive cases to probe these preliminary suppositions.

FENECIA framework [13] provides an approach for managing fault tolerance and QoS in the specification and execution of CWSs. FENECIA introduces WS- SAGAS, a transaction model based on arbitrary nesting, state, vitality degree, and compensation concepts to specify fault tolerant CWS as a hierarchy of recursively nested transactions. To ensure a correct execution order, the execution control of the resulting CWS is hierarchically delegated to distributed engines that communicate in a peer-to-peer fashion. A correct execution order is guaranteed in FENECIA by keeping track of the execution progress of a CWS and by enforcing forward and backward recovery. To manage failures during the runtime it allows the execution retrial with alternative candidates. FACTS [15] is another framework for fault tolerant composition of transactional WSs based on FENECIA transactional model. It combines exception handling strategies and a service transfer based termination protocol. When a fault occurs at run-time, it first employs appropriate exception handling strategies to repair it. If the fault cannot be fixed, it brings the CWS back to a consistent termination state according to the termination protocol (by considering alternative services, replacements, and compensation).

puting. In [12], WS invocations are intercepted by an integrated software compo- nent to the BPEL engine. If a failure occurs during an invocation, it is handled by this extension according to policies that take into account specific characteristics of the cloud environment. This solution is not transparent, it is strongly attached to the specific BPEL engine implementation. In [1], a replication strategy is used and a rollback workflow is automatically created considering the service dependencies. An actively replicated platform is presented, in which all replicas of a WS are si- multaneously invoked. Only results of the first replica finished are accepted, other executions are halted or ignored. The process of replication and coordination of replicas is implemented transparently to users and independent to WS implemen- tation.

