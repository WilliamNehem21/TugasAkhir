Modern mobile phones are powerful computers. Their primary task, providing mobile wireless telephone services, is comparatively losing importance as they are being used for a range of other applications, from personal information managers to web browsers, from media players to games. Most of these applications ac- cess the network 2 , either because it is integral to their functionality (e. g. web browsers, online games), or because networking is adding desired features (e. g. playing streaming media or synchronising diaries).

The cost of the standard computational resources, like execution time or memory space, is determined solely by the computational device (i. e. the hardware of the mobile phone) itself. The cost of network access, however, is determined by external entities, e. g. the business model of the phone operator, which is why we classify network access as an external resource. Moreover, it is a resource the spending of which users generally would like to control tightly because it costs them money.

The rest of this paper is structured as follows. Section 2 gathers some facts about MIDP which are relevant to us. Section 3 introduces the resource management library, which Section 4 extends by adding policies. Section 5 describes the security properties that library guarantees and outlines a deployment scenario. Section 6 discusses related work, and Section 7 concludes.

To instrument messaging, we have to augment MIDP and WMA in three places. We supplement the WMA interface MessageConnection with a new wrapper method send(ResManager,Message), provide a class which implements this extended in- terface, and revise the MIDP method Connector.open to return the new class.

By design, the resource management API is extensible. Monitoring new resources (e. g. the number of bytes sent over a TCP/IP connection, or the space available in the persistent record store) simply amounts to adding new resource types plus adding the appropriate instrumentation. New resource types are added by extend- ing the abstract class Resource with final subclasses, which abide by the contract

So far, the enable method involves the user, who is selecting to-be-added resources in a pop-up dialogue. That is, the user is acting as a policy oracle deciding which resources to grant and which to deny. In this section, we extend the API to include more flexible policy oracles, not just the user.

It may seem as if resource managers could infringe information flow security. Is it not possible that sensitive data (e. g. phone numbers from the address book) leaks from a manager while it is passed from method to method? We argue that at least for resource safe MIDlets, this is not the case.

The MIDlet does not bypass the instrumentation. More precisely, if the MIDlet allocates a particular resource type (e. g. MsgResource) then it does not call uninstrumented methods for consuming resources of that type (e. g. the method send(Message) declared in the WMA interface MessageConnection).

The correctness of the resource management library itself cannot be checked easily, hence the library (including the instrumented methods) has to be trusted. Yet, as MIDP does not support the download of trusted libraries, MIDlets using the resource management API have to provide the library as part of their own JAR. To establish trust in the library, a trustworthy third party (e. g. the network operator) should vouch for it by signing the MIDlet. In detail, the deployment process should comprise the following steps.

Runtime monitoring to increase software reliability is at the heart of the Java lan- guage [4] with its mandatory runtime checking of array bounds and null pointer dereferences. Several frameworks have been proposed for enhancing Java with run- time monitoring of resource consumption, for example JRes [3], J-Seal [1] and J- RAF [10]. Real-time Java (RTSJ [5]) provides resource monitoring as part of its support for real-time applications. These frameworks monitor specific resources (CPU, memory, network bandwidth, threads), relying on instrumentation of either the JVM (for CPU time), low level system classes (for memory and network band- width) and the bytecode itself (for memory and instruction counting). Where our resource management API is designed to enforce security, these frameworks were developed to support resource aware applications, which can adapt their behaviour in response to resource fluctuation, for example by trading precision for time (by returning an imprecise result to meet a deadline), or time for memory (by caching less to reduce memory consumption).

Runtime monitoring can be used to check whether a program meets a safety property specified in a propositional temporal logic. Tools like JPaX [9] compile a specification into a finite automaton which runs in parallel with the program, observing its behaviour. This kind of temporal specification can express resource protocols like authorise-before-use but is not expressive enough to capture protocols that involve counting potentially unbounded resources.

We have designed a Java library for tracking and monitoring the use of external re- sources on MIDP mobile phones (e. g. sending text messages). The library improves the flexibility of runtime monitoring in MIDP (which previously was in the hands of the user), providing a clear user interface and flexible policies while maintaining the security guarantee that any attempt to abuse resources will be trapped.

