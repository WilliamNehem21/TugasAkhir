see [23] for a solution using predicate transformers). The other approach, which has many sources but which has been advocated strongly by Tennent [31], has been to use binary logical relations [21,19,4] to model data refinement. Binary logical relations model data abstraction and are well suited to higher order types, but they do not compose. So one seeks a common generalisation that both accounts easily for higher order types and is closed under composition. That has led to the notion of lax logical relation [24,15] and variants [14]. Here, we explain and develop the notion of lax logical relation in the setting of call by value languages, based on but clarifying and extending the work of [15].

Finally, we reach the modelling of data refinement. With the above extensions or improvements of previous work, we routinely generalise the notion of lax logical relation in [15]. In doing so, we give a version of the Basic Lemma that is a much more direct generalisation of its usual formulation than appears in [15]. We also give a condition, satisfied by all our leading examples, under which lax logical relations compose; one can see immediately that lax logical relations account for higher order structure too.

A programming language may be freely generated by a signature, i.e., basic data types and basic expressions. For a recent account and use of the idea, see [14]. For a category theoretic formulation of the notion of signature, we give, for any finitary

