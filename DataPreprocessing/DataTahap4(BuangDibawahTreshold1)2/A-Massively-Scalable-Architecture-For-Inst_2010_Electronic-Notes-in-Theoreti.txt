This paper analyzes the scalability of Instant Messaging & Presence (IM&P) architectures. We take a queueing-based modelling and analysis approach to find the bottlenecks of the current IM&P architecture at the Dutch social network Hyves, as well as to analyse three alternative architectures: evolutionary partitioning, aggregated, batched presence updates and presence subscriptions. We use the Hierarchical Evaluation Tool (HIT) to create and analyse models analytically. Based on these results, we recommend a new architecture that provides better scalability than the current one.

lot of effort improving the architecture after it became popular is Twitter [11]. An instant messaging & presence (IM&P) service allows users to exchange messages and distribute presence information. Whereas messages are exchanged between one user and another, updates to presence information are multicasted from the source to all related users (contacts). An IM&P architecture needs to forward messages and exchange presences in a timely manner, as users expect instanteneous response, especially for messages. In addition to that, the architecture must provide the user with the presence information of all contacts when the user connects to the service. Hyves is a Dutch social network and offers all kinds of social applications, such as personal profiles, weblogs and IM&P. The current IM&P architecture is sufficient for the current workload, but Hyves engineers expect that it will not be able to handle a tenfold increase.

The main goal of scalability [5], [4] analysis is to compare an architecture under different workloads. For this it is not necessary to know each performance aspect in detail, as constant aspects do not contribute to comparisons. In the following we call an architecture scalable, if changing the amount of hardware resources allows the system to handle a proportionally changing workload while the performance remains the same.

scriptions. We take a queueing network-based modelling and analysis approach to find the bottlenecks of architectures. The Hierarchical Evaluation Tool (HIT) is used to create and analyse IM&P architectures. HIT translates these models then to open queueing networks and can be used to compute, e.g., throughput and response times.

Although several high-level descriptions of IM&P architectures are available on the internet, we are not aware of previous work on their analysis. However, a number of studies of with other purposes have been published, that mainly develop an analytically solveable model for an existing computer or software architecture. In [13] a simple webserver architecture is modelled and analysed using queueing networks. A comparison between two Enterprise Java Bean architectures using queueing networks is performed in [8].

This paper is structured as follows: we detail our modelling and analysis ap- proach in Section 2. In Section 3 we describe the current IM&P architecture and its bottlenecks. Section 4 contains detailed descriptions of three alternative architec- tures. In Section 5 we describe the analysis results for the current and alternative architectures. Section 6 contains the conclusion and recommendations for future work.

We use the Hierarchical Evaluation Tool (HIT) to create and analyse models. These models are constructed using a graphical notation in the supporting tool HIT- GRAPHIC [2,3]. HIT translates the models into an open queueing network and uses the DOQ4 solver to calculate measures, such as utilisation, throughput and response time. The term scalability relates to both the workload and the resources of a system. Hence, a scalability model captures the relation between workload and resources. We model both, the workload and the resources using HIT. Using HIT, an architecture can be represented by a single model, while the individual parts can each be modelled at convenient abstraction levels. At the upper level, parameters can be tweaked to model different user characteristics. This can be done to model a growth of the number of users or to model the change of behaviour of the average user. At the lower levels of the model, the utilisation of the resources is measured. In our models, we consider the following resources:

The workload is a combination of the current peak rates for the five actions users can perform on the service: log in, log out, send a message, receive a notification and change presence information. The peak rates are derived from measurements on the current architecture. These five rates are used together as one unit of workload in all architectures. The Facebook chat service [7] shows that response time is not an issue for presence propagation. Instead, the delay for transferring instant messages must be low, as users might become dissatisfied with the service if the messages do not arrive immediately. Hence, we will analyse the response time of the message send action for each architecture. In addition to that, we compare the architectures by analysing the relation between workload and number of machines necessary to handle that workload. We assume that each architecture is able to handle the current peak workload with the current number of machines, which is

The protocols used in this architecture are the MySQL protocol for data repli- cation between master and slaves and for the traffic between the slave nodes and the application nodes and the Extensible Messaging & Presence Protocol (XMPP) for the client-application traffic. The MySQL protocol is unicast, such that adding a slave causes additional outgoing traffic on the master node. The current archi- tecture does not enforce a particular network layout. In practice, the machines are dispersed over various data centres and locations within those data centres. The database of the current architecture stores user, presence and session information for each user that has ever connected to the service. The user information that is stored is just the username and the user identification number (userid). Other infor- mation is stored in external services. The presence information consists of a status

services of the architecture invoke services offered by the underlying components. Each used service is represented by a horizontal line originating at the service that uses an underlying service, such as login. Each offered service is represented by a vertical line originating at the corresponding component. The dot on the intersec- tion indicates the relation between the used service and the offered service. The model shows that that the services login, changestatus and logout are similar, as they all use the service changestatus of the slavegroup component.

are the top values of measurements on the current architecture. The packet sizes have been deduced from network traces on this architecture. The database load estimates were estimated using performance tests. A more detailed description of the parametrisation of the model is given in [12].

an overview of the alternative architecture. Each channel node forwards messages and stores presence information for a portion of the user base. Clients connect to one of the application nodes and the channel node that stores their messages. Application nodes forward incoming messages to the channel node of the receiving user. Incoming presence updates are forwarded to the channel node of the user that sent the presence update. They are stored at channel nodes and transmitted in batches at a given interval to all presence nodes, which store presence information for all users. Application nodes poll presence information for their connected users at a given interval. They fetch presence information for all users from the contact lists and forward this information to their clients.

Channel nodes are the authoritative source for presence information, while ap- plication nodes do not store presence information at all. When an application node tries to send a message to a channel node for a user that is unavailable, the channel node generates an error, which is transported back to the client. The capacity re- quirements on their links force us to reduce the amount of presence information kept per user. At this moment, a user can select one of six possible presence statusses as well as store information in a 500 byte free text field. Only the presence status can be stored in this architecture. We store this information using three bits of data.

aspects of real systems that determine latency. The analysis could however reveal fundamental problems of an architecture. For example, a constantly increasing response time indicates that the architecture will in practice exhibit performance problems. Architecture 2 delays presence updates by default, making it difficult to compare architectures on the response time of presence updates. Therefore, we only compare architectures on the response time of propagating an instant message.

from the aggregation of presence updates in this architecture. Recall that the load generated by the distribution of presence updates is unrelated to the number of presence updates per second. This property is unique for this architecture. From this we conclude that the first architecture is not scalable. The second architecture is scalable, with the reservation that the number of machines is only partially deter- mined by the workload. The third architecture is scalable in the most strict sense of the word: the number of machines is related linearly to the workload.

The third subscription-based alternative has a strictly linear relation between workload and utilisation. This relation is also linear for the second, aggregated pres- ence architecture, but here the utilisation is only partially determined by the the workload. The first, partitioned alternative has the worst scalability in this com- parison, its machine to workload ratio increases dramatically for larger workloads. The second architecture introduces delays in presence propagation and a limit on the amount of presence information that can be stored per user. These findings lead us to recommend the subscription-based architecture as the best architecture for Instant Messaging & Presence services. The evolutionary improved architecture might be used as a short term solution if scalability problems arise, but the model shows that it does not scale in the long run. The aggregated presence updates ar- chitecture is also scalable, but is less favourable, given the degradation in quality of service for presence propagation.

sufficient, but specific enhancements for models of scalable architectures would de- crease the analysis effort. Specifically, modelling multiple identical components is only possible using simulation, while it could probably be analysed analytically if HIT would support this. The HITGRAPHIC representation of a HIT model makes modelling easier, but this can be further enhanced by focusing more on relations between components. Cycles in the component hierarchy are not allowed, which prevented a straight-forward implementation of the current architecture.

