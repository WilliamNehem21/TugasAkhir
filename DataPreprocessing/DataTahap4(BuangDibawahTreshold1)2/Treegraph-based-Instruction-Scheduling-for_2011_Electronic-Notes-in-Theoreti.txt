In this paper we investigate how the semantics of a register-based IR can be mapped to stack-code. We introduce a novel program representation called treegraphs. Treegraph nodes encapsulate computations that can be represented by DFS trees. Treegraph edges manifest computations with multiple uses, which is inherently incompatible with the consuming semantics of stack-based operators. Instead of saving a multiply-used value in a temporary, our method keeps all values on the stack, which avoids costly store and load instructions. Code-generation then reduces to scheduling of treegraph nodes in the most cost-effective way.

The remainder of this paper is organized as follows. In Section 2 we provide background information and survey the related work. Section 3 introduces our tree- graph IR and the basic treegraph scheduling algorithm. In Section 4 we discuss the minimization of overall stack manipulation costs. Section 5 contains experimental results. We draw our conclusions in Section 6.

Generating register-code for arithmetic expressions was first studied by Andrei Er- shov [5]. Sethi and Ullman used Ershov numbers to devise an algorithm that they prove to generate optimal code for arithmetic expressions [18]. Aho and Johnson used dynamic programming to generate optimal code for expression trees on CISC machines [1].

Instruction FETCH k duplicates element k (counted from the top) and pushes the duplicate onto the TOS. The stack size is incremented by one. If there are less than k elements on the stack, the machine will go into the error state and will terminate the execution.

The resulting forest is not well-formed in the sense that some of the operations depend on computations that are not performed inside their tree. To generate code for a DAG, we find the roots r1,..., rm for all trees T1,.  , Tm in F , i.e., this is the

Proof. The properties of DAG G can only be destroyed by adding an edge that in- troduces a cycle. Condensating DAG G to a tree-graph H(F, A) does not introduce additional edges, because every tree of forest F becomes a single node representing the root of the tree. The edges of the tree-graph A correspond to the cut-set C. 2

All experiments were performed on an Intel Xeon 5120 server running Linux CentOS 5.4 with kernel version 2.6.18. We selected 24 C benchmark programs from the testsuite that comes with the LLVM compiler infrastructure [20]. Our TinyVM backend cannot handle floats and struct args yet, which is reflected in our selection of benchmarks.

In this paper we investigated how the semantics of a register-based IR can be mapped to stack-code. We introduced a novel program representation called tree- graphs. Treegraph nodes encapsulate computations that can be represented by DFS trees. Treegraph edges manifest computations with multiple uses. Instead of saving a multiply-used value in a temporary, our method keeps all values on the stack, which avoids costly store and load instructions. Values that are in the correct stack slot for (some of) their users are duplicated so that they can be consumed without stack manipulation. All other values are lifted to the top of stack via a FETCH instruction. We implemented our treegraph scheduler with the LLVM compiler infrastructure for TinyVM, a stack-based embedded systems VM for C.

