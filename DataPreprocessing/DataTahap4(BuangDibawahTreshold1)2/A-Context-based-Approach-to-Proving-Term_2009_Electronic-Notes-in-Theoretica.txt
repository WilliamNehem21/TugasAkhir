We present a context-based approach to proving termination of evaluation in reduction semantics (i.e., a form of operational semantics with explicit representation of reduction contexts), using Tait-style reducibility predicates defined on both terms and contexts. We consider the simply typed lambda calculus as well as its extension with abortive control operators for first-class continuations under the call-by-value and the

Because of their close relation to continuations, the benefits of using contexts can be seen perhaps most prominently in languages with control operators, i.e., syntactic constructs that manipulate the current continuation/context [15]. More- over, as shown by Wright and Felleisen [27], context-based reduction semantics of a programming language provide a convenient formalism for expressing and proving type soundness properties.

and the syntax of reduction contexts depends on the strategy we choose for reduction (in fact, the grammar of reduction contexts reflects the reduction strategy). Because of that, we postpone the actual definitions of reduction contexts for call by value and call by name to Section 2.2 and Section 2.3, respectively.

We define the set of free and bound variables in a term in the usual way, and we distinguish closed terms, i.e., terms with no free variables. As is also standard, we identify terms that differ only in the names of their bound variables.

In the standard approach, the reducibility predicate on well-typed terms ex- presses the property that whenever a reducible term is applied to another reducible term of the right type, the resulting term has also this property. Moreover, if a term is reducible, then it normalizes. The proof of termination consists in showing that all well-typed terms are reducible, from which it follows that all well-typed terms normalize.

Proof. It is straightforward to see that the empty context satisfies Ccont A for any type A. From Lemma 2.4 it follows that if we take a closed well-typed term t and put it in the empty context, then the resulting program evaluates to a value program.	 

Though it is impossible to prove a stronger type soundness property in the general case, we can obtain such a property if we consider only plain programs. As we will see, plain programs can be shown to satisfy the strong type soundness property stating that the type of a plain program and of its final value are the same, which in general is sufficiently strong and together with the termination theorem of Section 3.1.3 ensures that any well-typed plain program evaluates to a unique value of the same type. However, even in the case of plain programs, we cannot hope for a standard subject reduction property of our type system, since, in the course of computation, contexts get captured and are substituted for continuation variables, which leads to non-plain programs.

We shall prove strong type soundness for the above type system by relating it to a more restrictive one, namely an annotated type system that allows for applications of contexts of one fixed answer type. In the annotated type system the annotation on the turnstyle specifies the type of the entire program, of which the given phrase can be a part. Only contexts of that answer type are allowed to be captured and applied later on.

Our goal in this section is to prove termination of call-by-value evaluation of well- typed plain programs (hence, of well-typed plain terms). The logical predicates for the language with callcc are exactly the same as for the simply typed lambda calculus and we state a termination theorem analogous to that of Section 2.2.3.

Analogously to the call-by-value case, it can be shown that the plain language with the call-by-name reduction strategy satisfies both the weak and strong type soundness properties. Moreover, using the logical predicates defined for the simply typed call-by-name lambda calculus in Section 2.3.2, we prove termination of call- by-name evaluation for the language augmented with callcc.

It is easy to see that the presented typing rules for A and C are too liberal to ensure type preservation by reduction (because of the completely unconstrained type B in the premises). So even though the evaluation in the simply typed language with A and/or C always terminates, the type of the program may change in the course of computation. If we wanted to ensure type preservation under the given reduction rules (which are standard), we could use a more restrictive type system that is an extension of the annotated type system of Section 3.1.2 with the rules:

the call-by-value and the call-by-name reduction strategies. We have also presented evaluators extracted from each of the proofs. These evaluators are instances of nor- malization by evaluation. Moreover, they are in continuation-passing style and the continuations arise as the computational content of the reducibility predicates for reduction contexts. This latter fact shows a logical connection between continua- tions and contexts; the correspondence between them has previously been observed and investigated by Danvy in the setting of program transformations [11, 12].

Below we present example OCaml implementations of the evaluators from Sec- tion 3.1.4 and Section 3.2. These implementations can be seen as desired effects of a program extraction tool but they have not been obtained in that way (in fact, automatic tools usually produce much less readable code).

