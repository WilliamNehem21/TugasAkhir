Besides of the frameworks, which are beyond the scope of this article, one can also perform refinement proofs by means of model checks if the space of the reachable system states does not exceed a certain finite number (cf. [1,24]). The advantage of model checker application to the frameworks is that the proofs can be performed in a highly automated fashion. Since UML-based system descriptions tend to describe systems in a relatively abstract manner, we ex- pect that the modeled state space of many real-life systems can be handled by a model checker. Therefore we decided to apply the powerful checker TLC (Temporal Logic Checker) [24,33], to perform the refinement proofs. Tools for the transformation of UML specifications into cTLA [9,11] and of cTLA spec- ifications into TLA [19] exist. The transformation utilizes the compositional features of cTLA extensively since a UML diagram can be transformed into a separate cTLA process. Our approach complements a lot of other approaches formalizing UML diagrams by formal models (cf. [25,28,30,31]) which, however, do not use compositionality in the way explained in this paper.

A Read Write Action is used to perform read and write access to structural features like object attributes and properties, to create and destroy objects, and to handle links between objects. Derivations are Structural Feature Ac- tions to handle access to structural features, Object Actions to manage the life cycle of an object, and Association Actions in order to operate on links and associations. An example of the first subclass is ReadStructuralFeature retriev- ing the values of a uniquely identified and not statical structural feature of a certain target object. So called Object actions are responsible for the creation and destruction of objects. A CreateObjectAction is an action which creates an object conforming to a class. The destruction of objects is performed using a DestroyObjectAction.

A CreateObjectAction is an action which creates an object conforming to a class. The destruction of objects is performed using a DestroyObjectAction. The actions are incorporated into activities which define certain orders of action executions. In our current work, we concentrate on so called Basic- Activities which, in contrast to more powerful extensions, do not allow the concurrent execution of different actions. An activity is modelled in a Petri Net-like style containing nodes which are connected by edges forming a com- plete flow graph for data and control values. An activity model consists of three types of nodes: An action node is used to define an action operating on received control and data values and providing control and data to other ac- tions. Control nodes are used to coordinate control flow as well as data flow by routing control and data tokens through the graph. Finally, object nodes are applied to store both objects and data temporarily until they can be accepted

Systems and subsystems are described as compositions of concurrent pro- cesses. As in the ISO/OSI specification language LOTOS [20], a set of pro- cesses interact in a rendezvous-like way by performing actions jointly, and the data parameters of the actions can model the communication of values be- tween processes. Each process encapsulates its variables and changes its state by atomic execution of its actions. The system state is the vector of the process

each object instantiated from the corresponding UML class according to its statechart diagram. Our transformation of a statechart to a cTLA process is based on the concept of run-to-completion semantics (cf. [6]) which assumes that only one thread of control is active in an object at a certain point of time. This concept forces the interleaving of concurrent processes.

The transformation is performed in two steps. At first, we flatten a state chart to another state chart containing only simple states and pseudostates. This is done by application of graph grammars (cf. [7]). In this step, we also consider the actions defined in a state. Actions of entry activities are shifted to every activity of an ingoing transition. In contrast, an action of an exit activity belonging to a state is shifted to every activity of an outgoing transition. Do activities are not supported since they invoke concurrent computations which can be interrupted at any point of time. This, however, violates our assumption of run-to-completion semantics for a state machine.

contained in qu. A state variable sync used to block an object initiating a synchronized calls. Moreover we introduced the state variable lifecycle describing the lifecycle state of an object 3 . Possible values of lifecycle are unborn, alive, and dead. Unborn and dead objects are neither able to compute a result nor to take part in an interaction. Moreover, for every pin of an action we added a set of state variables. One variable is used to store the data transferred via the pin. For the sake of simplicity, we restrict the range of pin types to simple data types. Another variable states if the pin is currently filled by a data or control value.

cTLA actions that change the value of the state variable lifecycle if the cre- ation and destruction of objects is handled in the corresponding UML model. The cTLA action which creates an object sets the value of the state variable lifecycle to alive if it has the value unborn. An additional action is used to change the value of lifecycle to dead if an object has to be destroyed and the value of lifecycle is alive.

Similar to an operation call, the corresponding operation reply is also mod- elled by two coupled cTLA actions. In the UML, however, an incoming reply transmission is accepted by the same CallOperationAction which also trig- gered the initial call. Since this non-atomic behavior cannot be specified by a single cTLA action, we describe CallOperationActions by two cTLA ac- tions modelling the execution of an operation call resp. the acceptance of the reply transmission. In the process Adapter the actions callControl and callControlReply are both used to model a single CallOperationAction.

The goal of our verification is to prove that the refinement pattern per- forms only model transformations where the behavior of the derived more detailed UML specification does not contradict to the behavior of the original abstract UML description. For this purpose, we transform both UML models to cTLA specifications as outlined in Sec. 6 and 7. Thereafter, we perform

