The paper is organized as follows. In Section 2 we start with a small case study for an object-oriented component architecture. This is an explicit example of the advanced generic architecture framework presented in Sec- tion 3. Based on that, we define the semantics of connector architectures in Section 4. The main result in Section 4 shows existence and uniqueness of architecture semantics, which is based on compatibility of component com-

position in Section 3, within the extended framework allowing overlapping connector interfaces. Section 5 then presents the instantiation of the generic framework to UML diagrams, which is the concrete framework for our case study in Section 2. In Section 6 we conclude with a brief discussion of related work and an outlook to future research.

In this section we will model a small case study concerning the management of meta data using an object-oriented connector-component architecture based on UML. The corresponding architecture framework for UML is an instantia- tion of the generic framework for architectures presented in Sections 3 and 4. This instantiation will be described in more detail in Section 5.

The system shall be able to exchange the data of arbitrary Topic Maps via the HTTP protocol (see [12]). This way it shall be possible to share the data on one hand in a server based fashion, where a powerful web server processes the queries of lots of clients, and on the other hand in a peer-to-peer fashion, where clients exchange data directly. As exchange format the standardized XML transfer syntax [10] for Topic Maps shall be applied.

The <<architecture>> packages in this abstract view correspond to the ar- chitecture graphs of our generic framework in Section 3. The components are Ontology, Server, and Manager representing the three main areas of re- quirements. They are connected via the connectors SrvSrc between Server and the data model in Ontology and ManOnt between Manager and the domain ontology in Ontology.

[11] by a UML class diagram. Additionally two methods are declared which will be used by the Server component below. The first method getByIdentifier of TopicMap takes a URI as parameter and returns a topic containing the given URI as identifier if it exists. This is specified by the OCL constraint for the method. The second method serialize of Topic shall return an XTM

<<transform>> dependency, between ImpSource and ExpDataModel renaming the class DataSource with the method getByURI to the class TopicMap with method getByIdentifier and the class Resource to Topic (the method serialize is not renamed). The renamed model is included in ExpDataModel. The con- nection conSrv to the export of the Server component will be described in the next paragraph.

Next, we carry the concept of overlapping connector interfaces forward to whole architectures of components and connectors. Similarly to connectors we obtain an architecture diagram and an architecture graph. The first describes the architecture at the level of specifications and the second as a graph, where nodes are connectors or components.

Definition 3.7 (Architecture graph) An architecture graph GA for an ar- chitecture diagram DA is obtained by shrinking each connector diagram in DA to the corresponding connector graph. Hence, it consists of nodes labeled by the connectors and components and arrows in between labeled with the corresponding connection transformations.

In the following we consider the special case of binary connectors and components with two export interfaces each. The proof of this special case shows how to use the extension and the parallel extension property and can be extended without problems to the general case of Theorem 3.10 which is needed in the proof of Theorem 4.5.

In this section we will show, how the abstract connector framework can be ap- plied to UML diagrams. In this paper, we regard only the concrete graphical representation of UML diagrams on a more or less intuitive level. This implies that also our instantiation can be given only on an intuitive level. In later stages of our research we want to deal with the corresponding meta-model in- stances as formal abstract syntax, which would enable us to give a much more detailed definition of connector architectures for UML diagrams. Moreover, we could respect the syntactical dependencies between different diagrams, e. g. the case that a state machine refers to a certain method defined in the class diagram, which are documented in the UML meta-model instances.

means for example, that an attribute number : Nat of CD may be translated to an attribute number : Int, if all other occurrences of number : Nat in the class diagram CD are translated to number : Int. Of course, the images of the classes are allowed to have additional functionality with respect to their preimage. All connections between classes have to be transformed to corresponding connections of the same type, e. g. associations have to be mapped to associations. Again we allow a renaming of the inscriptions of the connections.

to translate the labels of the interactions in the diagram. The second step is to replace lifelines by disjoint sets of lifelines (including the given lifeline) and interactions (l, m, l') (where l and l' are lifelines and m is a message sent from l to l') by sets of diagrams involving only the lifelines included in the refinements of l and l'. Finally, each diagram in SD must be included in a diagram in SD '.

part of CD and thus, embedded by e. This may cause ill formed class rela- tions since their targets might have been removed. The well-formedness is restored in CD ' , since the loose ends of the class relations are connected to the tCD images of the deleted classes.

Proof Idea. The construction of extension and parallel extension diagrams has been discussed already above. It remains to show the properties. First of all, all embeddings preserve the type of the diagram elements and they do not change any inscriptions. Hence, they are special cases of the defined transfor-

The approach in this paper is based on an intuitive graphical representa- tion of UML diagrams. In future work we want to deal with the corresponding meta-model instances as formal abstract syntax, which would allow a much more detailed discussion of the instantiation, and we will also consider more general notions of transformations and embeddings. Moreover, it is possible to consider other UML techniques. Especially with respect to the example in Section 2 it seems sensible to include UML profiles to the components. Ontolo- gies could then be modeled as class hierarchies with respect to an ontology profile. On the other hand profiles could also be used for platform specific implementation models.

