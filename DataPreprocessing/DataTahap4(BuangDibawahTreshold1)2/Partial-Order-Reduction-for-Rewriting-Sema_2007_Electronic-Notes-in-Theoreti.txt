Flexible Dependence Relation. Although a basic dependence relation can gen- erally hold for a certain programming language, additional knowledge of the types of programs that one needs to verify can result in removing some dependencies; for example, Java supports shared memory in general, so we have to assume that memory read/write pairs are generally interdependent; but if the programs being verified do not use the shared memory at all, we can remove this dependency for such programs. Having the dependence relation as an explicit parameter of the par- tial order reduction module not only contributes to the generality of the method, but also gives the tool builder the advantage of specializing it, based on the type of input programs.

There are several existing heuristics to compute ample(s). [2] gives a set of four conditions that, if satisfied by ample(s), guarantee a correct reduction of the given state transition system. In Section 3.3, we present a special case of the conditions in [2] which are used in this paper.

In order to devise a general partial order reduction module for semantic definitions of concurrent programming languages, we have to make some basic assumptions about these semantic definitions. These assumptions are quite reasonable and do not limit in practice the class of semantic definitions that we can deal with. They simply specify a standard interface between the semantic definition module and the partial order reduction module. We can enumerate these assumptions as follows:

2 If the rule r rewrites the global state of the computation, the context Ct(.) is empty, i.e. Ct(l(u)) = l(u). We do however allow language specifications in which a rule r can be local to some fragment of the state. In this second case, it is important to make explicit a pattern Ct(.) for the context in which the rule is applied.

The partial order reduction is applied at state s, using the information in I, by means of a single operation MarkAmples. This operation takes a pair of elements of sorts MState and StateInfoSet as an input, and returns a pair of the same sort. The MarkAmples operation computes the ample set for the current state and returns the state with the ample transitions marked as specified by the POR algorithm. It also returns an updated version of StateInfoSet (see the POR algorithm part of Section 3.3). In the next section, we discuss in detail how the MarkAmples operations is specified.

As discussed above, a transition is a pair (ti, ri) of a thread identifier and a rewrite rule. We can add a third component Ik to this tuple, which includes all the informa- tion about context (i.e., names of variables, functions, locks, ...). This information can later help resolving some dependencies between the transitions, which may re- sult in fewer dependencies and possibly in a better reduction.

The most involved part of the partial order reduction algorithm is checking the conditions in [2]. Conditions C2 and C3 are exactly the same as in [2]. Condition C'1 is a stronger version (see [10]) of condition C1 from [2] (since the original C1 from the POR theory is not locally verifiable) and very similar to the variation of it in the heuristic proposed in [2]. Since the algorithm always works on nonempty sets, we are left to check three out of the four conditions. Here, we describe how the conditions are checked for a candidate set of transitions (ample set). The special case of a single transition as a candidate (as in [2]) follows from this easily.

This condition is the simplest of the three to verify. The set of propositions used in the desired property is given as an input. The check just has to go over this set, element by element, and check whether each proposition has the same truth value in state s and in its successor state with respect to all transitions in the ample candidate set.

This condition ensures that no transition is enabled over a cycle in the state transition graph and is never taken in the ample set. This condition can be easily checked when the partial order reduction algorithm is embedded in a model checker, since the stack of states being explored is available. In our case, we use exactly the same method, but we simulate part of that stack as part of the state. The second component of the new system state, StateInfoSet takes care of this. Whenever in a state s there is a transition t outside the ample set, the pair (t, s) will be stored in the StateInfoSet component. As soon as a transition is taken in some future step, the pair is removed from the StateInfoSet. If a pair (t, s) is still there when we revisit s, we know that we are closing a cycle, so we must take the transition.

As mentioned at the end of Section 3.3, to check condition C'1, the operation ThreadTransitions, which conservatively computes the set of future transitions of a thread, has to be specified by the user. In the case of Java bytecode the idea is to start from the current point in ti and add all the future instructions (transition steps) of the current method executing, and upon a method call, add in all the instructions (transitions) of the code of that method as well (avoiding repetition). This is conservative, in the sense that in the cases where more than one method

There are two well-known approaches to attack the state-explosion problem while model checking. The first approach consists of partial order methods intro- duced by Peled in [22]. The generic method proposed in this paper fits within this approach. Several different variations [14,15,25,1,12,3,18] of the POR approach have

Besides the POR methods, a second state space reduction approach, which could be called transaction-based, consists of more recent techniques that consider various kinds of exclusive access predicates for shared variables specifying some synchroniza- tion disciplines [24,13,6]. These predicates can be used to reduce the search space during the state space explorations. The POR techniques (including the method proposed in this paper) are complementary to these other methods. We discussed how our method exploits some ideas from [24] in Section 2.1. We strongly believe that the reductions in [13] can be achieved using a very similar method to that presented in this paper (see below for more details).

We have presented a general method to make software model checkers with POR capabilities language-independent, so that they can be specialized to any program- ming language L of interest. Our method is based on a theory transformation of the rewriting logic formal semantics of the given language. The language specialization can be done semi-automatically and with relatively little effort by a tool builder. Language-specific optimizations can also be added, because the heuristic algorithm

The current prototype implementation of our method does not support various well-known optimization strategies, but many of these can be incorporated into our framework in a straightforward way. These strategies are often based on as- sumptions about the structure of the programming language under consideration. Therefore, they belong to the second, language-specific customization phase of our theory transformation, although in some cases they can be applied to entire families of languages. For example, a reduction strategy proposed in [6] for concurrent ob- ject oriented software is detecting heap objects that are thread-local to sharpen the dependence relation. All the static/dynamic analysis in [6] that leads to detecting the thread locality is possible in our framework, since we have both the static and dynamic information available. A more extensive experimentation with a broader set of language instantiations and incorporating the above optimizations should be performed in the future. Furthermore, the mechanical verification of the correctness of our theory transformation along the lines of the proof sketched in [10] should be investigated.

