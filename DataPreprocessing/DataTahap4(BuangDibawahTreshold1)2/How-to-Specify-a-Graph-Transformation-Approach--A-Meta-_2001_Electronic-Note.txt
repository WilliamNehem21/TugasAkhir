In this paper, we propose the use of a meta graph grammar for the definition of such a complex graph transformation approach. A meta graph grammar is a typed graph grammar whose type graph provides a static description of the structure of graphs, rules, and transformations of the approach. This static meta model, which is comparable to the meta model in the Uml specification, is extended by a specifi- cation of the rule application operator by means of graphical embedding rules, i.e., the productions of the meta graph grammar. These embedding rules allow a concise visual description of the admissible context embeddings of a rule and of the side effects of the rule application on the context.

A graph transformation approach is formally given by its notions of graph, rule, and transformation. In addition, some approaches provide concepts like graph schemata or control structures. Usually, formal definitions of these no- tions are given in mathematical (e.g., set-theoretic, logic, algebraic, or categor- ical) terms (cf. [15] for a collection of such definitions). While mathematical definitions are an indispensable tool for the development of the theory, they are often not very useful for explaining the concepts and constructions to po- tential users, in particular, if the mathematical language has a very different nature than the approach to be defined.

A solution to this problem, which is popular for visual modeling languages like the Uml [13], is the approach of meta modeling [12]. Here, a modeling language is defined in a kind of boot-strapping process using as a meta lan- guage a simple subset of the language to be defined. (In order to avoid cyclic definitions, this subset has to be given an independent formalization.) For ex- ample, in the Uml specification [13], class diagrams and constraints are used in order to specify the abstract syntax and static semantics of the Uml. The dynamic semantics is just described in informal text.

In this paper we propose meta modeling as a technique for the specification of both the static and dynamic aspects of application-oriented graph transfor- mation approaches. Based on a Uml-like meta model defining statically the classes of graphs, rules, and transformations of the approach, a meta graph grammar is used for generating, from each rule, a class of transformations. As a case study, this technique is applied to (a subset of) the object-oriented graph transformation approach Fujaba which includes features like composi- tion, multiplicity constraints, and inheritance.

The Fujaba project [6] (see also www.fujaba.de) aims at promoting the use of graph transformation in object-oriented software development. To attract object-oriented software developers, Fujaba employs Uml collaboration di- agrams as a notation for graph rewrite rules. In addition, the Fujaba envi- ronment provides a code generator that generates a Java implementation of class diagrams and graph rewrite rules. We generate plain Java code that uses very simple implementation concepts. Graph rewrite rules are applied to usual main memory objects and employ standard Java Beans access methods for look-up and manipulation of object structures.

To-one associations are most naturally implemented by pointers. Thus, we generate a private data member of the neighbors type and set- and get- methods. The to-one end of association holds at class Robot creates a pri- vate data member Robot robot in class Good and methods setRobot and getRobot.

The implementation of to-one associations via usual pointers saves memory-space and reduces the read-access to a minimum. However, this im- plies that our implementation is not able to store more than one pointer for a given association at a certain object, not even temporarily. If, for example, a good g already belongs to a certain robot r1 and if we assign a new robot r2 to hold g by calling g.setRobot(r2), then we create a conflict in owner- ship between robots r1 and r2. One has to deal with this conflict by either rejecting the new owner or by overriding the old owner or by raising a runtime exception. In the Fujaba approach, the default behavior is to override the old owner with the new owner.

In order to guarantee the consistency of the pairs of pointers that represent a link between two objects, the write methods for the corre- sponding data members call each other, mutually. For example, method r.addToGoods(g) calls method g.setRobot(r) and vice versa. Similarly, the call r.removeFromGoods(g) results in call g.setRobot(null) and vice versa. Since the data members are private and may only be changed via their access methods, we are able to guarantee that each time a link is added to or removed from the object structure, the corresponding pair of pointers is established or removed properly. This guarantee turns usual Java object structures into a proper implementation of object-oriented graphs.

At first glance, the survival of good g3 may look strange, since intermedi- ately it became an orphan. However, in our project this semantics has proven to be very useful since it allows to deconstruct composition hierarchies and to unmount parts from their parents in order to store them separately for later reuse. In our example, the unmounted seat is directly reused for the new good g9.

To summarize, the application of graph transformation to object-oriented data models creates challenges for the semantics definition of graph rewrite rules. In particular, multiplicity constraints for associations and composition relations imply certain side effects of the creation and deletion of objects and links that need to be carefully specified. Semantic decisions like the overriding of links of to-one associations are guided by the implementation in Java and a in contrast with most other graph transformation approaches. In the following two sections, we present a formalization for the static and dynamic aspects of these non-standard features.

In this section, a meta graph grammar is used to specify, for each story pattern, the set of transformations resulting from applying the pattern to legal object- oriented graphs. The productions of this meta graph grammar generate the contexts in which the pattern can be placed. Each production describes, at the same time, the matching conditions and the effect of the transformation in the given context. The productions are presented as embedding rules like below on the left

Formally, our meta graph grammar is based on the algebraic double-pushout (DPO) approach to graph transformation [4,3] using typed graphs [2] and neg- ative application conditions [8]. The premise P and the condition T jointly form the left-hand side of a graph grammar production as shown above on the right. The right-hand side is given by the conclusion C and the typing condi- tion C, and the interface graph in the center is the intersection of the two. The application of such a production to a T G-typed graph representing a transfor- mation yields another T G-typed graph which represents a transformation with additional objects, links, or attribute instantiations. The set of all transfor- mations using a given story pattern G0 is given by all well-formed T G-typed graphs G derivable from G0 by means of the graph grammar productions. This use of embedding rules is inspired by the contextualization rules in SOS [14], like the rule for restriction in CCS [11] stating under which conditions an action can be performed in the context of the restriction operator.

The correspondence between graph transformation rules and full Uml col- laboration diagrams which describe, in addition to structural changes, the interaction between objects, is further extended in [9]. In this context very similar problems can be identified. For example, the distinction in the Uml between collaboration diagrams on the specification level and on the instance level corresponds to the one between graph transformation rules and trans- formations. Embedding rules can be a general means to specify the relation between these two levels.

