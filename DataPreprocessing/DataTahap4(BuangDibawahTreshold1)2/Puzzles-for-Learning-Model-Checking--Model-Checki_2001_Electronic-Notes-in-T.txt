In spite of the importance of the formal approach for development of a reli- able hard- and software this research domain is not well acquainted to non- professionals. In particular, many undergraduate students of departments which are closely related to further progress of computer hard- and software (i.e. pure/applied mathematics and electric/electronic engineering) consider formal methods in general to be out of scope of their interests, since they (formal methods) are

puter scientists seem non-impressive. There are several popular world-wide known journals on mathematics for students as well as for researchers (ex., The American Mathematical Monthly ). Moreover, mathematicians become more concerned by popularity of the applied mathematics among students. In particular, Society for Industrial and Applied Mathematics (SIAM) recently launched a special section on education in the SIAM Review (SIREV). As is stated in the Guidelines for SIREV Authors,

The above arguments can mislead to a conclusion that an attitude to pop- ularization of formal methods theory is negative. This conclusion is invalid of course. Really, let us just to remind International Summer Schools in Markto- berdorf and European Summer Schools in Logic, Language and Information. But let us also to remark that an auditory of these school is comparatively small (a couple of hundreds per year) and consists of graduate or postgraduate students, junior scientists or professors.

Earlier and better teaching formal methods via popular (but sound) pre- sentation of mathematical foundations of formal methods can be based on games and game-based puzzles. An educational role of games and game- based puzzles is well acknowledged in the literature on logics of knowledge in computer science. For example, in [13] a knowledge-based analysis of muddy children puzzle, synchronous attack and Byzantine agreement motivate and illustrate basic theoretical ideas and concepts. May be the main lesson which educators/researchers should learn from [13] is: for being attractive mathe- matical foundations of formal methods should be illustrated by challenging game-based examples.

Both authors were trainers of teams of undergraduates for ACM Regional programming contests. So a question how to put the puzzle for programming arose naturally. Finally a corresponding programming problem was designed and suggested to undergraduate students on training sessions. A brief form of the problem follows:

where P is a power-set operation. We write IM (p) and IM (a) instead of PM (p) and RM (a) whenever it is implicit that p and a are propositional and action variables. Models can be considered as labeled graphs with nodes and edges marked by sets of propositional and action variables respectively. For every model M = (DM , IM )a validity relation |=M between states and formulae can be defined inductively with respect to the structure of formulae. For boolean constants, propositional variables and propositional connectives semantics is defined in a standard way while we have

In accordance with proposition 3.2 this design is correct. Concrete models are quite good from pure mathematical viewpoint and an idea to implement, plug and play the above preliminary design seems to be natural. Sorry, concrete models are too large from viewpoint of computer science since amounts of possible positions and possible moves are exponential functions of N .

An importance of teaching program logics and model checking discussed above in section 2 is based on importance of model checking applications. The main area of a model-checking applications is automatic verification of hard- and software presented as finite state systems [8]. New application domains include verification of high-level software specifications [4] automatic test generation [14], etc. We suppose that in all cases a high-level reliability of model checkers is of extreme importance due to an automatic character of model checking.

Due to complexity reasons mentioned above, a polyvariant approach to reliable model checking is time, space and cost expensive. The second approach seems to be problematic also since test-generation is a non-trivial problem itself. This problem is discussed in brief in the next paragraph. As far as a formal verification is concerned, then let us point out on a recent paper [22], where an automatically generated from a proof model checker is reported. To the best of our knowledge it is the first and unique paper on formally verified model checkers. This verified model checker is an implementation on Caml of a model checking algorithm from [26], it is generated by an interactive logic framework Coq from a formally presented proof of correctness of the algorithm.

