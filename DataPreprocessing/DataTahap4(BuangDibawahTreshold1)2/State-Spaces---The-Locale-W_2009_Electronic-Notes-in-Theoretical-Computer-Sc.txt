Verification of imperative programs means reasoning about modifications of a program state. So proper representation of state spaces is crucial for the usability of a corresponding verification environment. In this paper we discuss various existing state space models under different aspects like strong typing, modularity and scalability. We also propose a variant based on the locale infrastructure of Isabelle. Thus we manage to combine the advantages of previous formulations (without suffering from their disadvantages), and gain extra flexibility in composing state space components (inherited from the modularity of locales).

This short discussion already shows that we cannot expect a single solution that fits best to all possible applications. Our particular motivation for this work was reasoning about C0 programs (a type-safe subset of C), within the Verisoft project. 4 Here the state was represented as a record in a general Hoare logic environment [20], implemented in Isabelle/HOL [17]. It turned out that the main limitation of this record representation is a lack of compositionality and scalability in the large verification tasks of Verisoft.

Lookup and update. The most basic features of a state space is the lookup and update of a variable, as they appear in programming language expressions, assertions, or in statements. To reason about a global state it is also crucial to express so-called frame conditions, the parts of a state that do not change during certain operations. Putting those aspects together we need means to access an individual variable and also its complement (all other variables).

Typing. Typed programming languages structure the program state by assigning different types to the variables. Programming language types can either be mapped to HOL types or HOL terms (e.g. as sets). If the program- ming language is type-safe and the HOL type system is expressive enough it is desirable to map the program types directly to HOL types. Thus strong typing of the underlying logic is directly employed to support verification of imperative programs.

Modularity. When composing a system from several components the ques- tion of modularity of the reasoning framework appears. Immediate composi- tionality demands a uniform representation of the state space of the different components. Otherwise intermediate steps may have to be introduced to lift a component and a property to the combined state space. If components are replicated, renaming may also become important for compositionality. E.g. consider a library for linked heap lists that regards only a next pointer for op- erations like append, reverse, etc. This basic structure may appear in various kinds of lists, like strings or queues. Then it is desirable to verify the library only once for an abstract next -field, and instantiate it later for various kinds

The different representations for integers (int ), Booleans (bool ) and arrays (value list ) are injected into the type value by the constructors Intg, Bool and Array. By modelling arrays as lists of values also nested arrays can be expressed. An example array of array of integers is Array [Array [Intg 1, Intg 2], Array [Intg 3, Intg 4]]. A drawback of this approach is that a mixed array like Array [Intg 1, Bool b] is a perfectly legal value but is typically ruled out by the type system of the programming language. This issue carries on to expressions, where we have to explicitly deal with programming language typing within HOL. Consider the simple statement x := y + 1. Such an assignment boils down to a function update in our state space. To handle the addition we somehow have to lift the HOL addition that is defined for type int to type value. There are two possibilities: project the arguments or lift the operation. Even in case of a deep embedding of the expression and statement language the evaluation function implements one of those two possibilities (or maybe a mixture of both of them).

Since the set of possible operations is made explicit by the datatype bop, the evaluation function eval can take care of typing issues and implicitly perform the projections from value. However, primitive values like 1 have to be injected into type value now. Moreover, basic properties of the operations only hold for correctly typed expressions. E.g. commutativity of addition: eval (Add , n, m) = eval (Add , m, n) only holds, if we know that both arguments are of the form Intg i. In this case we can reduce the addition on type value to the ordinary integer addition and inherit its properties. We need to insert those explicit type constraints into the assertions about the program to be able to lift the logical properties of the operations for types int or bool to type value. This basically means that we prove type safety of evaluation every time we reason about expressions. This is annoying, since for a type-safe programming language this can be shown once and for all.

projections and injections cancel each other in individual programs. E.g. if variable i is supposed to store an int, every update introduces the constructor Intg and a lookup (as it may appear in an assertion) uses the corresponding destructor the-Intg, but not the-Bool etc. The abstraction level on which assertions are formulated is the-Intg (s i ) and not something like s i = Intg

n. This uniform view on a state as holding atomic entities in the projected form the-Intg (s i ) avoids implicit type constraints that would have to be discharged later. This is exactly the same view as provided by the other state space representations discussed below.

The restriction to one common universal type of values is another (the- oretical) burden. We need to know in advance which values are embedded. This contradicts the very idea of truly modular development of components. However, as long as all the different values of the programming language can be embedded into an inductive datatype once and for all, this is not a practical issue.

Poor compositionality is also caused by the lack of a uniform state for all components. If we attempt to combine two components we can first build the Cartesian product of the underlying state spaces and try to rerun the old proofs. However, this will only work if the variable names occurring in the proofs are distinct to begin with. Elsewise we could try to come up with a calculus for composition, that lifts components to the Cartesian products.

Records are similar to tuples, but additionally allow us to give proper names to variables. They were proposed by Wenzel [23] as state space representation and successfully used by Prensa [19] for the verification of parallel programs and by Paulson [18] for the formalisation of UNITY. Records enhance tuples by supplying selection and update functions for each constituent. For example,

a calculus for record composition, by defining an operator that transforms the state space by lifting all operations and assertions from a component state to the compound state. This approach is implemented and elaborated for a Hoare logic [20], but it gets technically tedious to implement in the tool and is rather heavyweight. Paulson [18] has developed a theory of program composition for UNITY, experiencing similar inconveniences.

Scalability of records is better than for raw tuples. By using lookup and up- date functions the record is not explicitly split in every expression. Moreover, the representing type for records may be grouped according to the structure of record extensions, not individual record fields. This reduces the number of nested tuple constructions. However, the 2008/2009 version of the record package in Isabelle/HOL still decomposes records internally to prove some auxiliary theorems, e.g. in the simplification procedure that proves that an update of a field x does not affect the value of another field y. Hence the performance of records also suffers from their size. In Isabelle/HOL records are defined as an abstraction on tuples nested to the right. Better results may be achieved by balanced nesting of tuples as a binary tree, as for example implemented in HOL4. 5

Apart from such purely logical assumptions and conclusions, the context may also hold additional non-logical information (type constraints, concrete syntax, hints for proof tools etc.). Thus the content of a context may be understood as arbitrary data that is abstracted over logical entities (types, terms, theorems).

Locale expressions [3] compose existing locales via merge and rename op- erations. Multiple inheritance between locales can be expressed here. A new locale definition may add assumptions to a locale expression. Locale inter- pretation [4] transfers results stemming from one locale into another context. Interpretation works between locales, within a proof body, or at the outer theory level.

This specification of procedures on heap lists follows Mehta and Nipkow [14]. From the pointer structure in the heap we (relationally) abstract to HOL lists of references. The predicate List p next Ps expresses that we obtain the (HOL) list of references Ps by starting at reference p and following the next heap.

We can now use ordinary locale operations to merge and rename locales to create two instances of the list reversal procedure. One for strings, named RevS and one for queues named RevQ. The only thing we have to do is to rename the next component and the procedure name accordingly. This can be done with the following locale operations (new parameters are listed after for):

The aforementioned procedures command ensures, that any procedure using one of the procedures RevS or RevQ imports the locales RevS-impl or RevQ-impl, respectively. Within this setup both instances of the procedure specification are immediately available for the further program verification. E.g.

Our approach of representing state spaces for imperative programs is a com- bination of basic logical concepts with an extra-logical layer for type-checking and notation. The latter is based on existing locale infrastructure in Isabelle, which happily supports arbitrary declarations in proof contexts (such as pro- gram variables with their types). This careful arrangement in different layers allows to return to a simple logical model of states spaces as functions (as already seen in early experiments in HOL and in informal mathematics).

tomatically by our syntax layer. We did not need to consider the more complex notion of dependent function types, which are beyond HOL anyway. Instead, the Isabelle infrastructure is able to support a kind of user space type system outside the logic.

