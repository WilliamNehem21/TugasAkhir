We also present a more e ective methodology which is based on abstract inter- pretation. By approximating the intended speci cation of the success set we derive a nitely terminating debugging method, which can be used statically. Our fra- mework is parametric w.r.t. to the chosen approximation of the success set. We present one speci c example of approximation. We provide an implementation of our debugging system which shows experimentally on a wide set of benchmarks that we are able to nd some common errors in the user programs.

semantics of R. In Section 6, we present our method of abstract diagnosis and illustrate its use through examples. In Section 7, we present an experi- mental evaluation of the method on a set of benchmarks. Section 8 concludes and discusses some related work.

no confusion can arise, we omit the subscript R. A term s is a normal form, if there is no term t with s !R t. The program R is said to be canonical if the binary one-step rewriting relation !R de ned by R is noetherian and con uent [34].

Since unrestricted narrowing has quite a large search space, several strategies to control the selection of redexes have been developed. A narrowing strategy (or position constraint) is any well-de ned criterion which obtains a smaller search space by permitting narrowing to reduce only some chosen positions. A narrowing strategy ' can be formalized as a mapping that assigns a subset '(g) of O(g) to every goal g (di erent from >) such that, for all u 2 '(g), the goal g is narrowable at position u. An important property of a narrowing strategy ' is completeness, meaning that the narrowing constrained by ' is still complete. There is an inherited tradeo coming from functional programming, between the bene ts of outside-in evaluation of orthogonal, nonterminating rules and those of inner or eager evaluation with terminating, non orthogonal rules. A survey of results about the completeness of narrowing strategies can be found in [4,21,22,29]. To simplify our notation, we let IR' denote the class of CTRS's which satisfy the conditions for the completeness of the narrowing strategy '.

We let inn(g) (resp. out(g)) denote the narrowing strategy which assigns the position p of the leftmost-innermost (resp. leftmost-outermost) narrowing redex of g to the goal g. 6 We formulate a conditional narrower with strategy ', ' 2 finn; outg, as the smallest relation ;' satisfying

6 An innermost term is an operation applied to constructor terms, i.e., a term of the form f (d1;::: ; dk ), where f 2 F and for all i = 1;::: ; k, di 2 (C [ V ). The leftmost-innermost position of g is the leftmost position of g which points to an innermost subterm. A position p is leftmost-outermost in a set of positions O if there is no p0 2 O with p0 pre x of p, or p0 = q:i:q0 and p = q:j:q00 and i < j.

! f(x)g. According to De nition 3.4, Fca (R) = f0 = 0; s(x) = s(x); g(x) = 0; f(0) = 0; f(s(0)) = 0;::: ; f(sn (0)) = 0;:: :g. Given the goal g  (y = f(z)), innermost narrowing computes the answers ffy=0; z=0g; fy=0; z=s(0)g;

Example 3.8 Now consider the program R = ffrom(x) ! [xjfrom(s(x))]; first([xjy]) ! xg. According to De nition 3.4, Fca (R) = fs(x)  s(x); from(x) = ?; from(x) = [xj?];:::; from(x) = [xj[s(x)j ::: [sn (x)j?]]];::: ; first(x) = ?; first([xjy]) = xg, with n 2 !. Given the goal g  (first (from(s(x)))  z), outermost narrowing only computes the answer fz=s(x)g in R, which is also the only substitution which can be computed by unifying the at goal (first(y) = w; from(s(x)) = y; w  z) in Fca (R).

The theory of abstract interpretation [18] provides a formal framework for de- veloping advanced data- ow analysis tools. Abstract interpretation formalizes the idea of `approximate computation' in which computation is performed with descriptions of data rather than with the data itself. The semantics operators are then replaced by abstract operators which are shown to `safely' approxi- mate the standard ones. In this section, starting from the  xpoint semantics

Roughly speaking, the special symbol ] introduced in the abstract domains represents any concrete term. The behaviour of the symbol ] from a program- ming viewpoint resembles that of an \anonymous" variable in Prolog. From the viewpoint of logic, ] stands for an existentially quanti ed variable [2,37,38]. De ne [[S]] = S0, where the n-tuple of occurrences of ] in S is replaced by an n-tuple of existentially quanti ed fresh variables in S0.

De nition 5.2 An abstract substitution is a set of the form fx1=t1;::: ; xn=tng where, for each i = 1;::: ; n, xi is a distinct variable in V not occurring in any of the terms t1;::: ; tn and ti 2 ( [ V [ f]g). The ordering on ab- stract substitutions is given by logical implication: let ;  2 Sub],    i [[ ]] ) [[ ]].

De nition 5.5 (abstract rule) Let R be a program and let r = ( ! ( C) 2 R. Let GR be a loop-check for R. We de ne the abstraction of r as follows: r] = ( ! sh( ; GR) ( sh(C; GR)) where the shell sh(x; G) of an expression x according to a loop-check G is de ned inductively

From a semantics viewpoint, given a program R, the xpoint semantics F(R) (resp. Fca(R)) is approximated by the corresponding abstract xpoint semantics F](R) (resp. Fca](R)). That is, we can compute an abstract appro- ximation of the concrete semantics in a nite number of steps. The correctness of the abstract xpoint semantics with respect to the concrete semantics is proved by the following:

Theorem 5.13 (strong completeness)  Let R be a program in IR' and ( g be a non{trivial goal. If is a computed answer substitution for ( g in R, then there exists g0  e1;::: ; em << Fca](R) such that 0 = mgu](f lat(g); g0) and 0  .

In the following, by abuse we let I denote the program that speci es the intended semantics. In the following, we consider I+ = lf p(T ]), i.e. we consider the abstract success set that we have de ned in previous section as overapproximation of the success set of a program. We can consider any of the sets de ned in the works of [11,16] as underapproximation of I. Alternatively, we can simply take the set which results from a nite number of iterations of the TI function (the concrete operator). Let us illustrate this method.

Then the errors are automatically found by the debugger and the user has to indicate the corrections to be made on the wrong rules. The Buggy system is written in SICStus Prolog v3.8.1 and the complete implementation consists of about 300 clauses (1260 lines of code). The debugger is expressed by	147

[12] R. Caballero-Rold an, F.J. Lopez-Fraguas, and M. Rodr quez Artalejo. Theoretical Foundations for the Declarative Debugging of Lazy Functional Logic Programs. In Fifth International Symposium on Functional and Logic Programming, Lecture Notes in Computer Science. Springer-Verlag, Berlin, 2001. To appear.

