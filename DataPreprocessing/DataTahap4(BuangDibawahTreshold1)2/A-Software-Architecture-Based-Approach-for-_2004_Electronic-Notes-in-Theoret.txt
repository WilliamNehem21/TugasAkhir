The number of open specifications of middleware systems and middleware services is increasing. Despite their complexity, they are traditionally described through APIs (the operation signatures) and informal prose (the behaviour). This fact often leads to ambiguities and makes difficult a better understanding of what is really described. In this paper, we adopt software architecture principles for structuring middleware together the LOTOS language for formalising their behaviour. The adoption of software architecture principles makes explicit structural aspects of the middleware. Meanwhile, the formalisation enables us to check behavioural properties of the middleware. In order to illustrate our approach, we present a LOTOS specification of the well-known object-oriented middleware CORBA and its transaction service.

In this context, we present an approach that uses software architecture principles for structuring middleware systems. In the meantime, we propose the adoption of LOTOS [1] for specifying the behaviour of those software architectures. Initially, the middleware architecture is defined in terms of software architecture elements such as components and connectors. Next, the LOTOS language is used as an ADL (Architecture Description Language) [14], in which the middleware behaviour is formally described. It is worth observing that we are not interested in any particular middleware product or middleware model.

Formal description techniques have been used together middleware in the RM-ODP, in which the trader service is formally specified in LOTOS. Most recently, the Z notation and high level Petri nets have been adopted for spec- ifying CORBA services [4], the Naming service [11], the Event service [5] and the Security service [3]. All those works, however, do not adopt software archi- tecture principles for structuring the service descriptions. In terms of software architecture, a few ADLs include the possibility of describing behaviour, like Wright [2]. However, there are not tools that enables us to check behaviour properties. Medvidovic [13] has observed the convergence of middleware and software architecture principles. However, he does adopt a formal approach. Finally, it is possible to note that the software architecture principles are widely adopted to build distributed applications (client and servers), but its benefits are rarely applied to middleware that connect them.

This paper is organised as following: Section 2 presents how the middle- ware architecture is defined in terms of software architecture elements. Next, Section 3 presents the use of LOTOS for describing the middleware software architecture. In Section 4, we adopt our approach for specifying CORBA. Fi- nally, the last section presents the conclusions and some directions for future work.

Each service provided by the middleware (e.g., security, event) defines a component in the abstract software architecture, except the communica- tion service, which is modelled as a connector. Meanwhile, according to software architecture principles, a connector must always exist between any two components (service);

By observing those guidelines, some points have to be taken in account. Firstly, since middleware systems do not perform any application-specific com- putation, they are naturally modelled as connectors. Secondly, the middleware provides further services in addition to the communication one. Hence, the

middleware may not be only considered as a simple connector. In the software architecture discipline, however, only components (no connectors) are tradi- tionally decomposed into smaller elements. Finally, it is worth observing that the communication service enables other services (components) and applica- tions to interact. Hence, it is also naturally differentiated from other services and modelled as a connector.

A LOTOS specification describes a system through a hierarchy of active com- ponents, or processes. A process is an entity able to realize non-observable internal actions, and also interact with others processes through externally observable actions. The unit of atomic interaction among processes is called an event. Events correspond to a synchronous communication that may occur among processes able to interact with one another. Events are atomic, in the sense that they happen instantaneously and are not time consuming. The point of an event interaction occurs is known as a port. Such event may or may not actually involve the exchange of values. A non-observable action is referred to as an internal action or internal event. A process has a finite set of ports that can be shared.

According to Section 2, the definition of the middleware concrete software architecture consists of explicitly decomposing the middleware services into the client and server parts. The client part is the middleware service interface (remotely accessible), whilst the server part is the implementation of the service itself. As mentioned in Section 3.1, unlike other services, the communication service is a connector and it is not designed using this client/server approach. Hence, the same commu- nication services run in both sides of the architecture. The LOTOS specification of the concrete software architecture at top-level is shown in the following:

CORBA [16] is a standard that has been widely adopted for implementing middleware prod- ucts. According to the CORBA specification, in addition to the communication service known as ORB, fourteen distributed services should be provided by the middleware: persistence, external- isation, events, transactions, properties, concurrency, relationships, time, licensing, trader, query, collections, lifecycle and security [15]. All these services are not usually implemented in a single product, but at least the naming, life cycle and communication services are available in CORBA complaint products.

As defined in Section 3.2, the LOTOS process ServiceOrdering is not an architectural compo- nent, but it is defined in order to constrain the way the services interact. In this particular case, the most important ordering constraint is one related to the naming service (process Naming). As widely known, every distributed service must be registered in the naming before be used by clients

According to the COS Transaction specification [15], the transaction service is specified through 6 interfaces, namely Current, TransactionFactory, Terminator, Coordinator, RecoveryCoordinator and Resource. These interfaces allow multiple, distributed objects to cooperate to provide atomic- ity, consistency, isolation and durability properties. Each interface is modelled by a component in the software architecture.

For lack of space, we only present the concrete software architecture of the CORBA transac- tion service. The top specification is very similar to one shown in Section 3.3 that is a parallel composition of ServiceInterface and StateProc. The process ServiceInterface models the interfaces of the transaction service, which is made up of is 6 other interface as mentioned before: Current, TransactionFactory, Terminator, Coordinator, RecoveryCoordinator and Resource.

The adoption of LOTOS for describing the middleware enables us to check behaviour prop- erties (we have used the CADP Toolbox) of each individual middleware and middleware service specification. This is not possible in the case an ADL is adopted instead LOTOS. We know that LOTOS has not been originally designed to be used like an ADL. Its main limitations include lack of proper abstractions to model component, connector and interface, and the language does not allow to define architectural styles. However, its limitations are compensated by its powerful ability for describing behaviour and availability of tools.

