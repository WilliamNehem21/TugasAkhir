We present a low-level specification language used for describing real Internet security protocols. Specifications are automatically generated by a compiler, from TLA-based high-level descriptions of the protocols. The results are rule-based programs containing all the information needed for either implementing the protocols, or verifying some security properties. This approach has already been applied to several well-known Internet security protocols, and the generated programs have been successfully used for finding some attacks.

There has been a significant amount of work toward the specification of security protocols in the recent years [25,1,19,7,21,13]. However, a large part of this work, including our own, is applied only to toy protocols in the Alice&Bob notation, i.e. as a linear scenario describing the messages exchanged.

Our main goal is to successfully handle complex protocols such as those under discussion at the IETF [20]. To this end, a new High-Level Proto- col Specification Language (HLPSL) was developed in the AVISPA project, having in mind the constructions often found in the specification of these pro- tocols [9]. We have written a compiler transforming a protocol specification in this language to a set of rewrite rules. We present in this article not the compiler itself, but the encoding of high-level properties in rewrite rules. We believe that rule-based systems are a natural framework to encode the prop- erties encountered when studying cryptographic protocols.

Studying security protocols is a very important domain nowadays. This is often done in a three steps process. First, protocols are specified in a high- level, easily understandable language. Then, this specification is analyzed to ensure that there are no trivial errors. If no flaws are found, the protocol is verified in a time-consuming last step. We are interested in this paper in the

These objectives are motivated by the fact that protocols specifications have to be used as documentations: in general, protocols are described in long documents (for example provided by the IETF); this makes them diffi- cult to understand, and may lead to different interpretations according to the objectives of the reader (to implement the protocol, to verify it, or simply to understand it). Moreover, the underlying scientific foundations have to be clear in a protocol specification. This is very important for knowing if the protocol is easy to implement or not.

We will illustrate our new specification language [9] with the well-known Need- ham and Schroeder Public Key (NSPK) protocol. This example is usually considered as very simple and far away from real protocols. But the version that can be seen in most papers is a simplified one. Our aim being to consider all the options that may rise during the execution of a protocol, we will con- sider a more complex variant of the NSPK protocol: the NSPK Key Server (NSPK-KS). This protocol is given as follows, using an Alice&Bob-based no- tation:

A transition is a change of state, primed variables representing the values of the variables in the next state. So primed variables can be assigned in the right-hand side of transitions. However, if the new value of a variable is learned in the left-hand side of a transition (in a received message, in a comparison, or in a set expression, for examples), then its primed name is used (see for example step0 of role Server).

Specifications of protocols are compiled into a rule-based program. During this compilation phase, the syntax and the semantics of the initial specification are verified. If some goals are specified, the compiler can either generate one program containing all the properties to be checked, or it can generate one program for each goal.

The high-level specification of a protocol is mainly a list of roles of two kinds: basic roles, each one representing the behavior of a participant; com- posed roles, describing the environment of the basic roles, i.e. how to compose them and which instantiations to consider.

However, in the current version of the compiler, only one kind of channels is considered: channel on which the Dolev-Yao model of the intruder is ap- plied. So, for avoiding useless complex notation in the generated rules, all sent messages are directly added to the knowledge of the intruder (iknows(... )).

The generated program contains a section with the signature of each role state primitive, representing the internal data structure of the role. Note that the first argument of a role state is the name of its player. This information may be useful for tools that have to use this program, in particular if they want to manage the knowledge of the agents.

In the example given above, only constants are used. However, in the high- level specification, variables can be used for describing that some information is shared by several role states. For example, a will play twice the role Alice, and a variable could have been used for storing its key set. The translation of this in the initialization section would have been to used only one constant instead of local 104 and local 116.

In both transitions, the old state contains some variables named Dummy Kb, for example. Such variables capture the old value of the corresponding vari- able (e.g. Kb) when either a new value will be assigned in the new state (e.g. in step 3), or when the name of this variable has to be used in the transition without considering its value (e.g. in step 2).

In order to assess the compilation process, we have built a list of protocols from various sources. The aim here is to demonstrate that our compiler is able to handle a wide variety of protocols, known as important in different areas. We have selected both low-level protocols, such as TLS, as well as high-level ones, such as UMTS-AKA. There are also protocols already recommended by the IETF as well as protocols still under work.

We also work, in conjunction with Siemens, on the analysis of protocols under development. Among these, we have already analyzed the AAA Mo- bileIP protocol, which is a sub-protocol of Mobile IP. See [18] for a description of the protocol its goal. Note that the Mobile IP protocol is a collection of protocols in development since 1998. We hope to contribute to this develop- ment by speeding up part of its analysis. We have also analyzed the IKEv2 main protocol.

The compiler described is written in OCaml and documented with OCaml- Web (140 pages). It has been defined for the AVISPA project, for considering real industrial Internet security protocols. The first experiments generate very good results, so we are going to continue its development for being able to han- dle even more protocols. This is a considerable improvement compared to the first compiler that was realized for the AVISS project [2], where only simple protocols could be considered [12].

Comparing MuCAPSL with our specification language, this is clear that Mu- CAPSL offers many more data structures, primitives and instructions. How- ever, it is unclear how to specify that some roles share some information, or how many instances of a role are created, since there is no environment role and roles do not have parameters. In addition, with our language, the transitions are guarded and are not ordered: their application is not deter- ministic, and transitions can be applied several times if possible; this is not the case with MuCAPSL. So, this is not clear how the example given in this paper, NSPK Key Server, could be specified in MuCAPSL. About properties

For concluding, MuCAPSL-MuCIL and our compiler have both their own advantages, and if our specification language is more simple, this is because we have designed it with the objective to provide it to industrial partners. It is powerful enough for specifying rather easily most of the Internet security protocols. And the aim of our compiler is to provide rule-based specifications of protocols to industrials for helping them to implement the protocols that they design, and also for verifying those protocols, by plugging any kind of verification tool, as it has already been done with AVISPA for three very different tools.

