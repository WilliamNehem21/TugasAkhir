Collecting metadata on a family of programs is useful not only for generating statistical data on the programs but also for future re-engineering and reuse purposes. In this paper we discuss an industrial case where a project library is used to store visual programs and a database to store the metadata on these programs. The visual language in question is a domain-specific language, Function Block Language (FBL) that is used in Metso Automation for writing automation control programs. For reuse, program analysis and re-engineering activities and various data and program analysis methods are applied to study the FBL programs. Metadata stored in a database is used to provide advanced program analysis support; from the large amount of programs, the metadata allows focusing the analysis to certain kinds of programs. In this paper, we discuss the role and usage of the metadata in program analysis techniques applied to FBL programs.

The largest portions of software life-cycle costs are due to maintenance activ- ities [2,5,9]. Various reverse engineering techniques can be used to support software comprehension and visualization that, in turn, support maintenance. If available, metadata on the programs can be used to guide the reverse engi- neering and visualization activities. In this paper, we discuss metadata-driven program analysis techniques used for maintaining visual programs.

A visual language manipulates visual information, supports visual inter- action, or allows programming with visual expressions [4]. Further, visual programming languages can be defined as languages for programming using visual expressions [3]. The visual programming language under study, called Function Block Language (FBL), is a domain-specific language used at Metso since 1988. FBL is used in paper machine controls, power plants, and marine automation and in other various continuous real-time control systems.

Along the years, the language itself has been modified and further de- veloped. The programs written are stored in project library archives. In the storing process metadata is read from the programs and stored into the database. Metadata is used as search conditions, according to which desired programs can be downloaded from local project libraries. For instance, the engineer can look for existing solutions that could be reused for his current purposes. Stored programs and metadata together allow detailed analysis of programs themselves, relations of different programs, and statistical reports on the usage of FBL. Due to the analysis techniques developed and the syn- tax of the language, high reusability of programs and their parts have been achieved. The reverse engineering and visualization techniques are discussed in [8] in more detail. In this paper we focus on the metadata itself, describe the role of meta-models used for particular problem domains, discuss the iter- ative design process, and show statistical data collected on FBL usage along the years.

We first give a brief overview to FBL and discuss the language meta-models and their role in Section 2. We then present and discuss metadata-driven methods used for designing, maintaining, and reverse engineering FBL pro- grams in Section 3. These benefits include, e.g., high reusability and improved program quality. The metrics used and types of metadata collected to sup- port program analysis are introduced in Section 4. We also give some details of metadata statistics and discuss the benefits of using metadata to support program analysis activities. Finally, concluding remarks are given in Section 5.

With FBL, engineers can design visual programs that connect physical elec- trical measurement signals to program parameters. Those parameters are referenced by symbols containing other values needed as attributes. By con- necting these symbols the engineer can create algorithms to control and run actuators, such as valves, motors, and pumps, in the process.

The visual notation of FBL consists of symbols and lines connecting sym- bols. In FBL, symbols represent advanced functions. The core symbols of FBL, function blocks, are subroutines running specific functions to control a process. A simple example could contain an input symbol to read a water level measurement. That input symbol could be connected to a function block symbol representing a subroutine for calculating and keeping the level. Then the function block symbol is connected to an output symbol that will modify a control valve position.

FBL user interface domain is defined by those graphical objects that are needed to implement a visual language. The FBL itself is not a meta-language, but the symbols used contain enough meta-information to define new function block skeletons. This feature is especially useful for mapping the problem and solution domains. Namely, the real physical world with devices, e.g. pumps and valves, of the problem domain can be represented as appropriate graphical objects in the solution domain, i.e., in FBL programs. This is also useful when explaining the solutions to the customer: the solutions are easy to understand since they use familiar symbols.

Clustering in traditional reverse engineering methods can be constructed, for instance, by taking advantage of the syntax of the programming language used, using software product metrics to identify highly cohesive clusters, or using existing software architecture models and mapping them with the lower level details. Software product metrics used for identifying subsystems typ- ically measure inter couplings and intra cohesion of the sets of software ele- ments. In the approach presented in the paper, the syntax of the language is used to construct high-level models for the programs. This together with the usage of metadata stored and metrics values calculated form the basis for the program analysis techniques to be discussed next.

The design process involves multiple domains. The problem domain is the real physical world with devices, e.g. pumps, valves, temperature / flow mea- surements etc., which are modeled in a solution domain with FBL language. The FBL diagrams (FBL programs) designed and constructed by the engineer can be further connected to each other. The diagrams that belong together in a solution space are also close to each other in the real world as devices. So, the solution directly reflects the real world situation.

For generating an abstract view from Function Block Diagram, the de- tails of the program are filtered out and only the input and output symbols are preserved. The abstracted program is called Function Group, indicating that one symbol contains several functions (Function Blocks and IOs). A pro- gram visualization function creates new symbols on the fly for each abstracted component. To compare existing solutions, the engineers need few function groups to get the main idea of the principles used in solution.

When re-engineering programs, existing program instances can be changed by extending or modifying them. For instance, new function blocks can be added, parameter values of existing programs can be changed, and connections between function groups can be changed. The engineer can thus create new programs that were first extracted from the database using reverse engineering techniques.

For increasing the degree of reuse and thus decreasing the development times, reusing existing function groups instead of modifying individual pro- grams is preferred. This assumes that the existing function groups are general enough to be usable in various programs. In many cases, the structure of the program itself is reusable but the differences occur in parameter values. For enabling reuse in such cases, a concept of a template has been introduced to FBL. Templates are ready-made programs without instance values. They can be used by external module symbols. In other words, templates describe in- dividual parts of process control software, without project specific definitions. Actual application instances are created when project specific data is com- bined with a template. For a template, the environment generates a program according to given parameter values.

change Format) in a directory structure corresponding to the project s process hierarchy. These archives are accessible for project engineers by a web inter- face. These detached project libraries are then bound under a single content management entity. The centralized content management solution stores only the essential application metadata to a content management server and allows the archived files to remain in local project libraries. The stored metadata in- cludes also links to actual application solution files.

Project library archives and a database used to store FBL programs together with metadata allow the extraction of various kinds of statistical data of the programs. When extracting and storing metadata from a particular FBL program, a special program is used. The metadata stored is used as search conditions, according to which desired programs can be downloaded from local project libraries. For instance, the user can look for exact solutions using a specific tool by defining criteria to match a description or a primary function block. Navigating in a process hierarchy is also a way to search FBL programs. This is a common way to find similar problems and existing solutions. All the information that is used in a search / navigation is based on metadata. Metadata includes: a description of the FBL program, a process hierarchy it belongs to, parameters used, and primary function block and I/O types.

A rough estimate for the project complexity metric is calculated as an average: number of function blocks divided by the number of I/O connections. When analyzing traditional programming languages, a metric Lines of Code (LOC) is often used. A corresponding metrics used when analyzing FBL programs is Number Of Entities (NOE), where an entity is a symbol, text, a line, or any other graphical object in the diagram.

Even though a lot of metadata is stored on each FBL program, its amount is relatively small compared to the amount of programs (diagrams). As an example, information that is archived is currently roughly from 200 projects. There are about 40 Gb of compressed diagrams, while the amount of metadata is only about 850 Mb. Typically, the access rate is about 2000 searches in a month.

As an example scenario, the engineer can give conditions like description and process area to find certain type of solutions. As a result, he might get a list of a couple of hundreds of diagrams. By using the information provided in this list and other more detailed metadata on the programs, the user can further focus the search to limit matching results. The user can also quickly view the actual visual programs.

Special tools implemented by Karaila and his engineering group support another, less user-dependent way to use metadata to find programs that could be reused. These tools analyze implemented FBL programs. The tools look for basic program structures that are used multiple times in different FBL programs and use the following metadata in its matching algorithm: entity count of a FBL program, primary function block count, and function block count. This is used as a fingerprint to make first level matching faster and easier. The second level is more detailed and makes the actual comparison between the FBL programs.

Calculations are based on metadata stored in the database. Summary groups are sums of loop types and primary function blocks. Project analysis window shows an average number of different IO types from diagrams and the total amount of each IO type. This information can be used to estimate the scope of similar projects. Entity and function block counts and averages give an estimate of the capacity needed (memory and load). Finally, complexity is used later to analyze the project working hours. When selling a new project with similar process & devices, the complexity value can be checked to ensure we should allocate the right amount of hardware (devices) in that kind of project.

In small scale projects templates are used heavily but the same templates appear only few times. Namely, there are a lot of templates that are used only few times. In bigger projects, however, same templates are reused more often. The statistical values show that in 2000 diagram instances there are over 400 templates and a bit over 10% hand-made instances where templates have not been used. Most of the hand-made instances are not FBL-based diagrams. Instead, they are other needed instances, for example user interface modules and diagnostic modules that are not implemented with FBL. Thus, the templates are heavily used in practice.

In this paper we have discussed metadata-driven program analysis techniques used to support re-engineering and reuse of visual FBL programs. FBL is a domain-specific language used in automation industry. FBL is used e.g. in paper machine controls, power plants, and marine automation and in other various continuous real-time control systems. We have especially discussed the role and usage of metadata, characterized the design process, and discussed some statistical values collected on FBL usage along the years.

The core of FBL was implemented in the late 1980s. The software quality and usability has been improved based on internal measurements carried out at Metso and based on feedback from satisfied customers. In the programming environment, there has been a steady evolution and a desire to improve it. Lessons learnt from the long history of using FBL have guided the development of the program analysis techniques and especially helped the FBL environment developers to conclude what kind of metadata is needed and useful for program analysis, reuse, and re-engineering purposes.

As a part of our future work we aim at further studying the role of FBL meta-models, especially the domain models. The metadata-driven program analysis techniques could be improved if there was a semantic relation be- tween the metadata and the meta-models, namely, if metadata with semantic meaning could be used. This means that information from the real world would be tied with existing metadata. This semantic information could help us e.g. in the problem of recognizing a template for a device automatically.

