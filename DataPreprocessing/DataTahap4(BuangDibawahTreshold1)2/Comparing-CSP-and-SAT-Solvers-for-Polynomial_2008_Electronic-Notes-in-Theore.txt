Proofs of termination in term rewriting involve solving constraints between terms coming from (parts of) the rules of the term rewriting system. A common way to deal with such constraints in termination tools is treating them as polynomial constraints. Several recent works develop connections between these problems and more standard constraint solving problems for which well-known and efficient techniques apply. In particular, SAT techniques are receiving increasing attention in the field. The main idea is encoding polynomial constraints as propositional constraints which can (hopefully) be efficiently managed by using state-of-the-art SAT solvers. We have recently developed an algorithm for solving constraints in finite (small) domains of coefficients which are appropriate for termination tools. This algorithm benefits from the use of a specialized representation of the elements in the domain and the corresponding polynomials which permits using efficient arithmetics and constraint propagation techniques. In this paper we discuss these approaches, compare them from an experimental point of view, and point to possible improvements.

The dependency pairs conform a new TRS DP( ) which (together with ) deter- mines the so-called dependency chains. The absence of infinite dependency chains characterize termination of . The dependency pairs can be presented as a depen- dency graph (DG), where the absence of infinite chains can be analyzed by consid- ering the cycles in the graph.

Example 1.3 Consider the TRS  in Example 1.1 and the cycle C = 6 (see Example 1.2): QUOT(s(x),s(y)) -> QUOT(minus(x,y),s(y)). In order to prove termination of we have to find a reduction pair ( , >) which satisfies the following constraints:

Note that the variables which have to be solved here are the coefficients of the parametric polynomials in Example 1.4. The previous set of constraints is sound regarding DG-based termination proofs (i.e., its satisfaction implies that the cycle is harmless) provided that all such variables/parametric coefficients take non-negative values, see [4,15] for a justification of this claim.

numbers 4 [16]. Rational, integer, and natural numbers are well-known examples of real algebraic numbers. In practice, all termination tools restrict (as default or unique option) the usable coefficients to small domains like  0, 1 ,  0, 1, 2 , or 0, 1 , 1, 2 . In [16] we have proposed an efficient algorithm for solving polynomial constraints over small domains of powers of 2. Note that the aforementioned small (and widely used) domains of coefficients are covered by the algorithm. The al- gorithm efficiently handles polynomial expressions involving numbers having quite

When considering polynomial constraints over N1, the arithmetics on N1 become very close to boolean operations when 0 is interpreted as False and 1 as True, respectively. In particular, the product of values in N1 correspond to conjunction. Following this intuition, we have developed a simple encoding of polynomial con- straints as propositional formulas.

We have developed an efficient encoding of polynomial constraints over N1 = 0, 1 as propositional formulas which (in our benchmarks) is almost four times faster than the recent SAT-based algorithm by Fuhs et al. [5] when applied to solve poly- nomial constraints over N1. We have also generalized the algorithm in [16] to deal with arbitrary non-negative numbers. We have investigated the use of different constraint-solving algorithms for the efficient generation of polynomial interpreta- tions in termination provers. We have considered CSP-based solvers like the ones described in [4,16] and SAT-based solvers like the recent proposal in [5] and the new one introduced in this paper. We have implemented or connected (implementations of) the different algorithms as part of the tool mu-term.

The benchmarks for mu-term-SD (and even for mu-term-GSD) suggest that, in comparison to similar polynomial constraint solvers like the one reported in [4], it performs quite well. But the algorithm described in [16] can still benefit from some usual heuristics coming from the CSP area which have not been considered yet. Also, the SAT-encodings discussed here (both our new proposal in Section 3.2 and also [5]) do not take into account more sophisticated SAT frameworks like SMT (SAT modulo theories, see, e.g., [17]) which seem to be a natural choice for polynomial constraints. Furthermore, since the main goal of the algorithm in [16] is providing an efficient way to deal with polynomial constraints over rational (or even real algebraic) numbers, an interesting open problem is how to encode polynomial constraints over such more general domains using SAT/SMT techniques. These are interesting subjects for future work.

