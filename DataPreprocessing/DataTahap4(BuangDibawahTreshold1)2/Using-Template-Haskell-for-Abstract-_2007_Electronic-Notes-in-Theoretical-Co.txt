Metaprogramming consists of writing programs that generate or manipulate other programs. Template Haskell is a recent extension of Haskell, currently implemented in the Glasgow Haskell Compiler, giving support to metaprogramming at compile time. Our aim is to apply these facilities in order to statically analyse programs and transform them at compile time. In this paper we use Template Haskell to implement an abstract interpretation based strictness analysis and a let-to-case transformation that uses the results of the analysis. This work shows the advantages and disadvantages of the tool in order to incorporate new analyses and transformations into the compiler without modifying it.

Metaprogramming consists of writing programs that generate or manipulate other programs. Template Haskell [17,18] is a recent extension of Haskell, currently im- plemented in the Glasgow Haskell Compiler [12] (GHC 6.4.1), giving support to metaprogramming at compile time. Its functionality is obtained from the library package Language.Haskell.TH. It has been shown to be a useful tool for different purposes [6], like program transformations [7] or the definition of an interface for

In this paper we explore the usefulness of Template Haskell for these purposes by implementing an abstract interpretation based strictness analysis and a let-to- case transformation that uses the results of the analysis. These are well-known and already solved problems, which allows us to concentrate on the problems arising from the tool. In Section 2 we describe those features of Template Haskell used in later sections. In Section 3 we give an introduction to abstract interpretation, and describe the strictness analysis and the let-to-case transformation. Section 4 describes their implementation using Template Haskell and shows some examples. Finally, in Section 5 we conclude and discuss the improvements to the tool that could make it more useful.

Template Haskell is a recent extension of Haskell for compile-time meta-progra- mming. This extension allows the programmer to observe the structure of the code of a program and either transform that code, generate new code from it, or analyse its properties. In this section we summarize some of the facilities offered by the extension.

This mechanism is built on top of a monadic library. The quotation monad Q encapsulates meta-programming features as fresh name generation. It is an exten- sion of the IO monad. The usual monadic operators bind, return and fail are available, as well as the do-notation [19]. The function runQ makes the abstract syntax tree inside the Q monad available to the IO monad, for example for printing. This is everything we need to know about the quotation monad for our purposes.

Library Language.Haskell.TH makes available syntax construction functions built on top of the quotation monad. Their names are similar to the constructors of the algebraic data types, e.g. lamE :: [PatQ] -> ExpQ -> ExpQ. For example, we can build the expression [|\x->x|] also by writing lamE [varP (mkName "x")] (varE (mkName "x")), where mkName:: String -> Name.

We will use in Section 4 the quasi-quotation mechanism in order to analyse and transform Haskell programs, and the splicing notation in order to do this at compile time. A pretty printing library Language.Haskell.TH.PprLib will be useful in order to visualize the results of our examples.

Notice that this transformation assumes a strict semantics for the case expression. Core case expression is strict in the discriminant, but Haskell case with a unique variable pattern alternative is lazy. As our analysis and transformation happen at Haskell level we would not obtain the desired effect with the previous transfor- mation. Additionally it can even be incorrect from the point of view of the types because let-bound variables are polymorphic while case-bound ones are monomor- phic. For example, the expression

Mycroft [9] gave for the first time an abstract interpretation based strictness analysis for a first-order functional language. Later, Burn et al. [1] extended it to higher order programs and Wadler [20] introduced the analysis of data types. Peyton Jones and Partain [13] described how to use signatures in order to make abstract interpretation more efficient.

As the language is first-order the only places where lambda abstractions are allowed are function applications and right hand sides of let bindings. Function and constructor applications must be saturated. Let bindings may be recursive. Notice that if we lift the previously mentioned restrictions we have a higher-order subset of Haskell. This is the reason for our definition.

Module Strict contains the transformation function and the strictness analysis. First we quote the Haskell expression in order to be able to inspect the abstract syntax tree; then we modify such tree using function transfm, defined below. We use $ to execute the transformation at compile time. These small modifications can be trivially generalized and they could be even completely transparent to the programmer if we generate them automatically. If we want the new pass to do other things we just have to modify function transfm.

where function toExp :: AbsVal -> Exp just converts an abstract value into an expression. Notice that the analysis is carried out at compile time and that we have defined strict2 as a transformation from a expression to another expression representing its abstract value. This is because the compile time computations happen inside the quotation monad, so both the argument and the result of strict2 must be of type ExpQ. We use the do-notation in order to encapsulate strict into the monadic world.

so we use again function isCon to distinguish them. If it is a function application, absapply carries out the abstract function application. The abstract value FB n represents the completely undefined function so it returns B Bot when completely applied and FB (n-1) when there are remaining arguments to be applied to.

When a signature F [b1, ..., bn] is applied to an abstract value B b we need to know whether it is the last argument. If that is the case we can return a basic value, otherwise we have to return a functional value. The resulting abstract value depends on both b1 and b.

If neither b1 nor b is Top (i.e. when the least upper bound sups returns Bot) then the function is strict in its first argument, which is undefined, so we can return B Bot independently of the rest of the arguments. However if there are arguments left we return the completely undefined function FB (n-1).

The result is F [Bot, Top] as expected, telling us that the function is strict in the first argument but maybe not in the second one, although we know it is. Notice the loss of precision. This is because the analysis is static, but not because of the implementation.

In this case, if we want to view the result of the transformation instead of the evaluation of the transformed expression, we can use the function runQ of the monad, which allows us to extract the transformed expression before proceeding with the rest of the compilation. Then we print it with function ppr from the library Language.Haskell.TH.PprLib:

So when the let expression defines a function or is a set of recursive definitions (told by function isRecorFun) we do not apply the transformation at top level but we can apply it in the right hand sides of the declarations and in the main expression of the let. When transforming these expressions, the abstract values of the bound variables are irrelevant so we give them the top abstract value. This is done by addEnvtop.

Although there is a typing algorithm for Template Haskell [8], the type infor- mation is not kept in the syntax tree. We could of course develop our own typing algorithm but it would be of no help for other users if it is not integrated in the tool. This would be very useful also to do type-based analyses, which we plan to investigate.

