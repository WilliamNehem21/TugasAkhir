We present a tool-supported framework for proving that the composition of the behaviors of the separate parts of a complex system ensures a desired global property of the overall system. A compositional inference rule is formally introduced and encoded in the logic of the PVS theorem prover. Methodological considerations on the usage of the inference rule are presented, and the framework is then used to prove a meaningful property of a simple, but significant, control system.

Let us illustrate the features of TRIO by means of a simple, but mean- ingful example (which will also be used in Section 5 to show an application of our compositional framework). The case study consists of a reservoir and a controller. Whenever the level of liquid in the reservoir is below a certain threshold, the controller opens a valve to fill it. Moreover, the reservoir can nondeterministically leak.

This section presents a compositional inference rule for the TRIO language. More precisely, we are considering compositional specifications written in the rely/guarantee paradigm [2,1]. This rule will be used in Section 5 to derive formal properties of the composite system introduced in Section 2. For the sake of brevity, we do not demonstrate the soundness of the inference rule (see [3] for further details).

Now, we need to introduce some formal semantics for rely/guarantee spec- ifications; in other words, we have to define formally what is the link between the assumption formula of one module (e.g. E) and its guarantee formula (e.g. M ). In order to do this, we introduce a new temporal operator, represented

the logic of the PVS theorem prover [7] of the modular features of TRIO 7 . The encoding is composed of two parts: a mapping of the modular features of TRIO onto the PVS language (Section 4.1), and a set of strategies that automate the conduction of PVS proofs of TRIO specifications (Section 4.2).

Each TRIO class is mapped onto a PVS theory, the basic PVS encapsulation mechanism. Genericity is also translated naturally from TRIO to PVS: in fact, both TRIO classes and PVS theories can be generic with respect to a number of parameters. Therefore, each TRIO class parameter maps onto a PVS theory parameter; for example, TRIO constants are mapped onto PVS constants and TRIO domains are mapped onto PVS types.

Furthermore, an additional parameter must be added to each PVS transla- tion of a TRIO class. This parameter is named instances and is a non-empty type (in PVS: TYPE+). Whenever we translate a TRIO item into PVS, we add an argument of type instances. For example, a TRIO time-dependent proposition I, which for TRIO in-the-small would translate to a PVS item I: TD_Fmla 8 , is instead defined in PVS as I: [instances -> TD_Fmla], that is a function from instances to TD_Fmla. This particular way of param- eterizing theories is needed to render in PVS the TRIO semantics of module

importing. In fact, PVS does not allow importing multiple instances of the same theory, while TRIO does. This problem is solved by importing multiple instances of the same PVS theory using different actuals for the instances parameter (one for each corresponding TRIO module).

Two important features of the TRIO language, namely inheritance and visibility management, cannot be translated properly into correspondent PVS constructs. In fact, while PVS does have some mechanisms to support the reuse of code and to perform a minimal information hiding, they simply are too weak and not flexible enough to represent effectively the corresponding TRIO features. Therefore, inheritance and visibility management should be entirely realized by front-end tools that would serve as interface between the user and the PVS engine. Basically, these tools would ensure an automatic translation of TRIO code into PVS code, respecting the TRIO semantics for these important object-oriented features. Such tools are in fact currently under development. For the sake of brevity, we do not illustrate with examples the limitations of the PVS constructs in translating TRIO inheritance and visibility; the interested reader can find them in [3].

The case study we consider is a controlled reservoir system, introduced in Section 2. In this section, we briefly review some methodological aspects arisen from the development of the specification of this case study (Sec- tion 5.1), including the application of the rely/guarantee framework of Sec- tion 3.  Moreover, we outline the proof of the global correctness property

The specification of the reservoir system has been the result of a two-step re- finement process, exploiting TRIO inheritance mechanisms. The first version of the classes describes the basic behavior of the components, by means of axioms only. No assumptions on the environment are made and no high-level properties are derived, so that this basic kernel is as reusable as possible. The second version of the classes specifies with more detail the behavior of the

components, also assuming certain constraints on the environment (i.e. the other components) interacting with the module. Derived properties are stated, relying on the environment assumptions, like rely/guarantee properties. We believe that this basic two-phase scheme to develop a class can be fruitfully applied to the specification of components in general. Obviously, while the first version of the specification is usually generic enough to be unique, there may be several different second versions, according to different operative sce- narios. Moreover, multiple-step refinements are a natural extension of this basic scheme, with each step adding as much detail as it is needed.

when composing the class with other modules, these TRIO assumptions must be discharged (i.e. proved) from the formulae of the other components in the system. If we are able to discharge all the assumptions, then all the derived properties of the system (and in particular the applications of the rely/guar-

ing def (see Section 2) and assumption delta definition to get to the desired result. If instead filling holds at the current time, we introduce assumption level monotonicity and discuss the three cases, whether NowOn(level  Ll). In particular, the case NowOn(level < Ll) arises a contradiction if combined with axiom filling def, thus assuring the validity of the rely/guarantee local property.

This paper presented a compositional, tool-supported framework for the TRIO specification language. The framework is based on an inference rule that can be used to prove that the mutual interactions between components of a complex system guarantee some property for the global application, after the components are integrated into the system. The compositional inference rule has been encoded into the logic of the PVS theorem prover and a set of supporting strategies has been developed. The PVS-based tool has been used to apply our compositional framework to an example of control system, shown in Section 5.

