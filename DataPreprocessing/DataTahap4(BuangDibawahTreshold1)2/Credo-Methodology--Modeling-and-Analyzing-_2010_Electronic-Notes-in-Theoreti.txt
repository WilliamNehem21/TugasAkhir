to model objects and their behavioral interfaces. Given a specification of a schedul- ing policy (e.g., shortest deadline first) for an object, we use Uppaal to analyze the object with respect to its behavioral interface in order to ensure that tasks are accomplished within their specified deadlines.

To describe the facade of a component, we declare its ports and the events the component may raise. Below, we define two facades, ClientSide and ServerSide. The facade Peer inherits the ports and events declared in these two and adds another event that is needed when the two sides are combined.

because a network in general consists of a network manager and additional coor- dination artifacts like channels, as described later in this section. The description of the Broker declares the event handlers that it provides. For each event handler, it specifies the facade (representing a component) from which the handled event originated using the keyword with.

The behavioral description for a component facade comprises of specifying the or- der of raising events and the port operations. This is modeled using constraint automata [3]. In these automata, we denote port operations by specifying the port names. The corresponding action (read or write) is understood from the port type (given in the structural facade description).

In general, the behavior of the sub-type has to be a refinement of the behavior of its super-type [16]. This is achieved by computing the product of the automata describing the inherited behavior (ServerSide and ClientSide) and the automaton syn- chronizing them (Peer). In this product [3] transitions with different action names are interleaved while those with common action names are synchronized.

Notice that interleaving allows for components to be involved in more than one session at a time. The synchronized product of the Broker automaton with the com- ponent automata (from the previous subsection) describes the overall behavior of the system. This product constrains the Broker such that components are involved in at most one session at a time. We model the system and analyze it with the Vere- ofy tool [14,4], e.g., to ensure absence of deadlock. Furthermore, Vereofy includes symbolic model checking tools for linear-time, branching-time and alternating-time temporal logics with special operators to reason about the events and data flow at ports of components. Due to lack of space, we do not explain the details of such analyses.

Channels. We further refine the network model by introducing channels (which are a specific kind of connectors) [2,10]. In general, a channel provides two (channel)- ends. We distinguish between input-ends (to which a component can write) and output-ends (from which a component can read). We also describe the synchroniza- tion between the two channel-ends by an automaton. For example, the automaton below models a 1-place buffer. It provides an input-end in and an output-end out. In state e the buffer is empty and in state f it is full (for simplicity, we abstract from the data transfered and stored).

We use intra-component interfaces together with the behavioral interfaces of Section 2.2 to derive test specifications to check for conformance between the be- havioral models and the Creol implementation. We also use this specification to simulate the environment of a component while developing the component.

Given a C implementation of the system, we use the behavioral interfaces of Section 2.2 to derive test scenarios to check for conformance between the Creol model and an implementation in an actual programming language. The coverage of these test scenarios is improved by symbolic execution of the Creol implementation. Finally, we model the real-time aspects of the system using timed automata. In the real-time model, we add scheduling policies to the objects. Here, we check for

Each peer consists of a client object, a server object and a data-store object. The Client interface provides the user with a search operation. The data-store provides the client object with an add operation to introduce new data and the server object with a find operation to retrieve data. We model these two perspectives on the data-store by two interfaces StoreClientPerspective and StoreServerPerspective.

Creol programs and models can be executed using the rewriting logic of Maude [5]. Maude offers different modes of rewriting and additional capabilities for validation, e.g., a search command and the means for model checking. Credo offers techniques to analyze parts of the system in isolation; on the lowest level, to analyze the behavior of a single (active) object in isolation.

Credo offers techniques to analyze, in a black-box manner, the behavior of a component modeled in Creol, by interaction via message passing. This allows for the description and analysis of systems in a divide-and-conquer manner. Thus the developer has the choice of developing the system bottom-up or top-down.

step to Maude. The specification in Maude is executed together with the model. With the data-store at hand, we specify via the method parameters that the data delivered along the sAns port of the server is actually the data identified by the key. This needs to be done on the level of the Maude code.

The conformance testing introduced in the previous section is already a simulation of a part of the system, i.e., the object under test. We use a modified version of the above testing interpreter to eliminate of the error reporting. Notice that the Maude interpreter of Creol is a set of rewrite rules which reduces the modification of the interpreter in this case to the deletion of the rules dealing with the error reporting.

Furthermore, we use the facades and behavioral interfaces of section 2 to derive a Creol skeleton of the network. By filling in the details of the network manager, we get a Creol model of the network. The model of the network and the models of the components together form a model of the entire system, which can be executed in Maude.

We use a formal testing process to provide the necessary links between behavioral interfaces, Creol models, and the actual implementation. Behavioral interfaces pro- vide test scenarios, patterns of interactions between the components. A test case created according to a test scenario represents a functional description, but does not guarantee a good coverage of the model. To optimize the coverage, dynamic symbolic execution is used to analyzes execution paths through the Creol model to find representative test cases while avoiding redundancies in the test suite [9].

We instrument the implementation to record events and use the instrumented implementation to record traces of observable events. Then we restrict the execution of the model to these traces. If the model can successfully play back the trace recorded from the implementation (and the implementation produces the correct result(s) without assertion failures), then the test case is successful. The Creol model is used as a test oracle for the execution of the test cases on the actual implementation [1].

In this section, we explain how to model the real-time aspects of the peer-to-peer system using timed automata and the Uppaal model checker [15]. An object or component is called schedulable if it can accomplish all its tasks in time, i.e., within their designated deadlines. We demonstrate the schedulability analysis process [7,11] on the broker object in the peer-to-peer model, which is the most heavily loaded entity in this system.

Due to the high amount of concurrency in the model, model checking is of limited use. Nevertheless, we can use the simulation feature of Uppaal [17] to analyze bigger systems. We measure the worst-case response time for each message, which identifies a lower bound for the deadline value in a schedulable system.

