checkers, and standard automata-manipulating algorithms for lexer and parser generation. In these applications, the code comes out much more concisely than implementations in more standard languages. Concision is valuable not just for aesthetic reasons: minimizing the trusted computing base is important for security applications (see, e.g., [2,3]).

The main concern of this work is to show how Rogue can itself be concisely implemented in a simpler rewriting system, called MicroRogue. MicroRogue resembles a traditional implementation of term rewriting insofar as it rewrites terms using a global set of rules. The rules are only applied at the top level of terms, however. Rules are ordered: if more than one applies, the greatest in the ordering is used. Even less like traditional term rewriting, rules can be dynamically enabled and disabled. Inspired by work of Visser, we also allow new rules to be added dynamically [13]. Rules are added in scopes, which can be pushed and popped. Finally, MicroRogue provides mechanisms for specifying evaluation order.

Using the primitives of MicroRogue, a Rogue interpreter can be imple- mented in less than 40 (non-comment, non-blank) lines of MicroRogue code. This is attractive from a practical point of view, since it enables much easier development of Rogue than seems possible in an industrial non-symbolic lan- guage like C++. From a more theoretical perspective, the move from Rogue to MicroRogue is motivated by the observation that the definition of the op- erational semantics of the Rewriting Calculus contains several clauses which are essentially simple rewriting rules. This suggests that a meta-language for implementing Rogue or the Rewriting Calculus should be based on some kind of rewriting. This seems somewhat strange, since these are already supposed to be foundational rewriting languages! MicroRogue resolves this tension by providing a small set of rewriting primitives which are sufficient to implement the operational semantics of Rogue.

The rest of the paper is organized as follows. Section 2 describes Rogue. Section 3 discusses the forces leading to the development of MicroRogue from Rogue. Section 4 defines MicroRogue, and Section 5 walks through the im- plementation of Rogue in MicroRogue.

The first two applications succeed because the left hand side of the rule that is being applied is identical to the term to which the rule is applied. The third application fails (with null) since f(a) is not identical to f(c). Note that as stated above, f(a) is just alternative notation for f @ a. Consider now the following one-step evaluations of applications of rules with variables:

In the first example, (null,3) is first reduced to 3, which does not match the pattern (x,y). So the whole application reduces to null. But in the second example, because a lazy arrow expression is applied, we do not reduce (null,3). This unevaluated expression then matches the pattern (x,y), and evaluation continues successfully.

These can very naturally be viewed as term rewriting rules, which suggests that a good meta-language for implementing Rogue or the Rewriting Calculus would be some kind of rewriting language. This is true even though rewrite rules in the Rewriting Calculus do not map directly onto rewriting rules in standard term rewriting (for example, nonregular rules are allowed in the Rewriting Calculus). Since the Rewriting Calculus is itself proposed as a foundation for implementing rewriting systems, it seems in a sense somewhat paradoxical that the meta-language for describing it involves rewriting. That is, the foundation (Rewriting Calculus) seems to depend on that which it is intended to serve as a foundation for (term rewriting). To resolve this tension, we seek to accomodate:

In implementing imperative decision procedures for quantifier-free formulas of first-order theories, it is important to be able to backtrack all state of the deci- sion procedure on command [12,5]. This is because these decision procedures are integrated with propositional SAT solvers which perform backtracking search of the space of boolean assignments to the atomic subformulas of the goal. The SAT solver may decide to back out partially from some particular assignment, in which case the decision procedures must also backtrack their state to remain in synch with the SAT solver. So at least for these kinds of applications, it is highly useful to have:

The operational semantics of MicroRogue defines how a certain kind of state is updated during evaluation of a MicroRogue expression. This state has two parts. There is a global set of rules to use for top-level rewriting of expressions. There is also a single MicroRogue expression called the hold ex- pression. The hold expression can have its subexpressions rewritten in place. This is how MicroRogue allows evaluation order to be controlled. Both the

Evaluating DONE causes the hold expression to be marked as normalized. This is useful, for example, to prevent congruence rules from being needlessly applied to a term which has already been fully evaluated. In order to accomo- date dynamically added rules, however, expressions are marked as normalized just with respect to some core prefix of the global set of rules. Dynamic rules may still be used to rewrite expressions that have been normalized with re- spect to the core rules. The core prefix of rules is indicated by evaluating the special expression ENDCORE. If a term has been marked as normalized and the first rule in the ordering which applies to it is in the set of rules added before the evaluation of ENDCORE, then the term will be rewritten just to itself. Otherwise, the rewriting will proceed.

simply by giving the rule a name when it is added. Then the congruence rule indicates that the hold expression, which is a possibly rewritten version of the application, should be further rewritten. This gives the reduction rule a chance to rewrite it. The reduction rule is then responsible for enabling the congruence rule again, using ON. If it could happen that no reduction rule applies, we can include a catch-all rule after the reduction rules, to turn the congruence rule on again. Alternatively, we can have the congruence rule turn itself back on after the recursive evaluation of the hold expression.

At this point, if no reduction rule applies, the catch-all rule of expression 1 will be used, and the expression will be marked as normalized. If, on the other hand, the application is now of the form (l -> r) @ t, the rule of expression 17 will be applied. This rule just returns (l => r) @ t, since applications of lazy and eager arrows are evaluated the same way if the target expression has already been evaluated; and turns the congruence rule APP2 back on. We do the latter to maintain the invariant that when a rule is applied which occurs later in the list of rules than one of those congruence rules (APP1 and APP2), all earlier congruence rules are enabled.

A partial compiler for MicroRogue has also been implemented (in Rogue). MicroRogue rules are simply compiled into the C++ code that would other- wise be executed by the interpreter for them. This compilation is currently limited to the top-level of rules. Rules that are dynamically added by other rules are not compiled. The resulting partially compiled version of the Mi- croRogue program is then statically linked into the MicroRogue interpreter. Applied to the definition of Rogue in MicroRogue, this partial compilation has cut around 20% of the running time from the interpretation of representative Rogue programs.

