A prominent algorithm for learning such devices was developed by Angluin. We have implemented this algorithm in a straightforward way to gain further insights to practical applicability. Further- more, we have analyzed its performance on randomly generated as well as real-world examples. Our experiments focus on the impact of the alphabet size and the number of states on the needed number of membership queries. Additionally, we have implemented and analyzed an optimized version for learning prefix-closed regular languages. Memory consumption is one major obstacle when we attempted to learn large examples.

code generation [8] and model-based test generation [4,12]. They all assume that a formal model of the system under study is available. Such formal models are assumed to be developed during the specification phase of system development, or a posteriori from an existing implementation.

One approach to overcome these limitations is to develop techniques for generating formal models with less manual effort and more automated support. In the extreme case, a formal model could be generated a posteriori, from the developed system. If no model of the system under development was present, this model can be used to analyze and validate the implementation. If a formal model was available a priori, the generated model can be compared with this one to show conformance of the implementation with respect to its specification.

It can be shown that this construction yields a minimal DFA accepting L, i.e., the number of states is minimal among all DFA accepting L. Further- more, it can be shown that every minimal DFA is isomorphic to the one we constructed.

We studied 6 transition systems of CCS processes. They are simple ex- amples like buffers, vending machines, or several examples of schedulers and mutual exclusion protocols. Their number of states lie between 2 and 13 and the number of letters between 3 and 6. Note that we learned minimized DFA representations of the given protocols.

We failed to learn some larger protocols, namely some instances of param- eterized schedulers, the Jobshop (77 states, 7 letters) and an ATM protocol (1715 states, 27 letters). The reason is that we did not invest effort into a good algorithm for finding counterexamples; it took too long to find counterexam- ples for the protocols in question. (Note that the execution time which we measure is independent of the time spent for finding counterexamples.) The ATM, though, failed due to lack of memory.

Among the conclusions we draw from our experiences is the fact that ran- dom prefix-closed automata are harder to learn in comparison to completely randomly generated automata. For our random examples, the number of membership queries can roughly be described as linear in the number of tran- sitions. Membership queries for our prefix-closed examples, in comparison, are approximately quadratic in transitions.

Moving deeper into the domain of prefix-closed automata we conclude that it is possible to reduce the number of membership queries by using an optimization specially shaped for these automata. The optimization reduces the number of membership queries considerably. For the randomly generated prefix-closed automata we measured a reduction of about 20%.

Turning our attention to the real-world examples we see that the optimiza- tion works much better, saving 60% membership queries relative to unopti- mized learning. We also compared the result of learning real-world examples with randomly generated prefix-closed examples of the same size, in order to investigate if they behaved in the same manner. The result reveals a bet- ter performance for the real-world examples in terms of membership queries, especially with the optimization. This seems to imply that our real-world ex- amples have a more suited structure for learning. Hopefully this observation can be used to optimize the learning process further.

