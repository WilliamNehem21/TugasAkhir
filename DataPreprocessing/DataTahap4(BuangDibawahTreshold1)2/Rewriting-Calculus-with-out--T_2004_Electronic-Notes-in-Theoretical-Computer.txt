Rule abstractions generalize in turn pattern abstractions by binding arbitrary expressions instead of patterns, and are used in the Rewriting Calculus to provide a first-class account of rewrite rules and rewriting strategies. For example, rule abstractions can be used to encode innermost rewriting strategies for term rewriting systems. Furthermore, rule abstractions correspond to a form of higher-order natural deduction, where (parts of) proof trees are discharged instead of assumptions. Although such rule abstractions are a firmly grounded artifact both in logic and in programming language design and implementation, they lack established foundations.

Let P ara = (par(X ) d S d S.X,a d S d 3, ...). The method par(X ) seeks for a method name that is assigned to the variable X and then sends (i.e. installs, as a first-class citizen) this method to the object itself, i.e.

We define an operational semantics via a natural proof deduction system a` la Plotkin [35]. The purpose of the deduction system is to map every closed expression into a normal form, i.e. an irreducible term in weak head normal form. The presented strategy is lazy call-by-name since it does not work under

More precisely: first, we evaluate T1 (the protected term). If T1 evaluates to an output without matching failures (i.e. an output value), then this value will be the result of the whole try catch with expression. This roughly corresponds to executing T1 without raising exceptions.

