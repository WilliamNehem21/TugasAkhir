Since graph pattern matching leads to the subgraph isomorphism problem that is known to be NP-complete in general, this step is considered to be the most crucial in the overall performance of a graph transformation engine. The diversity of tools is thus mainly characterized by the different strategies used for the graph pattern matching step. These strategies can be grouped into two main categories.

dataflow network is constructed based on the condition (if ) parts of rules, which is basically a directed acyclic graph of a special structure. Initially, this network is fed by basic facts through its input channels. Compound facts are constituted of more elementary facts, thus they are the inputs of internal nodes in the network. If a fact reaches a terminal node, then the rule related to this specific node becomes applicable and assignments mod- ifying the set of basic facts may be executed (according to the then part). Since every node keeps a record of its input facts, only modifications of these facts have to be tracked at each step.

In the area of relational databases, views may be updated incrementally. A database view is a query on a database that computes a relation whose value is not stored explicitly in the database, but it appears to the users of the database as if it were. However, in a group of methods, which is called by view materialization approach, the view is explicitly maintained as stored relation [8]. Every time a base relation changes, the views that depend on it may need to be re-computed.

In the current paper, we discuss our initial experiments in mapping models and metamodels into an off-the-shelf relational database to implement the incremental update technique for the dining philosophers problem. Note that the integration of database and graph transformation techniques has a long tradition (see e.g., [1,13]), but these approaches use graph-oriented databases in contrast to relational ones (as in our case).

The metamodel describes the abstract syntax of a modeling language. For- mally, it can be represented by a type graph. Nodes of the type graph are called classes. A class may have attributes that define some kind of proper- ties of the specific class. Inheritance may be defined between classes, which means that the inherited class has all the properties its parent has, but it may further contain some extra attributes. Finally, associations define connections between classes.

This rule can be applied when a philosopher already holds his left fork in his hands, and now he tries to grab his right fork, if it is not held by another philosopher yet. This latter statement is expressed by the NAC. The RHS of the getRightForkRule shows that the philosopher will grab his right fork as the result of rule application. On rule level, the LHS has two nodes and an edge of type right that leads between these nodes, while the NAC graph (marked by the striped area) implicitly contains node F as well to impose a well-formed graph structure.

rows of R for which no row of S exists that satisfies F . Rows of the latter type are filled with null values in all columns originating only from S. The formal treatment of inner and left outer joins can be found in [11].

Pattern matching without considering negative application conditions is faster in inc mode with a total factor of 7.9 (2.15 sec in inc mode vs. 16.93 sec in fs mode). If negative application conditions are also consid- ered as a part of the pattern matching phase, then the factor significantly (with a factor of 56) increases in favor of the inc method (122 sec in fs mode and 2.15 in inc mode).

As a summary, the overall execution time of the entire transformation pro- cess (consisting of 5 rule applications) without the initialization phase was 22 times faster in inc mode with negative conditions and 3.3 times faster without considering negative conditions. Together with the initialization phase, there was still a factor of 2 in the favor of the inc mode.

