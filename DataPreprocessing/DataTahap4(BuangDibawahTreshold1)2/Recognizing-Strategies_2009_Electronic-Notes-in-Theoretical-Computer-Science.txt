We use strategies to specify how a wide range of exercises can be solved incrementally, such as bringing a logic proposition to disjunctive normal form, reducing a matrix, or calculating with fractions. With such a strategy, we can automatically generate worked-out solutions, track the progress of a student by inspecting submitted intermediate answers, and report back suggestions in case the student deviates from the strategy. Because we can calculate all kinds of feedback automatically from a strategy specification, it becomes less labor-intensive and less ad-hoc to specify new exercise domains and exercises within that domain.

In this paper we work out the similarities between parsing and solving exercises incrementally, and we discuss the implementation of a recognizer for strategies. We present a full implementation of such a recognizer, and discuss a number of design choices we have made. In particular, we discuss the use of a fixed point combinator to deal with repetition, and labels to mark positions in the strategy.

Strategies are used in many domains such as programming, rewriting, compiler construction, and theorem proving. We recently realized that strategies also play an important role in exercise assistants that support incrementally solving exercises in mathematics, logics, physics, etc. [6]. In the intelligent tutoring systems field, a strategy is called procedural knowledge, a production system, or a procedural plan.

1 This work was made possible by the support of the SURF Foundation, the higher education and research partnership organisation for Information and Communications Technology (ICT). For more information about SURF, please visit http://www.surf.nl. We thank Alex Gerdes and the anonymous reviewers for their constructive comments.

The information provided by our strategy recognizer is necessary for determin- ing what kind of feedback to give to a user of an exercise assistant. At the mo- ment the feedback provided by exercise assistants is almost always limited to cor- rect/incorrect. Using the diagnosis given by our strategy recognizer we can improve a lot on this.

This paper is organized as follows. Section 2 introduces our language for speci- fying strategies for exercises. We illustrate the language with a strategy for adding fractions: this strategy is used as a running example throughout the paper. Sec- tion 3 shows how we have implemented the components of our strategy language to obtain a strategy recognizer, and discusses the main design choices. We then present three extensions to our strategy recognizer in Section 4. Section 5 shows how the strategy language can be used for diagnosing possible problems in the user input. The last two sections (6 and 7) discuss related work and ongoing research, and draw conclusions.

Transformation rule. Such a rule is the smallest building block to construct composite strategies, and closely corresponds to a terminal symbol in a CFG. Occasionally, we write symbol r for some transformation rule r to distinguish the strategy from the transformation rule.

Labels. Because our primary interest in the strategy language is to automat- ically calculate feedback from it, we need some mechanism to mark positions in the strategy, for example, to encode the hierarchical structure of a strategy, or to refine the textual feedback that is associated with a certain position in the strategy. For this purpose, we introduce labels. Labeling a strategy s with some label l is written as label l s. The exact representation of a label is irrelevant.

The definition of addFractions contains the strategy combinators repeat , somewhere, and try . In an earlier paper [6], we discussed how these combinators, and many others, can be defined conveniently in terms of the strategy language. The combi- nator repeat is a variant of the many combinator: it applies its argument strategy exhaustively. The check that the strategy can no longer be applied is an adminis- trative rule. The definition of somewhere is another example of an administrative rule: this combinator changes the focus in the abstract syntax tree before it applies

In this section we discuss the design of a strategy recognizer. Instead of designing our own recognizer, we could reuse existing parsing libraries and tools. There are many excellent parser generators and various parser combinator libraries around [9,13], and these are often highly optimized and efficient in both their time and space behavior. However, the problem we are facing is quite different from other parsing applications. To start with, efficiency is no longer a key concern. Because we are recognizing applications of rewrite rules applied by a student, the length of the input is very limited. Our experience until now is that speed poses no serious constraints on the design of the library. A second difference is that we are not building an abstract syntax tree.

The ability to diagnose errors in the input highly influences the quality of the feedback services. It is not enough to detect that the input is incorrect, but we also want to know at which point the input deviates from the strategy, and what is expected at this point. Some of the more advanced parser tools have error correcting facilities, which helps diagnosing an error to some extent.

In earlier attempts to design a recognizer library for strategies, we tried to reuse an existing error-correcting parser combinator library [13], but failed because of the reasons listed above. The library we develop in this paper is written in the functional programming language Haskell [12]. The code in this paper is almost complete and conforms to the Haskell 98 standard. Although the code is relatively short, we want to emphasize that the library has been tested in practice on different domains. For instance, strategies implemented for the domain of linear algebra are more complex than the strategy for fractions reported in this paper. These strategies will be used in several courses during 2008.

The type variable a in this definition is an abstraction for the type of the symbols: for strategies, the symbols are rules. The first design choice is how to represent recursive grammars, for which we use the constructors Rec and Var . A Rec binds all the Var s in its scope that have the same integer. We assume that all our grammars are closed, i.e., there are no free occurrences of variables. This data type makes it easy to manipulate and analyze grammars. Alternative representations for recursion are higher-order fixed point functions, or nameless terms using de Bruijn

A smart constructor is a normal function that in addition to constructing a value performs some checks or some simplifications. We use smart constructors for sim- plifying grammars, and to obtain a normal form. We introduce a smart constructor for every alternative of the Grammar data type: the functions symbol , var , succeed , and fail do nothing special, but are introduced for consistency.

The list of results returned by run consists of two parts: the first part tests whether empty s holds, and if so, it yields the singleton list containing the term a. The second part takes care of the non-empty alternatives. Let r be one of the symbols that can appear first in strategy s (r is a rewrite rule). We are only interested in r if it can be applied to the current term a. It is irrelevant how the type Rule is defined, except that applying a rule to a term returns a list of results. We run the remainder of the strategy (that is, t ) with the result of the application of rule r .

The function run can produce an infinite list. In most cases, however, we are only interested in a single result (and rely on lazy evaluation). The part that considers the empty sentence is put at the front to return sentences with few rewrite rules early. Nonetheless, the definition returns results in a depth-first manner. We define a variant of run which exposes breadth-first behavior:

A labeled strategy is a strategy with a label (of type l ). A strategy is a grammar where the symbols are either rules or labeled strategies. For this choice, we use the Either data type: rules are tagged with the Left constructor, labeled strategies are tagged with Right . With the type definitions above, we can have grammars over other grammars, and the nesting can be arbitrarily deep.

The final answer, 1  1  , is indeed what we get. In fact, this term is returned twice because the strategy does not specify which of the fractions should be renamed first, which results in two different derivations. It is much more informative to step through the above derivation and see the intermediate steps.

The list has twenty steps, but only four correspond to actual steps from the deriva- tion: the rules of those steps are underlined. The other rules are administrative: the rules up and down are introduced by the somewhere combinator, whereas not comes from the use of repeat . Also observe that each Enter step has a matching Exit step. In principle, a label can be visited multiple times by a strategy.

rule, or a part of a strategy with a certain label. This is convenient if following a strategy becomes routine, and a step-wise approach is no longer helpful to the student. Similarly, a tool can ask a student to solve the entire problem first, and decompose the problem in steps if the submitted answer is not correct.

Example 5.5 A student is asked to provide the final answer to a question, and in case it is incorrect, the exercise tool poses sub-problems to the student. These sub- problems can be calculated automatically from the strategy by looking at the labels. The strategy for adding fractions, for instance, can be decomposed in 4 steps.

There are many tools that offer students an environment in which they can solve exercises incrementally, such as MathDox [3] and ActiveMath [5]. Most of these tools are limited to correct/incorrect feedback, because it is often difficult and laborious in these systems to diagnose mistakes. However, some tools use external domain reasoners for making a diagnosis, which is exactly what our strategy recognizer has to offer. Some work has been done on diagnosing student mistakes on the level of rewrite rules [2,7,15].

In this paper, we discuss the design and implementation of a strategy recognizer, which makes it possible to use strategies for improving error diagnosis. Strategies for specifying exercises are introduced in a different paper [6]. By viewing strategy recognition as a parsing problem, we take advantage of almost 50 years of experience in parsing sentences of context-free languages. The strategy language on which our work is based is very similar to languages that are used in parser libraries [9,13], but also to strategic programming languages such as Stratego [11,14] and Elan [1], data conversion libraries [4], and languages in other domains.

