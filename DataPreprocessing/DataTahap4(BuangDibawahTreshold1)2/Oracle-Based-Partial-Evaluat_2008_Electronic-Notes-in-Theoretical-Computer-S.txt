Partial Evaluation (PE ) [7] optimizes programs by specializing them w.r.t. part of their input, which is known as the static data. Those computations which only depend on the static data are performed at specialization-time, whereas those which depend on dynamic data remain in the specialized program. The idea, of course, is that the running-time of the specialized program should be smaller than that of

Poly-Controlled Partial Evaluation [13] (PCPE ) is a powerful approach to on- line partial evaluation of logic programs. Rather than using a fixed control strategy (as done in traditional partial evaluation algorithms), PCPE allows considering a set CS of control strategies. For each call pattern, PCPE can choose any of the control strategies in CS. This allows using different control (or specialization) strategies for different call patterns. Thus, PCPE can produce residual programs that are not directly achievable by traditional partial evaluation using any of the considered control strategies in isolation. This often results in hybrid solutions with better fitness value than any of the solutions achievable by traditional PE, for a number of different resource-aware fitness functions [11].

In this work we investigate the possibility of using an oracle which decides which is the most promising control strategy for each call pattern based on the specialization results for such call patterns using the different strategies. All other branches in the tree are pruned away. In our example, the oracle should be able to tell us: in T1, after specializing using the two control strategies, the most promising state between T2 and S5 is T2. Then, between T3 and T4, the latter is preferable. Then, T6 is preferable to S4. Finally, from T6 we can only reach S3. The benefits of building such an oracle are twofold, since a single specialized program would be computed. First, we do not spend time generating multiple specialized programs. Second, as in the case of PE, we do not need an evaluation phase, which can be very costly. However, this approach can only be useful in practice if the oracle makes good decisions, since some of the PCPE specialized programs outperform PE (such as S3), but others produce bad results (such as S5 or S2).

in charge of guaranteeing that the number of atoms which are specialized remains finite. This is done by replacing atoms by more general ones, i.e., by losing precision in order to guarantee termination. Given an atom A and an set of atoms H, we use

In most existing control strategies, which are focused on time efficiency, observ- ables C and S are not explicitly handled and most heuristics aim at maximizing D and E while keeping N with the value zero. Observable S is an example of information which is just partial when applying the oracle: in order to obtain a covered program, the code for the new atoms in S may in turn need including code for other atoms not yet covered. Perfect information can only be determined by actually expanding the PCPE-tree and observing it a posteriori.

Given a PCPE-tree Tree, we use C(Tree) to denote the set of O-constraints which can be obtained from Tree. The cardinality of C(Tree) is usually quite large: for each intermediate node T in Tree with p children we can build p constraints for T . Thus, for a realistic tree Tree it is not possible to find a vector of oracle constants which allow satisfying all constraints in C(Tree) simultaneously. There are several reasons for this. First, we have restricted ourselves to linear functions. It could be the case that there exists a non-linear oracle function which satisfies all constraints. However, the advantage of linear functions is that there exist tools capable of handling them, whereas inferring non-linear functions is a rather complicated task. Second, as already mentioned, a perfect oracle function does not exist in general, since it has to make decisions based on partial information, i.e., without expanding the complete tree below the current node.

We can formulate the process of finding a vector of oracle constants as a Maxi- mum Constraint Satisfaction Problem (Max CSP): though the set of O-constraints is unsatisfiable, the goal is to find a vector of oracle constants that maximizes the number of satisfied constraints in C(Tree). Unfortunately, the cardinality of C(Tree) is large in general, and finding an optimal solution to this Max CSP problem is quite costly. A simpler model results from collecting only (some of) the O-constraints oc- curring in a PCPE-path of maximal fitness.

After collecting a set {k1,..., kp} of oracle constants, one for each of the calibra- tion benchmarks, we normalize the value of each vector kj by forcing the absolute value of the first constant kj1 (in our case corresponding to the observable D) to be 1 (written |kj1| = 1). This is done by multiplying all constants kj1,..., kjn in each vector by 1/|kj1|. Note that this is a correct transformation since by multiplying a vector by a constant greater than zero, all constraints which were satisfied are again satisfied. Finally, the calibrated oracle constants result from computing the arithmetic mean over each normalized constant kji.

We have run a series of experiments in order to both evaluate the quality of the specialized programs obtained by means of OBPE and to compare the cost of this approach w.r.t. other specialization techniques. Three different specializa- tion techniques have been considered: standard PE (column PE), the optimized generate+evaluate PCPE presented in [11], which prunes the PCPE-tree using a combination of heuristics and branch and bound techniques (column PB-PCPE), and Oracle-based PE (column OBPE).

Another reason for this is that, for efficiency, in the implementation abstraction functions are applied first, and then those generalized atoms which are different are unfolded, i.e., if after abstraction we obtain two identical generalized atoms, only two children states are generated, instead of four. Column Ties shows the number of times the oracle returns the same value for two children. If this number were too high, it would probably indicate that the set of observables chosen does not convey enough information, and the possibility of choosing the wrong path would increase. However, this happens only 7.69% of the total number of decisions taken.

Control of PE has received considerable attention, but there is still plenty of room for improvement, especially in the context of resource aware specialization. Many decisions have to be taken during PE and it is often not obvious which is the right choice. The main advantage of PCPE is that we do not need to restrict ourselves to a single control strategy, but rather we can use several ones. This opens up the door to obtaining hybrid specializations which often outperform pure ones. However, the main problem of the generate+evaluate approach to PCPE [13] is that, even with the optimizations proposed in [11], it is too expensive in practice: it is an alternative only when the quality of the specialized program is of much importance, and the PCPE tree has a moderate size.

In this paper we have presented Oracle-based PE. This approach, in contrast to previous work [13,11], introduces a constant overhead factor, instead of an expo- nential one, to the complexity of standard PE. At least in our experiments, OBPE obtains specialized programs which are significantly better than those generated by standard PE and the constant overhead factor is quite reasonable.

