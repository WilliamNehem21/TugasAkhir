The idea of high-level replacement (HLR) systems is to define a set of rewrite rules, each consisting of a pattern, that must be matched and an associated tem- plate, describing the changes to be performed over the system. Additional appli- cation conditions may restrict the transformation further. A major advantage of this rewriting approach is that it allows to specify abstractly in which situations and how a system should be changed, including possible dependencies that need to be updated. Further, these rules cannot only be applied locally, but also globally,

including a short introduction to its dynamic aspects. Our running examples, intro- duced in Section 4 are taken from the field of service-oriented computing. Section 5 is an introduction to general high-level replacement systems. In Section 6, we give a formal definition of Reo connectors and show that these definitions give rise to a HLR-system. We then extend the examples of Section 4 by rewrite rules in Section

Reo is an exogenous coordination language wherein so-called connectors are used to coordinate components from outside, i.e. the components are not aware of the fact that they are coordinated. Complex connectors are composed out of primitive ones, called channels, with well-defined behavior, supplied by users. To build larger connectors, channels can be joined into nodes and, in this way, arranged in a circuit. Each channel type imposes its own constraints for the possible data flow at its ends,

synchrony or mutual exclusion. The ends of a channel can be either source ends or sink ends. Source ends accept data into, and sink ends produce data out of their respective channels. While the behavior of channels is user-defined, nodes are fixed in their routing constraints. Data flow at a node occurs, iff

sink end is ready to accept data. The LossySync has the same behavior, except that it does not block if the receiver cannot accept data. Instead, the data item is read and destroyed by the channel. The FIF O1 is an asynchronous channel that has a buffer of size one. Unlike the prior channels, FIFOs are stateful primitive connectors. The SyncDrain channel is different than the already introduced ones. It has two source ends through which it can only consume data. Its behavior can be described as follows: if there are data items available at both ends, it consumes both of them synchronously.

Reo further includes a number of operations for changing the topology of a connector at run-time. Reo allows the dynamic creation of channels, splitting and joining of nodes, hiding internal nodes and more. The hiding of internal nodes plays an important role, because it allows to freeze the topology of a connector, such that it can only be used from outside with its published interface, but not changed anymore. The resulting connector can be viewed as a new primitive connector, since its internal structure is hidden and its behaviour is fixed.

splitting and joining of nodes. To define complex transformations, we base our approach on the theory of so-called high-level replacement systems. An introduction to HLR-systems is given in Section 5. To motivate the use of such an abstract transformation approach, we first consider some examples from the field of Service- oriented Computing.

As the main coordination mechanism we rely on the channel-based exogenous coordination language Reo, introduced in Section 3. Reo supports a specific notion of compositionality that enables coordinated composition of individual services, as well as complex composite business processes. Accordingly, a coordinated business process consists of a set of web services whose collective behavior is coordinated by Reo connectors.

High-level replacement (HLR) systems, introduced in [16], arose as a generalization of the theory of graph transformation to other high-level structures, e.g. Petri-nets, AHL-nets and algebraic specifications. In the following, we apply this theory in the field of coordination to allow us to define transformations for Reo connectors conveniently.

Productions are interpreted as rewrite rules. To support this intuition, we usu- ally assume linear productions, i.e. the morphisms l, r are injective. In that case, the object K can be viewed as a substructure of both L and R. The object L is referred to as the left-hand side and R as the right-hand side of the rewrite rule. K can be thought of as a gluing object of the production, which means that it is the part that remains invariant during rule application. To apply a rewrite rule, the following steps must be performed:

which parts of the matched pattern should be deleted, and r determines which new parts should be added. The categorical formulation of this principle is the concept of so-called Double-Pushout (DPO) derivations. Pushouts are a categorical construction that describe the gluing of two structures.

transformed, using the rule p and a match m, to the output N . The idea of high- level replacement categories is to define a set of axioms, called HLR-conditions, that not only allow DPO-Rewriting, but also ensure a number of useful properties and theorems. We recall now the most important properties of HLR-categories. For a detailed discussion see [15].

Glueing Condition An arbitrary production is not always applicable with respect to a given match. Formally, this problem corresponds to the existence of the pushout complement C in Def. 5.2. The so-called glueing condition states under which circumstances C exists and hence, the rewriting rule can be applied.

morphisms and typed rewrite rules must preserve this information. A possible sce- nario may permit a component to attach to only a specific type of channels or that two different channel types may never join together. More information on typed graph transformation can be found in [15].

Proof. It is known that hypergraphs form a HLR-category [30]. To verify this also with our specific notion of connectors, we use the result that presheaves are adhesive categories [23]. The definitions for connectors and their morphisms have been chosen such as to form a presheaf over the small category

The examples given in this paper show that a good tool support is crucial for any kind of application in the field of coordination. The Eclipse Coordination Tools (ECT) project [14,22] aims at unifying a number of existing Reo-related tools into one integrated environment. ECT is implemented in Java as a set of plug-ins for the Eclipse platform 5 . Currently the framework consists of the following parts:

Since the Reo coordination tools are implemented using standard Eclipse mod- eling framework, we can directly use existing model transformation frameworks to define connector transformations. In particular, we use the Tiger EMF Model Transformation Framework (EMT) [6] which is an implementation of the graph- based HLR transformation approach, as presented in this paper. Our Reo model can be imported into the Tiger framework, where transformations are defined using a visual editor. Future work includes an integration of the run-time libraries of the transformation framework with the implementation of Reo.

