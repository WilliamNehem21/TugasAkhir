NiMo (Nets In Motion) is a Graphic-Functional-Data Flow language designed to visualize algo- rithms and their execution in an understandable way. Programs are process networks that evolve showing the full state at each execution step. Processes are polymorphic, higher order and have multiple outputs. The language has a set of primitive processes well suited for stream programming and supports open programs and interactive debugging. The new version of the environment NiMo Toons includes: an also graphic and incremental type inference system, multiple output processes as higher order parameters, symbolic execution, five evaluation modes that can be globally or lo- cally set for each process and dynamically changed, and facilities to measure the used resources (parallelism level, number of steps, number of processes, etc.)

The full semantics of NiMo was defined by means of graph grammars and implemented in a graph transformation system [12]. This first prototype (Ni- MoAGG) was the basis for the development of NiMoToons, the NiMo graphic environment. The current version presented here, is a substantial development of earlier work [6]. The system overall design and implementation issues were described in that paper. Here we focus on the main newly added features and their application possibilities. The novelties are:

b. The red multi-edges correspond to the shared expressions produced by the duplicators. In NiMo only constant values (circles and list-ends) are physically duplicated; any other subnet is shared. However, since sharing can obscure the understanding of the results, duplication can also be enforced. It can be performed locally on an in port, or by preceding the output of a subnet having

shared expressions with a special purpose process: the double-green-triangle that can be seen on the left of the duplicator. In the previous version, where the evaluation policy was lazy, it was used in the net outputs to set a continued demand on its provider. Now it also has this mentioned functionality for enforcing duplication of shared values. This algorithm is not trivial due to the existence of multiple outputs processes.

In NiMo type inference is static and incremental. During the net construction each connection is type consistent. The type inference system is a graphic generalization of the classical Hindley/Milner algorithm to deal with multiple outputs and curried/uncurried conversion. The net has an associated type graph. It is incrementally built during the net construction and its evolution is

There are several languages or tools sharing some common characteristics with NiMo. In [3] we related some tracers, debuggers, and visual representation tools for functional languages. GemCut [9] is a graphical viewer for functions in the Haskell like language CAL, the editor uses the inference system of the CAL compiler to prevent type errors. In NiMo the type inference is also made graphically and gives the user on line visibility of the type inference process. TypeTool [10] and System I [11] are web-based tools for visualizing type inference of lambda terms, they are oriented to teaching the basis of type inference algorithms for functional languages.

Regarding the different evaluation modes we can mention Ptolomy [7]. It is a visual language based on actors having ports as communicating interfaces. Actors have parameters that are not visualized on the actor but shown in a separate windows. In NiMo all the program state is visualized. Ptolomy deals with continuous data, while NiMo is only discrete. In Ptolomy there is a variety of domains with an uniform evaluation policy, for instance process network domain correspond to a Data-Driven policy.

