n in this example. The exact details of implementation are fortunately not part of the semantics, but this means that however bad the implementation is, it will still perform better than any cutting-edge lazy interpreter on certain terms. In other words, the amount of bookkeeping necessary for completely lazy reduction is not comparable to what is gained from the better sharing (on this example; this should also be studied in general). This contrasts with optimal reduction, where the cost of bookkeeping ruins the benefits of optimality [19].

The first important property to check is that the semantics is indeed well defined. Since it is defined only on terms of a particular form, as produced by the normal- isation procedure of Section 3.1, we should check that the result of evaluation has the correct form as well. The property that arguments of applications and bodies of abstractions are variables or metavariables is clearly preserved, since we only ever substitute variables for variables. The naming property is also preserved, as we will now show.

Besides a better understanding of the theoretical issues of sharing and efficiency in functional programming languages, this work aims at being used as a foundational basis for implementations. Of course, the legitimacy of (various degrees of) laziness has been decreasing along the years [19,5] and it may seem that our work is primarily of theoretical interest. We do not believe this.

First, laziness is not always useless and there are techniques to combine the advantages of strictness and laziness, such as static analyses [6] and optimistic eval- uation [5]. There is no reason to think that these techniques cannot be adapted to our framework. Moreover, proof assistants, like Coq, are an emerging class of functional languages, where programs (proof terms) are built interactively, rather than written directly, and may have a very unusual and intricate shape, for which highly lazy strategies may be well-suited. We believe that the emergence of these new paradigms, with their specific problems, is the occasion to take a fresh look at the theory and practice of the implementation of programming languages.

