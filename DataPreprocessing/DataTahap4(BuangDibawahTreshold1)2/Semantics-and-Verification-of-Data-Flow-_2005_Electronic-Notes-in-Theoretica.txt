2.0 standard by defining a denotational semantics. It covers basic control flow and data flow, but excludes hierarchy, expansion nodes, and exception handling (see [18,19,20] for these issues). The paper shows, where the constructs proposed in the standard are not so easily formalized, and how the formalisation may be used for formal analysis.

As of writing this, the work on the UML 2.0 has reached the finalization stage. The technical work is said to have ended, and voting should be completed late this year, leading to an official endorsement of the new UML version probably early 2005. Thus, the currently available specification [15] are already pretty close to what will become the UML 2.0 later this year (or early next year).

In UML 2.0, there are numerous substantial improvements over UML 1.5. The metamodel has been totally reengineered, and is now much cleaner, more complete and orthogonal than it used to be. Many details have been improved, and the UML 2.0 is now object-oriented again in some meaningful way.

2.0 (cf. [4]). It does not influence the behavior of an Activity, however, and may thus be ignored here. SubactivityStates have vanished, and nesting is now accomplished by calling subordinate Activities from the Actions that define the behavior of superordinate Activities. Data flow is now denoted by ObjectNodes and ObjectFlows.

Second, there are effect, selection and transformation functions in curly braces on ActivityEdges. All we can reasonably know about them is that they work on a given name space, changing the state of some of the objects in it, possibly augmenting or reducing the name space. The modeler must fill in the details, the effect expressions are simply handed down through the translation and mapped into effect expressions attached to the arcs going out of the transition representing the ActivityEdge. In our interpretation, these functions remain at the respective net arc.

Third, there are guard functions in square brackets on ActivityEdges. They simply access the name space, and may read states of the objects in it. In our interpretation, they are moved up- or downstream to the next net transition. Again, the exact meaning is left for the modeler, and the expressions are turned into guards (closed boolean expressions) over the variables defined by the arcs adjacent to the transition representing the ActivityEdge.

2.0 activity diagrams. In the remainder of this section, we assume that A is an Activity that is mapped to the CPN N by the semantics above (i.e. [[A]] = N ). We assume that there are sensible initial and final markings of N that correspond to initial and final states of A.

In this paper, a formal semantics of activity diagrams in UML 2.0 is defined. It is based on colored Petri-nets and covers control flow, concurrency and data flow, but not procedure call, exception handling, and expansion regions (see [18,19,20] for these aspects). By a carefully choice of net formalism and inscription language, the standard analysis techniques and tools for CPNs are made accessible for the verification and validation of UML Activities.

Since the semantics presented here preserves the structure of the original activity diagram in the resulting Petri-net, it is very easy to map between Activities and corresponding Petri-nets, opening the road to easy mapping between an Activity and corresponding CPN, and even visualisation of ex- ecutions of Activities. This is very difficult if not impossible for semantics based on a non-graphical formalism, like process algebras. Finally, defining the semantics also helped identify a number shortcomings in the standard.

A tool implementation to support industrial case-studies is currently under way, together with extensions and automation of the analysis techniques. This effort is impeded, however, by the current lack of true UML 2.0 tools: despite the marketing promises by many vendors, there are currently no such tools available. With the official adoption of the UML 2.0 standard, we are hoping that this unpleasant situation will disappear.

The next step is to extend this semantics to also cover quantitative as- pects like processing time and amount of processed data. Also, processing of streaming data is an unsolved problem. It would be interesting to see, whether these extensions allow quantitative analysis of system architectures at an early stage during development. In the Petri-net world, analysis techniques based on Markov-chains have a long tradition, so it seems feasible to turn the se- mantics presented in this paper into one that creates Generalised Stochastic

