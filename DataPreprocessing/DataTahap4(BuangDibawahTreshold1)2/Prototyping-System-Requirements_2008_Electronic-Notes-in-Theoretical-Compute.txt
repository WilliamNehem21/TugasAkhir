The rest of this paper is organized as follows. Section 2 defines the use-case model and conceptual class model of a project. We also define the notion of system state. Section 3 presents an algorithm that is used for transforming pre and post conditions into primitive actions. Section 4 focuses on the generation and the execution of the prototype. The prototype is written in Java. Finally, Section 5 discusses the conclusions and further work.

A conceptual class model is a pair CM = (D, I), where D is a class diagram and I is a state constraint written as a predicate of attributes and associations [13]. The conceptual class diagram D identifies the classes and their associations. It defines the environment in which the use cases are to be operated. In our model, a conceptual class diagram D consists of following parts:

An object of a class has an identity and a state which assigns values to the attributes of the class of the object. Let O(C) denote the set of all possible objects of class C. For each class C in the class diagram D, we use the capital letter (not bold) C to represent the variable which records the current existing objects of class C in the system. The type of C is the powerset P(O(C)). Let CV ar be the set of all class variables of a class diagram

We define eight primitive actions that will be used for implementing any system operations. They can be classified into five categories: Create an Instance including objects and links, Delete an Instance, Update a Property (or attribute) of an object, Find an Instance, and Check a Property of an object. The first three kinds of operations change the system state, while the last two kinds do not. These actions are described below in terms of the possible changes that they causes in the system state and the relation between the input and output parameters:

FindObject : Given an object identifier and a class name C, check whether an object with the identity exists. This action returns true if the object is found and false for otherwise. We can also find an object by an association which may contain the object. In general, we can find all objects in C that satisfy a provided property.

of some objects and links, non-existence of some objects and links, and properties of attributes of the existing objects. The postcondition of a use case that changes system states can be decomposed into the conjunction of creation of new objects, creation of new links, deleting existing objects, deleting existing links, and update values of attributes of existing objects. A query use cases only returns a truth value according to the existing objects and links as well as the values of the attributes of the existing objects. In summary, the truth value of pre and post conditions can be determined from the following four variables whose types are sets of instances. These variables will be used for implementing the decomposition of the pre and post conditions of a use case.

pre-objects: is the set that records the objects which should exist in before the execution of the use case. When we declare value of pre-objects, we also specify the values of attributes of objects in this set. The elements of pre-objects can only appear as parameters of use cases.

post-objects: is the set that is assumed to contain the objects which should exist after the execution of the use case. Values of attributes of objects should be declared when declaring post-object. The objects in post-objects can either be parameters of the use case or be an object newly created in the execution of an action.

