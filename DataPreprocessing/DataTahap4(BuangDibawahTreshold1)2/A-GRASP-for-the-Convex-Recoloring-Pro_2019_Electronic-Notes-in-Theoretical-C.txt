In this paper, we consider a coloring as a function that assigns a color to a vertex, regardless of the color of its neighbors. The Convex Recoloring Problem finds the minimum number of recolored vertices needed to turn a coloring convex, that is, every set formed by all the vertices with the same color induces a connected subgraph. The problem is most commonly studied considering trees due to its origins in the study of phylogenetic trees, but in this paper, we focus on general graphs and propose a GRASP heuristic to solve the problem. We present computational experiments for our heuristic and compare it to an Integer Linear Programming model from the literature. In these experiments, the GRASP algorithm recolored a similar number of vertices than the model from the literature, and used considerably less time. We also introduce a set of benchmark instances for the problem.

The convex recoloring problem has its origins in the study of phylogenetic trees. A phylogenetic tree reconstructs the evolutionary history of a set of species that have common characteristics. The leaves of these trees are known organisms, and the remaining vertices are hypothetical ancestors. An important feature of such trees is that similar organisms are expected to appear close to each other [9].

The problem is mainly studied on trees, due to its origin. Moran and Snir [12] proved that the version on trees is NP-hard. Chopra et al. [4] presented an integer programming model to the convex recoloring on trees that has good computational results, compared to the previous approaches. The best approximation factor known

In this paper, we focus on the convex recoloring problem on general graphs, without any restrictions on the recoloring. This version of the problem is also proved to be NP-hard [13]. To our knowledge, only exact algorithms have been proposed to solve this problem so far, but no computational results were reported.

The remaining of this paper is organized as follows. In Section 2, we give basic definitions for the convex recoloring problem that are used throughout the text. In Section 3, we discuss the methods currently available for the problem. In Section 4, we detail the algorithm proposed. In Section 5, we report on our experiments and discuss the results. Lastly, in Section 6, we draw our conclusions and point out future research directions.

The construction algorithm in the initial phase is also iterative, and has three key components. The first is the greedy component: at each iteration, a partial solution is available and the candidate elements to be added to it are put in a list, that is sorted according to a greedy criterion which measures how good an element is compared to the other possible ones. The second key component is the randomization: instead of picking the candidate at the top of the previously sorted list, a Restricted Candidate List (RCL) is formed with only a percentage of the best candidates from which one is chosen randomly. The third key component is the adaptivity: each iteration is affected by the previous ones, since each choice modifies the state of the solution.

We chose this meta-heuristic because of its simplicity and the small number of tuning parameters, namely, the percentage of best candidates considered for selection and the stopping condition. Another advantage of grasp is its potential to combine it with other techniques, such as Variable Neighborhood Search and parallelization [15]. Next, we describe the main ingredients of our grasp to solve the crp.

The construction phase is detailed in Algorithm 1. The greedy selection recolors the vertices aiming to obtain large monochromatic components. The algorithm operates on a colored graph (H, D), that is initialized with the original graph G and its coloring C. Next, every monochromatic component of H is shrunk into a single vertex. Then, the following steps are repeated until no bad colors remain in H: vertices are sorted according to a greedy criterion, a vertex v is chosen among a fraction of the best candidates following the greedy criterion, the color of v is switched and, finally, its neighbors with the same color are shrunk into it. The criteria we use to select the next candidate, to sort the candidate list, and to recolor the chosen vertices are detailed below. After a solution is constructed, all vertices from G are either in H or represented by a vertex of H. To extract a recoloring of G, we assign the color of a vertex v from H to its copy in G and to the vertices v represents. We envisaged two alternative criteria to select, sort, and recolor candidate vertices. One is called ratio while the other is named union.

Local Search. The local search routine is executed after each solution is con- structed to explore a neighborhood of the solution in search for a local maximum. We propose two neighborhoods for the crp: the simple and the extended neighbor- hood. These neighborhoods are detailed below. The basic idea is to revert the color change of a vertex, i.e., to find a vertex that was recolored and have it returned to its original color. The difference between simple and extended is how they find such vertices.

The extended neighborhood is constructed by systematically removing the color of all vertices that were recolored and can be removed from their new class without disconnecting them. After removing the color of every possible vertex, we iterate over the uncolored vertices and find a path to its original color. This path must contain only uncolored vertices. Then, we choose the vertex with the smallest path to be reverted, recoloring also the path. This process of finding paths and connecting

We compared the solutions of the ratio criterion using this test and found FF = 25.44, and therefore we reject the null hypothesis. Using the same test for solutions to the union criterion, we found FF = 4.81 and, again, reject the null

