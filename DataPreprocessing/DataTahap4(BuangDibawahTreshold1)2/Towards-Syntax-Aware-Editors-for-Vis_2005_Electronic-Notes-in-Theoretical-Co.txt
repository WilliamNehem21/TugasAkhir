In this work, we develop a strategy for the construction of syntax-aware visual language editors by integrating incremental subsentence parsers into free-hand editors. The parser combines the LR-based techniques for parsing visual languages with the more general incremental Generalized LR parsing techniques developed for string languages. Such approach has been profitably exploited for introducing a noncorrecting error recovery strategy, and for prompting during the editing the continuation of what the user is drawing.

language editors supporting the syntax-aware editing style. The generated editors support the editing of visual sentences in free-hand style. Moreover, the underlying parsers incrementally analyze the sentences while they are en- tered, providing an immediate feedback to the user by highlighting correct and incorrect subsentences, and offering additional support in the construction of the sentences. In particular, during the generation of an editor the parsing technique stores information that the editor exploits to suggest the user how to construct the visual sentence in an easier and more effective way.

The paper is organized as follows. Section 2 reviews the related approaches. Section 3 describes the main characteristics of the XPG grammar formalism, and shows a technique for the parsing of visual subsentences of languages modeled through XPGs. Section 4 illustrates how the parser can be used to implement noncorrecting syntax error recovery and to prompt next symbols during the editing process. Finally, conclusions and further researches are discussed in Section 5.

The intelligent diagram metaphor is a recent metaphor in which the editor parses the diagram as it is being constructed, while performing error correction and collecting geometric constraints that capture the relationships between di- agram components. This metaphor is supported by the editors generated with the visual programming environment generator Penguins [3]. In such editors the diagrams are created in free form and in any order. During diagram manip- ulation objects in the diagram can be moved or resized while the constraint solver maintains the semantics by preserving the geometric constraints be- tween the diagram components. Penguins leverages a constraint solver that is

able to maintain arbitrary linear arithmetic constraints necessary for geometric error correction and diagram manipulation. The error correction mechanism used in Penguins is based on the concept of the geometric distance between sentences. By computing the geometrically closest sentence that belongs to the language, an incorrect sentence can be automatically corrected by chang- ing attribute values of the graphical symbols.

An error handling strategy for the parsing algorithm based on atomic re- lational grammars has been proposed by Tuovinen [14]. In particular, the error recovery techniques aim at enabling the parser to continue processing the input in spite of syntactic errors rather than correcting the errors. The error handling strategy has been implemented into the Vilpert system [13], an object-oriented framework for implementing visual languages in Java.

In the following we show an example of XPG grammar modeling the data flow diagram language. Let DFD be the name of the grammar, the set of nonterminals is N = {DataFD, Node}, where each symbol has one attaching region as syntactic attribute, and DataFD is the starting symbol of DFD, i.e. S = DataFD. The set of terminals is given by T = {PROCESS, STORE, EN- TITY, EDGE, PLACEHOLD}. The terminal symbols PROCESS, STORE and ENTITY have one attaching region as syntactic attribute. They repre- sent, the processing step node, the data store (or data source) node, and the externally entity node, respectively, of a data flow diagram. The terminal symbol EDGE has two attaching points as syntactic attributes corresponding to the start and end points of the edge. Finally, PLACEHOLD is a fictitious terminal symbol to be dynamically inserted in the input sentence during the parsing process. It has one attaching region as syntactic attribute.

The graph stack has more than one stack top (usually visualized by circles). The operations of Splitting, Combining and Local Ambiguity Packing avoid an exponential growth of the stack during the parsing process [12]. For a highly ambiguous grammar, many parse trees might be generated for the input. The packed shared parse forest allows to share common subtrees, and to pack vertices whose parse subtrees describe the same portion of input and lead to the same state.

The forward and backward parser stacks can be considered as only one graph stack expanding to the right and to the left, and with two types of nodes: simple stack node and joint stack node. The latter encloses a bipartite graph whose elements are simple stack nodes from forward and backward parsers. Each stack node includes information on the state reached by the parser, the last terminal parsed, and a pointer to a node in the packed shared forest. The incremental parser must control that the rendezvous operation can be applied before reusing a subtree. Moreover, the reintroduction of the terminals is local to the couple of forward and backward parsers that execute the rendezvous.

inal XPG grammar G and for its reverse version rev (G). For each state in G (rev (G), resp.) reachable after the occurrence of the starting symbol the algo- rithm starts an incremental X-parser, named forward (backward, resp.). The forward parsers may interact with the backward parsers only when a parser tries to reduce a production. In this case, that parser waits for a rendezvous, i.e., an opposite parser attempting to apply the reverse version of the same reduction (and the parsers have parsed different symbols).

a couple (hA, kN ) is a tie-point of p, denoted by (hA = kN ), if the syntactic attribute h of A is synthesized from the syntactic attribute k of N , i.e., the value of hA depends on kN .

As an example, let us consider the XPG DFD presented in subsection 3.1. The link in production 5 is (1N ode, 1EDGE); the links in production 2 are (1DataFD', 1EDGE) and (2EDGE, 1N ode). The tie-points in production 2 are (1DataFD = 1DataFD') and (1PLACEHOLD = 1N ode).

The notion of JSET for a production can be extended to the XpLR items. This will allow us to keep track of the relations among the grammar symbols during the construction of the set of XpLR item collections. This information will be exploited to prompt the insertion of correct symbols during the editing of a visual sentence.

On the other hand, each edited symbol needs the parsing information spec- ifying the context in which it has been recognized. In particular, during the parsing process for each edited symbol we need to keep track of the grammar symbols that synthesize their syntactic attributes. Thus, we associate to each symbol T a set of couples (xGS, s) where GS is the last grammar symbol that has synthesized the syntactic attribute x of T , and s is the state of the forward or backward parser when the symbol GS has been processed. By analyzing the IJSETs of the extended items set Is of the forward or backward parser we extract the couples (xGS, yNS) and consider as symbols to be prompted all the unmarked symbols NS.

We have presented a strategy for constructing syntax-aware visual language editors. The approach relies on the grammar formalism of XPGs and an in- cremental LR-based subsentence parsing technique. Once integrated into a visual editor, the parser is able to provide immediate feedback to the users during the composition of visual sentences by highlighting correct and incor- rect subsentences, and offering additional support in the construction of the sentences. Indeed, such approach has been exploited for introducing a non- correcting error recovery strategy, and for prompting during the editing the continuation of what the user is drawing.

