The first of these is reflected in the syntax of the modelling language, which is itself object-based. The second is a practical concern: that the model need not concern itself with the design of external protocols. The third is quite fundamental: the modelling language cannot be used to describe the effects of concurrent access to data.

The language has two built-in types: STRING and NAT; other primitive types may be introduced directly, as sets, or indirectly, via enumeration classes or type synoyms. An attribute of primitive type is declared simply by writing pAtt : PTYPE. Whenever PTYPE is STRING, an additional argument is used to give the expected length.

att4 is a set-valued attribute, containing references to objects of class OtherC. This attribute has two methods of its own, Method3 and Method4; the definitions of these methods may include references to local methods Method5 and Method 6. The expected size of att4 is num. att5 is a derived attribute, whose valued is obtained by concatenating the values of the two (string-valued) attributes att2.oAttS and att2.oAttT.

With the exception of _0, these decorations may be applied to class names (to indicate a particular object) or to attribute names (to indicate a particular attribute). Where attribute names are unique within the scope of a method, any root qualification may be omitted: for example, Class.att1.att2 may be written as att2, and Classthis.att3 may be written as att3.

The precondition insists that the current object is an object of class C; that input Sin refers to an object of class D; and that Sin is not already an element of S. The change list indicates that the method may change the value of S. The postcondition states that, afterwards, Sin should be in S.

Each method has a corresponding decoration. Within a class C, the meth- ods Create and Destroy can use Cnew and Cthis to refer to the object that is to be created or, respectively, destroyed. For an optional attribute att, the methods Set and Clear can use attin and attthis to refer to the object that is to be inserted or, respectively, removed.

In this paper, we have described a model-driven approach to software engi- neering, based around the use of a new object-based language. This approach has developed through application: a number of large case studies, including two systems for commercial customers, have been produced, and are being maintained. The language is inspired by Z, and implemented using B, in a combination of formal techniques and code generation that has proved partic- ularly effective.

