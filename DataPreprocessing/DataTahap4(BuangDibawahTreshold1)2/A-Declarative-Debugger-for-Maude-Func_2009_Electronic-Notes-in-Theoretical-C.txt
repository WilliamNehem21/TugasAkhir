E. Y. Shapiro [19] and that constitutes the framework of this work. Declarative de- bugging has been widely employed in the logic [10,14,22], functional [21,17,16,18], and multiparadigm programming [5,3,11] languages. Declarative debugging is a semi-automatic technique that starts from a computation considered incorrect by the user (error symptom) and locates a program fragment responsible for the error.

Before starting the debugging process, the user can select a module containing only correct statements. By checking the correctness of the inferences with respect to this module (i.e., using this module as oracle) the debugger can reduce the number of questions asked to the user.

Exploiting the fact that rewriting logic is reflective [6,8], a key distinguishing feature of Maude is its systematic and efficient use of reflection through its prede- fined META-LEVEL module [7, Chap. 14], a feature that makes Maude remarkably extensible and that allows many advanced metaprogramming and metalanguage applications. This powerful feature allows access to metalevel entities such as spec- ifications or computations as usual data. Therefore, we are able to generate and navigate the debugging tree of a Maude computation using operations in Maude itself. In addition, the Maude system provides another module, LOOP-MODE [7, Chap. 17], which can be used to specify input/output interactions with the user. Thus, our declarative debugger for Maude functional modules, including its user interactions, is implemented in Maude itself.

Complete explanations about the fundamentals of our declarative debugging approach, additional examples, and more information about the implementation can be found in the technical report [4], which, together with the Maude source files for the debugger, is available from the webpage http://maude.sip.ucm.es/ debugging.

connected components of the subsort relation. The kind corresponding to a sort s is denoted [s]. For example, if we have sorts Nat for natural numbers and NzNat for nonzero natural numbers with a subsort NzNat < Nat, then [NzNat] = [Nat].

It will be convenient to represent deductions in the calculus as proof trees, where the premises are the child nodes of the conclusion at each inference step. In declar- ative debugging we are specially interested in buggy nodes which are invalid nodes with all its children valid. Our goal is to find a buggy node in any proof tree T rooted by the initial error symptom detected by the user. This could be done simply by asking questions to the user about the validity of the nodes in the tree according to the following top-down strategy:

The theorem states that we can safely employ the abbreviated proof tree as a basis for the declarative debugging of Maude functional modules: the technique will find a buggy node starting from any initial symptom detected by the user. Of course, these results assume that the user answers correctly all the questions about the validity of the APT nodes asked by the debugger (see Sect. 3.1).

Before describing the basics of the user interaction with the debugger, we make ex- plicit what is assumed about the modules introduced by the user; then we present the available commands and how to use them to debug the buggy example intro- duced in Sect. 2.2.1.

inference rules corresponding to a trusted statement is collapsed in the abbreviated proof tree. In order to obtain a nonempty abbreviated proof tree, the user must have labeled some statements (all with different labels); otherwise, everything is assumed to be correct. In particular, the buggy statement must be labeled in order to be found. When not all the statements are labeled, the correctness and completeness results shown in Sect. 2.3 are conditioned by the goodness of the labeling for which the user is responsible.

How the process continues depends on the selected strategy. In case the top- down strategy is selected, several nodes will be displayed in each question. If there is an invalid node, we must select one of them with the command (node N .), where N is the identifier of that wrong node. If all the nodes are correct, we type (all valid .). In the divide and query strategy, each question refers to one inference that can be either correct or wrong. The different answers are transmitted to the

debugger with the commands (yes .) and (no .). Instead of just answering yes, we can also trust some statements on the fly if, once the process has started, we decide the bug is not there. To trust the current statement we type the command (trust .).

can trust it. This answer has a behavior similar to yes: it deletes all the subtrees whose root is labeled as the current statement. With these answers, we obtain a tree with only one node and the debugger is able to conclude which is the buggy membership.

As we said in the introduction, the reflective power of Maude allows us to gen- erate and navigate the debugging tree of a computation in Maude itself. Since navigation is done by asking questions to the user, this stage has to handle the navigation strategy together with the input/output interaction with the user. In- deed, this interaction can also be implemented in Maude by using the predefined module LOOP-MODE [7, Chap. 17], that handles the input/output and maintains the persistent state of the tool.

Since we use the symmetric difference function, the difference between the size of the whole tree and the double of the size of the current subtree will initially decrease (while the double of the size of the subtree is bigger than the size of the tree) and finally it will increase (when the size of the tree is bigger than the double of the size of the subtree). Thus, the function searchBestNode keeps the information about the last difference in order to stop searching in the subtree when the current difference is bigger than the last one. It uses an auxiliary function that receives the tree, the total number of nodes in the whole tree, the last and the best difference so far, the identifier of the best node, and the identifier of the root of the subtree it is currently traversing. The last and best difference are initialized with a value big enough (ten times the number of nodes), in order to avoid the selection of the initial root as the best node.

In this paper we have presented how to use the Maude reflective capabilities to im- plement a debugger for Maude functional modules. It complements other debugging techniques for Maude, such as tracing and term coloring, by allowing to debug a large range of modules (only the strat attribute is forbidden, although we expect to allow it in a near future). An important advantage of this kind of debuggers is the help provided in locating the buggy statements, assuming the user answers correctly the corresponding questions.

