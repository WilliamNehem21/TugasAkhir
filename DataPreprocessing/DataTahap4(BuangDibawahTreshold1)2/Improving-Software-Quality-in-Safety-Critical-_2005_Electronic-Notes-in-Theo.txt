As an instance of the method, we present the MDA-based tool environment of the HIDOORS project [10]. In this environment, a real-time model checker is interpreted as a platform in the sense of MDA. UML designs can be annotated with verification markup, which is not only compiled to code, but also to a design verification model of the verification platform, the model-checker. In this way, model-checking for real-time designs is integrated into the model-driven development process and allows for early verification.

The approach can easily be transfered to other verification techniques. We give a preliminary classification of the possible verification platforms and analyse their interplay. The analysis reveals that for quality-aware application areas, the standard MDA approach should be extended by one or more MDA stacks for model-driven verification (MDV). The resulting approach, quality-driven development (QDD), is, to our knowledge, the first systematic approach to integrate code generation and verification in model-driven development.

MDA is a novel, promising development architecture and process for multi- platform development [12]. It has a lot of advantages. For instance, it prom- ises to reuse design models over many platforms. The design specifications (platform-independent models, PIM) are transformed towards a platform- specific implementation models (PSM), using parameterizations and other mapping technologies. MDA also tackles the design aging problem. In devel- opment often the relation between code and specifications is lost after some time because the specifications are no longer updated when the implementa- tions evolve. Since MDA maintains mappings between design and implement- ation levels, implementation changes can better be tracked in the designs, and designs can be updated easier.

This indicates that MDA, although being targeted at quality-aware applic- ation domains, such as real-time and embedded systems, does not yet offer the necessary integrated verification technology. This paper attempts to fill this gap and proposes an extension of MDA for model-driven verification (MDV). For the integrated method, MDA+MDV, we use the notion of quality-driven development (QDD).

The paper summarises observations from the HIDOORS project [10], in which a design verification of a real-time UML model has been envisaged, in addition to the usual code generation and code verification. In HIDOORS, the real-time UML designs are verified with a real-time model checker (Sec. 3). For the integrated development of verification and code generation we have developed a real-time UML profile [5], which refines the SPT profile of OMG [11]. The profile is used for code generation, as well as for the design verification with the real-time model checker.

In this framework we have discovered that MDA should be extended to support design verification. It is advantageous to introduce a second kind of platform stack for verification, in parallel to the traditional MDA stack (Sec. 3). This leads to the definition of new verification platforms for design and code verification, and platform stacks towards the final verification model of these platforms (Sec. 4). We show that in HIDOORS, two verification platforms are used: the model checker and a worst-case execution time analysis (WCETA), which analyses the generated Java system. We give an overview of the interplay of the traditional MDA stack and the verification stacks of the model checker and the WCETA (Sec. 4.2).

QDD has more advantages. Due to the tight integration with MDA, MDV supports early verification. The HIDOORS MDV supports model-checking for real-time designs early on in the development process, even before unit testing. If the model-checker verifies the design, the code has a much better chance to be correct, which implies that the code verification becomes sim- pler. Secondly, due to the benefits of model-driven development, the employed verification platform can be easily exchanged for others. In the HIDOORS framework, the employed model checker can be exchanged for another. Fi- nally, there is a lot of cross-fertilisation of the MDA and the MDV stacks. Because the design verification aids the code verification, and the code veri- fication supports the design verification, it pays off to keep and maintain the design. Because the design is not only used for code generation, but also for design verification, developers are encouraged to keep design and code con- sistent always. Hence, QDD reduces the effects of design aging.

model. (This implies that we identify the platform-specific implementation model with the code.) We summarize stereotypes and tagged values under the name markup tags, because they markup UML designs, i.e., assert non- standard domain-specific information. As usual, a model stack is a layered set of models on different abstraction levels.

The HIDOORS MDV stack for model verification is for intended for verifying the constraints expressed in the UML model of a system. As opposed to MDA where the final target always is an implementation the final target for the MDV stack for model verification is a verification model intended as input for a model-checker. The two first levels in the MDA stack are the same for MDA and verification. Where the platform specific model for the MDA consists of Java code the platform specific model for the MDV is a Timed Automata [2,1]. The final level of the MDV model stack is the input model for the model- checker. The model verification works on an abstract model of the system. On this level not all details are available about the target implementation and runtime platform. To make model verification feasible some assumptions must be made. During model verification it is assumed that the time budgets

The WCETA utilizes the same stack as the MDA but for different pur- poses. Similar to the MDV stack for model verification the MDV stack for code analysis is intended for verification. In this case the target is a Worst-Case Execution Time Analysis (WCETA) engine. WCETA and model-verification works on models of different abstraction levels. While the model verification verifies constraints in the model it makes assumptions about the final imple- mentation and runtime platform. It is up to the WCETA analysis to verify that these assumptions will hold for the final implementation on the selected runtime platform.

When the systems model has passed the model verification step the model represents a feasible system. The next thing to do is to select a target platform for the system. Given a target platform and a systems model the system is implemented. Next follows the second major step in the MDV-process, veri- fying the implementation of the model. The model-verification makes certain assumptions about the implemented system. Now it is up to the implement- ation verification step to verify that the model is implemented in such a way that these assumptions hold. When the implementation verification fails this means that the implementation breaks one ore more assumptions made by the model-verification. This means that the implemented system will not full-fill the modeled constraints in some case.

The main objective in this example is to design the controller that opens and closes the gate at a train-crossing when a train passes. There are four ob- jects involved in the example, a sensor that detects the train as it approaches, a gate that should be closed, a sensor that detects that the train has left the train-crossing and a controller which acts upon the signal from the sensors and handles the gate. From a real-time perspective there is a constraint on the response time of the controller. The response time must be for the gate to be closed by the time the train arrives at the gate. The idea is that the train has a maximum allowed speed when it passes the gate, which together with a fixed distance between the sensor and the gate yields a time budget for closing the gate.

Since the goal of MDA is to generate code automatically from the model, care must be taken in the interpretation and application of timing constraints in the model. The MDA code generation process can introduce new sub- classes with system dependent implementations (in the following called helper classes). The methods in the new helper classes must meet the same timing constraints as those in the original class. This parallels the general constraints for proper subtyping.

Once this principle is established, validating the timing of the implementa- tion can be reduced to demonstrating that the implementations of all methods execute within the timing constraints specified in the model. Since the overall timing relationships have been validated by model checking, WCETA can con- centrate on validation the timing of individual method calls. These method calls need only fill the timing constraints given in the model.

Standard MDA builds on runtime platforms. Since MDA is a process, which reuses design specifications, models, for several platforms, its focus is reuse. As such, MDA is not concerned with correctness of the designs, which is a major disadvantage for quality-aware applications. MDV, however, employs model-driven development for verification of models on verification platforms. Its focus is not on reuse, but on verification of the design models and the code. MDV intends to aid the final code verification, by transforming the designs into a form that they can be checked, validated, or proven.

Design verification platforms. Verification platforms provide a formal language in which features of the system can be verified statically. Design verification platforms, however, verify design models (design verification). A design model is more abstract than the code. Examples are Petri Net models, CSP models, or real-time state-chart models.

Typical for this scenario is that a verification platform can be more ab- stract or higher-level than another. This means that the system model is represented in a more abstract form than the code. For instance, the model- checking verification model assumes certain features of the code, which have to be proven or tested later, by other verification platforms, for instance the WCETA. Hence, model-checking platform is more abstract, seeing less detail of the system. On the other hand, in a more abstract verification it might be easier to prove features of the abstract system. Model checking works because it assumes that the interactions correspond to regular language (which is usu- ally an abstraction). And this is the reason why QDD is attractive: in order to prove system features, a set of abstract verification platforms is needed, which relate to each other and allow for conclusions about the quality of the system.

This section investigates the relationships of the verification platforms and the runtime platform. For verification and testing of a verification platform, information has to be added to the PIM. This can be done by adding markup specifications. In the following, we investigate for the example of the HI- DOORS QDD, how the different types of markup for verification interplay

for code generation in the standard MDA stack (which is well-known). Then, the markup may verification knowledge for verification models. In the first place, the markup may assert assumptions about lower-level verification mod- els and, finally, the code. These constrain the lower-level models, generating proof obligations for them. Assertional assumptions are an effect of abstrac- tion. Since some details of the lower-level verification platform or the runtime platform are ignored, the proof on the higher level relies on assertions that must be proven in the later platform. Essentially, assertional assumptions define lemmas for proofs in higher-level models, which are proven in a lower- level model. Hence, the assertions provide an interface between proofs in higher-level models and proofs in lower-level models.

Finally, there is a kind of dual effect in QDD. In a PIM, assertions about design knowledge can be specified, encoding design knowledge that helps veri- fication in later phases. Usually, a designer has more information about a system than a code analysis can find out, or a code verification can prove. In general, full verification may be rather hard for a system, however, it can be aided by additional assertions of design knowledge. Then, the code verifica- tion delivers a proof that is relative to the assertions on the design level. We call this effect a design-supported code verification.

Firstly, proofs on each abstraction level support proofs on other abstraction levels. In particular, design knowledge assertions support code verifications. Design verification can be done on the model, and assertional assumptions can simplify them. Hence, applications can be checked early on on errors, and the trust of the developer into the system is greatly improved, even before the code verification is performed.

The idea that proofs about a system can be done on different abstraction levels which are coupled via lemmata, or mappings, is a central idea in abstract in- terpretation [7]. However, in this context, abstract interpretations are created by hand and not derived from design models. QDD advances here, since it embeds the idea of several abstraction levels for verifications into model-driven development, in which the distinction of design and target models plays an important role. By identifying an abstract interpretation as a specific plat- form, MDA and abstract interpretation can be unified. Of course, this paper has only done a very first step in this direction, much more work is needed.

We have shown that MDA for quality-aware software needs to be extended by model-driven verification (MDV) to quality-driven development (QDD). To our knowledge, QDD is the first method for MDA in quality-aware application domains, with the following advantages. With integrated design verification in model-driven development, we are able to detect errors of real-time PIMs early. Traditional methods, testing or code verification, discover mistakes very late. Since the later a mistake is found, the more expensive it is to correct, QDD should give a leading edge to increase developer productivity.

Next, verification should become easier, if done in parallel on several dif- ferent abstraction levels. Developers should be able to detect errors that are very hard to find using traditional testing. On the one hand, assertional as- sumptions in a PIM facilitate the design verification and can be proven in the code verification later on. On the other hand, design knowledge asser-

Lastly, QDD provides an elegant extension of MDA for quality-aware ap- plication domains. When regarding a verification tool as a platform, the veri- fication engine becomes rather similar to a runtime platform. This gives QDD the flavor of unifying verification techniques and platform-oriented develop- ment into one uniform model-driven framework.

