A number of the variants to be described have standard approaches, e.g. La- grangian mechanics for the n-body problem or Maxwell-Boltzmann theory for gas motion. However these are treated as separate theories in physics. LOTOS supports a common approach to all the variations.

include aviation [3], computer-integrated manufacturing [8], embedded systems [1], graphics standards [9], hardware [6], medical devices [11], neural networks [4], and visualisation [12]. (Many more references could be given.) As far as the author knows, the n-body problem is quite different from any previous application of LOTOS. The only similar work is [13] that can generate graphical animations (the dining philosophers eating).

Section 2 presents the problem framework, showing how the original n-body problem can be interpreted in a more general way. A number of variants are illus- trated. The LOTOS specification framework to encompass these is then explained. Tool support for simulation is discussed in section 3. Section 4 gives some insight into the variants of the general problem. This is illustrated in sections 5 and 6 for the n-body and Brownian motion problems.

The system is considered to be closed, i.e. to be free from external influences. In LOTOS terms, all communication between bodies is therefore internal (i.e. the Ether gate is hidden). In most applications, the bodies act deterministically according to their attributes and the states of other bodies. Some applications, however, permit non-deterministic behaviour:

For most of the problem variants, the number of bodies is fixed in advance. However, for generality the LOTOS formulation permits bodies to become inactive or to be (re-)activated as the system evolves. This is relevant to the space game, for example, since the space-ships may fire missiles (thus creating new bodies).

A state is simply a record-like structure containing the attributes given earlier. A list of states and an operation to update a state are then defined. NoState is in- troduced as the undefined state. The reference to any params includes any specifi- cation parameters (such as masses or diameters) that are generated for the problem variant. The reference to any update includes the problem-defined update proce- dure.

The overall specification behaviour is that of the Bodies process synchronised with the Step control process. All bodies broadcast their state via the Ether gate. Each body may also communicate individually with step control via the Control gate. This is used to assign each body a unique identifier when it starts up.

Initially a body claims a unique identifier by synchronising with the Step control process. Bodies are normally initialised with no knowledge of other body states, but if a body is created dynamically during simulation then this information is supplied to it. In such a case the body immediately enters its updating phase BodyUpdate, otherwise it enters its waiting phase BodyWait.

is set to None. It therefore has no state to update and remains in the waiting phase. Normally the body is active and enters the update phase. While waiting a body may learn the state of other bodies, broadcast over the Ether gate. An inactive body may be activated by broadcasting its new state, so there is a check for a matching identifier in the new state. In the updating phase, the body may broadcast its own state and then go back to waiting. It may also learn the state of another body while its state broadcast is pending.

The StepUpdate process accepts the broadcast of an updated body state, call- ing draw state to note this. If the new body kind is None (because it has become inactive), the count of active bodies is decreased. Normally number of active bod- ies remains the same, and StepUpdate increments the count of bodies it has seen. If more body updates are expected, StepUpdate repeats its behaviour. When all updates have been received, behaviour reverts to the main Step process.

The specification parameters are mainly used to control the simulation. Vari- ous parameters are pre-defined and may be re-defined if necessary. These include Limit (number of simulation steps), Mode (drawing mode), Pause (time between animation frames), Scale (drawing scale), and Tick (simulation time step). Other specification parameters control only how bodies are drawn (e.g. the Diameter of a planetary body or particle). Parameters controlling the specification may also be defined (e.g. the Impulse delivered to a particle in Brownian motion). The parame- ters, plus other numerical constants, are accumulated in any params for inclusion in the final specification.

Section 2 has presented the overall strategy for simulating the n-body problem and its variants. The following notes explain how the specification framework is instan- tiated in each case. An informal rather than LOTOS explanation is given. Sections 5 and 6 give details of the n-body and brownian motion applications.

The N-Body Problem: There is only one kind of body, the mass. Masses are ini- tialised with values for their mass, diameter, position and velocity. To update the state of a mass m, its distance d to each other mass mi is calculated. The

gravitational constant. The force is a vector quantity directed towards the other mass. The force vectors for all masses are summed and divided by the mass m. This gives the instantaneous acceleration due to gravitational attraction as a vec- tor quantity. The simulation time-step uses the acceleration to determine the new position and velocity. The masses often move in surprisingly complex ways.

Orrery: An orrery is a simulation of the solar system. This is just the n-body problem with particular values for the inner planets as bodies (and, in principle, for all planets, planetoids and planetesimals). The bodies are initialised with the relevant mass, diameter, distance from the sun, and orbital velocity. The body kinds generate the labels during drawing.

Space Game: The inspiration for this example is an early computer game. It is rather similar to the n-body problem. There are two stars, considered fixed be- cause of their comparatively high mass and separation. There are two space- ships that, in the original game, are controlled by users. However since the LO- TOS model is closed, the effect of user control is simulated by strategic changes in the velocity and heading of each space-ship. Each space-ship may also ran- domly launch a missile; this is given a fixed velocity relative to the heading of the space-ship. The space-ships and the missiles are governed by the gravitational attraction of the stars, as in the n-body problem. If a collides with another body, the simulation stops and the remaining space-ship wins (unless it collides with the other space-ship).

Brownian Motion: In this example there are multiple instances of one kind of body, the particle. These are initialised with values for their diameter and posi- tion; velocities are initially zero. The weight of a particle is disregarded since the effect of gravity is considered negligible. The state update process simply adds

The state update process is rather crude; a full air traffic simulation would be an immense amount of work. In isolation an aircraft adjusts its velocity in increments, subject to a maximum speed. This maximum decides the size of any changes in velocity. The adjustment is made to send the aircraft towards its next waypoint. When the final waypoint is reached, the aircraft is removed from the simulation. The aircraft also checks its position relative to other aircraft. There is no problem if they are separated by at least 1000 feet vertically, one nautical mile to either side, and five nautical miles ahead. If two aircraft approach closer than this, the upper one climbs. (Clearly this simple rule can lead to conflicts and collisions!)

A mark is drawn as a fixed body. A yacht is drawn according to its length, position and heading. The position of its sail is determined automatically from its heading relative to the wind, varying from close to the centre line of the yacht (when sailing upwind) to extending at right angles to the centre line (when sailing with the wind behind). The wind is drawn according to its position (point of origin) and velocity (which determines the length and direction of the arrow).

In isolation, a yacht aims to complete the course subject to wind conditions. This is non-trivial because yachts cannot sail much closer to the wind than about 45 degrees. When sailing upwind (the angle between the bearing to the next mark and the wind origin is less than 90 degrees), yachts typically have to tack (zig-zag through 90 degree turns) in order not to sail too close to the wind. Their strategy depends on the relative bearings of the wind and the next mark. When a yacht reaches a mark, this is removed from its path list so that the next mark determines the heading. In pseudo-code, the state update process does the following:

When a yacht approaches another body, rules defined by ISAF (the Interna- tional Sailing Federation) dictate which yacht has priority. The full set of rules is complex, so only the most basic are specified. Proximity is taken as being within two boat-lengths of another body (a yacht or a mark). A yacht is said to be on a starboard tack if its sail is out to port (left), or on port tack if its sail is out to starboard (right). Yachts are said to overlap if neither is astern (behind) the other.

The description uses m4 to instantiate a random number of particle bodies of kind Particle, the given particle Diameter, and a random position. Macros are defined in m4 by giving their name and expansion. Macro parameters are identified as $1, etc.

As has been seen, the n-body problem can be generalised to an interesting range of applications. Some of these are obvious variations on the original problem, while others are more radical interpretations. Nonetheless it has been possible to develop a specification and simulation framework in LOTOS that encompasses the full gamut of examples. The specification framework is instantiated with the par- ticulars of the kinds of bodies, their initial setup, and how interactions update their states. A pre-processor takes this information and creates a specific instance of the n-body problem specification. Standard LOTOS tools (with the help of C annota- tions) then simulate the behaviour of the system. Each simulation step is animated graphically by a drawing tool, either on-screen or in an animated GIF file.

