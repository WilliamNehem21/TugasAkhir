issue in system development, since both aspects appear quite naturally in many business applications. We claim that the combination of the two aspects is far from being well understood. For instance, it is well-known that pre/postcondition style specifications do, in general, not work for systems of concurrent components, but we believe that it is still important to investigate how far one can go by combining both aspects in a concurrent environment. More specifically, this concerns the impact of integrated control flow and data flow on specifications, implementations, formal correctness and compatibility notions, composition, and, last not least, independent implementability.

The paper is organised as follows. After providing some technical preliminaries, we introduce the main structural elements of our component model in Sect. 2. Then, we define behaviour protocols and consider their compatibility in Sect. 3. In Sect. 4, we provide our formal, model-theoretic semantics for behaviour protocols in terms of component (and assembly) implementations and we present our central compositionality result.

Behaviour protocols are used for the specification of component and assembly be- haviours. In order to understand unambiguously the meaning of a specification, it is generally desirable to have a formal semantics of the specification at hand, which can be used as a basis for analysis and further reasoning, concerning, e.g.,

presses that communications between components on the implementation level must be allowed, i.e. simulated, by corresponding protocol transitions. Thus, unlike [6], we do not treat communications as invisible (silent) actions, which are abstracted in a refinement relation, because for assembly implementations it is still important that communications conform to the protocol.

Other related approaches are based on symbolic transition systems (STS) whose labels can be enriched with guards and effect expressions [7,1]. While the ap- proach in [1] is motivated by using STS as finite abstractions of programs for model- checking, the approach of [7] is more directed towards model-checking of symbolic transition systems as specifications and a generative approach to obtain Java code. None of these formalisms focuses on formal correctness notions for implementations and on a contractual interpretation of pre- and postconditions. For instance, there is no compatibility relation between the guards of synchronised transition systems. On the other hand, it would be interesting to see, in what extent the model checking techniques used in [7,1] could be adjusted to check compatibility of components as proposed here.

cations and implementations. The former are given by behaviour protocols which are contract-oriented and express the assumptions and guarantees concerning the implementor and the user of a component. Our approach can be considered as a study of the fundamental concepts that are needed to support the development of concurrent, component-oriented systems when data states of components are taken into account. Hence, on the specification level, our approach is independent from a particular assertion language for pre- and postconditions and, on the implemen- tation level, it is independent from a particular programming language notation. Of course, the instantiation to appropriate subsets of concrete languages, like OCL for assertions, UML for protocols, and concurrent Java for implementations is an interesting objective of further research.

