that allows for a more correct representation of actual computation. The transla- tion of terms into polygraphs is close to the one into termgraphs and they seem to have the same properties, as suggested by the first results in [8]. For example, let us consider the following term rewriting rule, used to compute the multiplication on natural numbers: mult(x, succ(y))  add(x, mult(x, y)). When applied, this rule duplicates the term corresponding to the argument x. In termgraph rewriting, one is able to share it instead, so that there is no need for extra memory space. This sharing operation can be algebraically formalized as an operation with one input and two outputs, whose semantics is a duplication operation. In polygraphs, one can have many such operations with many outputs, explicitely represented and handled.

The constructions are considered modulo some relations, including topological de- formation: one can stretch or contract wires freely, move 2-cells, provided one does not create crossings or break wires. Each 2-cell and each 2-path f has a 1-path s1(f) as input, its 1 -source, and a 1-path t1(f) as output, its 1 -target. The compact notation f : s1(f)  t1(f) summarizes these facts.

Dimension 3 contains rewriting rules called 3 -cells. They always transform a 2-path into another one with the same 1-source and the same 1-target. Using all the 1-cells, 2-cells and 3-cells as generators, one can build reductions paths called 3 -paths, by application of the following three compositions, defined for F going from f to f' and G going from g to g': F 0G goes from f 0g to f' 0g'; when t1(f) = s1(g), then F 1 G goes from f 1 g to f' 1 g'; when f' = g, then F 2 G goes from f to g'. These constructions are identified modulo some relations, given in [7], where their 3-dimensional nature was explained. The relations allow one to freely deform the constructions in a reasonable way: in particular, they identify paths that only differ by the order of application of the same 3-cells on non-overlapping parts of a 2-path. A 3-path is elementary when it contains exactly one 3-cell. Each 3-cell and each 3-path F has a 2-path s2(F) as left-hand side, its 2 -source, and a 2-path t2(F) as right-hand side, its 2 -target. The notation F : s2(F) $ t2(F) stands for these facts.

Example 2.6 Let us consider a polygraphic program that computes, among other functions, the fusion sort function on lists of natural numbers. It has two 1-cells, nat for natural numbers and list for lists of natural numbers. Its other cells, apart from structure ones are:

Proof. Here we give a sketch of the proof, while the complete one can be found in [2]. We could use the fact that we can simulate rewriting systems which are Turing complete, but we give the explicit simulation as a first step to the proof of Theorem 4.9. Given a Turing machine, one defines:

Polygraphic interpretations have been introduced to prove termination of 3- polygraphs [6]. Here we use a restricted form to get properties on the complexity of polygraphic programs. In order to give some intuition, let us imagine that 2-paths are electrical circuits, crossed by currents going downwards, from the inputs to the outputs.

From these maps, one can compute the currents and heat produced by each 2-path. The original use was to find a polygraphic interpretation such that each reduction step replaces a 2-path by another one that produces strictly less heat. Here, the current maps will be used as approximations of the size of the computed values, while heat maps will estimate the number of computation steps remaining to reach a result: hence, current maps and heat maps will give bounds respectively on the spatial and on the temporal complexities of a polygraphic program.

Definition 4.1 Let P be a polygraphic program. If f is a 2-path of P, we denote by ||f|| the number of 2-cells f is made of. If F is a 3-path of P, we denote by |||F||| the number of 3-cells F is made of.

For the polygraphic program of example 2.4, one gets P(x, y) = x + y and P(x, y) = xy. Hence, the current maps give us information on the spatial com- plexity of the computation, separated from the length of computations.

Now we interest ourselves into polynomial bounds for the length of computations. We start by a technical lemma, which proves that, during a computation, the po- tential structure heat increase due to the application of a computation 3-cell is polynomially bounded by the size of the arguments. We recall that, by assumption, each computation 3-cell contains at most K structure 2-cells.

Example 4.6 For the polygraphic program of example 2.6 we have K = 1, S(x) = x2, S  (x) = x2 and S  (x, y) = (x+y)2. For the one of example 2.4, we have K = 1, S  (x, y) = (x + y)2 and S  (x, y) = x2y2.

Example 4.8 For the functions of example 2.6, we have Q(x) = 2x2, Q(x) = x and Q(x, y) = x + y. For example, let us fix a list t. The polynomial Q tells us that, during the computation of the sorted list (t), there will be at most ||t|| applications of a computation 3-cell. The polynomial R guarantees that there is no

Proof. We start by proving that functions computed by simple polygraphic pro- grams are in ptime. Proposition 4.7 tells us that the length of any computation in such a polygraph are polynomially bounded by the size of the arguments. Fur- thermore, each step of computation can be done in polynomial time with respect

