ming language. As the real world keeps changing, the software system that represents it needs to be continuously maintained and evolved. To develop and maintain such an evolving software system is obviously difficult. A well disciplined process and a good modelling notation are essential to control the activities in constructing and documenting the different models obtained at different stages of the software development. The Rational Unified Process (RUP) [32] has emerged as a popular software development process [33,38,31]. As the modelling notation, RUP uses UML [9], which is the de-facto stan- dard modelling language for the development of software in a broad range of application.

Section 2 briefly discusses the activities and UML models in RUP. We provide a summary of the main ideas of our approach in Section 3. Section 4 introduces an object-oriented notation that will be used in the proposed formal method. Section 5 shows the use of the specification notation in the specifi- cation of UML models. Instead of going into details of the formalization of UML, we will use a library system as an example to illustrate the treatment of models created in different cycles of the RUP. Finally, Section 6 concludes the paper with a discussion. The discussion on the relationship to existing work is given in Section 7.

a formal semantics and it is not expressive enough to describe many useful aspects of object-orientation, such as recursive method call, dynamic binding. In this paper, we will define an object-oriented specification language (OOL) that can be used to specify functional behaviour at different levels of abstract. The conceptual model is a class diagram consisting of classes (also called concepts), and associations between classes. A class represents a set of concep- tual objects and an association determines how the objects in the associated classes are related in the application domain. The reason why we call the class diagram conceptual at this level is that it is not concerned with what an object does, how it behaves, or how an attribute is represented. The decisions on these issues will be made during the design phase when the responsibilities

After the responsibilities of the objects are decided, the directions of the associations (i.e. navigation and visibility from one object to another) and the methods of the classes can be determined. This will lead to the construction of the design class diagram, which shows the static view of the design, i.e. how the concepts and associations of the conceptual class diagram are realized by software classes.

Refinement can also be used to justify steps of incremental design (e.g. those informally used in [33,38]), such as adding attributes, promoting attributes from a subclass to it superclass, encapsulating attributes, delegating function- ality of an object to its associated objects, etc. Such an integration of the refinement calculus with RUP makes the use of the design calculus more ef- fective in an iterative and incremental manner so that only a small model will be treated at each stage of an iteration.

and similarly pro(N ) and pub(N ). We use attr(N ) to denote the union of these three sets of attributes; and for an attribute u of N , we use dcltype(N.u) to denote the type of a and Init(N.u) the initial value of u declared in N .

where null represents the special object of the special class Null. Notice that expressions can appear as arguments of method calls, but we do not allow method call to be an expression as we explicitly use result and val-result parameters in methods. We can include more expression such as type casting (C)e and type test (e is C), but they are not needed in this paper.

visattr: its value is the set of attributes which are visible from inside the current class, i.e. all its declared attributes plus the protected attributes of its superclasses and all public attributes. This value will be modified by the whole declaration of the program and by variable redeclarations.

Assignments: There are two cases of assignments. The first is to (re-)attach a value to a variable. This can be done only when the type of the object is consistent with the declared type of the variable. The attachment of values

Method Call:  Let v, r and vr be lists of expressions. The command le.m(v, r, vr) assigns the values of the actual parameters v and vr to the formal value and value-result parameters of the method m of the object o that le refers to, and then executes the body of m. After it terminates, the value of the result and value-result parameters of m are passed back to the actual parameters r and vr.

Notice that we did not introduce the syntax super.m to explicitly indicate the call to a method according to its definition in the superclass. Instead the a method call will be executed according to the definition of method at the lowest position in the inheritance hierarchy. There is no difficulty to introduce super.m and define its semantics accordingly.

The informal identification and description of a use case is important for the creation of the conceptual model to support it. However, the formal specifi- cation of the use cases depends on the specification of the conceptual model. We have a canonical form of a use case specification by introducing a use-case handler class 2 . At any time during the execution, this class will only have a single instance. Considering the use case RecordCopy that adds a new copy of an existing publication to the library. We specify this use case by introducing a use case handler class LS (denoting the logic library system):

We can consider RegisterM independently from RecordCopy with its own conceptual model of classes Lib, M ember and the association Has. We then obtain CM2 by merging this model with CM1. If different names are used for the same concept, rename one to another.

The important nature of the integrated method is that each iteration is only concerned with a small part of the system functionality and a small model at a time. Instead of using a traditional compositional approach, we decompose the system informally according to use cases. We obtain formal models in each iteration and compose them to form a larger system step by step. We believe that this is important for scaling up the use of a formal method. A system developed this way is easy to maintain when the business rules change. For example, consider the need to impose the restriction on the use case BorrowCopy that a member is only allowed to take a limited number k of loans. We only need to add a method NBorrow() method in LS

Because our approach supports refinement of models by introducing mod- elling elements in an incremental manner, it clearly supports the Sketch and blueprint modes of UML usage pointed out by Martin Fowler in his invited talk at <<UML>> 2003 [19]. Also, our formalization of UML model in a specification in a Java-like notation can be seen as a step toward third mode of usage of UML suggested by Martin Fowler as a programming language. Being able to use UML as a programming language is very important for the success of MDA [19,6,42].

Cavalcanti and Naumann define an object-oriented programming language with subtype and polymorphism using predicate transformer [11,45]. Mikha- jlova and Sekerinski [44] design a rich object-oriented language by using a type system and predicate transformers as well. However, neither reference types nor mutual dependency between classes is allowed in those approaches.

In addition, tool support, e.g. in the direction of [23], for formal object- oriented methods is an area of considerable significance for further industrial take-up of these methods. We are also interested in studying the difference and relationship between our model and Separation Logic [49].

First of all, we are very much grateful to the two referees for their careful reading, insight comments and for the technical errors they pointed, that have helped a lot to bring the paper into this revised form. We thank Dines Bjorner at Technical University of Denmark, Anders Ravn from Aalborg University of Denmark and Uday Reddy from Birmingham University of the UK for their helpful comments and discussions at and after the seminars that the second author gave on parts of the works when he visited them. Our UNU-IIST fellows Quan Long, Bhim Upadhyaya and Jing Yang also read and gave useful comments on earlier versions of the article. The second author would also like to thank the students at the University of Leicester and those participants of the UNU-IIST training schools and courses who took his course on Software Engineering and System Development for their feedback on the understanding of the use-case driven, incremental and iterative OO development and the design patterns.

