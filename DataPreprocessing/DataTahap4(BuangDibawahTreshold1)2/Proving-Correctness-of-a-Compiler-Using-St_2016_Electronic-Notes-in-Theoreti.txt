In this paper we prove the correctness of a compiler for a call-by-name language using step-indexed logical relations and biorthogonality. The source language is an extension of the simply typed lambda-calculus with recursion, and the target language is an extension of the Krivine abstract machine. We formalized the proof in the Coq proof assistant.

Since the first proofs of compiler correctness appeared many years ago [20,21], there has been a considerable amount of progress in the topic. Of particular im- portance is the work of the CompCert project [17], a certified compiler for a large subset of the C programming language. In the case of functional languages we can mention [8] which is a certified compiler for the the simply-typed lambda calculus, and [4] where the source language is a call-by-value functional language, and the target is a variant of the SECD machine [16].

Hereafter we use the notation f e t to specify both the set defined by the grammar and our naming convention for meta-variables ranging over it. The first three constructors correspond to the lambda calculus with de Bruijn indices. The language also includes a fixed-point operator, integer constants, strict arithmetic operators, pairs and projections. The last constructor is a conditional projection. We choose this form of conditional for convenience, but a more familiar constructor of the form ifz t then t1 else t2 can be expressed as ifz t . (t1, t2). We write gn to represent any strict arithmetic operator with arity n > 0; operators are written in prefix position and cannot be partially applied.

Lemma 5.7 shows, this allowed us to make a nested induction when considering the case for rec t. If the source language were strong normalizing (i.e., by setting aside the fixed point operator), there would be no need to introduce the semantic chain and correctness would directly relate the compiled code with the semantics of the term.

All the results presented in this paper has been completely formalized in the proof assistant Coq (version 8.4pl6 with Ssreflect 1.5). The formalization is construc- tive, as we do not assume any classical axiom. We invite the curious reader to download [25] and explore the formalization as it complements the content of this article.

As future work we plan to extend the source language by enriching the type sys- tem and adding new constructors. For example, in [26] we proved the correctness of a compiler for a higher-order imperative language with respect to the big-step operational semantics of the source language; it would be interesting to obtain a re- lational proof of compiler correctness. We also intend to investigate the application of this technique to lazy functional languages targeting the Sestoft abstract ma- chine [28] or the STG machine [13]. We are also interested in applying the method to other models of execution closer to real assembly code.

