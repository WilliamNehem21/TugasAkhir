Most model checkers operate on models that are given in a low-level language that is developed for specifying hardware circuits rather than software. The development of software, however, should be supported by a high-level lan- guage that provides usual language facilities such as complex data types, and appropriate structuring mechanisms. When using model checking to support analysing software models, we have to provide a transformation from such a high-level language to the input language of a chosen model checker. Such a transformation has to bridge the gap between the di erent languages in a se- mantic preserving way that, moreover, avoids adding complexity to the model checking task as far as possible.

An outline of the paper follows: Section 2 and Section 3 introduce ASM and MDGs, respectively. In Section 4, we show our transformation from ASM into the graph structure of MDGs. Our model checking approach for ASM using MDGs is introduced in Section 5. We conclude this work with related and future work in Sections 6 and 7.

Abstract ASM. In order to exploit the support of abstract data types provided by MDGs, we introduce a syntactic feature to label any sort as being an abstract sort. In the example given above, we might change the sort TIME to be abstract.

Functions over abstract sorts do not have a xed interpretation. They allow for any interpretation that matches their signature. Abstracting from sorts is a means of lifting a \concrete" ASM model into an \abstract" ASM model whose instances comprise concrete models for all possible interpretations of the abstract sorts and functions.

Multiway Decision Graphs (MDGs) are a generalisation of Binary Decision Diagrams. They are a data structure for canonically representing formulas of a many-sorted rst-order logic, called Directed Formulas (DFs). A special feature of the underlying logic is the distinction between concrete and abstract sorts. Correspondingly, function symbols may be concrete, abstract (if the range is abstract), or cross-operators (if the range is concrete but the domain contains some abstract sort).

case the MDGs Pi represent the transition relation and E the set of state variables). Pruning-by-subsumption approximates the di erence of two sets. This enables us to check if an invariant (given as an MDG) is satis ed in a given set of states (also given as an MDG).

The transformation between the two notations is split into two steps. By in- troducing an intermediate language, called ASM-IL, we bene t from a general interface that can be reused for connecting other model checkers or state- transition-based tools. Due to the limitation of space, we give only a short overview of the transformation algorithm. A more detailed description can be

ASM into ASM-IL. Due to the fact that any set of ASM transition rules can be attened into a set of simple guarded update rules, we can fully represent ASM models { except models that contain import-rules 3 { as a set of location-update pairs. A location is a dynamic function applied to a value, which can change its value over a run (similar to a state variable). A location-update pair is a tuple of a location and its possible guarded updates, (loc; f(guard j ; val j) j 0   j   ng).  We gather this information for each

Transforming ASM into ASM-IL involves two steps: (a) unfolding dy- namic functions into locations if they occur as LHSs of updates (e.g., f (x) with x 2 fa; bg results in f a and f b) or substituting them by their pos- sible values otherwise; (b) attening all (nested) transition rules into simple guarded update rules over only one location. This way, we produce a lot of code. However, predicates can be resolved and simpli ed due to the partial evaluation in the rst step.

[XCS+98,Xu99] introduce a rst-order temporal logic, called LMDG, and cor- responding model checking algorithms based on MDGs. LMDG is the universal fragment (i.e., it excludes the existential temporal operator) of Abstract CTL*, a deviation of CTL* that has an additional construct for quanti cation of vari- ables.

LMDG is restricted to simple templates of formulas with temporal path operators (A, AG, AF, etc.) as given above and does not support nest- ing of those. Furthermore, the nesting of X in Next let formulas is lim- ited. These two restrictions enable simple checking algorithms for this lan- guage ([Xu99,XCS+98]): The Next let formulas occurring in a formula to be checked are represented as a circuit consisting of and-gates, or-gates, compara-

For model checking ASM models represented as MDGs, we can use the same model checking algorithms since they are based on the MDG library. However, we have to change the representation of Next let formulas. They must be transformed into simple ASM models consisting of some additional variables (and their initialisation) and simple guarded transitions rules which can be transformed into ASM-IL.

Uninterpreted functions are addressed elsewhere: In [BD94] data values and operations within the speci cation of the DLX architecture are modelled by means of uninterpreted functions. However, this approach allows only va- lidity checking, no temporal properties can be checked. [CN94] introduce a new logic, called GTL, which also allows uninterpreted functions to be rep- resented. The decidable fragment of GTL can be treated by an automatic validity checker (based on PVS). The logic LMDG, however, is more expres- sive then the decidable fragment of GTL (as proven in [Xu99]) and model checking algorithms go beyond validity checking.

Due to the support for abstract sorts in MDGs, the computation of the abstract model appears to be much simpler than the mechanisms suggested in, e.g., [GS97] and [BPR00]. Instead of providing an abstraction function and proving that properties are preserved, we generate with less e ort an abstract model that includes the intended model and more. This may result in false negatives, that is counter-examples that are not related to the particular instance of the model we want to check (in this case, it may be possible to add rewriting rules to exclude the non-intended interpretations), but if no counter-example can be found then all instances are correct.

OBDD-based tools), MDGs support a more compact representation of multi- valued data types (less state variables have to be introduced). Moreover, we gain simple support for generating abstract models by means of abstracting large or in nite data types. MDGs allow for representation of abstract values and functions, of which the latter are left uninterpreted.

[CCL+97] E. Cerny, F. Corella, M. Langevin, X. Song, S. Tahar, and Z. Zhou. Automated veri cation with abstract state machines using Multiway Decision Graphs. In T. Kropf, editor, Formal Hardware Veri cation: Methods and Systems in Comparison, volume 1287 of LNCS, pages 79{

[CW00] G. Del Castillo and K. Winter. Model checking support for the ASM high-level language. In S. Graf and M. Schwartzbach, editors, Proc. of 6th Int. Conference for Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2000, volume 1785 of LNCS, pages 331{346. Springer-Verlag, 2000.

