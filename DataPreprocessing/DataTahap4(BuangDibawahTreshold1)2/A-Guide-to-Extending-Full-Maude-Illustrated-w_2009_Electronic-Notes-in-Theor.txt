The goal of this paper is to serve as a practical guide for implementing extensions of Maude by giving an overview of how the Real-Time Maude tool has been developed by extending the implementation of Full Maude. After giving a high-level summary of the key functionality and structure of the implementation of Full Maude, we describe the implementation of the Real-Time Maude language and tool. This extension includes key issues such as adding new kinds of modules, rules, and commands; as well as the need to store additional information in the persistent state of the execution environment.

The success of Maude [4] in modeling and analyzing concurrent systems has in- spired, and will continue to inspire, extensions to different kinds of systems (such as real-time [23], probabilistic [1], (stochastic) hybrid systems, etc.), as well as new analysis techniques for ordinary and extended Maude specifications (such as induc- tive theorem proving [7], narrowing analysis, TLR model checking, timed analysis, probabilistic analysis, etc.). The goal of this paper is to serve as a practical guide for implementing extensions of Maude by showing how the Real-Time Maude tool [23] has been developed by extending the implementation of Full Maude [4].

The Maude system provides powerful meta-programming facilities that allow us to develop execution environments for a wide range of languages and logics with much less effort than using conventional programming languages [5]. An early use of these facilities was the implementation of Full Maude, a language that extends Maude with support for object-oriented specification and advanced module opera- tions. The implementation of Full Maude includes code for parsing user input and pretty-printing; storing modules, theories, and views; transforming object-oriented modules into system modules; and so on. Therefore, you essentially have two choices for implementing in Maude an extension of Maude:

Our belief that extensions of Maude can be conveniently built by extending the implementation of Full Maude has been underscored by the more recent development of tools that have followed this approach. They include: the Church-Rosser and coherence checkers for Maude [13,9,6], the Maude MSOS tool for modular structural operational semantics [3], the automated circular coinductive prover CiRC [20], the strategy language proposed in [21], and the implementation of membrane systems in [2]. In addition, parts of the infrastructure provided by the implementation of Full Maude has been exploited to implement tools also for formalisms that are not extensions or variations of Maude, such as the LOTOS tool by Verdejo [26]. It is worth mentioning that there are also formal tools for Maude, written in Maude, that are not implemented on top of Full Maude, such as the ITP [7] and the SCC [17].

not intend to give a general methodology on extending Full Maude, but provide a guide based on our experience. The choice of Real-Time Maude is motivated by the fact that it is a mature and significant extension of Full Maude that includes additional module syntax and many new analysis commands. This paper assumes familiarity with the Maude language, including the features of its meta-level.

As for the reasons for not wanting to extend Full Maude: Regarding (i), the implementation of Full Maude is indeed hard to grasp. It is the aim of this paper to give an overview of that implementation and provide a good starting point for extending it. Detailed information on it is provided in [12,8].

Regarding (ii), one main problem with Full Maude has traditionally been its lack of robustness. Small errors in specification or command often resulted in a blank line and the need to restart the whole Full Maude session without getting any information about the source of the error. However, Full Maude makes it possible to make your implementation quite robust and to provide good diagnostic error messages without ending your Maude session, as shown in this paper.

To gain invaluable understanding of the different aspects of writing an interpreter, and of the Full Maude implementation, we have found it a very useful exercise to write from scratch an interpreter for a very small subset of Maude, for example using the fragment and techniques in [4, Sections 17.1 to 17.4].

Real-Time Maude therefore extends Full Maude by providing: a library of pre- defined modules (e.g., for time domains) that should be available for importation by user-defined modules; new kinds of modules and rules (tick rules); and additional analysis commands. Furthermore, the tool must store certain additional data, such

term of sort Term, and returns its representation as a list of quoted identifiers. We could manipulate this term TI directly. However, it is simpler and more appropriate to transform this term into another term in some data types Module, Command, etc.

Of course, we not only want to give some command or module expression with some arguments and get some result. We also want to interact with the system, entering modules, theories, views, and commands of different types. Therefore, we need to be able to store modules, theories, and views in a database, so that they can be referred later to evaluate module expressions and commands. The specification of Full Maude includes a data type Database for the database of modules, theories, and views. If not explicitly given, most commands are supposed to be executed on some by-default module, usually the last entered module. We need to keep track of such by-default module as part of the persistent state of the system.

The parsing accomplished in the in rule only deals with the top-level syntax, the input can still contain errors. Some of these errors may be detected when the different declarations in the module are analyzed, but others will have to wait until the signature is completed and the bubbles can be processed. To report on these errors, one of the components of the Database constructor will keep such messages. The DATABASE-HANDLING module includes the following rule, which takes a message (a QidList) from the eighth argument of the db operator, and puts it in the output channel of the DatabaseClass object.

Notice that all objects in the rules handling the database are given using a variable of sort DatabaseClass as class, and they all include a variable Atts that grabs any additional attributes of the object. This allows defining subclasses of class DatabaseClass to add additional attributes to the persistent state in a very straightforward manner, as explained in Section 5.5 for Real-Time Maude.

The evalPreModule function first normalizes the structure of the module, by calling the normalize function, and then all the subunits in the structure are collected. A single flattened module is built with all the subunits in the structure, which is then used to create a first version of the signature in which all the bubbles in the top pre-module are parsed using the solveBubbles function. The final version of the signature and the flat unit are generated once the bubbles have been parsed.

The procRew function processes the rewrite command. After parsing the bubbles in it, the metaRewrite function is invoked. The function solveBubblesRew does the heavy lifting of solving the above problems, and returns a tuple consisting of: the module in which the command is to be executed, the term to be rewritten parsed in the module above, the bound on the number of rewrites (unbounded if the command was not of the form rew [n] ...), and finally the set of variables in the module in which to execute the command. 8 From this tuple (TMVB), we can get the term, module, and bound, and do the actual rewriting by calling the Maude descent function metaRewrite:

The approach is the same as for rew. First, recompile the current module if necessary, then use solveBubblesRew to extract the module in which the command is to be executed, the term representing the initial state, and the bound on the number of rewrites. In addition, we must parse the bubbles representing the time limit and the current tick mode in the module we just found. When all this is done, the command is executed by calling the function timedMetaRewrite, which is the timed version of the function metaRewrite and is defined as an ordinary Maude function on Maude meta-modules and meta-terms.

In this paper, we have given a practical guide to significantly extending Full Maude, drawing on our considerable experience in developing different extensions and ex- plaining them to others. We have given a high-level overview of the structure and the main functions and modules of the large and complex implementation of Full Maude. We have illustrated how to extend this implementation by outlining the implementation of the Real-Time Maude tool. Real-Time Maude extends the syn- tax supported by Full Maude by adding real-time modules and theories, tick rules, and a variety of commands for manipulating and analyzing real-time systems.

