We show explicitly how five refinement relations, taken from the refinement literature, are instances of our general model. Henceforth, since they are specialisations of a general model, we call these instances special models. We show these theories of refinement are special models simply by fixing the sets of contexts and observations involved in appropriate ways.

In Section 2 (and in a companion paper [31]) we define our general model without fixing a specific operational semantics, thus allowing our general model to give rise to a wide variety of special models. A well-known spe- cific operational semantics that our general method can incorporate is (state- based) relational semantics and another is (event-based) labelled transition semantics. Any one of these particular incorporations can be specialised fur- ther, so, as examples, CSP [18] interprets the events in its labelled transition system semantics as handshake events, whereas CBS [26] interprets the events in the same labelled transition system as broadcast events.

Because of the very wide variety of examples we wish to consider our general theory must be quite abstract. In particular we do not wish to fix, at the general level, the operational semantics of its components. What we will concentrate on in the general model is the nature of the interfaces between the components and the rest of the system.

Readers familiar with definitions of refinement may be wondering why we need both contexts and users seeing as the roles these two systems play is normally played by a single system. The reason we need both contexts and users is that in some situations two interfaces, each with distinct properties, are needed. Details will follow in Section 2.3.1.

Note that the informal notion of refinement as presented earlier in this section talks about not only the entities involved in the refinement, but also the observations a user can make of them. Also, since the user, in order to make observations, must presumably use the entities they must have been placed in some contexts (e.g. programs which call the operations the entities provide). We should be careful when formalising refinement not to lose track of, or throw away, these contexts and observations.

An example of an interactive entity is a coffee machine. To obtain two cups of coffee the user first inserts a coin, then pushes the appropriate button and takes the first cup of coffee. But if after inserting a second coin the vending machine now fails to terminate the previously successful interactions mean that what has been observed cannot be represented by noting non-termination alone. (We still have our first cup of coffee!)

This section looks in some detail at particular ways that determinism has been treated in various places. It will turn out that determinism has a crucial role when we look at refinement of processes in later sections. Indeed, these sections, having introduced refinement, mainly concentrate on determinism and its role. When we consider that making progress towards more and more deterministic processes is a large part of what refinement for processes means, this is not so surprising. Also, because we build a general model that permits us to compare determinism from different special points-of-view we can see determinism in a very wide perspective.

Restricting the domain of the relational semantics to D , written )D , means that an entity E is deterministic in D if and only if E)D is a function. We choose to view deterministic entities as implementations. The meaning of a specification can be given by the set of implementations that satisfy the specification and with this interpretation it is again reasonable to view refinement as completing a semantics for specifications (see [17] for details and discussion).

We will consider examples of determinism where E is: one, an ADT with interaction via method calling (Section 4.2, Section 4.1); two, a process with interaction via output enabled broadcast (Section 5.1); and three, a state- based operation with interaction via shared memory (Section 6). In all of these three models of interaction our definition of determinism is the same as, or differs in uninteresting ways from, definitions of determinism found in the literature. A difference does occur, though, when we consider process algebraic, handshake-style interaction in Section 5.3.

an interactive program-user interface in Section 4.1. These constitute two distinct types of programs, transactional programs and interactive programs. We assume the program-ADT interface to be interactive and private, i.e. it cannot be observed by the user. We further assume that the successful termi- nation of the program can be achieved only if the ADT operations never fail to terminate. Thus if an ADT operation fails to terminate then the program

It can be seen that applying Definition 3.2 to picks out the same set of ADTs as being deterministic whether we apply Definition 3.2 to ADTs that can be placed in interactional program-user interfaces or ADTs that can be placed in transactional program-user interfaces.

We will classify processes, as appearing in the literature, into two types. The handshake processes of CSP, CCS and ACP treat all events in the same way, i.e. give all events the same semantics. The broadcast processes have two types of events, the active output events that cause the passive input events. The broadcast output event differs from all other observable events that we model in that it is under local control, i.e. it cannot be placed in a context that blocks its execution.

Since we are no longer dealing with transactional interfaces, we need make no distinction between context and user in what follows. Further, there is no longer any distinction between entities and contexts, in the sense that for any context []X, X is also an entity. Both entities and contexts are simply processes.

i.e. a listener cannot block a multi-way radio message from being broadcast nor can a receiver block a point-to-point email message from being broad- cast, whereas with handshake-style communication all events can be blocked. The only difference between our handshake and broadcast models will be that broadcasts cannot be blocked by any context and both will model point-to- point communication.

P! can broadcast either b! or c!. As broadcast output is under local control no other process can block either of these events. Hence it seems unavoidable that we consider P! to be non-deterministic. Yet clearly P! and MBC (P!) are deterministic transition systems according to the informal DFA characterisation.

Clearly there is a mismatch between our intuitions on the one hand and the DFA characterisation on the other hand. Because of this mismatch we turn to the DET characterisation. Unfortunately as entities and contexts are the same type of thing DET cannot be turned into a definition (recall Section 3) but having defined a set of deterministic broadcast processes we can check they satisfy Det-Cond .

It is common in the literature on handshake events ([18,32,24,5]) to treat events that synchronise in exactly the the same way, and not differentiate between the events of Rob and the events of VM. It is our intuition that the events of a vending machine VM are passive and the events of a robot Rob are active and cause the passive events of VM to occur, just as a program causes a method of an ADT to be executed. We view the active events as causing the performance of the passive events, but unlike broadcast events, and like programs and ADT, we do not have local control of the active events. Thus we allow the active events to be blocked by a context. The active events are written with the name over-lined (e.g. a) and the passive events with no over-line (e.g. a).

As the active events of IBP are the calling of a method (or the causing of a passive event) we model it as committing, i.e. once started the caller cannot back off but is blocked if the passive event cannot be executed.

We can easily transform the relations above into state-to-state (partial) relations by simply removing the redundant pre-state from the observation. Thus {(y, (y, x))} becomes {(y, x)}. This operational semantics is that used in ISO Z [1] (hence the subscript we have been using) and is silent as to whether the operation terminates or not.

