Concurrent Constraint Programming (ccp) is a model for concurrency where agents interact with each other by telling and asking constraints (i.e., formulas in logic) into a shared store of partial information. The ntcc calculus extends ccp with the notion of discrete time-units for the specification of reactive systems. Moreover, ntcc features constructors for non-deterministic choices and asynchronous behavior, thus allowing

2. Section 3 describes our approach to represent symbolically the behavior of ntcc processes. We prove that the symbolic model can be obtained for any process in a finite number of steps (Theorem 3.6) and also that our construction is correct with respect to the operational semantics (Theorem 3.9). In Section 3 we also present some examples to show how to compute the symbolic model of a process. Section 4 describes the logic that we shall use to specify properties and Section 5 shows how the symbolic model can be used in standard (symbolic) model checking algorithms. We conclude in Section 6 by pointing out to related work and briefly describing a prototypical tool implementing our methodology.

The ntcc calculus [16] extends ccp with time-units for the specification of reactive systems, i.e., systems that continuously interact with the surrounding environment. In this language, time is conceptually divided into discrete intervals (or time-units). Intuitively, in a particular time interval, a process P receives a stimulus (i.e., a constraint) from the environment, it executes with this stimulus as the initial store, and when it reaches its resting point, it responds to the environment with the resulting store. The resting point also determines a residual process Q, which is then executed in the next time interval.

The process P  Q represents the parallel composition of P and Q. The process local x(P ) behaves like P , except that all the information on x produced by P can only be seen by P , i.e., x is a local variable of P .

RASK and RSTAR). Our approach is then to use (temporal) formulas as a compact representation of the reachable states (i.e., stores) of a process. As we shall see, the proposed formulas capture the observable contributions (i.e., constraints) that processes can make to the final store; additionally, the internal (unobservable) tran- sitions are symbolically captured by logical connectives. More precisely, we shall follow the steps below:

As shown in [16], the process ?P resembles the eventually modality ( ) in LTL. Then, the states generated by this process can be characterized as the least fixpoint of the disjunction of a state where P holds and a state where P holds in the next time-unit. Similarly, the process ! P resembles the always ( ) modality in LTL. Then, the generated states correspond to the greatest fixpoint of the conjunction of a state satisfying P and a future state where P also holds.

Proof. The proof is a direct corollary from: (1) [22, Theorem 4.12] that shows that the output of P can be characterized by a finite subset of C (which is not necessarily finite); and (2) [22, Lemma 4.13] that shows that the number of different states P may generate is also finite. Hence, since the number of possible reachable states is the LTS L(S(P )) is finite, the fixpoint computation must terminate.	 

Example 3.7 (Control System) Assume a simple control system that must emit the signal on in the next time-unit when the environment reports a given signal signal in the current time-unit. Otherwise, it must emit the signal off in the next time-unit. This can be modeled as the process

Constraint Temporal Logic (CLTL). Since ntcc processes manipulate con- straints, it is reasonable to think that system properties must be stated in a logic able to deal with constraints. Hence, we shall use CLTL [16], a Linear Time Tem- poral Logic [14] where atomic formulas are constraints. Formulas in propositional CLTL are built from the grammar below:

DDDs share a large number of features with BDDs. As BDDs, DDDs need to be ordered and reduced, but in the case of DDDs, it is more difficult to obtain a canonical representation of the boolean formula. To deal with this problem, in [15] the authors propose the use of path reduced DDDs, with the aim to obtain a semi- canonical data structure, thus reducing the complexity of handling constraints. In fact, most of the operations on DDDs run in constant time.

In Section 3 we saw how to build a symbolic model which is a compact representation of the behavior of a ntcc process. In Section 4 we recalled the CLTL logic able to express temporal properties of ntcc processes. The last step is to use standard techniques from symbolic model checking to verify if a process satisfies a given property. This is done by combining the model of the system and the formula to be proved. In the following we give the relevant details to perform this step.

Recall from Section 4 that the satisfiability problem of CLTL can be reduced to the same problem in LTL. Moreover, as it was shown in [5], the model checking problem for LTL can be solved by reducing it to the symbolic model checking problem for Computation Tree Logic (CTL) [9] with fairness constraints. Then, we can use all the machinery and tools developed for CTL model checking to verify programs written in ntcc.

We implemented a tool in Ocaml (http://ocaml.org) to execute our verifica- tion process automatically. The power of functional programming, the compilation process and the type system of Ocaml, made possible to quickly develop such pro- totype. Moreover, we provide to users a more friendly way for writing programs in ntcc by parsing their syntax with ocamllex and menhir.

We do not describe the implementation of our tool in depth here in order to give a higher priority to the technical aspects of our approach. The reader can find the details of the implementation as well as the execution of the examples described in this paper at http://www.labri.fr/perso/jarias/symbolicMC.

Future work. Symbolic techniques in model checking aim at reducing the space and time needed to verify a given property, thus allowing for dealing with more complex systems [4,19]. However, the state explosion problem is unavoidable. In fact, the model checking algorithm for LTL is linear in the size of the model but exponential in the size of the formula to be verified. To mitigate this situation, we plan to provide tools for abstract debugging that allow the programmer to quickly find problems in her design before attempting the verification of more precise desirable properties. For that, we may rely on the abstract interpretation frameworks for the analysis of ccp programs that have been proposed in the literature (see e.g., [1,7,11,23]). Our idea is to use an abstraction of the constraint system in the lines of [11] in order to reduce the number of states generated by our technique.

