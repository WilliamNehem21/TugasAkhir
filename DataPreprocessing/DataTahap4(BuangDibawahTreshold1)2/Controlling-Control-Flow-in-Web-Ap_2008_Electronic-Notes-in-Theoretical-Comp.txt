Previous solutions used continuations as a model for user interaction. However continuations are insufficient as a model of all web interactions. We believe the protocol and browsers themselves are insufficiently powerful to represent the control flow desired in a web application.

We discuss how some of these ideas may be implemented within the existing HTTP/1.1 protocol; and what modest extensions to the protocol would enable full implementation. We also discuss the interaction with Web 2.0 and the security and privacy implications of our extensions.

The web was originally designed as a read-only, hypertext medium for publishing structured documents [5]. Since then, it has evolved, seemingly at random, to become one of the predominant user interface systems currently in use. Web servers have become more powerful and quickly moved from providing read-only access to files to now providing write access to databases, stock markets and shipping companies. Similarly, web client software has not stood still and has added such things as opening multiple windows, tabbed browsing, cookies and bookmarking. An increase in collaboration between web users has also led to a desire to share links that will continue to work for the foreseeable future.

Many of these things exhibit bad feature interactions with each other. Feature interactions were first described by Dworak et al. in relation to telephone systems [7]. Since then, feature interactions have been found in most complex software systems. In our case, the features of the web browser and the web application are the source of the interaction. To give some examples:

The web application uses cookies to create the impression of a stateful proto- col. However, the user has opened multiple browser windows, and so generates responses that the application misinterprets. For example, opening two win- dows containing products in an online store and clicking buy on the first one to be opened may result in the second one being bought. Added to this, are two browser windows the same as two tabs in the same window? 3

We look practically at how these extensions may be implemented, both within the current protocol, and also as extensions to existing browsers. Finally, we exam- ine how these enhancements interact with Web 2.0, and what security and privacy implications they have.

Web applications can be seen from this perspective, however, there are a number of conceptual and implementation differences. We naturally consider the web ap- plication to be the server. If we consider the client to be the web browser, then the clients are no longer orthogonal, since a user can and will open multiple browser win- dows within the same application. This is the main conceptual difference between web applications and classical client-server applications.

Many web applications are developed using the Model-View-Controller (MVC) pat- tern [11], which is designed to help decouple user interfaces from the logic of the application. In the MVC pattern, the application is divided into a model, which holds all the data of the application, and one or more views, which provide user interfaces to the model. The controller manages creation and destruction of the model and the views, and coordinates input from the views into the model. The controller is also responsible for serialising access to the model by the views. Use of this design pattern in web applications, for example the Apache Struts frame- work [4], usually considers most of the code running on the server as the model and controller, and the view as the HTML pages sent to the client.

One problem with this use of the MVC pattern is that the controller is often marginalised and does not really exist at all. Without a controller, the MVC pattern essentially degenerates to the client-server model described above. However, the MVC pattern is a good way to think about how web applications should be written. The model is a good match to the server and the data on the server, and the concept of the view matches well to the browser windows, each describing a portion of the model. Where then is the controller? We believe the controller should be seen as part of and implemented on the browser, coordinating multiple views of the same application. This is a good abstraction, but is not perfect because it does not allow the controller to moderate access by different users to the same part of the model. Generally, web applications use optimistic concurrency control or no concurrency control at all, so it is not really a problem that the controller is per-user instead of per-model. It is certainly better than the current solution, which has one controller per view, since integrating the controller with the view is the same as having no controller at all.

Views in the MVC pattern observe the model, and update themselves when the model changes. This is typically done by the model notifying the views when it changes. This is not possible with HTTP, so the user must manually refresh the views when they know something has changed, or the views must poll the model.

Not shareable The user is informed that this link cannot be shared publicly. Optionally, the application may provide a link to the user which will take them to a part of the application where they can acquire a link that is sharable. Such a link may have to be paid for, or may have a time limit, extra advertising, or other restrictions.

There is already a standard for specifying supplemental links from a page [1, sec. 12.3]. A standard for naming alternate bookmark and sharing links would need to be created and then browsers could use these elements to support the functionality described.

Being informed of window closing would be very useful, since it would allow any pending actions to be reverted or saved so the user can continue from where they left off when they return to the application. This is especially important in a Web 2.0 application since there is likely to be a larger amount of uncommitted user data than in an ordinary web application.

We also feel there is more to be done in separating the Model, View and Con- troller in Web 2.0 applications, and while Web 2.0 has made it possible to view new data without downloading the View again (i.e. to update the Model), it would also be good if the View could be updated without that necessitating the Model also being reloaded.

The extra features we define in Section 3 are not designed to increase the security of web applications. In fact, their use could lead to careless programmers making web applications less secure. For example, programmers may assume that certain actions can not happen, when in fact they have simply asked the browser for them not to occur, something which could easily be circumvented. We hope to address this in the future by having a framework by which servers can enforce constraints, like unclonable, that are advised to the browser.

Additionally, these features have an impact on user privacy. However, this im- pact can be minimised in two ways. Firstly, each distinct web application (defined as the domain part of the URL) could be treated distinctly by the browser. For example, a different set of window identifiers could be used for each domain. This would prevent a user being tracked across multiple applications, even if the applica- tions themselves are collaborating to try and see, for example, which users are using both applications. Only elements of a page fetched from the domain of the current web application would be given access to these extra features, which would restrict abuse. Secondly, in order to use these extensions, a server would send metadata saying this page was part of a web application with a certain base URL (which would need to contain at least the full domain of the page). The browser could then ask users whether they are willing to treat this site as a web application.

