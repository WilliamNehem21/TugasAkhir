We study one of the many aspects of privacy, which is referred to as data anonymity, in a formal context. Data anonymity expresses whether some piece of observed data, such as a vote, can be attributed to a user, in this case a voter. We validate the formal treatment of data anonymity by analyzing a well-known electronic voting protocol.

parties, being able to observe that the resource or service is being used. Informal definitions, as the above, are essential for the understanding of the different notions of privacy, but will only allow to investigate a system informally. In addition to [31], informal definitions of anonymity are given in [34,16,42].

When considering other systems (e-voting systems for instance) one wants to prove that some piece of information (a specific vote) cannot be related to its originator (i.e. the voter). In other words, the originator of data must be kept secret. This property is called data anonymity here. In order to reason about data anonymity we need a model where it is not only possible to reason about the occur- rence of events but where it is also possible to reason about the information within an event. In other words, a more sophisticated model is needed than the models introduced in [46] and [37]. In this paper we will concentrate on data anonymity

As already mentioned, data anonymity plays an essential role in voting systems. Electronic voting systems aim to provide a convenient, efficient and secure facility for recording and tallying votes. E-voting can be used in order to realize elections at a small local scale such as share holder meetings to full-scale national elections. Lipmaa [36] discerns two instances of e-voting: kiosk voting (voting in some fixed location using special hardware) or Internet voting using generally available devices,

accuracy (1) It should not be possible to alter votes. (2) It should be impossible to cause a situation where a valid vote is not taken into account. (3) On the other hand, an invalid vote should not be counted in the final tally.

Our formalization of the FOO voting scheme exploits an ACP style process algebra [5,23,7]. In the modeling of [35], the anonymous channel is not made explicit. In the applied pi calculus, every channel is anonymous unless input and output can be explicitly linked. By explicitly modeling the anonymous channel here, we take the opposite stance. Therefore, we can formally show that the level of data anonymity of the FOO voting scheme depends on two items: (i) the behaviour of

This paper is organized as follows. In Section 2 we provide a formal definition of data anonymity. In Section 3 we describe and specify the FOO voting scheme. Sec- tion 4 provides a characterization of anonymity of voters in the FOO voting scheme in terms of attribution sets, whereas Section 5 presents the resulting vulnerability analysis. In Section 6 we discuss conclusions and future research.

The idea behind tagging is that different bit strings in different runs of the system can represent the same encrypted information. The difference can be due to non-essential phenomena, in particular a different choice of nonces in the other run. The identification of bitstrings does not make sense within the same system run where different bit strings represent really different data.

The protocol describes the communication between an administrator, a number of voters and a counter. The role of the administrator is to check if the voter is eligible to vote and to sign the (blinded) ballot of the voter. The role of the counter is to collect all (anonymous) ballots and to publish them.

Therefore, after verifying the signature of the administrator, the voter can de- duce scb, which is his committed ballot signed by the administrator. After this, the role of the administrator ends and the voter communicates to the counter. Messages sent from the voter to the counter go via an anonymous channel, so that the identity of the sender of the messages cannot be retrieved.

The voter sends his committed ballot cb and its signed version scb to the counter, who verifies that it is indeed signed by the administrator. He stores the received information from all voters in the list L1 and after all voters have voted (or after some deadline has passed), he publishes this list. Every voter can now verify that his committed ballot is in the list and sends the key to open the committed ballot to the counter (again using the anonymous channel). The counter opens the ballots and finally publishes the second list L2, containing all open ballots.

Note that we only explained the main line of the protocol. We did not specify exactly what happens if one of the checks fail due to an attempt to disrupt the voting by one of the participants. The interested reader is referred to [25] for the details.

Next, we provide a formal specification of the FOO voting scheme in process algebra (see, e.g., [5,23,7]). This process algebra allows us to give a compact and formal specification of the set of all traces of the FOO voting scheme. However, it should be noted that, our treatment of anonymity is not tied to any particular specification formalism, as long as it supports reasoning about traces.

We strive to obtain a minimal specification by leaving out all exceptional be- haviour. Having understood the informal description of the protocol in the previous section, the formal algebraic specification is relatively easy to read. However, we will explain some of the intricacies of the design decisions that we made.

The precise description provided by Theorem 4.2 is a starting point to look for ways to influence the privacy of the voter beneficially. In order to avoid the situation that votes are being submitted to the counter while voters are still able to register, Fujioka, Okamoto and Ohta suggest, as modeled in [35], to synchronize the registration, sending and opening of ballots of voters. However, the authors of [25] make not explicit which synchronizations are essential. The same applies to the privacy analysis that is part of [35].

One can distinguish three phases in the voting process: all registration takes place before any sending of ballots; openings are sent only after all votes have been sent in. This can be arranged by having explicit time lines. Looking at our specification, we find two places where synchronization may be implemented. The first way to synchronize affects the behaviour of the voters: they will have to wait until a certain deadline has passed before they submit their vote to the anonymous channel. After this deadline they will not try to register anymore. Disadvantage, when elections take place at a large scale, is that voter processes span a relatively large time frame. This may be undesirable from a usability point of view if such is at the responsibility of each individual voter. Therefore, as our formal specification facilitates, it is better to have the synchronization at another place, viz. to have the anonymous channel in charge for this. The anonymous channel specified above already starts producing output while still accepting input. One can adapt the

(Further details to deal with time or voter counting have been suppressed here.) This implements a synchronization point and solves the problem. Note that, the solution boils down to the plain old ballot box which may only be opened for counting after collection of the votes.

As is to be expected, the increased anonymity without a two or three phase vot- ing regime comes at a price. The anonymous channel needs to be trusted, not only for prudence when dealing with private information as before, but also regarding the very outcome of the election. Obviously, the channel can cover the number of votes for any option on its part and open this after the votes have been collected. The net outcome will then be the grand total per option minus the number of dummy votes for this option. However, there is a priori no guarantee that the channel will deliver the votes it commits itself to, as long as there is no control mechanism in place for this. It is conjectured that zero-knowledge techniques can help here, a topic for fur- ther investigation. It is noted though, that the formal description of the attribution set as given by Theorem 4.2 has catalyzed the above line of reasoning, that is, to our best knowledge, not conceived before.

One of the drawbacks of a formal verification is the fact that it considers a for- mal object, rather than an actual implementation. While implementing the protocol many decisions have to be made, e.g. with respect to the actual cryptographic prim- itives. A concrete cryptographic algorithm may have certain properties, which in a particular setting could be used by an intruder to his advantage. In the FOO voting scheme anonymity of the voter essentially depends on the unlinkability between two events: the sending of a blinded committed ballot to the administrator and the sending of the committed ballot (and its corresponding key) to the counter. Now, if the implementation allows an observer to link these events, anonymity is breached. Such vulnerabilities could e.g. be introduced by naive use of a probabilistic sign- ing algorithm or by including network information of the voter in the payload of messages and thus to travel unmodified through the supposedly anonymous channel.

In case a Public Key Infrastructure is adopted when implementing the FOO vot- ing scheme, then also possibilities might emerge for linking the blinded committed ballot bcb to the committed ballot cb. More specifically, one could think of an im- plementation of the FOO voting scheme where the administrator sends the signed blinded committed vote to the voter together with its public key and corresponding certificate. The certificate was created by the Certification Authority (CA). The voter can check the validity and integrity of the received public key by checking the corresponding certificate.

If the CA is not strictly separated from the administrator, then an attack is possible in the following way: The administrator generates a public/secret key pair for each voter and asks the CA to generate a certificate for each public key. The administrator signs the blinded committed ballot of each voter with a different secret key. He sends the signed blinded committed vote together with the corresponding public key and its certificate to the voter.

Another problem might arise if the administrator adopts a group signature scheme. Group signatures, see e.g. [15], denote a signature scheme where each member of a group can generate a signature. The receiver (i.e. the voter in our case) cannot find out what group member generated it. When the administrator uses a group signature scheme he can act as a specific group member. Thus he has got the possibility to generate a signature specific for a certain voter. This leads to a link between the blinded committed ballot and the committed ballot.

In principle, a flooding attack might be possible in the presence of malicious and conspiring voters, affecting the availability of the system. However, if the system is synchronized in any of the two ways indicated above, conspiring agents can hardly influence the privacy of other agents. In order to model conspiring voters, we extend the initial intruder knowledge with the ballots, keys and nonces of the malicious voters. Repeating the calculation of the attribution set with this extended intruder knowledge will give a reduction of the attribution set as the ballots from the conspiring voters can be identified and deleted. We will not provide these calculations, since they are a straightforward extension of the case without

observations of an intruder. It can be considered a measure for the data anonymity of the user. If, for some system, this attribution set can be calculated in an explicit form, it will give insight in the vulnerabilities of the system and it can be used to strengthen the protocol.

The analysis of the FOO voting scheme clearly supports our view. Not only did it show how an intruder could try to break anonymity, it also showed that a synchronization point would solve the problem. We indicated two possibilities for such a synchronization, one of which was not considered by the designers of the FOO voting scheme. Our analysis also revealed some other possible weakness. If the communication from the publisher process to the voters is compromised, the intruder can manipulate this in such a way that at least one vote can be attributed to its voter. Furthermore, a weakness occurs if the administrator can manipulate the distribution of his public signing key.

Our work can be extended in several directions. First of all, our specification only considered the main operation of the protocol: whenever an unexpected sit- uation occurs, the involved agent will simply deadlock. In the original description such exceptions are treated in a more meaningful way. However, we think that such exception handling is not essential for reaching privacy, but to satisfy other properties. A second extension, as mentioned above, is to consider a Dolev-Yao intruder modeled as a first-class citizen, instead of an eavesdropping intruder as in the present setting. Our current analysis hints at system flaws in this setting, but further work on modeling synchronization is needed to make this precise. A last promising point for follow-up research is to look for zero-knowledge mechanisms for a secure injection of dummy votes, so that the attribution set of all voters can be maximized without putting unnecessary trust in the anonymous channel.

