Modeling concurrent systems and testing multi-threaded implementations against the model is an exciting field of study. This paper presents work done on constructing and executing test cases for an industrial- size multi-threaded application against a model written in the Creol modeling language. Models written in Creol, an object-oriented, concurrent modeling language, can be structurally similar to the finished implementation; we show how to keep this desirable property when re-using Creol models as test oracles. Also, a conformance relation between model and system under test that needs less controllability than other relations that are based on automata is presented.

Formal testing of single-threaded programs can rely on a rich body of theory and industrial experience [11,19,10]. Formal testing of multi-threaded or distributed systems, on the other hand, is still an open area of research. This paper presents work on modeling a concurrent system and testing the system against the model.

We verify our testing approach through a case study based on ASK, an industrial software system for connecting people to each other via a context-aware response system. A substantial part of the ASK implementation, which is mainly written in C, has been modeled in Creol. The ASK system is inherently multi-threaded and uses asynchronous communication.

The rest of the paper is organized as follows: Section 2 presents some related work in the area of formal testing, followed by a presentation of the Creol modeling language in Section 3. Section 4 presents the ASK system, the case study that we use in Section 5 to present our approach in detail. Finally, Section 6 gives conclusions and discusses possible future work.

In our application, however, the components are coupled asynchronously. Input actions emitted from the environment are put in a queue. They are processed in any order determined by the implementation, emitting input events. A test verdict is reached by observing the input events interleaved with output events.

Each object has its own object-internal (and not further specified) scheduler. In a standard setting, there are no assumptions that can be made about the order of process execution. (For an approach to add schedulers to Creol objects, see [16]) Only one process per object is active at a time. Creol processes do not use preemp- tion. Instead, explicit conditional suspension points (in form of await statements) are used to release a process and allow another process to execute. Cooperative scheduling might be inefficient for a production language, but has great benefits for modeling. Because scheduling points are explicit, race conditions can often be found

The aforementioned properties of Creol make the language well suited for mod- eling distributed systems. Typically, an object represents one module of the system, where modules communicate through clearly defined interfaces. Methods are anno- tated with a co-interface, allowing both the restriction of the possible callers to the method and a way of call-back using the caller variable. The prove statement and invariants on methods allow for checking conditions during runtime.

where l is the label (future variable) of the call. The l? statement to wait for the return values is blocking, which means the process is not released and no process in the caller is executed until the called method returns. To release the process while waiting for a method to finish, the statement await l? is used. A blocking method call can be implemented by calling the method and immediately waiting for its return. The code in this paper mainly uses the syntactic form

The ASK components have been implemented in C. Each component is itself multi- threaded. The threads act as workers in a thread-pool, which execute tasks put into a component-wide shared task queue. Within a single component, threads do not communicate with each other directly. However, they can dispatch new tasks in the task queue, which are then eventually executed by another or the same thread. Threads are also able to send messages to other components. Incoming messages for a component are received by a thread executing a special hostess task, which continually checks for incoming messages and dispatches tasks accordingly. In most of the components, the amount of threads can change over time, depending on the amount of pending tasks in the task queue and the amount of idle threads.

In testing, we initiate a run of the SuT (System under Test) and check if the resulting run behaves as expected. For synchronous systems, this can be done by building a test graph, which relates inputs given to the SuT with the outputs returned from the SuT. Depending on the outputs, new inputs can be selected to reach a certain goal in the test graph.

An action is a stimulation to SuT and model, while an event testifies that some- thing happened in the system. E.g., a method call from the tester is an action, the start of execution of that method is a related event. Because of the asynchronism of our systems, several events might occur between a method call (the action) and its execution (the event). Likewise, the order in which methods are executed might be different from the order of the calls.

A test is successful if the model successfully handles the same trace as the imple- mentation and if all assertions and invariants in the model are true. If an assertion in the model is violated, the model itself has an inconsistency and is in error; no verdict about the implementation can be reached. If the tester deadlocks when run in parallel with the model, the implementation violates the test assumption and the test fails. If the tester runs to completion, the test passes.

