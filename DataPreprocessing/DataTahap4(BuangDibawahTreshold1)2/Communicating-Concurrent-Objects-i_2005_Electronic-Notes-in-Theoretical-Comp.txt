In this paper we add value-passing communication to hiddenCCS, a new formalism proposed in [2] for synchronizing concurrent objects. We use hidden algebra to specify object-oriented systems, and CCS process algebra to describe the coordination aspects. The new specification formalism extends the object specification with synchronization and communication elements associated with methods and attributes of the objects, and use a CCS description of the interaction patterns. The operational semantics of hiddenCCS specifications is based on labeled transition systems which can be specified in rewriting logic. We use Maude as a platform for verification of the communicating concurrent objects specified in hiddenCCS. Triple Modular Redundancy is used as an example of a hiddenCCS specification and its verification in Maude.

We extend the algebraic specifications of hidden algebra with two ele- ments of interaction, namely with synchronization and communication ele- ments. Synchronization elements link two objects whenever one is asking for a resource, and the other can offer such a resource. Communication given by a method accessing an attribute is similar to a value-passing interaction from the object having the attribute to the object having the method. The formal operational semantics of hiddenCCS integrates model semantics of hid- den algebra and CCS reduction rules by using these elements of interaction. The resulting labeled transition systems are translated into rewriting logic specifications using the Maude implementations of CCS and Hennessy-Milner logic. We use the Maude implementation of the linear temporal logic to verify properties of the hiddenCCS specifications.

The structure of the paper is as follows. Section 2 briefly presents hidden algebra. Section 3 briefly presents CCS. Section 4 includes the main contribu- tions: we introduce the new hiddenCCS specifications, and present some theo- retical results. Then we show how the operational semantics of the hiddenCCS specifications is described in rewriting logic and how the Maude system is used to verify temporal properties of hiddenCCS specifications. Conclusions and references end the paper.

Elements of synchronization given by pairs (a, a) denoting the necessity and availability of the shared name a. Both a and a denote behavioral methods in different object components; the invocation of these methods expresses the necessity and the availability of a (it does not matter which one). An element a is called closed synchronization for B iff both a and a are present. If only one (either a or a) is present, then we have an open synchronization. Let Synch(B) denote the set of the synchronization elements of B.

Elements of communication given by pairs (a, a) denoting the receiving and sending of a value along the communication channel a. Now a de- notes a behavioral method and a denotes a behavioral attribute; the value supplied by the attribute is passed to the second component as an argu- ment of the calling method. A communication channel a is called closed communication for B iff both a and a are present. If only one element of a communication pair (either a or a) is present, then we have an open com- munication. Let Comm(B) denote the set of the communication elements of B.

We use the BOBJ language (http://www.cs.ucsd.edu/groups/tatami/bobj/) to ex- press the behavioral specifications. We enrich the BOBJ syntax by adding the synchronization capabilities by synch attributes of the corresponding meth- ods, and the communication capabilities by comm: ~a and comm: index ->

a. The index in comm: index -> a is used to identify the receiving com- ponent linked to the corresponding comm: ~a. Our extension of the BOBJ language uses ~a to denote a. We consider methods receiving along at most a single communication channel. However the attributes may send values along more than one communication channel.

op rec1 : Voter Data -> Voter . [comm: 1 -> mo1] op rec2 : Voter Data -> Voter . [comm: 1 -> mo2] op rec3 : Voter Data -> Voter . [comm: 1 -> mo3] op val : Voter -> Data .    [comm: out]

ceives a value along in, passes this value along ~mi1, ~mi2, ~mi3, and waits for an acknowledgment along ack. The voter receives data along mo1, mo2, mo3, and sends the majority value along ~out; then it sends an acknowledg- ment along ~ack. The effective actions are made by the operations behind these synchronization and communication elements.

In our formalism, we provide a computational structure to the CCS ac- tions, and it is enough to consider pure CCS to model the synchronization and communication between concurrent objects. According to the computa- tional structure behind each action, it is possible to decide the type of an interaction. The synchronization elements are provided by pairs (a, a) with each component associated with a method; in this way we have a method- method interaction. The communication elements are also provided by pairs (a, a); however, now a is associated with an attribute, and a is associated with a method.

~ mi3 . ~ mi1 . ~ mi2 . S2 + ~ mi3 . ~ mi2 . ~ mi1 . S2 ) & ( S2 =def ack . S ) & ( M1 =def mi1 . w1 . ~ mo1 . M1 ) & 

The object-oriented features of hidden algebra add a new dimension that is missing in other approaches including LOTOS [1], a formalism combining a dynamic part based on CCS and CSP with the algebraic specification language ACT ONE. Another formalism with a high level of abstraction is presented in [15]; it combines CCS with the Common Algebraic Specification Language (CASL). In hiddenCCS we have a clear concern separation that allows a better reuse of the coordination and objects than in [15].

