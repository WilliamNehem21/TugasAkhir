In this paper we illustrate some of the ways in which rewriting strategies can be used to separate the de nition of program transformation rules from the strategies under which they are applied. Doing so supports the generic de nition of program transformation components. Fusion techniques for strategies can then be used to specialize such generic components.

We show how the generic innermost rewriting strategy can be optimized by fusing it with the rules to which it is applied. Both the optimization and the programs to which the optimization applies are speci ed in the strategy language Stratego. The optimization is based on small transformation rules that are applied locally under the control of strategies, using special knowledge about the contexts in which the rules are applied.

In conventional program optimization, transformations are applied through- out a program. In optimizing imperative programs, complex transformations are applied to entire programs [12]. In the style of compilation by transforma- tion [3] | as applied, for example, in the Glasgow Haskell Compiler [14] | a large number of small, almost trivial program transformations are applied throughout a program to achieve large-scale optimization by accumulating small program changes. The style of optimization that we develop in this pa- per isa combination of these ideas: Combinea number of small transformation steps using strategies that will apply them to speci c parts of a program to achieve the e ects of complex transformations. Because the transformations are local, special knowledge about the subject program at the point of appli-

The remainder of this paper is organized as follows. In Section 2 we ex- plain the basics of Stratego and introduce the generic Stratego speci cation of innermost reduction. We present an optimized version of this strategy in Section 3. In Section 4 we show how the optimized speci cation of innermost can be derived from the original speci cation. Section 5 presents the Stratego implementation of the optimization rules from Section 4. Section 6 concludes.

Stratego is a language for specifying program transformations. A key design choice of the language is the separation of logic and control. The logic of pro- gram transformations is captured by rewrite rules, while rewriting strategies control the application of those rules.

In this section we describe the elements of Stratego that are relevant for this paper. We illustrate them with a small application which simpli es expressions over natural numbers with addition using a generic speci cation of innermost reduction. A complete description of Stratego, including a formal semantics, is given in [16].

Rewrite rules express basic transformations on terms. A rewrite rule has the form L : l -> r, where L is the label of the rule, and the term patterns l and r are its left-hand side and right-hand side, respectively. A term pattern is either a variable, a nullary constructor C, or the application C(p1,...,pn)

A rule L: l -> r applies to a (ground) term t when the pattern l matches t, i.e., when l has the same top-level structure as t. Applying L to t has the e ect of transforming t to the term obtained by replacing the vari- ables in r with the subterms of t to which they correspond. For exam- ple, rule B transforms the term Plus(Succ(Zero),Succ(Zero)) to the term Succ(Plus(Zero,Succ(Zero))), where x corresponds to Zero and y corre- sponds to Succ(Zero).

In the normal interpretation of term rewriting, terms are normalized by ex- haustively applying rewrite rules to a term and its subterms until no further applications are possible. The term Plus(Succ(Zero),Zero), for instance, normalizes to the term Succ(Zero) under rules A and B. But because normal- izing a term with respect to all rules in a speci cation is not always desirable, and because rewrite systems need not be con uent or terminating, more care- ful control is often necessary. A common solution is to introduce additional constructors into signatures and then use them to encode control by means of additional rules which specify where and in what order the original rules are to be applied. Programmable rewriting strategies provide an alternative mechanism for achieving such control while avoiding the introduction of new constructors or rules.

A strategy de nition f(x1,...,xn) = s introduces a new strategy oper- ator f parameterized with strategies x1,...,xn and having body s. Such de nitions cannot refer (directly or indirectly) to the operator being de ned. Instead, all recursion must be expressed explicitly by means of the recursion operator rec.

The strategy combinators just described combine strategies which apply trans- formation rules to the roots of their subject terms. In order to apply a rule at an internal site of a term (i.e., to a subterm), it is necessary to traverse the term. Stratego de nes several primitive operators which expose the direct subterms of a constructor application. These can be combined with the op- erators described above to de ne a wide variety of complete term traversals. For the purposes of this paper we restrict the discussion of traversal operators to congruence operators and the all operator.

This rule is not valid for all strategy expressions. Consider a term t for which x and y both succeed, (x;z) fails, and (y;z) succeeds. Then (x + y); z will fail if application of x is attempted. By contrast, (x;z) + (y;z) will always

We can now apply bottomup(r) to the term built in the right-hand side of each rule. Using the notation <s> t to denote !t; s, i.e., to denote application of the strategy s to the instance of t determined by the current bindings, we get

if v is a variable originating in the left-hand side of a rule. That is, if vs contains all variables occurring in l, v is in vs, and {vs:?l;!r} is a strategy, then occurrences of <bottomup(r)>v in r can be replaced by v itself. This observation is valid because terms matching variables from the left-hand side of a rule are already in normal form.

Although this observation relies on non-local information, it does give rise to a transformation which is local in the sense that it is applied only within a single strategy, i.e., that is applied (locally) to a selected part of a program under the control of a strategy. Using it, we arrive at the desired optimized version of innermost(A+B):

can be implemented in Stratego. We start by de ning the abstract syntax of Stratego programs. We then add overlays to abstract over speci c pat- terns in the abstract syntax that occur often in the rules. Next, we formalize the rules used in the derivation as Stratego rules. Finally, we combine these rules into a strategy that optimizes occurrences of the innermost strategy in Stratego speci cations. The optimization works for all strategies of the form innermost(R1 + ... + Rn) with arbitrary rules Ri.

We want to optimize certain speci c patterns of strategy expressions. Since we do not want to rely on the names chosen for those patterns by the spec- i cation writer, we need to be able to recognize the structure of patterns. Because encoding patterns using abstract syntax expressions can lead to large unmanageable terms, we use the Stratego overlay mechanism to abstract over them.

rules. The propagated marks make it possible to distinguish normalizing rules from local rules in the normalizing strategy. Note that it is an additional constructor that is used to convey information from one transformation to the next. Although strategies often make it possible to avoid additional construc- tors, they are sometimes still needed.

Finally, BottomupToVarIsId removes the applications of Bottomup(_,r) to variables in the right-hand sides of marked rules provided these also occur in their left-hand sides. The rst local rule of BottomupToVarIsId uses tvars to record those variables occurring in the left-hand side of a normalizing rule. The second then removes applications of Bottomup(_,r) to occurrences of these variables in the right-hand side of the normalizing rule by means of a local traversal of that right-hand side (rhs).

which removes the application of Bottomup(_,r) to Var(v). It uses the con- dition <fetch(?v)> vs to determine whether or not the variable v to which Bottomup(_,r) is applied appears in the left-hand side of a marked rule, i.e., is in the list of variables vs. The strategy isr is passed to the rule by the fusion strategy, and indicates whether or not r is indeed the recursion vari- able. This ensures that only the desired applications of Bottomup(_,r) are removed.

Strategies have also been used to optimize programs which are not them- selves de ned in terms of strategies. In [6], for example, they are used to elimi- nate intermediate data structures from functional programs. In [16], strategies are used to build optimizers for an intermediate format for ML-like programs. In both cases, strategies are used | as they are here | in conjunction with small local transformations to achieve large-scale optimization e ects.

Small local transformations have been dubbed \humble transformations" in [14]. Such transformations are used extensively in optimizing compilers based on the compilation-by-transformation idiom [8,9,1,13]. They are also used to some degree in most compilers, although not necessarily recognizable as rewrite rules in the implementation.

The importance of optimizing term traversals in functional transformation systems is discussed in [10]. Term traversals are modelled there by fold func- tions but, since the fold algebras under consideration are updateable, standard fusion techniques for functional programs [17,11,18] are not immediately ap- plicable. The fusion techniques presented here may nevertheless provide a means of implementing optimizations which automatically shortcut recursion in term traversals. If, as suggested in [10], shortcuts of recursion in term traversals should be regarded as program specialization then, since special- ization can be seen as an automated instance of the traditional fold/unfold program optimization methodology [7], optimization of traversals should in- deed be achievable via fold/unfold transformations. These connections are deserving of further investigation.

[15] E. Visser. Stratego: A language for program transformation based on rewriting strategies. System description of Stratego 0.5. In A. Middeldorp, editor, Rewriting Techniques and Applications (RTA'01), volume 2051 of Lecture Notes in Computer Science, pages 357{361. Springer-Verlag, May 2001. 1

