In this paper, we present our study on a triple modular computer system from the aerospace field, which is designed to compute the course of action that other subsystems take and output the result to other subsystems. This work is based on our early experiment and improvement on a design originally given to us by the practical engineer. In the experiment, we analyzed the drawbacks of the design, and suggested a design that provides more effective fault-tolerance. In the improvement [6], we endow each component of the system with more functions. Then we give a formal model of the improved system using a network of timed automaton [9] in UPPAAL [10]. The detailed C code specification can be easily read and translated

However, UPPAAL does not support parameters so we need to instantiate the parameters for some values in different hardware environments to check whether or not T is fulfilled. In our current work, we improve on the above results in two ways: (1) we find constraints on the parameters that ensure satisfaction of property T ; (2) we prove manually with the parametric constraints, the system satisfies the correctness property. Therefore, rather than verifying the correctness of the system for a single, specific choice of parameter values like in UPPAAL, we derive (by hand) general constraints on the parameters which ensure correctness and give the correctness proof. Such technique has been applied in other case study, such as lego car system [12].

As shown by our earlier work, the system falls into the case of the big state space problem [13,14].To make the testing and verification with fixed parameter values practically feasible, several abstraction techniques have been applied in the modeling previously. Still the same for the manual proof in our current paper, there is no interconnection between any two of the CPUs, and each voter can independently judge whether its corresponding CPU needs a restart. Thus, the properties T of the system can be described and manually proved by working on a simplified version of the system with only one CPU, one voter and one arbitrator.

The remainder of the paper is organized as follows: Section 2 presents the orig- inal triple modular redundancy system and an improved version of the system, focusing on the augmented functions of the voter and the arbitrator. With a net- work of timed automata, Section 3 gives a formal model of the improved system in UPPAAL. Section 4 presents the correctness properties that we want to prove, the constraints needed for their validity. Section 5 roughly gives the correctness proofs. Finally, Section 6 concludes the paper.

As a CPU starts, it first enters a reset phase and stays there for a period C before it enters a startup phase, in which it may stay for maximally a period of RUB time. In other words, from the time when CPU jumps to startup phase till the time when it is in working status, the period lies in the interval [0, RUB]. In the hardware design, the voltage change of a special pin from the CPU illustrates this procedure: the voltage value stays in the low level (0) for a period C before it is changed to the high level (1). We use a Boolean array flag to denote the value of pin voltage of the CPUs. Thus, the fact that flag[i] is 0 implies that CPU i is in the reset phase, and it is in the startup phase or working status otherwise.

A CPU receives various sampling data as its inputs and computes results as outputs. Let cpu voter fifo[i] denote the buffer that stores the output of CPU i, that can be read by its voters. After receiving a synclk xms impulse at some time t, all the three CPUs start to execute the following actions simultaneously.

process their inputs simultaneously. The purpose to have two of them is to avoid the voter as a single point of failure that reduces the overall fault tolerance behavior of the system. We use a boolean variable voter status to describe if a voter is faulty or not, where 1 indicates the voter is faulty. In our later model, to reduce system behaviors, we assume all the voters are not faulty. This assumption will not alter the checking results of the interested properties.

After the startup phase, CPU[i] stays in Idle to wait for a CPU synchronization impulse. In reality, the CPU has its own real state: the non-faulty state and the faulty state. In the case of the non-faulty state, the CPU kicks its watchdog with the timer set to RWD, where we use a transition surrounding Idle to indicate that. For the faulty case, it ceases doing this. As a result, the watchdog timer settles in Idle and will reach the limit WD UB with the time being elapsed, which forces the automaton to restart. Each outgoing transition from location Idle to Reset denotes a restart phenomenon. Once a synchronization impulse synclk xms occurs, that is, when a synclk xmx ? transition occurs, The CPU may either transit to location Processing

Whenever the watchdog timer overflows or receives a dsp restart[i]? sig- nal from the arbitrator, CPU[i] will switch to Reset without time delay, and set flag[i] to 0. This occurs in any of the active locations: Reset, Startup , Idle and Processing. The fact that dsp restart[0]? being an urgent channel ensures the transition is taken immediately as it is enabled. The location Nopower in the automaton designates that CPU[i] has a permanent fault and is turned off. From any of the locations, except for NoPower, CPU[i] transits to NoPower immediately after it detects that the arbitrator has decided this CPU has a permanent fault, i.e. demotion[i] == 1.

The automaton Arbitrator resides in Idle initially, whenever synclk x9mx is issued; that is when a synclk x9mx ? transition occurs, it jumps to location Processing and stays there non-deterministically in the interval [0, ARBI PERIOD). It then switches to Idle by completing the function arbitrate(). We use a lo- cal boolean variable restart flag by arbi[i] to express if CPU[i] needs to restart judged by automaton Arbitrator.

Verification of the above model in UPPAAL reveals that both watchdog and arbitra- tor can trigger a CPU to restart. This can solve the problems proposed in section 3. However, we also found unpleasant scenario regarding a CPU restart. Since there is no information intersection in between any two CPUs, and each voter independently judges that whether or not there exists a CPU restart, in the following section, we use a product automaton of these four automata: CPU[0], Voter[0], Arbitrator and Impulse to describe the phenomena, the parametric constraints and the proof.

As described before, there are a number of key timing parameters in the system: the time period CPU PERIOD between synclk xms and synclk 5xms impulse, the time period VOTER PERIOD between synclk 5xms and synclk 9xms impulse, the time pe- riod ARBI PERIOD between synclk 9xms and synclk xms impulse, and the impulse cycle T. In addition to these, there is also the parameters n1 and n2, the reset time C, the upper bound RUB in CPU startup phase. These parameters have been set to different values and have been shown to influence the above property greatly.

Lemma 4.1 Function fault check() of Voter[0] will judge that CPU[0] needs a restart or not, CPU[0] is normal or not, ect., and is executed in the transition of Voter[0] from location Processing to location Idle. The transition is labeled as

S. Gnesi, G. Lenzini and F. Martinelli. Logical specification and analysis of fault tolerant systems through partial model checking. In: Proceedings of the International Workshop on Software Verification and Validation (SVV 2003), December 14 2003, Mumbai, India. pp. 57-70. Electronic Notes in Theoretical Computer Science 118.

