program and verify reactive systems. There are several different approaches: graphical languages based on automata (Statecharts [14], RSML [22], Sync- Charts [2], Argos [25]), data- flow based languages (Signal [21], Lustre [13]), imperative languages (Esterel [5], Reactive C [8]), ..., but all of them are based on the synchrony hypothesis. The adoption of this hypothesis (which says that the reaction time of the system is zero), helps the developer to specify reactive systems.

We use the term distributed reactive system to define a set of reactive nodes connected one another by means of a communication network. Each node have a specific function to perform autonomously, but they have to share information to do it. So distribution has to be given at specification level.

Synchronous Estelle is an extension of the ISO Standard Estelle. Estelle is a Formal Description Technique standardized by ISO, designed to specify distributed systems. An Estelle specification consists of a set of modules and a set of channels to communicate one another by means of exchanging messages. One module can be divided into several modules in order to develop the system in a structured way. The behaviour of each module is represented by a finite state machine, where the transitions between states are triggered

Synchronous Estelle supports both textual and graphical specification. The textual specification of this kind of modules has a very similar syntax to Standard Estelle, to make it familiar to Estelle developers. This syntax has a direct relationship with the graphical specification. This allows us to use a graphical representation in early stages of development, and a textual language to complete implementation details.

The header declaration should include the name of the module, the inter- action points with the rest of the specification and the interaction points with the environment. Interaction points with other modules are maintained to use the usual message passing mechanism to communicate the module with the rest of the system (other systemsynchrony or Standard Estelle modules). In- teraction points with the environment are an easy way to connect the system and the rest of the world. Three types can be distinguished, depending on the

The body declaration is made apart, as said before. In it we can declare constants, types, variables, procedures and functions in the same way it is done in Standard Estelle. We can also declare new modules, which will represent compound states in the global state machine 3 . Transitions between modules represent transitions between states. Inter-level transitions are allowed. Each transition have an enabling condition and a guard. The first one is a logical expression of events (where de presence of an event is treated like true and its absence like false), while the guard is a Pascal-like logical expression. When both are computed as true the transition is said enabled. Finally, a module can be tagged as parallel.

The system execution (for this kind of modules) is divided into a set of computations steps, which are also divided into micro-steps. A step begins with the arrival of a set of messages from other modules and events from the environment; then all the messages are dealt with generating, eventually, a set of events. These, together with environmental events, are the input for the first micro-step. These events will enable some transitions. Incompatible transitions will be eliminated from this set. Every transition of the resulting set will be shot (the enable transition with higher priority will be the first one), making the system to change its state, and, eventually, to generate more events. When all transitions are been shot, the next micro-step begins. This process goes on until one micro-step can not begin because there is not any enabled transition. Now external signals are sent to the environment and messages are sent to other modules, finishing the step. Algorithm 1 shows the implementation of the computation step.

Each synchronous module runs asynchronously in parallel with the rest of the modules of the system. The interaction between synchronous modules and the rest of the system is performed only at the beginning and at the end of the computational step. At the beginning of the step all messages arrived to the synchronous module are processed, usually to generate internal events. At the end of the step all external signals generated inside it are sent through external interaction points.

System response time is supposed to be zero (due to synchrony hypothesis), but in fact it will take some time. All events received during one step will be dealt with in the next step. All events that have not been dealt with during one step are ignored. This behaviour is similar to Statecharts one, but it differs from SyncCharts semantics.

The interpreter represents all the information of the original specification for each reactive module within a C program. All the structural informa- tion (states, substates, transitions, etc) is included with data structures, but maintaining the original hierarchical information. An execution engine that implements the semantics of the system, as has been seen in section 2.2, is added to this program.

The transformation is not a simple process, because every state and every transition has to be treated, eventually, several times. Every code of each state or transition has to be modified, too. In [27] a complete description of how to perform the transformation is done.

It is important for a language like Synchronous Estelle to have some kind of tool to perform properties verification of the specification. Now we are working in verifying Synchronous Estelle specifications, using SPIN. Instead of building a new model checker from scratch, we are trying to use SPIN [16], an automated verification tool (model checker) that uses PROMELA (PROcess MEta LAnguage) as system specification language, in a similar way to what we have done before using SPIN to verify SA/RT Models [29]. Our intention is to translate the Synchronous Estelle Specification to PROMELA in order to use SPIN to verify the original system. A translator from Synchronous Estelle to PROMELA is under development for that purpose.

using a single-slot buffer of signals. The global behaviour of the system is asynchronous, because communication is not instantaneous, so each FSM sees that the reaction time of the other FSMs is not zero. The POLIS [3] design environment uses a GALS model (CFSM - Codesign Finite State Machines), where each node is developed using Esterel synchronous language.

All modules in POLIS are synchronous; a Synchronous Estelle specification can be made up of synchronous modules and Standard Estelle modules. This kind of modules has a different structure and semantics, and have been mainly used to specify network protocols. This different approach can be interesting in some circumstances, and we can reuse existing protocol specifications when the network behaviour is important for the global system performance.

OcRep [10] deals with distribution from a different point of view. With OcRep where the whole system is compiled in only one module. This module contains the code that every node of the distributed system has to execute. The idea is to distribute this program to every location, according to distribu- tion directives given by the user, and then remove on each node the code that is not relevant to it. Communication and synchronization will be automati- cally done, too. This approach offers a centralized compilation and debugging before the distribution. The advantage of this approach is that supposedly the distributed program has the same safety as the centralized one.

The steam boiler is a typical example of a reactive system. There is a set of sensors (water level, steam rate, state of the pumps) and a set of actuators (four pumps, one valve). According to the values measured by the sensors, the system has to react opening or closing the pumps or the valve to keep the water level in a safe value. The controller has to respond as soon as possible to avoid the boiler damage, even when one component of the boiler fail.

We have used this problem to test the Synchronous Estelle language and related tools. We will specify every physical part of it and the controller itself as different synchronous modules, while the communication network will be specified with a Standard Estelle module. All the synchronous modules will be connected to the network module to exchange information. Modules representing physical parts of the system are connected with the environment too, in order to get information or to send commands. All messages emitted by the physical units are sent to the control program. The messages emitted by the control program are sent only to one physical unit.

The first step in our specification is to define the main modules of the system and the interconnection channels between them. All the channels will connect every module with the network module. This module has to route every message to the proper destination. The declaration of the channels is very simple: it only enumerates the messages that can travel through them.

The behaviour of the physical units is really simple: sensors send period- ically read values to the control program, while actuators send signals to the environment to change the state of some physical unit (pump and valve). The modules dealing with the physical parts of the system have to manage the er- rors, too. When the system control program detects a failure in some physical part of the system it will send a message to notify the failure. The controller of this part then stops the normal behaviour until the device is repaired: Any message received will be ignored, and no message will be emitted until the physical device is repaired. Then, the physical device will notify this event to its controller, which will report it to the system controller.

The core of the steam boiler program is the Control module. This module represents all the logic of the system: it has to accept read values of system parameters (water level, steam level, state of the pumps) and it has to decide what to do in each moment to maintain a safe water level. The controller has to deal with potential failures of the physical units too. Therefore this is the most complex module of the specification. It is constituted by four submodules that run in parallel:

All those modules (states) are decomposed in more complex state ma- chines. To give an idea of the complexity of the control module we can say that it has 160 submodules, 154 transitions and 52 Estelle transitions. Be- sides states and transitions the specification should be completed with pieces of Pascal code to define the actions to perform when the transition fires or when an state is entered or exited.

A very simple protocol has been used in this first approach (messages are sent to their destination without any further considerations). More complex and real protocols can be used to study real systems, but in this paper we are only interested in studying the applicability of Synchronous Estelle to distributed reactive systems, not in a real, efficient and fault tolerant specifi- cation. Further refinements of this first work can improve and complete the specification to become more robust.

