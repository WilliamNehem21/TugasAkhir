[5] for graph grammars without object-oriented features. However, besides building the translations for inheritance, polymorphism and dynamic binding features, we also do the translation based on a well defined observational semantics [7] which interprets object-oriented graph grammars computations from the object-oriented paradigm view. This article is structure as follows: Sec. 2 presents the main com- ponents of object-oriented graphs and grammars. Sec. 3 presents the guidelines followed for the definition of a formal translation from object-oriented graph gram- mars specifications into Promela programs, followed by an example shown in Sec. 4. The running example is a classic problem in the theory of concurrency, known as the Dining Philosophers problem. Final remarks are presented in Sec. 5.

Object-oriented systems consist of instances of previously defined classes having an internal structure defined by attributes and communicating among themselves through message passing. An object-oriented system state consists of objects, together with a set of messages yet to be consumed. Messages are the triggers of method executions, and their implementation may be redefined within derived classes. Classes and messages are modeled together in a class-model graph. Form- ally, class identifiers are graph nodes, attributes are modeled as hyperarcs (that is, each class may be connected to many others via an attribute hyperarc), and messages are also modeled as hyperarcs (in which the target is the destination of the message, and sources are its parameters). The inheritance hierarchy is defined by imposing a strict relation among the graph nodes. A strict relation is an irre- flexive, acyclic, functional relation, with the additional property that there is no infinite chain of elements connected through it (the reflexive and transitive closure of a strict relation is a partial order [7]). Message hyperarcs also possess an order

Class-model graphs can be used as typing structures for states of object-oriented systems. Before defining such states, which will be object-oriented graphs, we will define how to map a graph into a class-model graph, and then impose restrictions to make this mapping compatible with inheritance. Based on the inheritance and over- riding relations, we define auxiliary functions that, given a class identifier (node), return the sets of attributes (inherited or not) of this class, and the sets of messages (method triggers) that this class may receive.

sage typed as Thinking. However, since its parent class Philosopher has those arcs connected to it, they can be connected to any derived object, thus allow- ing inheritance of elements. To see that, consider the attribute isAt of the right-handed philosopher Kant. The edge it is mapped to by the typing morph-

A graph morphism is a mapping which preserves hyperarcs sources and targets. A typed graph morphism also preserves (node and edge) types. Ordinary typed graph morphisms [3], however, cannot describe correctly morphisms on object- oriented systems because the existing inheritance relation among objects causes that actions available for objects of a certain kind are valid to all objects derived from it. So, an object can be viewed as not being uniquely typed, but having a type set (namely, the set of all types it is connected via the inheritance relation). Defining a graph morphism compatible with the underlying order relations assures that polymorphism can be applied consistently.

observations. This semantics holds information about events happening in a system (message exchange among objects), and forgets about system structure. Therefore, although we are not able to express properties based on object states, we are still allowed to investigate properties of objects based on how they respond to the rules applied to them. The abstract semantics is given by a labeled transition system where its states are the graphs generated by rule applications in the grammar, and the transition between two states is labeled with the name of the rule applied together with the object identity the rule was applied to.

Rule application can be described as: (i) object attributes are modified accord- ing to the rule morphism; (ii) a global variable event RuleName is set with the applied production name; (iii) the set of variables event x, for all classes to which the type of the production attribute vertex is related by inheritance, are set to the object identity; (iv) finally, all messages appearing in the right-hand side of the applied production are created, and it is particularly relevant, since it is this pro- cedure which performs dynamic binding. Steps (i) to (iii) are performed without generating intermediate states, to assure correctness of property verification. If no rule is applied (because no match were possible for any production implementing the received message), then the message is put back in the local buffer, and marked as inspected. An already inspected message will not be retrieved for application until a new message arrives. Since only an object can change its own state, a match for this message could only happen after another production is actually applied. This procedure also helps to decrease the program state space for the verification process.

The translation proposed is arguably semantically sound, in the sense that no graph system behaviour is removed or introduced by the translation. Even if there are states in the Promela program that do not correspond to any graph belonging to the grammar language, those states can always be translated if they are not part of a rule application procedure. If they are, they cannot interleave with any other process execution, since rule application is performed atomically, and hence it suffices to leave the atomic block for the Promela state can be translated to a graph state. A formal proof of this translation soundness is being prepared for publication. Finally, we have used a modeling for the Dining Philosophers problem to illustrate how verification can be performed, and how errors can be found using our approach.

