back to CORBA, DCOM, J2EE and IBM WebSphere, the most successful instan- tiation of the SOC paradigm are probably the more recent web services. These are sets of operations that can be published, located and invoked through the Web via XML messages complying with given standard formats. To support the web service approach, several new languages and technologies have been designed and many international companies have invested a lot of efforts.

Current software engineering technologies for SOC, however, remain at the de- scriptive level and lack rigorous formal foundations. We are still experiencing a gap between practice (programming) and theory (formal methods and analysis tech- niques) in the design of SOC applications. The challenges come from the necessity of dealing at once with such issues as asynchronous interactions, concurrent ac- tivities, workflow coordination, business transactions, failures, resource usage, and security, in a setting where demands and guarantees can be very different for the many different components. Many researchers have hence put forward the idea of using process calculi, a cornerstone of current foundational research on specification and analysis of concurrent, distributed and mobile systems through mathematical

By taking inspiration from well-known process calculi and from the standard language for orchestration of web services WS-BPEL [22], in [17] we have designed COWS (Calculus for Orchestration of Web Services), a process calculus for spec- ifying and combining service-oriented applications, while modelling their dynamic behaviour. We have shown that COWS can model and handle distinctive features of (web) services, such as, e.g., correlation-based communication, compensation activities, service instances and interactions among them, race conditions among service instances and service definitions.

In this section, we present COWS main features and syntax in a step-by-step fashion while modelling an Italian-English translation service. By means of this scenario, we discuss some verification problems and present the major intuitions underlying the symbolic operational semantics for COWS. For the time being, we use a monadic variant of COWS, i.e. we assume that invoke and receive activities can carry one single parameter at a time. In fact, for the sake of presentation, the symbolic semantics is introduced for the monadic variant in Section 4, and is then extended to polyadic communication in Section 5.

Applying the symbolic approach to COWS. The main contribution of this work is the development of a symbolic operational semantics for COWS. To achieve this goal, the main issue is to give receive activities a proper semantics, because variables in their arguments are placeholders for something to be received. For example, let

COWS (Calculus for Orchestration of Web Services, [17]) is a recently designed pro- cess calculus for specifying, combining and analyzing service-oriented applications, while modelling their dynamic behaviour. COWS combines in an original way a number of ingredients borrowed from well-known process calculi, e.g. asynchronous communication, polyadic synchronization, pattern matching, protection, delimited receiving and killing activities, while resulting different from any of them. In this section, we present the standard syntax and operational semantics of COWS. We re- fer the interested reader to [17] for many examples illustrating COWS peculiarities and expressiveness, and for comparisons with other process-based and orchestration formalisms.

First, we exploit a function [ ] for evaluating closed expressions (i.e. expressions without variables): it takes a closed expression and returns a value. However, [ ]] cannot be explicitly defined because the exact syntax of expressions is deliberately not specified.

We also define a function, named halt( ), that takes a service s as an argument and returns the service obtained by only retaining the protected activities inside s. halt( ) is defined inductively on the syntax of services. The most significant case is halt({|s|})= {|s|}. In the other cases, halt( ) returns 0, except for parallel composi- tion, delimitation and replication operators, for which it acts as an homomorphism.

Actions: n [n] denotes execution of a bound invoke activity over the endpoint n, while n D [x ] denotes taking place of external communication over the endpoint n with receive parameter x (that will be replaced by the unknown value x). The remaining labels have the usual meaning. Notably, due to the restraint on monadic communication, here the natural number l can only be either 0 or 1.

We comment on the aspects of the symbolic semantics rules that mainly differ from the standard ones. Bound invocations, that transmit private names, can be generated by rule (s-open). Notably, bound invocation actions do not appear in rules (s-match) and (s-com), and therefore cannot directly interact with receive actions. Such interactions are instead inferred by using structural congruence to pull name delim- itation outside both interacting activities. Although the bound transitions and rule (s-open) can be omitted, we include them both to give a proper semantics to terms

COWS is a process calculus introduced in [17] for specifying and combining service-oriented applications, while modelling their dynamic behaviour. Since its definition, a number of methods and tools have been devised to analyse COWS specifications, such as a type system to check confidentiality properties [18], a logic and a model checker to express and check functional properties of services [12], a stochastic extension to enable quantitative reasoning on service behaviours [23], a static analysis to establish properties of the flow of information between services [2], and bisimulation-based observational semantics to check interchangeability of services and conformance against service specifications [24]. An overview of some of the above tools, with an application to the analysis of a case study, can be found in [19].

