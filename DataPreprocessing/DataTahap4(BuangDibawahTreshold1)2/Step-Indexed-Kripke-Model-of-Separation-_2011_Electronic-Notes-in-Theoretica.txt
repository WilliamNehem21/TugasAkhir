We present a version of separation logic for modular reasoning about concurrent programs with dynamically allocated storable locks and dynamic thread creation. The assertions of the program logic are modelled by a Kripke model over a recursively defined set of worlds and the program logic is proved sound through a Kripke relation to the standard operational semantics. This constitutes an elegant solution to the circularity issue arising from lock resource invariants depending on worlds containing lock resource invariants.

We present a version of separation program logic for modular reasoning about shared-variable concurrent imperative programs with dynamically allocated storable locks and dynamic thread creation. Following earlier work [8,9,11], the idea of the logic is that a lock can be used to protect a resource invariant which, conceptually speaking, is transferred from one thread to another. The resource invariant follows the movements of the lock itself, changing ownership through acquire and release operations. Since the resource invariants associated with locks describe properties of heaps while locks are themselves (dynamically allocated and) stored in the heap, there is a tricky form of circularity that needs to be resolved in order to develop a model to show soundness of the logic. More specifically, since locks are dynamically

To sum up, we believe our new approach to the semantics and soundness is both semantically simple and useful since it solves the circularity issues directly and soundness is proved w.r.t. standard operational semantics. We demonstrate our approach on a simple but illustrative language and also include an example of using the resulting logic.

Also, in order to keep things relatively simple, the language does not support any freeing of resources, be it regular memory cells or locks. The latter permits us to omit the entire system of fractional permissions found in previous works (e.g. [8] and [9]).

In order to express lock properties, we use two predicates: Ex(E, P ) and Locked(E, P ). The first affirms that the interpretation of expression E points to a lock in the heap, with resource invariant P . No hypothesis is made as to whether the lock is available or not. Locked(E, P ) is similar, with the additional affirmation that the current thread owns the lock.

The side condition (*) stipulates that all occurrences of the predicate variable r in P are guarded, i.e. that they only appear under a Locked or Ex predicate. More formally, using the notation that P [ ] is a formula with a hole which can be filled by a predicate Q, written P [Q]:

This is a departure from the way heap sharing has been handled in concurrent separation logic. Instead of having a general shared space that is not private to any thread and that everybody can manipulate, we include duplicate values of the shared memory cells in relevant private spaces. This reflects more accurately the scope of the lock variables, and permits much finer granularity, with locks being known only to a limited number of threads.

We prove soundness separately for each proof rule, in each case using strong induc- tion on the index of the safety predicate. The proofs are relatively straightforward, consisting mostly in unfolding various definitions, considering all reduction steps that can be taken from the initial state and then proving safety of the new state. The following result takes care of the cases where a reduction happens in a thread other than the one we have just added.

Future work includes extending the language with new features, for instance storable procedures, which we believe would be straightforward to add. The sound- ness proof also appears to lend itself particularly well to formalisation and auto- mated machine proving, e.g. using the work by Benton et al. [2].

