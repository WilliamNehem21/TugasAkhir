Spider diagrams are a visual notation for expressing logical statements. In this paper we describe a tool that supports reasoning with a sound and complete spider diagram system. The tool allows the construction of diagrams and proofs by users. We present an algorithm which the tool uses to determine whether one diagram semantically entails another. If the premise diagram does semantically entail the conclusion diagram then a proof is presented to the user. Otherwise it gives a counterexample: a model for the premise that is not a model for the conclusion. The proof of completeness given in [8] can be used to create an alternative proof writing algorithm. The algorithm described here improves upon this by providing counterexamples and significantly shorter proofs.

In this paper we present a theorem proving algorithm for a diagrammatic reasoning system. Such a system is comprised of three things. Firstly, one specifies the syntax of the diagrams under consideration. Second, one gives meaning to syntactically correct diagrams: the semantics. Finally, reasoning

Conceptual graphs [12,10] and Euler-based diagrams have both been used to visually express logical statements and for reasoning [1]. In both cases there is a textual form which can be used as an abstract representation of the diagram, which is especially useful for tool-building. Given a simple con- ceptual graph it is possible to draw a spider diagram to express the same information. Each type gives rise to a contour in the spider diagram. A con- cept drawn in a conceptual graph would give a spider (named or otherwise), and relations in conceptual graphs can be represented by contours. As the conceptual graph syntax becomes richer, with for example nested graphs, it gets more difficult to see how such statements could manifest themselves as spider diagrams. Indeed, the expressiveness of conceptual graphs [9] exceeds that of spider diagrams [14]. A more interesting comparison of expressiveness would be between conceptual graphs and constraint diagrams, which include a natural representation of relations between objects [2].

In this paper we discuss a proving environment for spider diagrams, im- plemented in java. By implementing this tool we show that it is possible to fully automate diagrammatic theorem proving. The tool we have implemented allows users to construct spider diagrams and write proofs, as well as automat- ing proof construction. Given two diagrams, d1 and d2, if we wish to know whether d1 semantically entails d2, the tool will give one of two responses. If d1 semantically entails d2 then the tool will provide a proof, otherwise it provides a counterexample.

Spider diagrams form the basis of the much more expressive constraint di- agram notation. Constraint diagrams include further syntactic elements, for example universal spiders and arrows. Universal spiders represent universal quantification (spiders in spider diagrams represent existential quantification). Arrows denote relational navigation. Semantics are given to constraint dia- grams in [2] and a constraint diagram reasoning system (with restricted syntax and semantics) is introduced in [13]. Since the constraint diagram notation extends the spider diagram notation, developing this tool is a significant step towards the development of such a tool for constraint diagrams.

The implementation uses an algorithm which has some steps used in the completeness proof given in [8]. In [13], the authors state that the strategy used to prove completeness in spider diagram systems extends to a constraint diagram system. Thus it is likely that the proof writing algorithm we present here (and therefore our tool) can be extended to prove theorems with con- straint diagrams.

One application for diagrammatic reasoning systems is for expressing, and reasoning about, constraints in object-oriented models. The Unified Modeling Language (UML) is a collection of mainly diagrammatic notations that are used by software engineers in the process of object-oriented modelling. The only non-diagrammatic notation in the UML is the Object Constraint Lan- guage (OCL). The OCL is, essentially, a stylized form of first order predicate

Regions in spider diagrams represent sets. The region that comprises all the zones in a unitary diagram represents the universal set. A spider represents the existence of an element in the set represented by its habitat. Distinct spiders represent the existence of distinct elements. In the set represented by a shaded region, all of the elements are represented by spiders. Thus we can express lower and upper bounds on the cardinalities of sets. For the compound

In this section we give informal descriptions of the syntactic reasoning rules for spider diagrams. Each rule is expressed as a transformation of one spider diagram into another. Formal descriptions of the rules can be found in [8]. Firstly, we consider rules that are applied to unitary diagrams.

Rule 1 Introduction of a contour (reversible). A contour can be in- troduced to a unitary diagram provided the following occurs. The new contour has a label not present in the diagram. Each zone splits into two zones and shading is preserved. Each foot of each spider is replaced by a connected pair of feet, one in each new zone.

Rule 4 Excluded middle (reversible). Let d be a unitary diagram with a non-shaded region, r. We can replace d by d1 H d2, where d1 and d2 are copies of d except that r is shaded in d1 and there is an additional spider in d2 with habitat r.

comprising other Diagram objects. In principle, an AndCompoundDiagram could have a child which is another AndCompoundDiagram object, representing D1 H (D2 H D3). But in the implementation such structures are immediately flattened to a single AndCompoundDiagram object with the combined children set: D1 H D2 H D3. As a result, we do not implement associative rules.

Finally, we consider the collection of children of a compound diagram as an unordered collection. This decision was made because a concrete diagram- matic presentation of a set of children might not show a clear ordering between the components, unlike a textual representation. As a result, we do not im- plement the commutative rules.

In this paper we have described a tool that supports reasoning with spider di- agrams. This tool allows users to construct their own proofs and, at any given proof step, offers only valid rule applications to the user. In addition, given D1 and D2, it can construct a proof that D1 entails D2 or a counterexample. The automatically generated proofs are significantly shorter than proofs which are generated using an algorithm directly derived from the completeness proof in [8].

