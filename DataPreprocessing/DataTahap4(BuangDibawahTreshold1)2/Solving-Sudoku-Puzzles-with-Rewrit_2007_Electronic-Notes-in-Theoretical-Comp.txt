Rewriting logic [13] is a logic of concurrent change that can naturally deal with states and with highly nondeterministic concurrent computations. It has good properties as a flexible and general semantic framework for giving semantics to a wide range of languages and models of concurrency. Moreover, it allows user-definable syntax with complete freedom to choose the operators and structural properties appropriate for each problem.

As described in [12], three processes (scanning, marking up, and analysis) are the classical techniques for solving sudokus. The application of these processes is not deterministic so that the real performance of a sudoku solver depends on the ap- proaches in their combination: if one applies these processes blindly, a combinatorial blowup may happen. Ideally, then, one needs to find a combination of these tech- niques which finds a solution in an efficient manner.

Scanning comes to a halt when no more numbers can be discovered. At this point, it is useful to mark candidate numbers in the blank cells. Subscripts are a popular notation: the candidate numbers are written as subscripts in the cells. It is usually difficult to use this method in the newspaper because the cell space is small. There is a second notation with dots (a dot in the top left corner represents a 1 and

Among the different processes (scanning, marking up, and analysis) for solving sudokus, the main strategy that we have considered is that of analysis for elimi- nation. It is defined by Rule 1 below, which removes an element from the set of possible numbers in a cell. We have complemented it with Rules 2 and 3, of second and third order simplification, which respectively consider two and three elements. Several contingencies corresponding to the scanning process are covered by Rules 4 to 6. The strategy what-if is implemented with the sudoku split rules (Rules 7 and 8).

The correctness of each rule is immediate by their definition. Its application, however, does not lead to a confluent system: in case a sudoku has several solutions, the one that is reached can vary according to the order of execution of the rules; when a sudoku has a unique solution, this is obtained. The system is terminating: even though Rule 7 introduces a new sudoku, every rule decreases the cardinal of the set of possible numbers in one of the cells.

Each of our rewrite rules diminishes the number of elements in the set of possible numbers of some cell, in a way that faithfully mimics the presentation of the solving rules given in Section 3.2. We illustrate the naturalness with which they are written in Maude by presenting two of them; for the rest, we refer the reader to the files at http://maude.sip.ucm.es/~miguelpt/bibliography.

The previous section has described how a procedure for solving sudokus can be specified in Maude. As discussed in Section 3.1, however, one cannot simply apply the rewrite rules in it to obtain a solution lest a combinatorial explosion is produced. Then, in order to avoid this it will be necessary to apply the rules according to some

Maude has been extended with a powerful strategy language that allows a user to specify the ways in which the rewrite rules in a module will be applied [11]. This language is itself built on top of another extension, called Full Maude (see [9]) which adds to Maude a richer set of primitives for working with parameterization and object-oriented modules. We will not use any of the advanced features of Full Maude and for our purposes it will be enough to know that to load a module it is necessary to enclose it in parentheses. Regarding the strategy language, we will limit ourselves to a very limited subset; we refer the reader to [11] for the complete details.

This module defines three strategies. The first one, rules, simply tries to apply one of the first six rules, in order: it tries with simplify1st; if it is not possi- ble, it tries with simplify2nd; and so on. The second one, split, tries to apply sudokuSplit and sudokuSplitN rules in order. The last one, solve, applies the first strategy and, only if it is not possible, tries to rewrite using splitting rules; the bang ! at the end asks to continue with the application of the strategy while possible.

