This paper is organized as follows. The next section contains a brief overview of technologies and research approaches relevant to extra-functional properties. Sec- tion 3 describes the general principles of our work, it shows how we define EFPs and their relation to deployment contracts, including the modifications we introduced to existing approaches. Then follows detailed information about our registry sys- tem. The last section of this paper provides a case study in which we show how a current system developed by a Czech company can be enhanced using our proposed method.

A newer approach proposed by Aagedal is the CQML [1] language. He has described a complete syntax of an EFPs language and introduced a UML profile for quality attributes. The CQML approach is a language usable for general description of EFPs. The language defines the following basic types: Number, Enum or Set; no complex type is provided. CQML also provides derived properties, but they are meant only to extend an existing simple property or to compose a derived property from other ones without any further definition how this composition is treated. CQML allows to deal with properties before deployment and after a component is deployed. Although properties are usually treated differently in different phases,

profile contains a set of qualities with a set of QoS properties. The quality allows to encapsulate context dependent values, but assuming we have c contexts and n QoS properties it may produce up to 2n quality records and 22n different profiles. In addition, each profile must be created for c contexts. This may lead to a hardly manageable number of records.

components but also resources between a component and a system (framework or hardware). This is an important aspect of component-based development where a component has not only relations to other components but also relations to the deployment environment. CQML+ extends syntax of original CQML rather than providing a more generalised way.

[8] is oriented to the field of Service Level Agreement in which EFPs play also an important role. SLang uses XML to describe EFPs. It distinguishes between Vertical and Horizontal SLAs. Vertical SLAs concern different infrastructure and Horizontal SLAs concern different layers of abstraction. Each layer of abstraction covers different group of EFPs, allowing to use different EFPs for different layer of abstraction.The weakness of these approaches is their targeting at particular cases and developing a limited set of properties. We in opposite aim at providing a general solution.

Furthermore, while ProCom attributes are meant to be used during the whole system life cycle, which motivated introducing multi-valued attributes, we are inter- ested in describing EFPs of the final black-box components. The most interesting idea in ProCom is the usage of registries storing EFPs. The main reason for intro- ducing registries is to gather attribute types.

PECT [19] focuses on real-time quality attributes and their predictions. ROBO- COP 4 uses a set of various model with particular information about the system including an EFPs model that model i.e. reliability, cpu and memory usage. How- ever, both of these models do not allow for EFP context-independent specification. For instance, it is not possible to parametrise an EFP with a particular platform.

A list of EFPs has been put together in the Component Quality Model [2] which may be used for defining a set of EFPs for a particular system. A different approach, Performance Trees [17], aim at an easy-to-use graphical representation of stochastic systems where states, transitions between states and transition conditions together with probabilities are modelled. It allows to express performance queries as graphical trees which is useful to model EFPs of performance demanding systems.

As can be seen from the above analysis of related work, there is no consistent understanding how extra-functional properties should look like, where they should be stored and how they should be defined. In our point of view, EFPs are addi- tional information about components and their features. Their role is to enhance component specification and extend the possibilities of component verification.

To obtain comparable properties, there must be a shared understanding between different component vendors and users about the available properties and their char- acteristics. Apart from the use of standards such as the CQM [2], such understand- ing can be helped by a technical infrastructure which comprises a general repository containing all available properties in the domain (the field of usage). It allows to assume that properties are defined before a component is created and vendors can therefore use it to attach properties with the same meaning to components.

records with the name and the type of each property. It only defines the properties themselves but does not contain their values. Global registry is valid for all contexts specified by the domain of the registry. It contains the definition of all meaningful EFPs defined by a domain expert. The domain expert may be a program working with a domain specification or a human knowing the domain.

context has one local registry (with a link to the domain GR) which stores values valid for the context. They are linked to the definitions provided by the GR. A component to be deployed in a particular context which links to a LR. It thus binds context-dependent values to its properties (taken from the GR).

Note that for every property it is optional to have a record in local registry. Each property which is not, in essence, context dependent can have values assigned directly in a component descriptor. It is usually every deployment contract or other EFPs (e.g. physical values like t = 0oC, gravity = 6, 67 or context independent ones like price, marketability).

In our approach, we distinguish between two types of extra-functional properties: simple properties and derived properties. A simple property is any measurable property which often has a measuring unit. A derived property is based on a set of simple or derived properties using logical expressions.

We have also generalised deployment contract properties [9] to be consistent with our (simple or derived) properties. The provided generalisation defines a deployment contract the same way as extra-functional properties and they differ later when they are used on components. EFPs bound to a component express strictly a relation to other components while DCs bound to a component express strictly a relation to a runtime environment even though the definitions of both do not differ.

There is another component which is a database of addresses. It stores all addresses in the Czech republic and can provide them through web services. Data about citizens provided by the Ministry may contain mistakes. For that reason, data about addresses are synchronised through the process of the import and mistakes are corrected. When the correctly working component of addresses is present, it must provide valid addresses all the time.

We have defined two simple properties data transferred and time to process concerning the speed and amount of transferred data for the database import. Both properties are referenced by a derived property performance. The system depends on an installed database engine, which we define as a deployment contract because it is an external resource. The assumed correctness of addresses is expressed by a data correct property.

Since this is still a work in progress, there are several issues that need further research. We need to find a good solution concerning the actual location of context registries. One option is to store this information as a part of the global registry file, another one is to provide other (physically separated) registries per individual contexts and link them to the global file.

We have formalised the deployment contract attributes with the original algo- rithm presented in [10], but we would like to simplify the algorithm. We allow to put properties only on components and services though the original work allows to do so even for methods, parameters and return types of methods. This will not pose problems, because a resource demand is moved to a component or a service but it is still present. We also assume not to use each attribute of the original work because some are weakly related to deployment (e.g. reentrance and state of methods) and some are difficult to manage (e.g. an ability to store a browser cookie).

Whereas this paper has developed a fundamental mathematical model for a static definitions of EFPs and DCs, the technical means allowing the practical usage of the model have yet to be created. We are currently working on a tool which uses XML to form registry and a Java GUI which serves as an editor of registry. Our next goal is to finish the tool which will verify the model.

This paper has presented an approach to the definition of extra-functional properties and deployment contracts targeted to the field of reusable software components. The study of existing approaches has shown that some of the languages describing extra- functional properties developed earlier are a useful base for further developments. Our proposed system builds on CQML and NoFun but simplifies their syntax and extends them in a few directions to better fit our needs. We have further used the approach to introduce a formalisation of the existing, informally defined deployment contracts.

