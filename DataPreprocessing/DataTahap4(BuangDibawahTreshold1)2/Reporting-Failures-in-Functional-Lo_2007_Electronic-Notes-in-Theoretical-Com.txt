Functional logic languages (see [17] for a survey) integrate the most important features of functional and logic languages to provide a variety of programming con- cepts to the programmer. For instance, the concepts of demand-driven evaluation, higher-order functions, and polymorphic typing from functional programming are combined with logic programming features like computing with partial information (logic variables), constraint solving, and nondeterministic search for solutions. This combination, supported by optimal evaluation strategies [3] and new design pat- terns [5], leads to better abstractions in application programs such as implementing graphical user interfaces [20] or programming dynamic web pages [21,23].

Since functional logic languages, like Curry [19,28] or Toy [31], support both functional and logic programming styles, functional logic programs often contain parts that are evaluated in a purely deterministic manner and other parts where search for solutions is involved. These parts are sometimes combined by encapsu- lating search [10,27] so that the search results are processed by a deterministic part of the program. Thus, computing with failure is a typical programming technique in nondeterministic computations whereas a failure in the deterministic parts is a programming error in most cases. In the latter situation, the programmer is inter- ested to see the failed function call as well as the context of the failure in order to analyze its reason.

functional logic programs into Prolog programs in order to exploit the implemen- tation technology available for Prolog. Actually, there are various approaches to implement functional logic languages with demand-driven evaluation strategies in Prolog (e.g., [2,4,14,18,29,30]). Since modern functional logic languages are based on the non-strict lazy evaluation of functions [1], the main challenge of Prolog- based implementations are efficient techniques to obtain this behavior. Since the computation to a head normal form (i.e., a constructor-rooted term or a variable) is the central task of lazy evaluation, a common idea of such implementations is the translation of source operations into predicates that compute only the head normal form of a call to this operation. Thus, an n-ary operation could be translated into a predicate with n + 1 arguments where the last argument contains the head nor- mal form of the evaluated call. For instance, the list concatenation conc defined in Example 2.1 and the function head defined in Section 1 can be translated into the following Prolog predicates:

Since conc is defined by a case distinction on the first argument, the value is needed and, hence, computed by the predicate hnf before it is passed to conc_1 implement- ing the pattern matching on the first argument. Since the right-hand side of the second rule of conc is already in head normal form, no further evaluation is neces- sary. In the first rule of conc_1, it is unknown at compile time whether the second argument Ys is already in head normal form. Therefore, the evaluation to head normal form is enforced by the predicate hnf. The goal hnf(t,h) evaluates any term t to its head normal form h. Some of the clauses defining hnf are:

The main idea of our approach is to treat a failing computation not as a failed computation in the Prolog program but as a computation that returns a specific value containing some information about the source of the failure. For this pur- pose, we assume a predefined function failure that wraps its argument into the distinguished constructor FAIL that is not accessible to standard Curry programs. Although this function is predefined (since it is not typable w.r.t. the standard type

Thus, failure puts its argument into a list which will later be stepwise extended to the list of all failed function calls from the main expression to the innermost failed call. The function failure is explicitly used whenever some function call might fail due to missing pattern combinations. 5 For instance, the operation head is not defined on empty lists. Therefore, we complete the definition of head with a call to failure in case of an empty list as argument so that we obtain the following extended definition of the predicate head_1:

Note that all predicates implementing pattern matching in source programs can be automatically completed in this way due to the typed nature of the source language Curry. 6 However, this code contains a slight problem. Since Curry is a functional logic language, head can be also called with a logic variable as argument. In the new implementation, the logic variable can be bound to [X|Xs] as well as to []. In the latter case, failure is called to report a failure although this was not present in the original program.

As mentioned above, FAIL is a new constructor to pass the information about failing computations. Therefore, it is a new value that must be considered in all pattern matchings, i.e., if the actual argument is a FAIL value, it is directly returned to the caller. Thus, we obtain the following final code that implements the pattern matching of head:

Note that all pattern matching predicates must be extended by a FAIL clause. How- ever, the varcut clause needs only be inserted in case of partially defined functions. Our extended translation of pattern matching for failure reporting causes only a slight increase in the code size but has no negative influence on the execution of these predicates. Thus, we can compile all Curry modules in this extended way independent of the fact whether we want to report failures or not. This property is important to support separate compilation, e.g., usually system libraries cannot be recompiled by individual users of an installed Curry system. All the logic about the treatment of FAIL values is contained in the implementation of the predefined operation failure and hnf clauses which we discuss next.

checkFailValue but does not introduce new choice points. Hence, this scheme is compatible with the execution of large applications. The predicate checkFailValue checks whether its second argument is a FAIL value. If this is the case, it extends the argument by the current function call which is passed as the first argument, otherwise it just returns the second argument:

Enter an interactive mode for failure tracing. This mode is useful if the complete trace is too large to show it on a screen. In this mode the programmer can explore different regions of the complete trace, show calls with arguments up to some depth (useful for large argument terms) etc.

Our implementation scheme causes only a small overhead in case of non-failing computations and has a behavior substantially different from the standard execution only if a failure occurs. Although the returned structure can be large if considered as a term, it fits well into main memory even for larger applications since most parts of the structure (in particular, the arguments of the function calls) are already created in the heap when the failure occurs. Thus, our implementation is a viable and more generally applicable alternative than failure reporting based on backtracking (Section 4.2) or tracing the complete execution [9,11,15].

As mentioned at the beginning, computing with failures is a typical programming technique in functional logic programs. However, in practical applications one has to restrict the search for solutions in order to avoid a nondeterministic behavior of the entire program in I/O operations (such a behavior is considered as a run-time error in Curry). Thus, the programmer usually encapsulate nondeterministic search by specific search operators that return the solutions to some constraint [10,27]. Since reporting failures is usually not intended in these parts of the programs, failure reporting is disabled during encapsulated search (which is controlled by a simple flag in the run-time system), i.e., the predicate failure always fails inside an encapsulated search. If the programmer is still interested to see failures in these parts of the program, he can just execute these parts at the top-level of PAKCS without the search operators.

For future work, it might be interesting to explore whether it is possible to generate more structural information in case of errors. Since the structure of the call stack is oriented towards the lazy evaluation of expressions, the order of calls might not be the best one for presentation to the programmer. Further practical experience is necessary to develop appropriate presentation structures.

