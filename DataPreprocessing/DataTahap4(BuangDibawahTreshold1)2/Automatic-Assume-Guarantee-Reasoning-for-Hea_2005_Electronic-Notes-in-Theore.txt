Assume/Guarantee (A/G) reasoning for heap-manipulating programs is challenging because the heap can be mutated in an arbitrary way by procedure calls. Moreover, specifying the potential side-effects of a procedure is non-trivial. We report on an on-going effort to reduce the burden of A/G reasoning for heap-manipulating programs by automatically generating post-conditions and estimating side-effects of non-recursive procedures. Our method is sound. It combines the use of theorem provers and abstract-interpretation algorithms.

Object oriented programs contain several challenging features, including intensive usage of the heap and the ability to redefine behavior using inheri- tance. In this paper, we address the problem of analyzing the heap, and rely on existing methods to handle inheritance, e.g., [1]. We make a simplifying assumption of working on single-threaded programs.

The Process. In this paper, we restrict our attention to non-recursive procedures. This allows us to analyze procedures before they are used. Every procedure is analyzed once on an abstract value that represents a superset of the stores fulfilling the precondition. The outcome of the analysis is a safe ap-

proximation to the post-condition including the potential side-effects of every procedure. The analysis can also verify safety properties, such as the absence of memory leaks and null dereferences, and user-defined assertions, including post-conditions. The analysis of every procedure uses the (computed) post- conditions of invoked procedures.

Symbolic Operations. To realize the process described above, we imple- mented two operations with the use of a theorem prover: assert and assume. The assert operation takes a formula in first-order logic with transitive closure, and an abstract value, and returns TRUE if all concrete stores represented by the abstract value satisfy the formula. The assume operation takes a formula in first-order logic with transitive closure and an abstract value. It returns an abstract value that refines the input abstract value by eliminating concrete stores that do not satisfy the formula. 2

Notice that this analysis establishes the absence of memory leaks and null dereferences in append not only for this program, but for all programs in which the precondition of append is satisfied. The reason is that we conservatively analyzed append with an input abstract value that describes all stores that satisfy its precondition. Also, the post-condition that has been generated describes the behavior of append in all such programs.

Analyzing main. Intraprocedural statements are analyzed as usual, and procedure calls are interpreted by checking the precondition and assuming the post-condition. A crucial issue is that we want to maintain information about the store before the call while allowing the procedure to mutate parts of the store.

We can model dynamic memory allocation using an additional unary re- lation active(v). Conceptually, we assume that the number of nodes in a structure is always infinite; active is set to FALSE for all nodes in an empty heap. Allocation is modelled by setting active to TRUE for the newly allo- cated node. To simplify the exposition, we omit the active relation in this paper.

Specifications We use pre f and post f to denote the pre- and post-conditions of a procedure f . In our method, pre f and post f are formulas in first-order logic with transitive closure over a vocabulary that describes formal parame- ters and visible fields of the procedure f . The precondition is specified by the user, and the post-condition is generated by our system.

Example 4.2 In our example, we do not represent the variables x, y, z of main while analyzing append. This way, we can use a more coarse represen- tation of those data-structures that do not change during the execution of the procedure.

matically updates the value of change[n] (and other instrumentation relations) during the analysis via differencing [7]. Note that the project operation does not remove change[n] because it is an instrumentation relation that is ex- pressed in terms of variables that are visible in the caller. Thus, change[n] becomes a part of the postcondition.

We use the standard notion of a two-vocabulary store, which relates the store before and after the call to a procedure. The two-vocabulary store contains two versions of each binary relation symbol, where the unprimed version describes the store before the call and the primed version describes the store after the call. We do not introduce primed versions of unary relation symbols, because these relation symbols denote program variables of the caller, whose values cannot be changed by the procedure call, as they are invisible to the callee. One exception is the return value of a procedure, which is described by a primed version of the corresponding relation symbol. 3

To evaluate the two-vocabulary formula post2 on p1, we need to extend p1 with primed version of relations, first initialized to unknown; this operation is called primed2unknown, and results in a new set of shape graphs, p2. Then, we apply the symbolic operation assume, which generates from p2 a set of shape graphs p3. The assume operation refines the primed relations in p2 to more precise values, by excluding values that do not happen in any valid store.

To evaluate the feasibility of the method, we implemented our method using the TVLA system [6] and the Simplify theorem prover [3]. We established the correctness of the running example of this paper using TVLA enhanced by a symbolic engine to compute assume and assert. We used the Simplify theorem prover to discharge queries posed by the symbolic part. We modeled transitive closure using a binary relation and a set of simple axioms. Currently, we are developing a Java front end, and plan to perform more experiments in which we apply the approach to Java methods.

