While the functionality is the most important factor in selecting a com- ponent for an application that is being developed, non-functional properties (NFPs) are becoming more and more important, too. These NFPs should not be determined afterwards, but must be considered in the design process from the beginning and thus influence the selection of components. The designer should be able to estimate the NFPs of the system being built at any point in time.

storage, another predicate Is RO is used which is more strict in expressing upper bounds. These predicates are in fact valued-based, as has been indi- cated above. Hence, the resource specifications approximate the bounds using predicates, but rely on a detailed functional specification that exhibits the concrete implementation. They must be supplied by the developer of a com- ponent and obviously need a white-box view of the component. Furthermore, how to obtain the base values used in the specifications (e.g. initialization of an entry in the stack example) is not clearly stated.

The COMPAS project [10] uses a matrix to describe the import-export relation of components. This matrix indicates for each pair of methods in the system the probability that method 1 calls method 2 in a particular transac- tion, that is, a particular workload. The information is extracted from traces. So the system must be complete before the evaluation can start. The purpose is to predict the behavior of the same system under new workloads from the measurements. But the development process itself is not modified to take care of performance issues while building the system.

For the purpose of this paper a quite general component model can be used. This model describes components mainly as software building blocks having declared interfaces of services a component offers and interfaces a component imports, that is the interfaces of other components it will call to implement its own functionality. An interface is a set of methods. We come from an Enterprise-Java-Beans-like [12] component model, focusing on the main prop-

To have this information is crucial when addressing the NFPs of components. The relation at the moment does not show the dependence on the parameters of the methods. That would be even more useful, but it would make the relation much more complex. So we start with the elementary form with the clear intension to later extend it.

It has just been said that the implementor of a component decides which interfaces to import. In our setting, components and their exported methods are subject to annotations regarding NFPs. These NFPs must be consistent with the NFPs of the components that offer the imported interfaces [19]. As mentioned above, we use response time as an example here.

For response time, the resources considered to be most important are CPU and memory 10 . In general, their usage depends on the platform and on the data processed. The data must be included if the relationship of resource usage and an NFP is to be identified. These data can be of a simple type like integer with its limited value range, or of more complex types like video or

image. Value-based specification [18] may be feasible for the simple types, but for the complex types data values are much too large and too detailed, so the salient properties must be used instead, e.g. frame rate, compression format, and size in case of video. Both is denoted by data in the following, meaning either values or properties depending on the type.

In the COMQUAD project, an extension of CQML [1] is used to describe the resource usages of NFPs (for details see [16,24]). In addition to the qual- ities and profiles of CQML, CQML+ allows to specify the resource demands a component has. Although in this paper we focus on CPU and memory us- age, the extension is flexible enough to add arbitrary resource types, as the semantics are defined by the underlying resource manager [2].

bound referring to the approximation. Of course, in order to be able to re- spond within the given time bound, SquareRoot must rely on the methods contained in the imported interface math of type Math, which themselves have to return their answers within a given (smaller) bound. Based on definitions of the quality characteristics response_time and square_error 13 , three dif- ferent qualities are defined, constraining response_time and square_error, respectively. Two further qualities constrain the resource usage using inter- vals. Finally, a profile associates those qualities with the component. As the component itself needs certain resources to offer medium response time and high error bound, this is stated in the resources clause of CQML+.

As the goal is to reason about non-functional properties of the whole sys- tem under construction, the properties of all components must be considered. Taking again response time as a simple example, each component will have a response time for each of its methods (which depends on the available re- sources; see above). If one component calls another, the response time of the called method becomes part of the response time of the calling method. In total, the latter response time is accumulated from all calls to imported methods and the time used in the component itself.

of the response times can still be increased, and the testing of the resources can be repeated. If all that fails, the assembly chosen exceeds the resources available or a given resource limit for the assembly. So a alternative assembly has to be constructed.

The formalism also allows to go the other way. That means to enquire the available resources and then use ff2(mij ) to calculate the values of tj,local and finally the response time of method instance mi1. However, this is con- sidered to be less interesting, because the available resources are known only at runtime.

Obviously, NFPs other than response time must also be considered. At the moment, they must be investigated one by one, before a common treatment can be identified. Their nature is very different, so most likely a common treatment can only be achieved for classes of similar NFPs. However, we believe that the approach presented here is applicable to NFPs other than time and space as well, as long as they are additive. We will investigate this issue in further work.

Murali Sitaraman. Compositional performance reasoning. In Ivica Crnkovic, Heinz Schmidt, Judith Stafford, and Kurt Wallnau, editors, Proc. 4th ICSE Workshop on Component-Based Software Engineering - Component Certification and System Prediction (Toronto, Canada, May 14-15). IEEE Computer Society, USA; Monash University, Australia; Carnegie Mellon University, USA, 2001. URL http://www.sei.cmu.edu/pacc/CBSE4-Proceedings.html.

