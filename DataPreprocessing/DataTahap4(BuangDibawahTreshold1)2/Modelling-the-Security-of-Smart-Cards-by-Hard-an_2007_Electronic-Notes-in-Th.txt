We exemplify the use of the calculus by modelling a simplistic e-cash Smart Card system, the security of which depends on the interplay between (linear) mobile hardware, embedded (non-linear) mobile processes, and local names. A purely linear calculus would not be able to express that embedded software processes may be copied. Conversely, a purely non-linear calculus would not be able to express that mobile hardware processes cannot be copied.

Following the seminal work on Mobile Ambients [10], several process calculi, in- cluding variations of Mobile Ambients [18,4], the Seal calculus [11], and the Homer calculus [15], have been proposed that combine (1) mobile processes, (2) nested explicit locations and (3) local names. These models are motivated by scenarios in global ubiquitous computing: Mobile processes are employed to represent both mobile computing devices (i.e. non-copyable devices such as laptops, PDAs, and

smart cards), as well as mobile computations (i.e. copyable software agents and migrating processes). Nested explicit locations are typically used to represent ad- ministrative domains, firewalls, physical boundaries of mobile devices, boundaries of software messages and processes such as encryption, sand-boxes and locations of data in memory. Finally, local names are used to represent private keys and scope of references to locations in memory.

In the present paper we argue that mobile computing hardware devices are intrinsically linear, while mobile computations in software are intrinsically non- linear : A hardware device cannot easily be copied, and the security of a system often depends on this fact, for instance for smart cards. Contrarily, software must usually be explicitly protected against copying, e.g. by enclosing it in a tamper-proof (and non-copyable) hardware device.

Somewhat surprisingly, we found no calculus combining linear and non-linear mobile embedded processes and local names. In the present paper we thus present an extension, inspired by affine intuitionistic linear logic, of the type and effect sys- tem for Homer presented in [13]. The extension allows us to distinguish between affine linear and non-linear uses of variables (as in the linear lambda calculus) and to type the names of locations (akin to reference types) and thereby to restrict the content of locations to be either linear or non-linear. We define non-linear to be a subtype of affine linear, which enable non-linear (software) locations to be embed- ded in linear (hardware) locations. This also ensures that non-linear resources can be used as affine linear resources. On the other hand, the type system guarantees that linear resources are never copied nor embedded in non-linear resources: If a linear resource could be embedded within a non-linear resource it could be copied by copying the embedding resource. In Homer it is possible to reference nested resources using composite location paths. To type these paths we introduce com- posite reference types guaranteeing that linear locations within non-linear locations are never referenced.

We claim that the calculus captures the intrinsic copyability features of mobile computing hardware devices and software processes as outlined above. We justify this claim by giving in Sec. 5 an example of a simplistic e-cash system, the security of which depends on the non-copyability of smart cards and the ATM itself. Dually, the copyability of software processes, in this case encrypted messages, constitutes an important security threat. We do not claim that the example prove the security of a realistic smart card system, but that it shows that a realistic model for both

The structure of the paper is as follows. In Sec. 2 we present the Homer calculus, and in Sec. 3 we give it transition semantics. The type system for Homer is presented in Sec. 4, and we provide the Smart Card example in Sec. 5. In Sec. 6 we conclude and propose future work.

The Homer calculus extends Plain CHOCS, but shares ideas with recent cal- culi for mobility such as the Seal calculus [11], the M-calculus [20] (and its recent successor the Kell calculus [21]), in particular the ability to represent copyable (non- linear), objectively mobile anonymous resources in nested named locations. Type systems have been introduced for the M-calculus (and the Kell calculus [3]) which ensure unity of location names (used for deterministic routing). A type system for Seal calculus is presented in [11], the type system both type active processes and locations, thus enabling one to declare the type of processes that can enter and exit a location.

introduced by the type system in [13] and can be regarded as an effect that captures the names used or allocated by the process, as described in Sec. 2. The type system guarantees that this set is a superset of the free names in the process. Besides process types, we also define concretion and abstraction types. The concretion type

We can prove the standard properties about the type system: strengthening of unused names and variables, invariance under structural congruence etc. Again, we refer to the full paper for these results [7] and only present the main results here. As expected in a type system with subtyping we have narrowing of variables.

The control process can potentially be executed any number of times. The intended behaviour is however, that only one coin will ever be delivered, since the method on the card can only encrypt once. Alas, if the process in the slot v can be copied, the security is broken. A e-cash copying thief may be defined by

The type system presented in the previous section allows us to type the location v as affine linear. Thereby, we can model that the process in location v is intended as being embedded in a non-copyable smart card (and also ensure that the entire system cannot be copied either). First, we show that the system is well-typed.

