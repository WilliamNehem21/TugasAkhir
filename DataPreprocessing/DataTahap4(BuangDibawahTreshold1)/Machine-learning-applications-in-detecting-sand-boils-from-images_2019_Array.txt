Levees are constructed to provide safety along natural water bodies, to stop the flooding of low-lying areas. The presence of sand boils along the outside of the levee signifies a possible impending structural failure of the construction. This can result in a lot of damage to both property and life [1]. The analysis and monitoring of sand boils are currently done manually [2,3].

We aim to automate this process by picking the best models out of several developing machine learning models, that can most accurately detect sand boils near the levees so that personnel can be more targeted in their monitoring. The dataset for this study has been collected manually from various sources since there is no centralized dataset available for these relevant images. It has been made sure that it contains satellite images of rough terrain that can pose as a challenge for a ma- chine learning algorithm to identify sand boils from. This resulted in the creation of a robust predictor capable of identifying potential sand boils with high accuracy, which was ensured by comparing it with other po- tential machine learning approaches.

especially in the New Orleans area. However, levees and flood-walls degrade over time due to the impact of severe weather, development of sand boils, subsidence of land, seepage, development of cracks, etc. Further, published data [16] indicates that coastal Louisiana lost approximately 16 square miles of land between 1985 and 2010. In 2005, there were over 50 failures of the levees and floodwalls protecting New Orleans, Louisiana, and its surrounding suburbs following the passage of Hurricane Katrina and landfall in Mississippi. These failures caused flooding in 80% of the city of New Orleans and all of St. Bernard Parish. Events like Hurricane Katrina in 2005 have shown that levee failures can be catastrophic, and very costly. If these levees fail due to these condi- tions, there is a potential for significant property damage, and loss of life, as experienced in New Orleans in the 2005 hurricane, Katrina. It is of great importance to monitor the physical conditions of levees for flood control [3,17]. The Great Mississippi Flood of 1927 and 1993 are some other examples of the development of sand boils. The Mississippi

and the height and diameter if a cone of sand is formed around it must be measured to determine the severity of the sand boil. Levees need to be appropriately maintained and actively monitored for failure. Due to the tremendous length and variations of levee structures, proper operation and maintenance of levees can be challenging, especially when it is currently done manually [2,3] using physical surveys which are a drain on time and resources. This thesis aims to speed up this process and assist in the monitoring process of levees and coastal changes by detecting sand boil from images, expected to be collected by drones for monitoring the levees.

Computer vision is the study of algorithms that manipulate image- based data [26]. These algorithms extract features from images and pass them to machine learning models, which then identify particular regions of interest (ROI) in the image. Object detection, however, is a combination of computer vision and machine learning. It recognizes an instance of the target object and draws bounding boxes around it.

The major difference between image detection and recognition is that the former is generally concerned with detecting where the image a particular object resides by drawing bounding boxes around them. Image detection can be treated as a simple classification problem where the image can be classified based on the presence of the object within it. Image detection is an essential preprocessing step for object recognition. Object recognition is used to compare the similarity between two images. For example, face recognition algorithms that group pictures of people together [27].

the real world. Application of machine learning on object detection can be challenging depending on the characteristics of the object. Detection of sand boils within the muddy settings could be very hard to perform from a given image. Object detection has previously been applied to some similar issues [28].

In this research, the dataset was collected from different sources. There is no centralized, easy to access data for levees and sand boils available. Hence, most of the collection was done manually. An addi- tional explanation of the subsets of data used for each method is described below.

The usage of a subset of images was necessary for the other methods because, to input the images, the exact areas within the samples con- taining the positive region must be hand annotated. It is a manual process that is intensely time-consuming. Hence, we labeled only 956 images as positive samples. To do this, a tool called BBoxLabel [31] was used. BBoxLabel is an opensource tool that opens a simple GUI where it allows the user to load a directory of images and annotate them. These anno- tations are stored in two formats. Both a simple text file and an XML file format which both YOLO and SSD use. On the other hand, annotations for the Viola-Jones method are internally calculated by OpenCV using a simple command. These files generated by OpenCV cannot be used by YOLO and SSD because they have one major distinction. The x, y anno- tation from BBoxLabel tool is the center coordinate of the image, whereas the one calculated by OpenCV is the coordinate of the top-left pixel.

In this section, we describe the features from both positive and negative samples that have been extracted and fed into the machine learning methods. For the Viola-Jones algorithm, the features used are called Haar features. These are calculated internally by OpenCV. They can be visualized to see which regions of the image contribute to the classification of it being a positive sample. Further discussion and ex- amples can be found in the results section. For the YOLO algorithm and the SSD method, since the architecture can be considered a part of the convolutional neural network, the features are extracted internally by the convolutional net itself. For the non-deep learning methods, we need to extract some features manually as described below.

The cascade is trained using 25 stages, 4500 positive samples, and 3000 negative samples. This results in an XML file that can be used to make predictions on a test dataset. The test dataset contains a total of 8300 images out of which 2000 are negative samples, and the rest are positive samples of sand boils. The cascade training is stopped at stage 25, and the intermediate stages, 10, 15, 20 and 25 are tested for per- formance. The best performance is achieved by cascade stage 15. This is evidenced in the results section.

The single-shot multibox detector [7,43] is an improvement on the YOLO object detector in the sense that it does not have to traverse through the image twice as YOLO does. It can map out the object in a single shot. It is a very fast approach and extremely accurate. SSD is also a deep learning method for object detection.

A PyTorch implementation [45] with some alterations to the number of classes, etc. of SSD was used to make the detections. After training the net for 200 epochs, we use the latest generated checkpoint to make the predictions. Then we produce the bounding boxes for each of the images in the test data set.

The genetic algorithm is an evolution-based algorithm that iteratively generates new populations and selects the best possible set of genes to do so. Over successive generations, the population moves toward the most optimized solution. This algorithm can be applied to a variety of opti- mization problems. We chose to use it to select the best possible set of features among the 700 that were derived. We arrived at a total of 324 features. After running the above-described methods on both sets of features, it was determined that the complete set of 700 features per- formed better in comparison to the feature set selected by the genetic algorithm. The possible reasons for failure might be that the genetic algorithm-based feature selection uses XGBoost to compute the fitness of the population. The features selected using XGBoost might not always be the optimal settings for other state-of-the-art algorithms. Another reason is that the set of HOG features described above work on the basis of corresponding pixels. Trying to isolate the features might prove not to be useful.

