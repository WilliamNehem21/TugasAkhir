This tutorial discusses a high-level reversible programming language called Janus, which supports both forward and backward computation. Janus is a simple yet powerful language with constructs that can be used as a model for designing reversible languages in general.

Traditional computing models, such as Turing machines and random access machines, involve the destruction of information at each computational step. However, it has been shown that any irreversible computation can be simulated by reversible computation, provided that sufficient extra storage is available to remember the history of computation and to erase garbage information through inverse computation.

An example of reversible programming in Janus is provided through a procedure for computing Fibonacci pairs. This demonstrates the injective nature of the Fibonacci function by returning a pair of Fibonacci numbers for a given input.

Reversible assignment in Janus allows for the updating of integer variables or array elements, while the uncall procedure invokes the inverse computation of a procedure. Additionally, Janus employs a mechanism to avoid problems with aliasing by prohibiting the passing of the same reference to more than a single parameter.

Janus also employs a promising semantics technique by capturing the concept of switching input and output store for inverse constructs. Furthermore, it is capable of implementing a reversible self-interpreter and a tower of reversible interpreters. Several articles and surveys on reversible computing have been published, exploring various computation models for reversibility.

The concept of reversible programming languages is closely related to program inversion, which generates semi-inversed programs and addresses the view updating problem. Bidirectional languages, with forward and backward semantics, are designed to handle this problem as well.