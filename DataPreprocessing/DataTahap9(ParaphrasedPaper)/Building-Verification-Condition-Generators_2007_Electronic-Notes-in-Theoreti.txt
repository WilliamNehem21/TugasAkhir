We propose a method for developing verification condition generators in a more compositional manner, incorporating concepts from monadic denotational semantics and generic programming. Our technique facilitates the extension of an existing verification condition generator to handle new language constructs and to incorporate additional features, such as the generation of validation traces. We illustrate this method by extending a simple while language with an exception handling construct, which requires both a logic extension and a change in its structure.

The development and maintenance of realistic programming logics are known to be challenging, particularly when dealing with changes resulting from language modifications or feature additions. Implementing these changes is a complex and error-prone process that can introduce inconsistencies in the logic.

Our approach to representing a syntax-driven logic utilizes ideas from generic programming and monadic denotational semantics. Generic programming abstracts from algebraic data types, allowing us to decouple recursion over the datatype from the calculation of the semantics. This enables us to represent a syntax-driven logic by means of a generic fold, thereby simplifying the implementation process.

Monadic denotational semantics is employed to separate concerns within the denotational semantics, allowing different computations in the domain to be combined in a standard manner. By relying on this combination method, independence of the domain is achieved, enabling us to add to the underlying structure while keeping the base logic code unchanged.

To facilitate changes in the code, we transform it into an explicit algebra over the provided algebraic data type, making alterations easier. We achieve this by implementing the algebra as a fold over the abstract syntax and using monadic coproducts to add aspects to the existing monad, as described by Luth and Ghani.

The choice of a monad R, which maps the operations on record and post, is essential for the domain of the semantics. In our approach, we use a general state-carrying monad, with the state represented as a tuple of expressions and an expression. This monad includes functions for extracting and putting back the state.

This approach opens up several research opportunities, including the desire for a more compositional method of implementing verification condition generators and the formal verification of the generator itself. Furthermore, our approach suggests the possibility of reusing both existing code and proofs, potentially simplifying the process of proving soundness for a changed verification condition generator. However, further investigation is needed to assess its scalability to languages with function abstraction and application.