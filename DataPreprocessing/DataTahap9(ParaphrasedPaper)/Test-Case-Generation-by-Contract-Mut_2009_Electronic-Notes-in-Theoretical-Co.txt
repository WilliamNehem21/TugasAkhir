The spec# system, developed by Microsoft for use with C#, extends the programming language with preconditions, postconditions, invariants, and a concept of ownership. By integrating spec# with boogie, a verification condition generator that takes common intermediate language (CIL) code as input, and using the Z3 SMT-solver, a framework for automatically verifying code has been established. This framework is capable of producing error models and generating counterexamples when, for instance, a postcondition cannot be validated. One advantage of having a counterexample is that it can be shown to the developer to help them understand why the contract may be violated. A tool has been developed based on this approach that enables execution of counterexamples.

The functioning of the spec# system is similar to an event-based system such as event-B, where each action (function) is equipped with a guard and an update statement. In model programs, the update statement corresponds to the method body, while the guard is constructed using a modified form of the precondition concept. By leveraging these guards and postconditions in the method body, SpecExplorer conducts a state-space exploration to discover the transition system. It should be noted that these model programs lack postconditions specified in a contract-like manner.

The organization of this paper is as follows. Section 2 revisits the key definitions of the underlying theory and introduces a formula for generating test cases based on mutation. Section 3 provides an introduction to spec# and boogie and explains how to connect the refinement check of boogie with the previously presented test-case generation formula. Next, in Section 4, the proposed methodology is discussed, and an example is provided. Section 5 evaluates the challenges that arise in more complex environments. Before concluding, related research is presented.

The paper adopts the idea that a test case is an abstraction of the system specification. In the context of fault-based testing, the aim is to cover anticipated faults, and thus, the search is for test cases that can differentiate between correct and incorrect specifications. The paper also follows the standard notion that faults result from errors (bugs), while a failure is a wrong behavior caused by a fault.

To generate faulty specifications from the correct one, the paper relies on mutation operations similar to those presented in existing work. The underlying assumption is that the developer will create an almost correct implementation and that errors will represent minor deviations from the correct specification. By slightly mutating the correct specification and calculating test cases to distinguish between the two versions, the approach covers most errors.

Boogie is a static program verifier that uses the SMT-solver Z3 to handle the proof obligations. Boogie has its own input language, and different front-end systems can utilize Boogie for automated reasoning. Spec# is an extension to C# and adds features for contract-based program verification. Internally, Spec# relies on Boogie.

Boogie provides several counterexamples when more than one precondition/postcondition does not hold. This may be due to non-deterministic behavior that potentially violates multiple conditions, or when both pre- and postconditions have been mutated. However, adding mutated pre- and postconditions simultaneously is not recommended, as a mutated precondition may mask contract violations of the postcondition.

From the counterexample, the input values and the return value of the mutated method can be observed. However, the expected return value according to the specification cannot be directly observed from the provided error model. This is because the postcondition is checked within the subsequent statement.

One of the key features of spec# is its ability to work with all data types offered by C#, including reference types, value types, and generic types. Spec# also includes annotations for some parts of the .NET core library. Considering Microsoft's commitment to bringing contracts to everyday developers, future improvements in contract coverage of core libraries are anticipated. However, the same reasons make test case generation a complex task, as reflected to some degree in the reported counterexamples.

At different points within the computation process, these functions will yield different values, as indicated by different heap generations in the counterexample: $heap represents the initial generation followed by $heap@0 (the successorship is encoded elsewhere in the counterexample).

In addition to object-creation issues, there are more fundamental challenges. For testcase generation, the approach relies on the solving capabilities of Z3. If the solver cannot prove a given verification condition, even if it is true, the testing approach attempts to create a test case. However, given that the approach starts from a proved specification and also has control over the performed mutation operations, this case seems manageable.

Testing, as proposed in existing work, can be used to generate test cases from pre- and postconditions. This work has been integrated into the latest version of the Eiffel development environment with the goal of providing immediate feedback to the developer if an implementation does not adhere to the given contract. Failing test cases are stored and rerun during subsequent compilation cycles. The paper considers the potential adaptation of the approach to fit the Pex methodology, which could also involve using random testing for generating discriminating test inputs. However, the combination of these approaches was not further evaluated.

