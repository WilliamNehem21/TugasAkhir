This research paper introduces an algorithm for determining whether a type expression represents an empty set of terms. It discusses the use of regular term languages as types and their limitations compared to tuple distributive types. The paper presents an algorithm that can decide the emptiness of a type expression and demonstrates its correctness and complexity. The algorithm is designed to work with regular types with parametric type definitions, accommodating parametric and overloading polymorphism. The paper also highlights the challenges of applying existing tree automata algorithms to type expressions with parameterized definitions, leading to the development of a new algorithm that can handle type definitions directly, avoiding the repeated construction of automata. 

The paper is organized as follows: Section 2 describes the language of type expressions and type definitions, Section 3 presents the emptiness testing algorithm, Section 4 addresses the correctness of the algorithm, and Section 5 discusses the algorithm's time complexity. The paper concludes in Section 6. Additionally, the paper specifies that proofs in an appendix are not necessary for the final version.

The paper also addresses the issue of complexity, focusing on the worst-case time complexity of the algorithm and measuring the time spent on evaluating a given type expression in terms of the number of nodes in the evaluation tree.