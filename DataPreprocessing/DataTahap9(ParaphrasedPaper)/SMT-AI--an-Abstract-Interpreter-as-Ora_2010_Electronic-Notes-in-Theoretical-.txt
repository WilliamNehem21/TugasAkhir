In the past ten years, there has been significant progress in verification techniques utilizing SMT solvers for demonstrating inductive invariants in systems. This approach enables the verification of functional properties and can be applied to address industrial-scale problems. However, it often requires human intervention to provide manually crafted lemmas to assist in the analysis and completion of the proof.

The subsequent section will introduce and justify the integration of multiple analysis methods, while the rest of the paper will focus on the implementation of one of these methods. Section 3 will outline the input language of the tools, and the following sections will delve into the analysis it performs. Finally, Section 6 will provide implementation details, Section 7 will offer an example, and Section 8 will conclude and outline the remaining work.

Abstract semantics are computed using common least fixpoint increasing iterations supplemented by delayed widening with thresholds, followed by decreasing steps with narrowing, wherein memi and memu predicates serve as assignments for variables functioning as memory in the synchronous system. The majority of the work involves analyzing the expressions that define the values of these variables from their values in the previous step. The subsequent part of this section will focus on this separate analysis, conducted through decreasing iterations towards the greatest fixpoint.

When the result n is false, one of the subexpressions e1 or e2 can determine the value of the conjunction. Consequently, we can only compute a join of backward evaluations to false of subexpressions, with disjunction involving a similar process, replacing join with meet and vice versa.

This backward semantics is commonly applied to the guards of constructs such as if... then... else or while loops in imperative languages like C. Iteration may be necessary in our case to enhance precision, as information learned in one part of an expression can enable more precise results in another part.

We cannot utilize a widening operator (or its dual) to expedite convergence, as this would result in an under-approximation of the greatest fixpoint, whereas we aim to compute an over-approximation of it. The only solution to ensure convergence within a reasonable timeframe is to employ a narrowing operator, which essentially limits the number of iterations. While frequent stopping by narrowing would yield overly coarse results, it appears that convergence is achieved after only a few iterations on the formula provided to our tool (see section 3.3).

The analysis presented here, even when using simple abstractions such as intervals, yields compelling results. Calculating non-relational properties like variable bounds enables the optimization of the analysis for the SMT solver, such as by leveraging bit-blasting techniques. For example, in some simple systems with integer counters, the k-induction analysis might require increasing the induction depth to unmanageable levels, whereas our abstract interpretation tool using widening with thresholds can infer bounds within a few computational steps.