In this paper, we introduce a systematic approach for simulating and visualizing distributed algorithms using graph relabelling systems. Specifically, we employ the use of local relabelling rules in distributed applications to automatically display the execution of entire distributed algorithms. We have developed a prototype tool in Java for implementing and visualizing distributed algorithms, and we demonstrate the capabilities of our framework through the simulation of various distributed algorithms, including election and spanning trees.

Our work presents a novel method based on local graph transformations to visualize distributed algorithms, surpassing the existing animation of isolated instances of such algorithms. We demonstrate that a broad class of distributed algorithms, describable by graph transformation systems, can be automatically simulated and visualized. Graph relabelling systems, along with local computations in graphs, serve as powerful models for encoding distributed algorithms, proving their correctness, and comprehending their capabilities. We consider a network of processors with arbitrary topology, represented as a connected, undirected graph, where vertices denote processors and edges denote direct communication links. Algorithms are encoded using local relabellings, which are carried out within a fixed radius k of the given graph. The relabelling is performed until no further transformation is possible.

Additionally, we investigate the use of randomized algorithms for implementing distributed algorithms specified by local computations, where each process attempts to synchronize with its neighbors at random. We use these techniques to visualize the execution of distributed algorithms, displaying all random local synchronizations throughout the network and the messages exchanged during these synchronizations until termination.

The paper is structured as follows: Section 2 introduces graph relabelling systems and their application in describing distributed algorithms, while Section 3 presents a method for simulating and visualizing distributed algorithms coded by graph relabelling systems. Finally, Section 4 outlines future work and provides the concluding remarks.

We assume that all graphs under consideration are finite, undirected, simple, and connected. An l-labelled graph is a graph whose vertices and edges are labeled with labels from a possibly infinite alphabet l. We denote it as (g; ), with g as the underlying graph and as the labelling function. The class of l-labelled graphs is denoted by gl, or simply g if the alphabet l is clear from the context.

Our visualization approach includes showing and animating the execution of distributed algorithms, with data exchanged between processors and updates of processor and channel statuses and labels displayed. For instance, marking edges belonging to the spanning tree is crucial for determining a spanning tree. We also present a detailed explanation of the distributed synchronized procedures and local computations used in our visualization techniques.

For the implementation of distributed algorithms, we develop a prototype tool using the Java language, where processors are simulated by Java threads. The tool includes a library of high-level primitives that allow users to implement local computations, including functions for implementing synchronizations such as rendezvous and starsynchro. Furthermore, communications between processors can be expressed by primitives such as sendto and receivefrom.

To illustrate the implementation of our approach, we provide an example of the implementation of a spanning tree using the relabelling system primitives discussed in Section 2.