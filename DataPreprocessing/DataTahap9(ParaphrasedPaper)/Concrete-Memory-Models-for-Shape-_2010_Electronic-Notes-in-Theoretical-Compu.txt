The goal of shape analysis is to deduce characteristics about the runtime structure of the memory heap. It surpasses alias and null-pointer analyses in terms of both expressiveness and precision. Applications of shape analyses encompass optimizing compilation, prevention of runtime errors such as dereferencing dangling or null pointers, program verification, and automatic parallelization.

Languages like C, C++, and to a lesser extent Ada allow pointers to point inside an object and support additional operations such as taking the address of a record field, pointer arithmetic, and implicit pointer passing.

Various shape analysis tools have been developed for different programming languages, such as TVLA for Java-like languages and XISA based on separation logic for a subset of C. The memory models for shape analyses are typically described at an abstract level, but a clear understanding of the concrete memory model is necessary to comprehend the scope of these analyses and to facilitate their reuse in different contexts.

In general, the semantics we have presented assume static typing of expressions. However, casts introduce dynamic typing and are not addressed by any of these analyses. Handling casts requires additional assumptions about the internal representation of types (which could be provided by the ABI), and the memory model needs to retain the value of each byte.

We have categorized concrete store-based memory models using two criteria: the way they store pointers and the way they represent offsets. For each of the four memory models, we have provided a concise semantics of a segment of Clight, which includes arrays and pointer arithmetic. In the case of this language, the standard semantics can be expressed using our standard memory model. The object memory model commonly utilized in shape analyses imposes strong semantic restrictions, which we have addressed through instrumentation.