This translation method differs from approaches that incorporate an assertion language interpreter within the run-time environment. While the translational approach may be less potent than the interpreter approach in some aspects, as it can only accommodate design assertion constructs with relatively straightforward translations into an implementation assertion language, its simplicity affords flexibility. Modifying translation rules and creating new bindings to different implementation or assertion languages are relatively uncomplicated compared to producing a new interpreter. This makes the translational approach well-suited for systems implemented in a mix of languages, such as component-based systems.

The remaining sections of the paper are structured as follows: Section 2 presents the main concepts of the approach and discusses some issues through the application of a hypothetical system. Section 3 outlines an initial prototype implementation that includes a customizable translator for OCL. Section 4 examines the relationship between the current work and related research in assertion systems, particularly alternative approaches to supporting OCL. Finally, Section 5 concludes the paper.

For example, a comment containing a link to the UML model could activate a translator that inserts assertions into the iContract assertion language. While the approach showcased the use of this assertion system, several other Java assertion languages could have served the same purpose. Another potential solution would have involved using assert statements in the Java programming language, where the tradeoff lies between flexibility and more specialized constructs. Directly utilizing the language's features offers flexibility but leaves the user free to specify their preferred assertions, whereas a specialized assertion system better restricts what the user can do.

The obvious constraint that "off" time must always be greater than "on" time is not explicitly stated here. While it is apparent that the times in each row must increase moving from left to right, it is less obvious that each leg of the trip must adhere to the defined constraints.

Similar to programming language processors, there is no clear boundary between translation and interpretation. Interpreters typically involve at least some translation to an intermediate form, while translators usually rely partly on the provision of run-time libraries. It is conceivable to envision solutions where design constraints are partially translated, with library support bridging the gaps between the design constraint language and the functionality offered by existing assertion languages.

Previous approaches to supporting OCL have predominantly employed specialized interpreters. For instance, [reference] proposes a meta-model for OCL as a starting point for implementing an interpreter. A similar approach is adopted by [reference], which details experiences in interpreting OCL, and by [reference], which proposes efficient methods for executing complex OCL assertions.