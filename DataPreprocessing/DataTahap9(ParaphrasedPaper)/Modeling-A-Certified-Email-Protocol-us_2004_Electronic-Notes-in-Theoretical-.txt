Describing and reasoning about asynchronous distributed systems is often a challenging and error-prone task. In this paper, we aim to explore the use of the input/output automata framework as a tool for describing and reasoning about cryptographic protocols operating in an asynchronous distributed system. To demonstrate the effectiveness of this approach, we present a formalization of a simple certified email protocol using the input/output automata model and establish the satisfaction of certain security properties during the execution of the protocol.

Cryptographic techniques have been employed to enhance the security of email services. Several certified email protocols have been proposed in the literature to ensure that the message exchange procedure offers participants various security properties. These protocols typically involve a trusted third party (TTP) that oversees the behavior of the participants, assists in message exchange, and resolves disputes when necessary. Based on the role played by the TTP, protocols are categorized as either inline or optimistic. In inline protocols, the TTP actively participates in each message exchange, while in optimistic protocols, the sender and receiver conduct the message exchange without TTP intervention, but they can involve the TTP to resolve disputes, such as those arising from attempted cheating by one of the parties.

The notation p_kb(m) denotes the encryption of message m using the public key of user b in a public-key encryption algorithm that ensures non-malleability, meaning that given a ciphertext, it is impossible to generate another ciphertext such that the respective plaintexts are related.

In the context of communication from node i to node j, the channel's state is defined by a list of variables describing the state of the automaton. For this channel, the state is entirely defined by a variable containing the messages currently in transit on the channel.

The channel has an input action send(m)i,j, which is controlled by another unspecified automaton, denoted as a and modeling node i, and which has the same action send(m)i,j as an output action. When automaton a executes this action, the channel also executes the action simultaneously, indicating that the action send of a controls the action send of the channeli,j. Consequently, the effect of this action in the channel automaton is to add a message to the set of in-transit messages.

Additionally, the channel has an output action receive(m)i,j with a precondition (a boolean condition) specifying when the action is enabled and can be executed. Moreover, all other automata with this action as an input will execute it. An automaton denoted as b, modeling node j, has receive(m)i,j as an input action.

There are also internal actions similar to output actions (i.e., they have a precondition and an effect), with the distinction that they do not interact with other automata. Multiple automata may have internal actions with the same name, and they are all independent. Notation name.var is used to indicate variable var of automaton name. For example, channel.msgs refers to variable msgs of automaton channeli,j.

The certified email protocol aims to provide non-repudiation of delivery, ensuring that the mail originator has irrevocable proof that the recipient received the same content sent by the originator, thus preventing the recipient from falsely denying the message receipt. Additionally, the protocol's proper execution must guarantee fairness and fail-safe behavior. Fairness ensures that the proof-of-delivery from the recipient and the proof-of-origin from the originator are available to the respective parties, while fail-safe behavior prevents incomplete execution of the protocol from resulting in situations where one party has the proof-of-delivery but the other party does not have the proof-of-origin, or vice versa.

The actions of the automaton are described in a logical order from top to bottom, left column first, corresponding to the logical order in which the actions are executed. A unique identifier id is attached to all messages related to a particular email to avoid interference with delayed messages from other sessions.

The action constr m1 sets the variable statussnd to send, allowing the send action to be the only non-input action enabled. This action interacts with the recipient j and sends the message stored in m1 through the channel. The program counter enters a wait state, where all non-input actions are disabled. Execution continues when a message is received from the TTP, which is stored in variable m4. Subsequently, the program counter is updated to done, indicating successful termination of the protocol. The output action send is in a task and, in a fair execution, has infinitely many opportunities to be performed.

The lose action models the delivery of a corrupted message, setting the program counter statusrcv to discarded and aborting the protocol. The first receive action retrieves a message from the channel and initiates processing of the incoming message.