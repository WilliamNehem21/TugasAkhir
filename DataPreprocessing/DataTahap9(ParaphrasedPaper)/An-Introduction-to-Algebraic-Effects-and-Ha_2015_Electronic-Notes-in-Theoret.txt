The operation call op(v; y. c) involves passing a parameter value v (e.g., the memory location to be read) to the operation op. After op performs the effect, its result value (e.g., the contents of the memory location) is bound to y, and the evaluation of c, known as a continuation, resumes. It is important to note, however, that enclosing handlers may override this behavior.

When a computation returns a value x without further printouts, the given accumulator acc is returned in addition to x. If print is called, the continuation is resumed by yielding it the expected unit result. Since the continuation is further handled as a function, we need to pass k() the new accumulator, which is acc extended with s. To obtain the collected output of a computation c, we apply the resulting function to the empty accumulator as follows:

Exception handlers are a special instance of handlers. Exceptions are represented with an operation raise, which takes an exception argument (e.g., error message) and yields nothing to the continuation. For more details on how this can be enforced, refer to Example 4.1.

With the backtrack handle pythagorean(m, n), the computation finds (5, 12, 13) for (m, n) = (4, 15) but fails for (m, n) = (7, 10). The exact triple found depends on the implementation of the handler. If, instead, we tried yielding false, the resulting triple for (m, n) = (4, 15) would be (9, 12, 15). To obtain a list of all possible triples, we can use the handler pickall from section 2.3.1, extended with a clause that handles fail with an empty list.

The state is represented with operations set for setting the state contents and get for reading them. For simplicity, it is assumed that a single memory location holds an integer. The set operation takes an integer, stores it, and returns a unit result, while the get operation takes a unit parameter, reads the stored integer, and returns it.

Handlers can be used to temporarily alter the stored value or to log all updates. They can also be used to implement stateful behavior even without assuming a built-in one, as shown in section 2.1.3, where a parameter-passing handler is used to pass.

To make the intuition about the behavior of computations concrete, an operational semantics is provided. The idea is that operation calls do not perform actual effects (e.g., printing to an output device) but behave as signals that propagate outwards until they reach a handler with a matching clause. Any operation call that escapes all handlers is treated as a terminating computation, i.e., one that does not further reduce. Actual effectful behavior is simulated by an outermost handler or through one of the approaches listed in section 6.5.

Call-by-push-value is an evolved version of the fine-grain call-by-value approach. Although the latter was used in this tutorial as it is closer to the more familiar call-by-value, recent work on algebraic effects often uses call-by-push-value. For comparisons of the operational semantics and effect system in a call-by-push-value setting, see [citation needed]. For denotational semantics and reasoning, see [citation needed].

The list of examples in section 2 is not exhaustive. For more involved examples, including multi-threading, delimited continuations, selection functionals, text processing, resource management, efficient backtracking, or logic programming, refer to [5, 10, 6, 25]. Several implementations of handlers have also been developed, either as independent languages [3, 14] or as libraries in existing languages [10, 6, 25]. More recently, a multicore branch of OCaml has started adopting handlers as a way of implementing concurrency primitives.