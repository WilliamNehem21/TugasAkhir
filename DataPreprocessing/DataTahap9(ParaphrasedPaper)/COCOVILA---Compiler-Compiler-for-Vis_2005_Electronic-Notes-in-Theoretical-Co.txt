The paper introduces a compiler-compiler specifically designed for visual languages, serving as a platform for constructing visual programming environments that can translate schemas into both textual representation and programs that capture the underlying meaning of the schemas. The framework leverages attribute grammars for implementing deep semantics in schema languages, with attribute dependencies being implemented as methods of Java classes. In contrast to compiler-compilers for textual languages, a significant portion of the framework is dedicated to supporting interactive usage of visual languages.

The primary goal is to create a compiler-compiler for visual languages akin to those used for programming languages, intended for expedited development of domain-specific visual languages. To achieve this, the scope is limited to schema languages with well-defined abstract syntax in order to describe both syntax and semantics of the considered languages. On the semantic front, the framework facilitates the precise specification of shallow semantics that produces a textual representation of schemas without compromising essential information included in a schema. Additionally, a general method is presented for implementation.

While similar to meta-modelling tools such as MetaEdit or Atom3 in some aspects, COCOVILA differs notably in its treatment of scheme semantics. It utilizes a dynamic evaluation technique for attributes of the syntactic graph underlying the scheme, distinguishing it from the former tools.

Moreover, the paper describes the application of the scheme in the context of calculating loads and kinematics of a gearbox, where gears are interconnected using arrangement and lines to other objects like the motor and monitoring device. The scheme editor allows for adding, deleting, and arranging objects and relations using a toolbar and pop-up windows for instantiating object attributes and manipulating the scheme.

To handle large schemes, the scheme editor employs hierarchical composition, enabling parts of a scheme to be encapsulated as separate classes. This enables the construction of a hierarchy of schemes, with each scheme object containing sub-schemes, allowing for the viewing and manipulation of different levels of abstraction within the scheme to address specific issues.