One popular approach in security analysis uses abstract, symbolic terms to represent the bit strings transmitted over a network. However, the high level of abstraction in such models can obscure the relevance of proofs carried out in these models when applied to real-world executions. Notably, while effective encryption functions involve randomization, most existing symbolic security models do not explicitly incorporate this randomization of ciphertexts.

In this paper, we propose a more practical alternative approach. We demonstrate that for a broad range of security properties (including standard formulations of secrecy and authenticity), the security of protocols within a simpler model implies security in a model that utilizes labels. When combined with the computational soundness result, our theorem facilitates the translation of security findings from symbolic models that do not employ labels to conventional computational security. Based on these results, we have developed an Avispa module for verifying security properties within a standard cryptographic model.

One key feature of computational, complexity-based models is their ability to explicitly consider and reason about the use of randomness, which is essential for achieving meaningful security for encryption. In contrast, symbolic models often do not represent randomness directly. For example, a typical representation of the encryption of a message m under the public key of entity b is the term {m}ek(b), which does not capture the dependency on the randomness used to generate the ciphertext. While this abstraction may be adequate in certain scenarios, it may not be sufficient in others.

Recently, a model that utilizes labels to capture the randomness in ciphertexts (and signatures) has been employed to establish the soundness of symbolic analysis with respect to computational models. Their results rely on an emulation lemma, which asserts that for protocol executions, every computational trace can be mapped to a valid symbolic trace. This mapping is then used to translate security properties that hold in the symbolic model to computational analogues. Notably, the use of labels is essential even when there is no explicit repetition of ciphertexts, in order to distinguish between encrypted messages generated by agents and those generated by the adversary.

In this paper, we propose and elucidate an implicit alternative solution. The idea is to keep existing tools unchanged, utilize their underlying (unlabeled) model to prove security properties, and subsequently demonstrate that the results are indeed meaningful for the labeled model. The main result of this paper is to prove that for a broad class of security properties, the approach we propose is feasible.

We provide the syntax of protocols with labels, which is adapted from a previous work. The specification language allows parties to exchange messages using public key encryption and digital signatures built from identities and randomly generated nonces. Protocols that do not use labels are derived straightforwardly.

At the commencement of the execution, each party outputs a set of identities and receives the corresponding secret keys. We focus on static corruption, as the soundness result using explicit labels only addresses this type of corruption. However, in our formal context, our reduction result can be easily extended to the case of adaptive corruption, as we can map traces with dynamic corruption to traces where all corrupted agents are so at the beginning.

We use deduction relations to characterize the set of valid execution traces. A trace (sid1, f1, h1),...,(sidn, fn, hn) is deemed valid if the messages sent by the adversary can be computed by Dolev-Yao operations.

The key argument in our proof is that only pattern matching is performed in protocols, and when a term with labels matches a pattern, the unlabeled term matches the corresponding unlabeled pattern. The proof is carried out by induction on the length of the trace, with full details provided in the appendix.

The Avispa project offers a platform for the automatic verification of security protocols and includes a specification language called HLPSL for specifying both protocols and security properties. Protocols specified in this language can be verified using four different tools, three of which (OFMC, ATSE, and SATMC) utilize symbolic models with bounded parallel execution sessions. The fourth tool, TA4SP, provides verification capabilities for an unbounded number of sessions. These tools can be employed to verify three security properties: secrecy, weak authentication, and replay protection.