This academic paper investigates the optimization of ri automata for a given grammar, focusing on the reduction of automaton size while minimizing impact on run time stack activity. The paper presents examples from ANSI-C, IBM VS-COBOL, and Pascal to demonstrate how making small compromises in stack activity suppression can significantly decrease automaton size without significantly affecting run time stack activity. The authors discuss the development of heuristics to guide the specification of these automata and emphasize the main goal of creating a tool that automatically optimizes ri automaton size for a given application. The paper also touches upon technical compromises, such as placing an upper bound on nesting levels, and proposes the separation of regular parts of a grammar from the context-free parts using ri parsing technology.

The paper introduces the concept of reduction-incorporated (ri) parsing and discusses the work of various algorithms that allow for the construction of automata from context-free grammars. It also presents experiments that highlight how small changes to grammar terminalization schemes can lead to significant reductions in the size of ri automata without greatly impacting parse times. The authors note that a more comprehensive understanding of the space of ri automata will be achievable once automated tools are complete.

Additionally, the paper compares the traditional approach of defining programming language grammars in terms of individual ASCII characters with the approach of using a regular lexer to consume tokens defined as regular sets over characters and a parser to perform context-free matching on the resulting token stream. It emphasizes the advantages of using a regular lexer, such as improved speed, error reporting, and reduced non-determinisms in the grammar.

The paper concludes by discussing the potential for reducing the size of the automaton by adding extra terminalizations within a chain and speculates on the benefits of manual manipulation in languages like COBOL versus block-structured languages like C and Pascal. It also references a case study comparing GLR parsing algorithms as a relevant source.