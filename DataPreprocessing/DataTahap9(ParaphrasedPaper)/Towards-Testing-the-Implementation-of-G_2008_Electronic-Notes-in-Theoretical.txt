We introduce a testing approach for evaluating the implementation of graph transformation specifications, specifically focusing on generating test cases for graph pattern matching. Our method involves the creation of an adaptable fault model that incorporates common programming errors and the intricacies of graph transformations. To achieve this, we integrate conventional hardware testing techniques used for combinational circuits with software testing methods for mutant generation in order to produce test cases.

In practice, conceptual flaws in transformations are typically identified through verification techniques (such as termination, confluence, and semantic correctness) and/or testing techniques. While verification is predominantly employed during the design phase of transformations, testing is more suited for the implementation phase, particularly when a standalone transformation plug-in has been developed according to the corresponding specification. Testing offers two main advantages: it can be applied to large models without encountering combinatorial explosion, and tests are directly executed on the implementation, which may not always be feasible with model checking.

We propose a fault model to encompass potential flaws in the implementation, where test generation is conducted by utilizing a combinational circuit representation derived from the preconditions of graph transformation (hereafter referred to as GT) rules. These potential faults are translated into stuck-at faults, as various hardware testing techniques for the combinational circuit support this fault model. Through systematic fault injection, single binary faults are introduced into the circuit, and test vectors are computed. The specific test cases are then generated using mutation rules in the form of test graphs.

For instance, according to the metamodel, a correctly formed instance of a finite automaton is composed of states and transitions. A transition links from its original state to its destination state. The automaton's initial states are marked with 'init', while the active states are indicated by current edges. It is also possible to define special, for example, colored states, based on inheritance.

Graph transformation is a formalism based on patterns and rules and is utilized for manipulating graph models. When a rule is applied, a graph undergoes transformation by replacing a portion of it with another graph. By defining a metamodel and a set of rules over that metamodel, dynamic changes in an initial model can be described.
In addition, the rule application in a graph transformation rule 'r' contains a left-hand side graph 'lhs', a right-hand side graph 'rhs', and negative application condition graphs 'nacs'.

To evaluate the success of matching each rule, pattern matching criteria are extracted from the transformation specification in the form of a boolean expression. This formula is considered satisfied when a successful matching is found for the corresponding GT rule. The objective is to repurpose existing techniques for hardware testing, hence the boolean formula is depicted in the form of a combinational circuit, allowing for the application of traditional test generation algorithms.

In the context of test generation, fault injection involves introducing single faults into the inputs of the circuit. For simplicity, the method of boolean differences is applied here to generate binary test vectors for stuck-at faults in the combinational circuit that represents pattern matching. This method guarantees that the fault is observable at the output of the circuit using the generated test vectors.

Following the generation of test graphs, the set of produced test graphs should be examined for test optimization in order to create a more concise set of test cases. During this process, it is essential to determine whether the goal is solely fault detection or also diagnosis, as test compaction can only be cautiously applied in the latter case to avoid information loss for diagnosis.

Additionally, it is our aim to expand our testing method to consider the postcondition of GT rules, and to enhance the fault model by incorporating control flow faults and design methods for testing the control structure of graph transformations. Furthermore, further work is needed in the area of test set optimization. Our future goal is to explore the applicability of our method not only for fault detection but also for diagnosis, and to test our method on graph transformation implementations.