Jolie stands out due to its unique combination of a robust mathematical foundation provided by the orchestration process calculus, along with a developer-friendly development and execution environment featuring a C/Java-like syntax, as opposed to an XML-based syntax. This contrasts with most current web services orchestration languages, where the formal operational semantics are typically investigated and defined after the syntax has been established. Additionally, it differs from the trend in the development of WS-BPEL, where extensions to support the invocation and utilization of Java programs are being developed only after the orchestration language's definition.

Furthermore, Jolie represents a significant advancement in research on orchestration and choreography languages, as it allows for experimental verification of whether the theoretical approach taken during the design of process calculi holds up in practical execution of orchestration programs. As part of this effort, certain additional constructs not present in the original process calculus were incorporated into Jolie, such as an iterative "while" statement and a timing statement "sleep(msec)" for programming processes that need to wait for a specific amount of time. The latter is particularly useful for orchestrators that should not wait indefinitely for a service response due to communication or service faults. It's also important to note that Jolie was developed by leveraging the principle of encapsulation and modularity, enabling protocol and communication medium independence. This allows for easy extension of the engine to support orchestrators that utilize various communication mediums such as SOAP, internet sockets, shared files, and more.

Jolie employs a C-like syntax for designing orchestrator services, making the language intuitive and easily learnable for programmers familiar with C. The communication in Jolie is based on sockets, with orchestrators waiting for messages on a network port. In order to communicate with another orchestrator, it is essential to know its hostname or IP address and the port it is listening on, and this information is stored in a location definition.

Jolie's communication operations are designed such that input operations expect a list of identifiers, while output operations expect a list of id=id pairs. The language's characteristic of distinguishing between the internal operation name used within the orchestrator and the bound operation name of the invoked one allows for decoupling of the orchestrator code from the external operation name binding.

Additionally, Jolie provides a mechanism for defining procedures that can be called by other procedures using the "call" statement, and each definition pairs an identifier with a process, which syntactically resembles a piece of code composed of Jolie statements. Informally, the process defined within a definition can be viewed as the body of a C function.

The language also supports a range of operations such as the notification operation represented by id@id<id list>, and synchronization operations like "linkin" and "linkout" for parallel process synchronization. The use of guards within square brackets allows for non-deterministic choices, making the interpreter wait for input on one of its guards.

In future developments, there are plans to implement a new format for locations aimed at enhancing communication medium independence and to enable interactivity with WSDL definitions. This will involve leveraging object-oriented internal operations implementation along with protocol-independent communication core data to enable orchestrators to use a variety of protocols for exchanging data with external applications. This will build on the current capability focused on network sockets and extend it to support alternative communication mediums such as files and internal pipes.
