The JML specifications utilize Java syntax and are embedded within Java code using specially marked comments like /*@...@*/ or after //@. A simple JML specification for a Java class includes pre- and post-conditions added to its methods, as well as class invariants that restrict the possible states of class instances. Method pre- and post-conditions are embedded as comments immediately before method declarations. JML predicates are first-order logic predicates formed of side-effect free Java boolean expressions and several specification-only JML constructs. Due to the side-effect restriction, certain Java operators such as ++ and - are not allowed in JML specifications. JML provides notations for forward and backward logical signals (e e) r, specifying an exceptional method post-condition r. It states that if the method throws an exception e of type e (a subtype of java.lang.Exception), then the JML predicate r must hold. Predicate r must be a valid JML predicate. JML allows the use of the alternative clause exsures for signals.

The assignable l specification specifies that the method may only modify location l, and any other location not listed in l may not be modified. This must hold true for both normal and exceptional post-conditions. Two special assignable specifications, assignable\nothing and assignable\everything, are also defined. The former specifies that the method modifies no location, while the latter specifies that the method may modify any location. JML allows the use of the alternative clauses modifies and modifiable for assignable.

The invariant i declares a class invariant i. In JML, class invariants must be established by the class constructors and must hold after any public method is called. Invariants can be temporarily broken inside methods but must be re-established before returning from them.

For the method setValue, the normal behavior specification states that if v is non-negative, then the method will terminate normally, the new value for decimal will be v*precision, and the value returned by the method will be the object this. The exceptional behavior specification states that if v is negative, the method will throw an exception of type DecimalException, and no location will be modified. The "also" keyword expresses that setValue can have either a normal or an exceptional behavior.

The JML specifications for the AX-LIMS project manager plugin were tested using the JML Common Tools, a suite of tools that provides support for run-time assertion checking of JML-specified Java programs. The suite includes JMLC, JMLUnit, and JMLRAC. The JMLC tool compiles JML-specified Java programs into Java bytecode that includes instructions for checking JML specifications at run-time. The JMLUnit tool generates JUnit unit test code from JML specifications and uses JML specifications processed by JMLC to determine whether the code being tested is correct. Test drivers are run using the JMLRAC tool, a modified version of the Java command that refers to appropriate run-time assertion checking libraries. For the case study presented in this paper, JML specifications were provided for the main classes of the AX-LIMS project manager plugin; however, some classes related to the graphical user interface (GUI) were not specified. JMLUnit was used to generate JUnit tests for each method in every class, and JMLRAC was used to run the tests.

Redundant properties serve to bring the attention of the readers of the specification and the people working on the implementation of the application. Thinking about invariants prior to writing code is a practice to which programmers do not easily adhere. Having a formal specification of the application and systematically using a tool for checking the correctness of the code forces programmers to think about how the written code affects the consistency and the correctness of the whole program. A correct implementation for the method setTasks is presented below and relies on the correctness of the implementation of both delTask and addTask.

JML can be further used for checking insight on how method setASD works in specific cases. To do this, the JML assert specification construct, which checks for the satisfaction of a predicate at a dedicated point within a method, is used. After several iterations of specifying and checking, an appropriate JML code for setting the project state is provided. In previous software developments carried out by the ParqueSoft engineers, OCL (Object Constraint Language) was used for expressing constraints on the UML models. However, for this case study, the ParqueSoft engineers decided to use JML for expressing these constraints instead, finding JML specifications much easier to code than OCL constraints. Therefore, JML will be used as the language for expressing model constraints in future ParqueSoft Java-based software developments.