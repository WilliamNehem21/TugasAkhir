The ambient calculus and lmntal share the notable feature of nested membranes, suggesting that any natural mapping from the ambient calculus to lmntal should translate ambients into lmntal cells, which is a key consideration in our encoding design. As a result, we refer to cells representing ambients as ambient cells.

Subsequently, we define the normal form of a name tree, which ideally aligns with the underlying ambient hierarchy. Specifically, an ambient hierarchy forms a tree structure, referred to as an ambient tree, and a name tree in a normal form should have a root cell at the topmost node of a connected subgraph of the ambient tree, as well as a proxy cell at each other node in the aforementioned connected subgraph.

Rules with names starting with proxy_ serve to reinstate the normal-form conditions of a name tree structure when the set of names referenced in each ambient is altered by mobility primitives. For example, proxy_enter enables recognition of two references to the same name within an ambient, while proxy_resolve merges two consecutive proxies for the same name in the same ambient. Additionally, proxy_insert_ middle is activated when two directly connected name cells (root or proxy) are moved to remote places not in a parent-child relation, and a new proxy is inserted in between. Similarly, proxy_insert_outer is activated when a child proxy is exported out of an ambient, changing the parent-child relationship between proxies and creating a new proxy at the parent level. Finally, proxy_merge_outer is activated when the second parent of a proxy is created (by proxy_insert_outer) and merges the two parents.

It is important to note that name normalization and ambient operations can occur concurrently. This means that in, out, and open rules may be applied even when name trees are not in their normal forms. However, these rules also maintain the aforementioned invariants, allowing name tree normalization to proceed asynchronously with ambient operations.

An issue arises in the encoding of !(open n.p) due to the duplication of p creating new references to the free names of p. The duplication of[p]] with free names can be expressed using aggregates, which are not yet supported in our current implementation. Instead, the lmntal system supports an nlmem (nonlinear membrane) API, which fulfills the necessary function. For instance, nlmem.copy({p}, a, r) creates two copies of the cell {+r0, p} with all its free links renamed, and connects r and the two fresh copies of r0 using a ternary atom with the name a. Furthermore, for each free link l except r0 of the original cell {+r0, p}, nlmem.copy connects the two fresh copies of l and the original l via the ternary atom a. The semantics of nlmem.copy can be given by the following rule scheme.

The author would like to express gratitude to the current and former members of the lmntal development team who collectively developed our publicly available lmntal implementation. This work is partially supported by grant-in-aid for scientific research ((b)(2) 16300009; priority areas (c)(2)13324050, (b)(2)14085205 and 04560009), MEXT and JSPS.