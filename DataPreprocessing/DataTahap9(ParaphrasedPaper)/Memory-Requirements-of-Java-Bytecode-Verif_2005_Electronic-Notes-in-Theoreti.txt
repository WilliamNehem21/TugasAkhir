Bytecode verification is a crucial aspect of the Java security model, ensuring the integrity of the runtime environment in the presence of untrusted code. However, on limited devices such as Java smart cards, there may not be enough memory to perform the necessary type-safety verification of Java bytecode locally. To address this issue, proof carrying code techniques are used to compute tamper-proof certificates outside the device, simplifying bytecode verification. Rose has developed an approach for a subset of the Java bytecode language that addresses this challenge.

Ensuring the type safety of program code is essential, as it is important to guarantee that bytecode instructions operate on program objects of the correct type. For instance, arithmetic instructions should not operate on object references, as this could compromise program security.

In this paper, we focus on the fundamental extensions of the Rose approach and introduce a new technique for memory optimization. The evaluation results of our approach are presented, and we also discuss related work on alternative approaches to bytecode verification in resource-constrained environments.

We make extensions to the type system itself and consider the special case of data types such as long and double, which slightly influences the implementation of the verifier. Furthermore, we address the issue of references to uninitialized objects within our type system, providing a transparent solution to a specific verification task.

We define a type transfer function of an instruction, which maps a given frame type to a frame type that characterizes the effect of execution according to the type-based semantics of the instruction. The final input frame type denotes the result of type inference for an instruction. We emphasize that if all instructions can be executed on their final input frame type, the program is considered type-safe.

The verification process involves an off-card phase to determine certificates through classical data flow analysis without the resource restrictions of the Java card. It is important to ensure the correctness of the information in the certificate, and several checks are performed to verify compliance between different frame types.

Our approach involves storing frame types temporarily to facilitate the verification process, and we discuss the memory consumption implications of this method. We utilize the type lattice to evaluate type transfer functions and merge frame types using the least upper bound relation.

We also address the handling of uninitialized object references within the type system and describe how the verifier rejects code if uninitialized references are used as operands of conventional instructions.

In our investigations, we focus on worst-case scenarios to ensure that they remain manageable within the limited memory of a Java card. We have analyzed various codebases, including the standard API supplied by the Java card development kit, packages of the standard Java runtime library, and the JDFA data flow analysis framework.

Additionally, we discuss the handling of multi-branches arising from switch instructions and the impact of our model on the Java card API. We compare the performance of our model in worst-case scenarios to explore potential optimizations.

Overall, our approach addresses the challenges of bytecode verification in resource-constrained environments and presents techniques to ensure the integrity and security of the runtime environment.