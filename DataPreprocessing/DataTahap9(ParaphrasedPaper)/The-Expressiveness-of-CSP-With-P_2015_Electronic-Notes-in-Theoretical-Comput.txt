In the context of our study, a specific action can be carried out by another process whose identification is based on the structure of the process p for which we are analyzing transitions. With the exception of recursion, these identified processes are parameters of the operator for which we are establishing the meaning.

In scenarios other than recursion, it is necessary to capture the state into which the process transitions. This state is always represented by a syntax containing placeholders for active and inactive arguments. The syntax of the state is constrained to prevent cloning or suspension of the active arguments of the original operator. However, the syntax can freely handle inactive arguments and discard any argument as needed.

Theorem 4.1 states that if the operator f q(p) is pri-csp-like and all other operators reachable through the transitive closure of its combinators' third components exhibit similar characteristics, then for any arguments p and q, f q(p) can be expressed in pri-csp, meaning that the simulation is strongly bisimilar to f q(p).

Similar to previous studies, our proof involves constructing the (pri-)csp implementation, which is more intricate than the implementation without negative premises. Although there are commonalities with earlier results in the constructions we employ, we have identified several simplifications.

If no combinator has both positive and negative premises for the same argument, we can ensure that the argument process contributes to the firing of the combinator as necessary. For positive premises, achieving this contribution is straightforward. For negative premises, we can utilize priority to trigger an event specifically when a certain set of actions is not feasible.

There are two approaches for dealing with the activation of inactive arguments, each of which is discussed in separate sources. The first method involves dynamically generating new argument processes each time one is activated, while the second approach is applicable when there is an upper bound on the overall number of active arguments. In the latter approach, inactive arguments can be recycled, allowing the "zombies" created by deactivating arguments to be reborn in a different form.