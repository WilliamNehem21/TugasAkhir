The primary focus in deriving a loop function lies in identifying the inductive argument that led to the creation of the loop. Although expressing the loop function through a recursive formula substitutes one inductive argument with another, we aim to determine the function of the loop in a closed form by elucidating the impact of the loop's execution on all pertinent variables within the program.

Our method entails a stepwise approach to deriving the loop function, wherein we dissect minuscule segments of the loop to deduce precise functional intricacies. This technique allows for handling considerably expansive loops with minimal increases in complexity.

Once the loop body is organized in canonical concurrent assignment (CCA) form, we establish lower bounds by scrutinizing one, two, or three statements at a time, to avoid overwhelming combinatorial complexities. To ascertain these lower bounds, we examine the loop body, expressed in CCA form, and match its statements or combinations of statements against predefined code patterns. Subsequently, we determine instantiated lower bounds when a match is identified. Our approach involves using recognizers, composed of variable declarations, code patterns, and corresponding lower bounds, differentiating between one-recognizers, two-recognizers, and three-recognizers based on the number of statements they match. The current state of the extraction algorithm's development can be defined by the following assertions.

Our divide-and-conquer strategy heavily relies on representing the loop body as an intersection of concurrent assignments. The inclusion of conditionals (if-then, if-then-else) disrupts this structured approach by introducing union operators between the assignments. To identify a superset of a union, both terms of the union must be examined, contradicting our localized inspection philosophy promoted by the divide-and-conquer method. However, the subsequent theorem allows us to derive a lower bound of the loop function even in the presence of if-then-else statements, without needing to simultaneously consider their then-branch and else-branch, but rather examining them sequentially.