In their previous work [7, 8], the authors demonstrated that the multi-party and open (allowing an arbitrary number of participants) nature of CNA (Calculus of Communicating Systems with Names) presents interesting verification challenges. Specifically, they found that while the number of possible successor states from a CCS (Calculus of Communicating Systems) process is quadratic in the number of its outermost prefixes, it becomes exponential in the case of a CNA process. Additionally, they showed that a graph of agents can be specified as a CNA process, and the presence of a Hamiltonian path in the graph can be verified by checking for exactly one immediate successor of the process. Symbolic techniques were explored in [7, 8] with the aim of managing the inherent complexity of the CNA transition system.

The synchronization mechanism (rule com) operates by merging two VCCS (Variably Constructed Communicating Systems). During this process, it is observed that the link chains can be expanded, allowing the links of one chain to be placed in a suitable position within the other chain. The length of the resulting chain is determined at the use of the rule com, which represents a different approach from that considered in the canonical problem of the dining philosophers. By incorporating constraints, a deadlock-free and fair solution for the problem can be specified, as demonstrated in the examples involving a network transportation system and service level agreements in a negotiation protocol.

Using a multiparty synchronization calculus, a simple and natural deadlock-free specification for the dining philosophers problem is achieved, as detailed in [7, 8], which avoids the previously described deadlock situation. However, solutions using multi-CCS and CNA may exhibit unfair computations, such as a philosopher eating or thinking continuously to the detriment of the others.

A fair solution for the dining philosophers problem is pursued, aiming for deadlock-freeness and ensuring that each philosopher eats infinitely many times in every computation. Constraints are employed to implement a ticket service, guaranteeing that philosophers must alternate the use of forks. Moving forward, the structure clm is fixed to be the structure kn.

The initial attempt to solve the problem yields a deadlock-free specification but does not ensure fairness. We denote the instance of the dining philosophers problem with n philosophers as dp(n) and use i+ to represent (i+1) modulo n.

The transition system generated by the process dp, utilizing the tool described in Section 5, proves to be deadlock-free. Once a philosopher pi has used the forks n times, they must wait for their neighbors to also eat n times before being able to eat again. This prevents pi from retaining control of the forks indefinitely and forces them to wait for the others, thus ensuring that no computation exists where pi eats infinitely while others cannot grab the forks.

By controlling the thinking action as well, a fair system can be achieved. Similar to a previous solution, it is possible to enforce that philosophers must eat after thinking, thereby alternating between thinking and eating states. This is accomplished by transitioning to the state philj after initiating the think action in the model.

The next example illustrates the utility of values and constraints for declaratively specifying the internal state of processes. In this context, philosophers may choose to remain in the thinking state for a period before deciding to eat. It is important for the system to ensure that philosophers transitioning to the thinking state do not impede the activities of others. As emphasized previously, the solution for the problem in multi-CCS (as well as in CNA) is fully distributed at an abstract level, without centralized shared memory. However, a truly distributed deterministic implementation of such multiparty synchronization mechanisms is not feasible.