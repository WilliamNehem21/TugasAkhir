As we developed the teaching machine (TM) [8,9], we grappled with a significant issue. While working with less proficient students in the lab, we observed prevalent superstitious behaviors, with students treating lines of code like magical spells without fully comprehending their significance. Consequently, we found ourselves emphasizing that each line of code conveys a specific instruction to the machine. Establishing an effective mental model of the underlying machine was crucial in teaching students to reason about their code. It’s noteworthy that the machine we were programming, T, was not a traditional computer, and the TM had certain limitations in handling standard C++ or Java files. Despite these limitations, the subsets supported were extensive, adhered to standards, and proved effective in the courses where the TM was utilized.

Notably, at Memorial University, the TM was integrated into a three-course stream in electrical and computer engineering. The TM was employed extensively to illustrate key points of interest and surpassed the debugger in usefulness due to its ability to display constructs that the debugger could not. The transition to HTML-based interactive notes integrated with the TM further facilitated the demonstration of examples during lectures. In a similar vein, at the University of Athens, the TM was introduced to supplement the teaching of computational aspects of programming languages in a joint M.Sc. degree program. The TM was instrumental in dispelling misconceptions and providing visual demonstrations of concepts such as expressions in C++ and parameter passing approaches.

Ultimately, we recognized the TM’s potential as a robust platform for further development. Its ease of use, flexibility, and adaptability make it suitable for integrating specialized input and output plugins to enhance visualizations and interactivity. This approach is expected to simplify the process of incorporating new visualizers and improving the overall functionality.