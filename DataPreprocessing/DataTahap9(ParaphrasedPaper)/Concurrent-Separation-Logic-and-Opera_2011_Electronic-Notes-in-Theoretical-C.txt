This research paper takes a straightforward approach to establishing the validity of Concurrent Separation Logic (CSL). The authors define the meaning of CSL judgments directly with respect to a standard operational semantics for the programming language. This definition is succinct and leads to a relatively simple proof of soundness, which has been formalized in Isabelle/HOL. The soundness statement derived from the definition offers three important advantages: it does not require resource invariants to be exact, it demonstrates that CSL with potentially imprecise resource invariants and without the conjunction rule is sound, and it shows that the conjunction rule is sound as long as the resource invariants in scope are precise. Both proofs rely on the same semantics for CSL judgments.

One notable feature of Definition 3.1 is that the basic lemmas about the safety of compound commands are typically already inductive, making the usually most challenging part of soundness proofs trivial. An exception is Lemma 5.3 concerning the resource declaration rule (for an extension of Definition 3.1 to handle multiple named conditional critical regions), which was arguably the most intellectually demanding part of the proof.

To establish the implication, one would naturally expect to use induction on n with an induction hypothesis quantifying over all c and h. The base case is straightforward; thus, considering the n + 1 case. The first two subcases are easy, so one should consider subcase (iii). From the first assumption, it is known that there exist h1 and h1 such that hj = h1 h1.

The first part of the paper introduces a new mutual exclusion lock, r, referred to as a resource or a resource bundle in CSL terminology, while the second part denotes a conditional critical region (CCR) that runs independently of any other CCRs with the same lock. The execution of a CCR is suspended until the resource is available and the condition b is satisfied, after which the body c is executed in isolation from other CCRs operating on the same resource. This is achieved by holding a lock for the duration of testing whether b is satisfied and executing its body. Finally, within r do c represents a partially executed CCR: one that has acquired the lock, tested the condition, and still needs to execute c. The set of regions locked by c is defined as locked(c): those r for which c contains a within r do cj subterm.

To ensure the absence of data races, a rule (racedetect) has been incorporated that aborts whenever a data race is detected. In this context, the functions accesses(c, s) and writes(c, s) return the set of heap locations accessed or modified by c, respectively. The formal definitions of these functions can be found in [reference to the location of the formal definitions].