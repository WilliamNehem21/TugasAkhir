This paper introduces an enhanced theorem proving interface designed for use in proof-directed debugging and other disproof-based applications. The extension involves tracking a user-selected set of rules to generate an informative program slice, collecting data from the involvement of these rules in both successful and unsuccessful proof branches. This data enables the heuristic scoring of rule correctness judgments. The assumption underlying the extension is that the debugging process entails identifying an incorrect program statement or, in the case of functional programs, an incorrect function case. This incorrect statement can be identified within a program slice, while other program slices leading to correct deductions can also be identified during the proof process. This information can then be used to implement appropriate syntax highlighting of function cases in an interface. The paper proposes a potential highlighting scheme and demonstrates its application through a simple case study using Isabelle/HOL and ProofGeneral.

The concept of program slicing, initially proposed by Weiser, involves identifying a variable of interest in a program (called the slicing criterion) and extracting a fragment of the program (a program slice) containing all the statements upon which the value of the variable depends or that fragment whose values are affected by the value of that variable. Program slicing techniques for imperative languages have generally followed this work, using control flow graphs, data flow graphs, or other graph-based representations of programs. In the case of functional programs, function application replaces program statements, and the notion of a slicing criterion can be generalized. A real example illustrating this approach is provided, showing an erroneous solution to an exercise involving the development of a function, onceonly, that returns a list containing only one copy of each element in a given list. The example contains three errors, which are systematically analyzed.

During the course of attempting the above proof, it becomes evident that some independent lemmas need to be established about the sort function, providing an example of how the system behaves when a goal evaluates to false. The paper moves on to consider a further example, assuming that a certain error has been corrected and new functions and a lemma have been introduced.

The intention is to demonstrate the implementation of these concepts using the Isabelle/Isar system with the ProofGeneral interface, aiming to ensure a clear separation between the information used by the interface and that used by the underlying theorem prover. However, this approach also poses some challenges, particularly in inferring the necessary properties of goals and proof states and in tracking the relationships between parent and child goals. Throughout the paper, the authors emphasize that successful and unsuccessful proof states will require appropriate handling within the interface, which may bring about some difficulties in tracking information. The paper concludes by addressing the need to trigger updates of tracking information when a rule is used directly with a tactic, such as the rule method in Isar, which should be achievable through simple analysis of tactic calls.