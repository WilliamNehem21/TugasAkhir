We aim to illustrate the proposed modularization at the source code level and the correctness of the compiler. To achieve this, we present two examples that are interconnected. In section 2, we provide an overview of an industrial project focused on verifying the correctness of a safety-critical expert system, which has been formally verified using the ACL2 theorem prover. We demonstrate that safety can be proven through a technique we refer to as "verifications for realistic correct compilation." In section 4, we establish a mathematical framework that precisely defines compiler correctness as the preservation of source program correctness. Specifically, we outline a mechanical proof of the preservation of partial correctness for a simplified compiler in ACL2 (section 5). We emphasize the importance of using toy examples to ultimately achieve success, and we offer some insights in section 6. Finally, we discuss lessons learned and express our desires for theorem provers used in software verification.

For the sake of simplicity, we only consider relay groups consisting of terminals, connectors (such as wires and soldering points), and relay contacts as components. Diodes, resistors, and capacitors are excluded from consideration. The generated test plan includes conduction and isolation tests. It is crucial to note that relay contacts are integral parts of relays and cannot be switched independently. Additionally, the test robot can only measure between terminals (outside connectors). Since the certification process is intended to be automated, the generated test plan and, consequently, the relay master, are critical to safety. We require the following guarantee:

The explanation delves into the methodology, proof checker, and input for a Lisp program. The inputs are s-expressions representing "c" and "t" (as described in the earlier example), where "c" represents a graph with nodes for each element, and "t" is a set of either conduction or isolation tests between two terminals in a given state of the relay contacts.

Relative program correctness extends the classical concepts of partial or total program correctness. To illustrate this, let "f" be the original unextended program semantics in the set of input-output pairs (di* do), with preconditions "p_di" and post-conditions "q_do." We define "f" as partially correct with respect to "p_di" and "q_do" (fp_g f fqg for short) if f(p_di) -> q_do. In other words, whenever the precondition "p_di" holds for an input "d" belonging to "di," and if f(d) is defined, then any d_0 belonging to f(d) satisfies the postcondition "q". Furthermore, "f" is deemed totally correct with respect to "p_di" and "q_do" ([p] f[q] for short) if "f" is guaranteed to be defined for any "d" belonging to "p_di." In essence, "f" is both partially correct w.r.t. "p_di" and "q_do," and the domain domf.

We are unable to provide an in-depth discussion of the program and the proof. The proof checker is a Lisp program. Inputs are s-expressions representing 'c' and 't' (as in the above example). 'c' is a graph with nodes for each element, 't' is a set of either conduction or isolation tests between two terminals in a given state of the relay contacts.

Establishing program correctness involves verifying the definedness of the source code semantics and the correctness of the machine execution result simultaneously. The conditional statement poses a challenge in this process. Its definedness properties depend inductively on the value of the condition. The conditional need not be strict in both alternatives and may not be for recursive definitions, making it a particularly challenging case.

In comparison to the substantial work required for verifying realistic compilers for practical source programming languages and real target processors, our example is relatively simplistic. Our source language is very small, and the abstract target stack machine code is unrealistically abstract and far removed from the complexities of real-world processors. However, the proof is an interesting exercise and contributes to the realistic verification of compilers in two significant aspects.

During the PVS proof, we utilize structural operational semantics and inductive relations to formalize partial functions. It is noteworthy that we can essentially reapply the proof concept and overall proof structure of the ACL2 proof presented here: the PVS proof also entails combined structural and computational induction. This is a positive development in terms of proof engineering.

While software verification is often considered challenging or even unfeasible, mechanical proof support can aid in finding proofs (and errors), facilitate the revision (or reuse) of proofs after minor modifications, and contribute to establishing correctness. However, in the latter case, we are reliant on the prover. Consequently, its positive results (i.e., successful proofs) should ideally be understandable and/or verifiable, either manually or through trusted proof-checking programs. Otherwise, there would be a significant gap in the process of mechanically supported correct software construction and proof documentation.

The second wish pertains to a more technical aspect. Compiler verification involves programming language semantics, where programs often represent partial functions. In ACL2, we model these functions as error-strict total functions, which can be cumbersome and require additional justification. Similarly, in PVS, we utilize inductive relations, which are also somewhat challenging to handle. In both cases, informal meta-arguments are necessary to justify the formalization. Despite being aware of these challenges, we sometimes desire a logic of partial functions and a theorem prover that is as usable and sophisticated as the provers we have utilized thus far.

For citation information, please refer to the following academic papers:

- R. Bartsch and W. Goerigk. Mechanical A-posteriori Verification of Results: A Case Study for a Safety Critical AI System (abstract). In Lina Khatib (Ed.), Proceedings of the AAAI Spring Symposium on Model-Based Validation of Intelligence (MBVI'2001), Stanford, CA, U.S.A., March 2001.
- E.M. Clarke and E.A. Emerson. Design and Synthesis of Synchronization Skeletons Using Branching Time Temporal Logic. In D. Kozen (Ed.), Proceedings of the Workshop on Logics of Programs, Volume 131 of Lecture Notes in Computer Science, pages 52-71, Yorktown Heights, New York, May 1981. Springer-Verlag.
- U. Hofmann, H. Langmaack, H. Pfeifer, H. Ruess, and W. Zimmermann. Compiler Correctness and Implementation Verification: The Veri X Approach. In P. Fritzson (Ed.), Proceedings of the Poster Session of CC'96 – International Conference on Compiler Construction, pages 65-73, IDA Technical Report LITH-IDA-R-96-12, Linköping, Sweden, 1996.
- W. Goerigk, Th. Gaul, and W. Zimmermann. Correct Programs Without Proof? On Checker-Based Program Verification. In R. Berghammer and Y. Lakhnech (Eds.), Proceedings ATOOLS'98 Workshop on "Tool Support for System Specific Specification, Development, and Verification," Advances in Computing Science, Malente, 1998. Springer Verlag.
- W. Goerigk and U. Hofmann. Rigorous Compiler Implementation Correctness: How to Prove the Real Thing Correct. In D. Hutter, W. Stephan, P. Traverso, and M. Ullmann (Eds.), Applied Formal Methods – FM-Trends 98, Volume 1641 of Lecture Notes in Computer Science, pages 122-136, 1998.
- S. Owre, J.M. Rushby, and N. Shankar. PVS: A Prototype Verification System. In Deepak Kapur (Ed.), Proceedings 11th International Conference on Automated Deduction (CADE), Volume 607 of Lecture Notes in Artificial Intelligence, pages 748-752, Saratoga, NY, October 1992. Springer-Verlag.