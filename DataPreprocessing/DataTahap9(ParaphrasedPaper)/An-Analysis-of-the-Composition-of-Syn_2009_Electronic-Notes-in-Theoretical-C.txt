Distributed safety-critical embedded applications, such as those used in automotive and avionics control systems, often involve software distributed across multiple processors connected through domain-specific buses. The correctness of these applications is crucial due to their safety-critical nature. Synchronous programming models (e.g., Esterel, Signal, Lustre) make synchrony assumptions, such as zero-time intra-module computation and inter-module communication, to facilitate easier verification of the model. However, once verified, distributing these models over an asynchronous communication-based platform presents challenges in ensuring safe communication between modules.

In this paper, we first present a more general sufficient condition for isochrony and then generalize the definition of isochrony for weakly endochronous modules. Additionally, we introduce the notion of directional isochrony, which provides sufficient conditions for safe communication between modules in one direction but not in the other. These results not only simplify the understanding of the conditions for implementing a polychronous specification in a Globally Asynchronous Locally Synchronous (GALS) system, but also shed light on causality and isochrony. When the synchronous modules are reused as Intellectual Properties (IPs), the conditions described here can be used to determine whether those modules can be composed asynchronously while preserving their synchronous behavior.

As reaching one end of the chip from another within a clock cycle becomes increasingly difficult and the power consumed in the clock distribution network exceeds that consumed in computation, there is a push towards multiple clock domains and the crossing of signals between these domains. This has generated interest in GALS design, necessitating the development of methodologies and tools for GALS design.

A new value of y is computed by function f, sampling the values at signals x1, x2, …, xn, and it is the responsibility of the modeler to ensure that the values of each signal are present at their appropriate rate. The usage of signals by the modeler indicates to the compiler the rates at which the values of x1, x2, …, xn are updated, and y gets updated at the same rate, as per the synchrony hypothesis. The signal compiler assumes that the environment will supply the inputs at each clock instant and will show errors if this cannot be guaranteed by the clock calculus.

The signal language incorporates a syntactic construct called "process" to modularize the dataflow specification. Processes are assumed to be concurrent modules, and when these boundaries are removed, a large dataflow network is obtained where operators are connected via signals. However, when distributed in a GALS environment, separate modules are deployed at different sites, and signals that cross module boundaries require special attention because the zero-time communication for those signals can no longer be assumed. The concept of isochrony pertains particularly to these signals.

The sharing of clock information between IPs in a distributed environment involves exchanging meta-information about the clock relations for these endochronous processes, which can then be used to check for isochrony. It is crucial to ensure that the communication structure and relations are complete during the design process of an IP, as correcting IP blocks during composition is not feasible.

Another important factor is the independence of clocks of signals in weakly endochronous processes. For weakly endochronous processes, the clock dependencies are not relevant since the statements in these processes are independent. It is crucial to evaluate correct communication (isochrony) for endochronous or weakly endochronous processes.

In other synchronous languages, different code generation strategies for incorporating distributed operation have been proposed. For example, in Esterel, the code has been divided into atomic tasks and scheduled with parallelism by referring to a linked list containing the dependencies. Moreover, work has been done on a multi-threaded code generator for achieving a separated but centralized implementation for synchronous programs. However, the consideration of expensive global clock synchronization protocols for GALS execution remains an ongoing research focus. Multi-threaded code generation represents an important milestone in achieving distributed execution of synchronous programs.