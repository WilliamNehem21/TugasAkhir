We present a denotational semantics for a kernel-calculus of the parallel functional language eden, utilizing continuations to manage side-effects such as process creation and communication within a lazy context. The calculus includes stream-based communication, and representing streams using denotational semantics is non-trivial due to the potential infiniteness of streams.

Thanks to the stream-based communication in eden, processes can exhibit behavior akin to continuously introducing characters with a keyboard. However, modeling streams using denotational semantics is challenging because of the potential infiniteness of streams, making it difficult to compute denotational values for such streams. Within the model of continuations, the semantic value for an expression is a well-defined function, even if its computational effect may be infinite.

In the context of parallel application, a list corresponds to an input communication channel, and the same applies to the output. Evaluating a stream is not entirely lazy, as both the constructor and the head must be obtained, resulting in an element-wise evaluation.

A continuation captures the details of the remainder of the program and serves as a state transformer for executing tasks derived from the context. Two types of continuations can be distinguished:

- A closure, meaningful only after the corresponding process identifier has been provided, requires an expression continuation to establish its context, effectively becoming a state transformer.

In a maximal semantics scenario, after evaluating the application, if the channel is a stream, i.e., the identifier is bound to a list, it must be fully evaluated. This involves invoking the function forcefv and using the expression continuation kstr x (see section 3.3.2) to force each component of the stream, including the free dependencies.

Channels are not demanded, but in a maximal semantics context, every local variable originally bound to a parallel application is forced, leading to the creation of new processes and channels. The function mforce (multiple forcing) forces a set of identifiers, invoking the function force (see section 3.3.1) repeatedly, and the function card calculates the cardinal of a set.

When the obtained value is an abstraction, its free dependencies are also demanded and recursively evaluated. If it represents a communication variable, the abstraction is communicated, and the channel is closed. Finally, the expression continuation is applied to the obtained value.

Our denotational model also enables the extraction of the degree of parallelism and the amount of speculative computation. In the final state, the nodes of the graph corresponding to the set of channels represent the processes created during the evaluation of the main expression. Variations in degrees of parallelism for #-expressions and local declarations can be achieved by modifying the expression continuation, ranging between the minimal and maximal degrees. For instance, one could demand the evaluation of the output but not the input of a process, or evaluate only a subset of the parallel applications in a local declaration based on the number of available processors. To analyze speculative computation, the system's edges must be examined: if the edge from a child to its parent is labeled with <>, the child (together with all its descendants) is a speculative process because its output has not been used for the main result.