In this paper, we present a method for devising distributed algorithms by first solving a simpler problem and then reinterpreting the solution within the context of a generic distributed backtracking mechanism. This approach is reminiscent of the breakdown of solutions to NP problems into an exploration phase (guessing the solution) and a verification phase (checking the guess is correct), as well as simulated annealing methods where locally-driven search is supported by random perturbations. Additionally, it aligns with declarative programming. This method is particularly advantageous for problems that require reaching a consensus in a highly distributed manner.

We illustrate the method by applying it to a class of problems that serves as a simplified representation of the self-assembly phenomenon, where simple parts assemble in a predefined spatial arrangement through local and asynchronous interactions, resulting in solutions involving arbitrarily complex distributed consensus.

The algorithm is derived indirectly by first defining a simple CCS algorithm capable of simulating any allowed tree construction, although the induced assembly may deadlock. By reinterpreting the same algorithm in RCCS, thereby allowing backtrack on reversible actions, a real solution is obtained. Comparing this approach with a direct solution in CCS that explicitly deals with deadlocks shows that the latter is both more difficult to understand and prove correct, and requires more computational power from the basic processes.

There are limitations to this method, as it is likely to provide significantly simpler solutions only to problems requiring complex consensus. Additionally, it is currently restricted to problems for which the solution can be expressed in CCS. However, recent developments indicate that correct backtracking mechanisms can be derived for a broader class of agent-languages, and the reinterpretation theorem can be extended to cover more general grounds, such as Petri nets.

The paper is self-contained, except for the more technical notion of causality, which is informally treated and rigorously addressed in other references. The sections of the paper cover the self-assembly specification, the algorithm in CCS, verification of its correctness in RCCS, and a comparison with a direct solution in CCS.

Inherent in the approach is the requirement for a means of stating the correctness of an implementation with respect to a given specification. This is accomplished using the notion of bisimulation.

It is important to note that coherence is the only constraint on trees grown from the starting set of nodes. Different rules for growing trees could be specified, but the local growth rule is chosen for its simplicity, with the flexibility to adapt to the global growth case.

While it is impossible to demonstrate a bisimulation relation between the specification and the code-induced LTS, the code is correct in the weaker sense that its causal computations align with the specification. This alignment is enough to ensure correctness when the process is re-interpreted in RCCS.

The direct code may circumvent deadlocks by sacrificing part of the distributed structure of the system: nodes do not wait for confirmations from their children until their recruiting tasks are completed. However, the main difference lies in the backtracking mechanism, with the RCCS code utilizing partial backtracking to reach a final shape, while the CCS code employs a top-down cancellation procedure to abort the construction altogether.