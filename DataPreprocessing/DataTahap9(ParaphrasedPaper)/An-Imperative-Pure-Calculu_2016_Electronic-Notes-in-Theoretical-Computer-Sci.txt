In this research paper, we introduce a straightforward approach to modeling imperative features in programming languages. Instead of using an auxiliary structure to mimic physical memory, our approach involves rewriting source code terms using a block construct to introduce local variable declarations, which also serves as a store when these declarations are evaluated. This method results in a more abstract language semantics that directly represents constraints on aliasing at the syntactic level, enabling simpler reasoning about related properties. To demonstrate the potential of our approach, we extend the standard type system by assigning a capsule tag to expressions that represent isolated portions of the store.

The remainder of the paper is organized as follows: Section 2 presents the formal definition of the calculus, Section 3 covers the type system, Section 4 presents the results, and Section 5 offers conclusions and pointers to future work. Additionally, the appendix provides auxiliary definitions, and proofs omitted due to space constraints will be included in an extended version of this paper.

Furthermore, we discuss the temporary aliasing of objects, where they can be temporarily aliased (e.g., when passed as a method parameter) but cannot be stored within other objects. This notion of aliasing corresponds to static aliasing, which can lead to unexpected behavior at a distant point in the execution. We also observe the behavior of type modifiers in different rules, such as the propagation of type modifiers to fields and the restrictions on readable objects in field assignments and object creation.

Additionally, the paper demonstrates how to extend the formal definition to handle primitive types and introduces the concept of a "capsule" as a reachable object subgraph where nodes cannot be reached from the outside. We also discuss the possibility of implementing an interpreter for the calculus into a theorem prover, which could be aided by the expression of aliasing properties at the syntax level.

The future work envisioned includes using variants of the presented calculus as a basis for expressing and formally verifying different properties of object graphs, as well as investigating hoare logic on top of this model. We anticipate that the hierarchical memory representation in our approach will facilitate local reasoning, making it possible to specify and prove only the relevant portions, similar to what is achieved by separation logic.

Finally, the paper acknowledges the valuable feedback from anonymous referees and co-author Lindsay Groves, whose input has contributed to the development and improved formulation of the presented concepts.