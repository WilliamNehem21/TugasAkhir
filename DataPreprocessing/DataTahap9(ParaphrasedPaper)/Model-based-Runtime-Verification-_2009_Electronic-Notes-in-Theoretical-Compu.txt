Model-based runtime verification is an advancement in the field of runtime verification that focuses on assessing the consistency of the system implementation in comparison to the system model and the conformity of the system model to the system specification. Unlike traditional runtime verification, which operates at the system execution level, model-based runtime verification operates at the model level, allowing it to utilize runtime information obtained from the system execution to reduce the state space of the system model. This approach can operate either before or after the actual system execution, alternating between a proactive pre-checking mode and a reactive post-checking mode.

For complex systems, simulation and testing only cover a subset of the potential behaviors and scenarios, while exhaustive model checking encounters the challenge of state explosion. Furthermore, determining the completeness of the set of system properties to be verified is often difficult.

By conducting safety checking at the model level, model-based runtime verification can identify property violations before they occur, leveraging monitored concrete states to locate corresponding abstract states in the system model and reduce the state exploration space. This approach can switch between pre-checking and post-checking based on its positioning relative to the system execution, effectively engaging in a "two-player game" with the system execution. To improve its chances of taking the leading position against the system execution, model-based runtime verification introduced two strategies.

The implementation of a component represents a refinement of the component's model, indicating that the accuracy of verification at the model level implies its applicability at the implementation level, making the conservative nature of runtime safety checking worth the trade-off due to its application at the model level.

Experimental results demonstrated that model-based runtime verification, through randomly generated state transition graphs and execution traces, can assess the performance of verifying ahead of the system execution. Compared to offline model checking, model-based runtime verification can reduce the state exploration space using monitored states obtained during system execution, thus exhibiting lower computational complexity. Additionally, by focusing on model-level consistency checking and state space reduction using monitored states, model-based runtime verification can check more general properties specified by ACTL and/or LTL formulas. Despite its computational complexity, several strategies can be employed to align its performance with that of state-of-the-art runtime verification.

While the ideal scenario would involve model-based runtime verification consistently operating ahead of the system execution, the introduction of pre-checking and post-checking modes acknowledges the potential for the runtime verification to fall behind. Both modes present distinctive advantages for safety-critical systems, with pre-checking allowing for the prediction of violations and post-checking facilitating the detection of violations.

By strategically selecting major transitions and employing tactics to reduce the state space to be explored, model-based runtime verification can effectively look ahead beyond its current position. However, increasing the complexity of the system model and communication overhead should be taken into consideration when implementing such selective exploration strategies.

Furthermore, model-based runtime verification aligns with the "two-player game" juxtaposition with the system execution by striving to maintain a leading position. This is achieved by optimizing the checking speed based on the out-degrees of states in the system model and employing effective strategies for exploring transitions.

Finally, the paper highlights the broader implications of model-based runtime verification compared to existing approaches and emphasizes its flexibility, computational complexity, and practical applications in assessing system correctness and behavior.