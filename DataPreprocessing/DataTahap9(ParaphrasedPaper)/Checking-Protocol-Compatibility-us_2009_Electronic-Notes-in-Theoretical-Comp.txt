Verifying compatibility of services accessed through their behavioral interfaces is a critical concern in service-oriented computing, which focuses on creating new systems from existing software services. In this paper, we introduce a model of services that incorporates value passing and non-observable actions, and propose an approach to systematically assess various compatibility notions between two service protocols using the rewriting logic system Maude. We specifically demonstrate our approach using three common compatibility notions: opposite behaviors, unspecified receptions, and deadlock freeness. These notions, along with various strategies to handle non-observable actions, have been formalized and fully implemented into a prototype tool that can automatically detect whether two services are compatible, providing a counterexample if they are not.

Component-based software engineering and service-oriented computing emphasize the reuse of existing software components or web services when constructing new systems to save time and resources. In this context, ensuring compatibility is crucial to enable successful interoperability and integration of reused services in the system being developed. However, verifying compatibility becomes especially challenging when considering interaction protocols of services, which is essential to avoid erroneous behaviors or deadlock situations when executing a set of services together.

Our model of service interfaces allows for the specification of interaction protocols, including messages and their application order, as well as consideration of value passing and internal actions. Our framework offers a systematic way to check different compatibility notions, taking into account various strategies to deal with internal actions. We focus on three widely used compatibility notions—opposite behaviors, unspecified receptions, and deadlock freeness—but our solution is designed to be independent of specific applications, making it useful for a range of issues such as automatic service composition, software adaptation, service substitution, service discovery, and code reengineering.

The remainder of this paper is structured as follows: Section 2 formalizes our model of services, Section 3 introduces some preliminary concepts and the compatibility notions used for illustration purposes, Section 4 presents how service compatibility is checked using Maude, Section 5 provides a comparison with related approaches, and finally, Section 6 draws some conclusions.

(Please note that due to character limitations, the paraphrased text does not include all the details and examples from the original paper.)