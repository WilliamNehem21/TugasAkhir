The OCL 2.0 proposal lacks both consistency and completeness at present. Some of the newly introduced concepts such as OCL messages have not been adequately considered in terms of their formal semantics. Similarly, concepts that were already part of OCL as a component of UML 1.5 have not been sufficiently defined. For example, there is no provided semantics for state-related operations, despite the syntax allowing the specification of constraints over state activations.

This article primarily focuses on enhancing the modeling of the predefined type OclType within the OCL standard library and accurately specifying related operations. As a result, this work is intended to contribute to the finalization process of OCL for UML 2.0.

It is essential to note that formulating constraints without a UML model for reference lacks purpose. Throughout the remainder of this article, we will refer to this UML model as the "referred UML user model." Each classifier defined within the referred UML user model represents a distinct OCL type and is implicitly included in the OCL standard library as a subtype of OclAny.

Among the predefined OCL types within the standard library, OclType holds a unique role. This type encompasses all basic types present in the OCL type system. An important observation is that OclType is inherently a kind of metaelement belonging to the metalevel M2, while also needing to be accessible on the user level M1 in order to formulate constraints that require reasoning about object types (e.g., type conformance checks).

There are several issues with the signatures of these operations. For instance, the signatures of the operations = and <> are incorrect for OclModelElement. OclModelElement is viewed as an enumeration type in the OCL 2.0 proposal, where each element in a given UML user model has a corresponding enumeration literal. OclModelElement must encompass all user-defined classifiers, as well as other model elements like statechart states, transitions, events, operations, signals, etc. While the necessity and relevance of this type are questionable, the corresponding operation signatures need to be corrected, i.e., the formal parameter types should be OclModelElement instead of OclType.

In the coming sections, we will analyze the definition and usage of the type OclType within various approaches in the literature (Section 2) and the current OCL 2.0 proposal (Section 3). In Section 4, we will demonstrate how the powertype concept can be introduced to better integrate types defined at the user level into the OCL standard library type system on level M1. Section 5 will conclude this article.

In UML 1.5, predefined operations are provided for OclType to further access metalevel features, such as operations to retrieve a list of attribute names, association end names, and direct as well as indirect supertype names. However, operations to extract subtypes are absent.

The oclIsNew() operation must return false when applied to datatype values, as primitive values cannot be dynamically created or destroyed. This holds true for the enumeration literals of OclType as well. Similarly, when considering expressions involving operations that reason about object types, it is evident that they are operating at the wrong architectural level.

In conclusion, the modeling of OclType as an enumeration type in order to separate the predefined OCL types from the metalevel introduces several type-related difficulties. It is impractical to formulate expressions with operations that reason about object types without limited access to the metalevel. Additionally, it is not feasible to provide a semantics of operations that reason about OCL types without accessing the metalevel.

Furthermore, defining allInstances() as an operation of the base type OclAny is illogical, as that operation should only be applicable to types and not to objects. With the currently proposed OCL type system, M1 types cannot be accessed, since user-defined classes (e.g., person) and OCL types (e.g., OclVoid) are only treated as enumeration literals of the enumeration type OclType. It is not type-conformant to apply the operation allInstances() to an enumeration literal, such as person, in order to obtain the set of objects of the class which the literal represents.

The return types for the operations are not accurately specified. An instance of OclType is an enumeration literal and cannot be the retyped object as intended. Additionally, the unnamed type "t" has no concrete meaning in the signature. The correct signature, therefore, is unspecified in the OCL 2.0 proposal. Specifications for related operations, such as oclTypeOf() and oclIsKindOf(), can be formulated in a similar way. Unfortunately, two modeling levels have to be accessed, which is not desired in the OCL 2.0 proposal. Therefore, we will propose a different approach in the next section that finds a more elegant (and UML-compliant) way to capture OCL types at modeling layer M1.

None of the approaches for modeling OclType has considered the powertype concept so far. Powertype, a UML core concept, denotes a dependency relationship among a generalization. A powertype is modeled as part of a class diagram residing on level M1. Essentially, a powertype is a user-defined metaelement whose instances are classes of the user model. Thus, a powertype provides access to specialized types as instances.

The annotation "complete" indicates that all of the children of OclAny have been declared. Note that this does not contradict the ellipsis used to represent the user-defined classes; it is argued that OCL expressions only make sense over a given UML model.

Furthermore, we suggest using the powertype concept to model the types accessible in OCL expressions on the modeling layer M1. In this context, several other open issues could be resolved. For instance, we propose that the operation allInstances() should no longer belong to OclAny, as it is not meaningful to apply it to objects and datatype values. Instead, it naturally belongs to the powertype OclType.

Overall, the OCL 2.0 proposal has apparent deficiencies, especially in fundamental definitions such as the discussed operations. There are many other open issues to address in the OCL 2.0 proposal, particularly concerning the two semantics definitions that are currently neither consistent nor complete.