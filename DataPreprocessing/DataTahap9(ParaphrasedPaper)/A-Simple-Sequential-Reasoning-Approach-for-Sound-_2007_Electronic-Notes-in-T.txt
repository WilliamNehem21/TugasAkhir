We present a programming model for concurrent programming in Java-like languages and propose a set of program annotations to explicitly specify the use of the programming model. These annotations provide information for static analysis tools to verify the correctness of locking in the program, ensuring that shared objects are properly locked before use and that unshared objects are only accessed by the creating thread. The modular verification approach allows for scalability to large programs.

Data races, where multiple threads access the same variable simultaneously, often occur in concurrent programming. To address this, we propose associating a mutual exclusion lock with each data structure to protect them from concurrent access. However, mainstream programming languages like Java and C# do not enforce the acquisition of locks before accessing data structures, leading to inconsistent association of locks with data structures.

Additionally, method implementations may assume that an object is already locked by its caller, leading to potential issues when indicating shared objects. Thus, it is important for method implementors to explicitly specify their assumptions about locks held by the calling thread in a method contract.

Our programming model associates a global shared set with each run-time state, defining shared and unshared objects. This conceptual set is used to explain the model and implement verification, and is not present at run time.

Formally, the correctness of the original annotated program is determined by the correctness of the translated program with respect to its assertions and classical method contracts. We use an existing automatic program verifier for single-threaded programs to check the correctness of the translated program, and experiments demonstrate the capability of state-of-the-art verifiers to verify realistic programs using our approach.

In our model, objects protect global resources and must be acquired in a statically defined order. Another strategy involves defining the order based on certain object fields, such as locking account objects in order of account numbers to prevent deadlocks during a transfer operation between accounts.

Developers may also wish to impose partial constraints on locking order or abstract over a set of objects. For example, in the subject-observer pattern, the developer may specify that observers should be locked before the subject, preventing deadlocks.

In our model, a lock level is associated with an object when it is shared, defining the lock order. A thread is only allowed to lock an object if the object...

We explain the syntax and semantics of class initialization in Java before presenting the extension of the programming model. We also discuss the acyclicity of the lock before relation and support for classes whose static state does not change after initialization.

We describe a call that checks for the existence of a path between two methods and handles cases where adding an edge between the methods would create a cycle.

Additionally, we mention extended static checkers for Modula-3 and Java, which aim to find errors in object-oriented programs, including support for preventing data races and deadlocks. However, these tools trade soundness for ease of use and lack a formalized methodology to allow a soundness proof.