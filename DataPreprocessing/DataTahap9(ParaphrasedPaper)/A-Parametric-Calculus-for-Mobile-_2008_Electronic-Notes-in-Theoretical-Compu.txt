In our framework, we address two separate forms of subtyping relations: the static subtyping relation, which represents subtyping that could potentially be enforced by the static type system, and the dynamic subtyping relation, which is designed to be more permissive and is used for dynamic checks. The runtime check is designed to be liberal, allowing for the acceptance of mobile code that may be rejected if only statically available. To achieve this, the runtime check automatically introduces coercions driven by the dynamic subtyping relation in order to minimize the refusal of communication. This approach ensures the safety of mobile code exchange after coercion and provides flexibility by allowing the acceptance of a wider range of code.

The rest of the paper is organized as follows: we initially introduce the untyped version of our calculus in section 1, and then incorporate static and dynamic checks in section 2. We formalize the concept of type safety in our parametric framework and provide an analysis at the core level. It is important to note that core code can either be sent or further reduced in a nondeterministic manner, and this applies analogously in the case of core code in a rebinding. This means that we are indifferent to where core mobile code is executed, whether by the sender or the receiver, although this may have practical implications, such as in the case of non-termination. Notably, sending a process term intuitively implies sending coordination code to be executed by the receiver.

We validate the aforementioned proposition by considering communication steps with the outside world. Intuitively, when receiving code "e," no unbound variables are introduced if "e" has no more free variables than those it declares. Similarly, code sent to the external world should have no more free variables than those it declares, and this property is inductively used to demonstrate the property on internal steps.

We ensure the safe exchange of mobile code by employing a runtime check similar to that considered for mixin classes, in order to address the classic problem of interference in record/object types. Specifically, the dynamic subtyping corresponds to standard width subtyping on record types, along with a coercion function that removes additional fields. The type declared by mobile code is thereby made a subtype of the expected type, enabling communication to take place. Mobile code is adapted to the local code through a series of steps involving coercions to ensure a safe record extension in the communication process.

The main contribution of this paper can be summarized as follows. First, we have expanded upon previous work by introducing an abstract framework for the type-safe exchange of mobile code, specifically addressing the non-trivial case of open code. The result is a parameterized process calculus that allows for the straightforward expression of code rebinding in a distributed environment. In this context, some of the influencing work is that on dynamic software updating, where we consider arbitrary core calculi as opposed to lambda-calculi and utilize an explicit language for the process layer, in contrast to other works where the basic primitive is an update operation that changes local code in a less controlled manner.