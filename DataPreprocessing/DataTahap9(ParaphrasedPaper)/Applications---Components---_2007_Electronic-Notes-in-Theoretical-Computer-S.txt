The remaining sections of this document are structured as follows: Section 2 provides a brief overview of the key features and design principles of the gloo framework, while Section 3 presents the design and implementation of the language-of-java-services. In Section 4, we explore related work and its impact on the design of the gloo framework. Finally, we conclude in Section 5 by summarizing our key findings and outlining future activities in the field of narrow-focused domain sublanguages specification and implementation.

Concurrency is considered a language feature and is thus essential to be integrated into the underlying language specification. However, identifying and defining the appropriate set of abstractions for concurrency within a given language is a challenging task. For example, both Java and C# offer a wide range of primitives to handle concurrent activities within a software system. Nevertheless, these abstractions may not be powerful enough to separate coordination from computation concerns, as synchronization often needs to be specified at the method level, or the lifecycle of object instances may be impacted by application-specific settings controlled by the .NET remoting infrastructure.

Gloo does not provide predefined abstractions to represent algorithms, except for sequencing. Nonetheless, Gloo allows for both syntactic and semantic extensions. Although Gloo recognizes most Java operators, their actual semantics are undefined, requiring the user to supply the appropriate implementation to the Gloo system.

In order to define the language-of-java-services, it is necessary to incorporate Java classes and objects as first-class values in the Gloo framework. This involves defining container value types that encapsulate classes and objects, along with a javaclass meta level that specifies core abstractions for loading classes, creating objects, calling methods, and mapping Gloo values to Java values and vice versa. Container value types are directly specified in Java as part of the "javasupport" package, which is automatically loaded into the Gloo system when processing a specification unit.

The definition of the container value type for Java classes is depicted in Listing 2. The type "javaclassvalue" defines a read-only value representing a runtime instance of a Java class. Apart from the getter method "getclassvalue()", the "tostring()" method also needs to be redefined to obtain a standard textual representation for the newly defined data type. Additionally, by deriving "javaclassvalue" from the class literalvalue, a solid integration of the new container value type in the Gloo framework is ensured, promoting Java classes to first-class values in the Gloo system.

The core of the language-of-java-services is presented in Listing 4. It introduces two abstractions: the type constructor "javaclass" and the function "new", which takes a class container value and returns a function expecting an extensible record representing the constructor arguments to be passed to the meta level function "java.newinstance". The term "|args, class=class|" defines a binding extension, refining the record "args" with the binding "class=class". Furthermore, the core also defines the function "propagate positions", visible only to the local scope of the unit. This function combines the position information specified in the signature record with the bindings in the argument record, giving precedence to the bindings of arguments and yielding a record with the same bindings as arguments but potentially augmented with positions.

The success or failure of a software project is not solely dependent on our understanding of the problem domain, but also on the choice of programming languages and their suitability for modeling the problem domain. While general-purpose programming languages facilitate the encapsulation of domain expertise in reusable software entities, they may not be as effective in specifying applications as compositions of reusable software components due to a mismatch between the abstraction level of supported language constructs and the level at which software composition occurs.

In this paper, we conducted an analysis of gloo, a novel component-oriented programming framework that enables the definition of narrow-focused compositional domain sublanguages, providing a user-centric view of a given problem domain for the application programmer – the component assembler. Gloo is a dynamic, open-ended composition language built on concepts such as dynamic binding, explicit namespaces, incremental refinement, and a foreign code gateway – all pivotal for comprehensive component-oriented software development.

The foreign code gateway is a significant innovation of Gloo compared to its predecessor Piccola, providing an effective means to directly incorporate Java code into the scope of gloo specification units to construct problem-oriented domain abstractions, as demonstrated in the definition of the language-of-java-services. The Gloo programming model enables a lightweight and scalable approach to define domain abstractions, encouraging the creation of small, first-class subject-oriented development artifacts that can be composed and extended to build larger, more complex, and possibly concurrent compositional programming abstractions.

Additionally, the gloo framework supports model-driven engineering (MDE), which combines domain-specific modeling languages with program synthesis tools to create domain-specific models of large-scale systems, treating models as first-class entities. The Gloo programming paradigm does not impose restrictions on definable development artifacts. In future work, we plan to utilize Gloo as a model-integrated computing platform and conduct feasibility studies to determine the effectiveness of representing domain models in the Gloo framework.