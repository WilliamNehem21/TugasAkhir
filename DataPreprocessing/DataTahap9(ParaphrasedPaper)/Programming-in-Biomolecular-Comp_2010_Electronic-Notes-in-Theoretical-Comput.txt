Biomolecular computation frameworks enable the avoidance of typical asymptotic slowdowns associated with Turing-type models, thus representing an advancement over previous work on automata-based computation models (such as Turing machines and counter machines) and other existing contributions in the field. The existing literature contains various articles that describe concrete finite-automaton-like computations and emphasize their realization in biochemical laboratory contexts, showcasing the feasibility of specific computations in practical settings. Some articles directly address Turing completeness, but the algorithmic or programming aspects are not readily apparent.

A program can be roughly defined as a set of instructions that specify a series of actions on data, to be executed when the program is activated. It is a software entity that can be replaced to define different actions. Demonstrating the Turing completeness of a computation framework is typically achieved through reduction from another problem already known to be Turing complete. A common approach is to use a very small Turing complete language, such as Minsky register machines or two-counter machines, and show that a biomolecular system being studied can faithfully simulate these small Turing complete languages through technical arguments.

In a biologically feasible model of computation, there are constraints such as the absence of pointers to data and the requirement for proximity between data values and actuators for actions to be carried out. The model must also tap into available biochemical resources, such as free energy, for performing actions. The main idea is to keep the program control point and the current data inspection site close to a focus point where all actions occur, achieved by continually shifting the program or the data. Each "blob" in the model contains local storage bits for instructions and an activation bit, with specific instruction formats and informal semantics specified through biochemical reaction rules.

Despite the close analogy between blob programs and machine language, there are differences, such as the absence of address space, address decoding hardware, fixed word size for data, computed addresses, registers, or indirection. While programming tasks can be solved straightforwardly, the low level of blob code may result in inelegant solutions. However, it is shown that it is possible to generate blob code from a Turing machine, establishing Turing-completeness.

The instruction set in the model is believed to be parsimonious, with all instructions appearing to be necessary for programming the self-interpreter. Notably, the dimensionality of the model does not significantly impact its computational capabilities, and it is likely that the class of problems solvable in linear time for blob machines is more robust compared to traditional Turing machines.

Overall, the paper discusses the development of biomolecular computation frameworks as a promising alternative to traditional computation models and highlights the unique features and challenges associated with these frameworks.