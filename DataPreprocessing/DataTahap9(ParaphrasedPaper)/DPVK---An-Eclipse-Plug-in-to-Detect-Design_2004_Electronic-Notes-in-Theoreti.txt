The usage of design patterns is advantageous not only in the forward engineering process but also aids in design recovery and program understanding, which are commonly associated with reverse engineering activities. This paper introduces dpvk, a reverse engineering tool designed to identify instances of patterns within Eiffel systems. To achieve more accurate detection results, the tool conducts an analysis of various patterns and examines Eiffel software in terms of both its static structure and dynamic behavior. dpvk is implemented as an Eclipse plug-in to ensure improved compatibility and extensibility.

The typical system structure for pattern detection tools includes three components: a parser, a detector, and a database. The parser extracts facts from the implementation, and the detector retrieves pattern definitions from the database, compares these definitions with the facts, and outputs the detection results. The database can also be used to store detected pattern instances for further analysis.

Efforts have been made to minimize the occurrences of false positives in pattern instances. Many recently developed tools utilize multiple passes or recursive filtering to enhance the accuracy of the detection output. Simultaneously, both the static structure and dynamic interaction of the software are considered to increase the hit rate and decrease the missing rate of true pattern instances.

KT, a tool designed to reverse-engineer design diagrams from Smalltalk code and detect patterns, supports both static and dynamic modeling constructs. The detection methods for analyzing three GoF design patterns (Composite, Decorator, and Chain of Responsibility) are directly coded into the KT source code.

The environment follows a three-tier architecture, comprising an object-oriented database, a repository schema, and end-user tools. The lowest tier provides physical storage of the reverse engineering model and design information, the middle tier contains the object-oriented schema of the reverse engineering model, and the upper-tier consists of end-user tools implementing domain-specific functions.

The authors Heuzeroth, Holl, Hogstrom, and Lowe present a method to automatically detect patterns by combining static and dynamic analysis. The static analysis constrains the code construction, while the dynamic analysis focuses on the runtime behavior, independent of coding or naming conventions.

The study details a process involving source code processing using static analysis to transform the implementation into tuples of abstract syntax tree (AST) nodes. Subsequently, static analysis computes predefined pattern relationships on the AST nodes and generates a candidate set of pattern instances. Dynamic analysis then monitors the execution of the nodes and checks if the candidate complies with dynamic pattern rules.

The study also discusses the protocol conformance of patterns. The tool can detect several patterns, such as Observer, Composite, Mediator, Chain of Responsibility, and Visitor patterns, with minimal false positives in most experiments.

The study emphasizes the significance of Eiffel's mechanism, Design by Contract, which allows developers to precisely specify the obligations and responsibilities among classes. This mechanism aids in defining mutual obligations and benefits among classes and helps in constructing robust designs, indicating a potential bug when a contract is violated.

BON is selected for its integration with EiffelStudio and its similar function to UML, while being easier to learn and use. The study analyzes both the static structure and dynamic behavior of GoF patterns in Eiffel source code and compiles a diagram catalog of these patterns.

The study highlights the use of dpvk, an integrated text-search tool written in Java, to detect design patterns in Eiffel programs, offering enhanced compatibility and portability.

The study introduces Grok, a relational calculator and scripting language that supports binary relations to manipulate and understand large-scale software systems.

The paper discusses the importance of modeling and defining design patterns precisely and expressing those definitions. It proposes the use of two definitions for each design pattern in dpvk, based on the pattern's static structure and dynamic behavior.

The paper proposes the creation of a design pattern definition repository to store as many variant definitions as possible, to improve the chances of finding design patterns and their variants in software systems.

The study details the extraction of static facts from Eiffel source code files using the Eiffel compiler, and the subsequent comparison of these facts with the definition of the static structure of design patterns.

The study outlines a four-stage process for dpvk, including static fact extraction, candidate instance discovery, false positive elimination, and manual evaluation of previous stages.

Finally, the study discusses the future development of a new Eclipse-based tool at York University, which could replace EiffelStudio and EC for extracting static and dynamic facts, and the extension of dpvk to detect design patterns in other popular object-oriented languages such as Java and C++.