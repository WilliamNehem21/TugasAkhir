Therefore, in (i), a scanner produced by flex identifies system calls as tokens of the language. To create the context-free grammar (CFG) cfg(p), the parsing of the source code in (ii) is divided into two additional steps. In the initial step, the semantic actions of the generated parser yield an abstract syntax tree (AST). The internal nodes of this tree represent either functions defined in the source code of p or statements/expressions, while leaf nodes represent system calls. In the second step, the parser traverses the AST to construct cfg(p) by applying the GGA. Cfg(p) is specified using the Bison syntax so that, in (iii), we can utilize Bison to generate the parser for l(p), which is employed at runtime to verify that the trace of p is valid.

This analysis comprises: (i) a CFG cfg(p) that defines the legal system call traces; (ii) a set of invariants inv(p)={i(p, 1),...,i(p, n)}, each paired with a program point i where p calls a system call. The implementation of the i-VM can access each component of the Mon-VM, such as any memory region and any processor register, to inspect its running state and evaluate assertions on p's state, i.e., on the values of its variables. Each invariant is associated with a system call and generally constrains the values of the system call parameters or relates them to variable values. During the execution of p, the Mon-VM transfers control to the i-VM each time p calls a system call. At this juncture, the i-VM checks that the current trace satisfies cfg(p) and evaluates the invariant i(p, i) paired with the point i that p has reached.

The key assumptions underpinning the adopted approach are that: (i) the source code executed by p is known; (ii) the VMM can be trusted; (iii) introspection safely extends the Trusted Computing Base (TCB). Two reasons bolster the latter two assumptions. Firstly, the VMM has full visibility of the Mon-VM because it can access every component of it. Secondly, the VMM is more robust than commodity OSes because: (i) it exposes a simple interface to the higher levels, which is more challenging to subvert than, for example, the interface of a kernel that implements hundreds of system calls; (ii) the small size of the VMM code diminishes the likelihood of a compromise and enables the validation of its correct implementation through formal analysis. It is important to note that the kernel of the Mon-VM does not belong to the TCB because its integrity can be verified by the i-VM. In conclusion, since the VMM has full visibility of the VMs while being strongly isolated from them, the complexity of compromising the VMM or evading the introspection monitoring capabilities of the Mon-VM is very high. Nevertheless, there are recognized threats against the VMM that also need to be considered.

Xen is the chosen technology to create the VMs that implement the dynamic tools. We selected the Xen VMM primarily for its high performance and seamless integration with the Linux kernel. Psycotrace leverages the paravirtualization approach, in which OSes are aware of the existence of the Xen VMM.

The current dynamic tools are the Himod and the Analyst, which run, respectively, in the kernel of the Mon-VM and at the user level of the i-VM. Himod is a kernel module that intercepts the system calls invoked by p. Each time p invokes a system call, Himod notifies the Analyst, which can conduct consistency checks on the state of p. The Analyst encompasses the Bison-generated parser and an assertion checker that, respectively, verify the traces of p and assess the invariants. The Analyst begins by listening for communications from Himod regarding system call invocations. This interaction is synchronous, meaning that each time a system call is invoked, p is paused and execution only resumes after the Analyst has completed the security checks. It is noteworthy that implementing the Analyst at the user level significantly simplifies its implementation compared to the scenario in which it is implemented at the kernel level in the Mon-VM.

By using the VMs in the Xen architecture, a privileged machine can access information about the running VMs. Himod stores the base address of the shared page in a well-known token in the Xenstore tree. The Analyst accesses the token and utilizes the address to map the page in its address space. The overall solution enables the Analyst to retrieve information about the system call in the shared memory page.

Himod consists of 2.5k lines of C code, while the Analyst is composed of about 3k lines of C code, including the introspection library. The definition of the extended C grammar, including the semantic actions to generate cfg(p), comprises approximately 1k lines of C++ code. Lastly, the generated Bison parser for cfg(p) is about

In the current Psycotrace prototype, Himod monitors a single PID. This implies that a process that forks some children processes is not appropriately monitored. Therefore, Psycotrace also needs to monitor the children, for example by retrieving their PID through introspection whenever a fork is called. Lastly, we are presently working on the definition of the static tools that extract the set of assertions from the source code.