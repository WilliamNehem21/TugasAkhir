The concept of action systems was originally introduced by Back and Kurki-Suonio as a formalism for modeling distributed systems. We have opted to use this formalism because it is well-suited for modeling reactive systems and has been employed for model-based mutation testing. Although there are different variations of action systems, such as object-oriented action systems, the specific formalism we are employing here is more limited in scope. While it shares similarities with the event-B language, it does not support set-theoretic constructs like event-B.

Informally, the execution of an action system begins in an initial state, which is then modified through the repeated execution of actions. During this process, one action is chosen at each step in a nondeterministic manner from the set of enabled actions, where an action is considered enabled if its guard is satisfiable in the current state. The execution terminates when the set of enabled actions is empty.

We have decided to use action systems because they can be easily translated to initialized input-output symbolic transition systems (IOSTS), thus enabling the use of the symbolic framework. Additionally, we will employ the same concepts and notation for first-order formulae.

The concept of symbolic execution trees for action systems is inspired by execution trees created for programs. A symbolic execution tree represents the effects of symbolically executing various actions, starting from an initial state. We have chosen to describe the symbolic execution of action systems in a tree-based manner in order to emphasize the effects of actions on symbolic states.

It is important to note that the indices of states directly correspond to the depth of execution at which they are detected. Internal actions are considered to be at the same depth label as the preceding state, and thus do not increase the index value, since they do not introduce new indexed parameter variables. However, the symbolic state index is increased for the quiescence observation, as it is observable.

Since action systems may exhibit non-deterministic behavior, the SIOCO conformance relation accounts for this non-determinism. Therefore, the conformance check is able to handle action systems containing internal actions without producing spurious counterexamples.

In addition, the product graph allows actions to be executed only if the path condition of the target product state is satisfiable, while the IOCO relation is defined for suspension traces of the specification. This restriction is utilized to ensure that the non-conformance condition for product states with unsatisfiable path conditions is not satisfied. 

The implementation of the test case generator performs a depth-first search for unsafe states in the product graph, and we have developed several optimizations to decrease the runtime of this search. Some of these optimizations specifically target model-based mutation using first-order mutants, and make use of an efficient syntactical mutation analysis to detect the location of mutations.

In conclusion, we have presented an approach for utilizing symbolic input-output conformance checking for test case generation and have provided guidelines for implementing the conformance check efficiently. Our approach is particularly geared towards model-based mutation testing, covering faults corresponding to model mutations, as well as faults related to ignored inputs through angelic completion. Our work represents the first fully symbolic IOCO conformance checker that we are aware of. We also discussed potential future research directions, such as studying the composition of action systems in the context of asynchronous communication.