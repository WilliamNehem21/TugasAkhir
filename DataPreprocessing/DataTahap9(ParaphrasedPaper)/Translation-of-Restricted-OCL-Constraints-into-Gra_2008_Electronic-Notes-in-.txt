The use of meta modeling in defining the syntax of visual modeling techniques, particularly in the context of UML, has become widely popular. However, since meta-modeling is non-constructive, it lacks a systematic method for generating all potential meta model instances. In our approach, we automatically create an instance-generating graph grammar from a given meta model to ensure correct typing and cardinality constraints, although OCL constraints for the meta model are currently not supported. To address this limitation, well-formedness checks are performed in addition to satisfy the specified OCL constraints. We present a restricted form of OCL constraints that can be translated into graph constraints and checked during the instance generation process.

Section 2 introduces meta models with OCL constraints, while Section 3 outlines the key concepts for the automatic generation of instances from meta models using the graph grammar approach. We illustrate the generation process using a simplified statechart meta model. Our approach involves utilizing graph transformation with node type inheritance. In Section 4, we explain how restricted OCL constraints can be translated into graph constraints. Finally, we discuss related and future work in our conclusion.

Visual languages like UML are commonly defined through meta modeling, wherein a meta model describes the abstract syntax of the language. This meta model can be likened to a class diagram on the meta level, encompassing meta classes, associations, cardinality constraints, and special association types such as aggregation, composition, and inheritance, as well as abstract meta classes.

Our approach involves the creation of a create rule for each non-abstract class within the meta model, allowing for the generation of instances of all non-abstract classes. These rules are applied arbitrarily often in layer 1 and need to be interrupted by user interaction or after a random time period. Additionally, we identify graph constraints as properties on graphs that must be satisfied, used to express contextual conditions within a given graph.

Finally, we define complex navigation expressions as atomic navigation expressions, and present various complex navigation expressions and their applications.