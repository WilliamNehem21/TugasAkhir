The two points mentioned above are in line with the customary practice of representing formalizations on paper using pencil and paper. In a broader sense, our nominal approach aims to remove the necessity of reasoning about terms that are not explicitly present in paper proofs, such as pre-terms, shifted terms, and exotic terms.

This paper primarily aims to showcase the feasibility of a nominal approach to variable binding in Coq and to elucidate the challenges encountered during the implementation of such an approach in a dependently-typed type theory. Although the complete system as described is not currently available, we have evaluated the theoretical and practical potential of this approach within the context of an untyped lambda calculus, while acknowledging the complexities that may arise in more intricate languages. Our insights from this specific case will enable us to eventually develop a comprehensive system as envisioned.

The remainder of this paper is structured as follows: Section 2 outlines the fundamental elements of our approach, while Section 3 delves into the design and implementation of our signature for an untyped lambda calculus. Subsequently, in Section 4, we present practical observations regarding the utilization of this signature. Section 5 discusses related research, and we conclude in Section 6 by providing an overview of our ongoing work.

Similar to prior research on nominal approaches for variable binding, which has drawn on atoms, swapping, and support, our work is also based on these concepts. As swapping and support cannot be universally defined for all types, we utilize a representation of Haskell-like type classes to quantify over types for which these concepts are applicable. Each component is elaborated upon in this section.

The record type is parameterized by 't,' representing the type of elements contained in the sets. The actual type of finite sets over 't' is denoted as 'extfset,' and 'in' serves as a set-membership predicate. The field names are constants (i.e., record field selectors) with full types as classes. Each record type defines a type class, and the fields of the record type are attributes of the type class. To specifically quantify over types that belong to a particular type class, we quantify over its dictionary. We refrain from using modules for this purpose, as we are unable to quantify over all modules that implement a given signature.

In theory, users can employ any definition of swapping for a given type that complies with the properties in 'swapt.' However, in practice, there generally exists a naturally defined one based on the type's structure. The simplest form of swapping involves the exchange of atoms 'a' and 'b' of type 'atom a,' when applied to the atom 'c' (also of type 'atom a'), denoted as 'swapa a(a, b) c.' We provide the constructor 'mkatomswap,' which utilizes the 'swapa' function to construct the 'swapt' record. For types where no atoms (of the sort being swapped) are present (e.g., the 'nat' type), the only reasonable definition for applying a swap is to leave the object unchanged.