The control systems team at AWE is currently engaged in formally analyzing a hardware implementation of a Java Virtual Machine (JVM). The aim is to study the behavior of the processor in relation to the instruction set outlined in the official JVM documentation, which comprises over 200 bytecodes. Although this paper will only demonstrate one of the intended approaches using a smaller example, it is sufficient to showcase potential risks in developing pipelined hardware through refinement.

Informally, the ACL2 and Event-B approaches mentioned are analogous, as the refinement map in ACL2 corresponds to the gluing invariant in Event-B. A gluing invariant establishes a relationship between states in a refined (concrete) Event-B model and states in the corresponding abstract model. Finite stuttering in the ACL2 approach corresponds to the introduction of new events in an Event-B refinement (see section 1.2).

The paper is structured as follows: Event-B and its notion of refinement are introduced, followed by an informal description of the instruction set of a hypothetical processor in section 2, from which an abstract Event-B specification is constructed. In section 2.2, a pipelined hardware architecture is introduced as a candidate processor for the instruction set, and Event-B refinement is used to formalize the architecture and its behavior with respect to the instruction set. A proof of refinement, described in section 2.4, fails to highlight potential hazards in the pipelined architecture, and a novel solution (event merging) is proposed in section 3 to address these issues. Section 4 discusses how overzealous merging can introduce further problems in a refinement.

It's important to note that this paper is not questioning the soundness of superposition refinement. The purpose is to propose a solution to formally refine an abstract specification of an instruction set to hardware. Additionally, the refined model presented in this paper is still relatively abstract compared to hardware description languages such as VHDL. Hence, the paper does not propose a complete route to hardware, but it could be integrated into any future approach that generates hardware from Event-B specifications.

An abstract Event-B specification consists of a static part called the context, and a dynamic part called the machine. The machine has access to the context via a "sees" relationship, meaning that all sets, constants, and associated properties defined in the context are visible to the machine. The dynamic aspects are represented by the machine, which declares all the state variables, sets up their initial values using the initialization clause, and allows their values to be changed through the execution of events. The goal is to prove properties of the specification, and these properties are explicitly stated using the invariant clause in the machine. The tool support generates proof obligations that must be fulfilled to verify that the specification is well-defined and the invariant is maintained. It also provides both interactive and automated theorem proving capabilities to discharge the generated proof obligations.

In order to express the desired properties of a system concisely, an abstract specification avoids many implementation details in favor of a more mathematical representation. Refinement is the process of incorporating the artifacts of an implementation into a formal specification while conforming to the behavior of the abstract specification. Section 2.4 presents a demonstration of Event-B refinement.

The context and machine of an abstract Event-B specification can be refined separately. Refinement of a context involves adding sets, constants, or properties, while the link between an abstract machine and its refinement is established through a gluing invariant defined in the concrete machine. Proof obligations are generated to ensure that this invariant is maintained.

When a substitution s' and variable v' cause a transition to a new state, then the new state is related (via "j") to a new state in the abstract world (i.e., a state resulting from the abstract event with generalised substitution s with abstract variable v). It's worth noting that the multiple arrows in the diagram indicate that generalised substitutions can be non-deterministic, and it's not necessary for transitions in the abstract world to correspond to transitions in the concrete world (i.e., refinement can reduce non-determinism).

The guard of an event is only enabled when the instruction indexed by pc contains the appropriate opcode. For example, the event "add inst" is enabled only when "ins opcode(program(pc)) = add". Notably, there are two events corresponding to the "bez" instruction: one event for the zero case (i.e., when the first source register is 0) and one for the non-zero case; the guards determine which of these events is enabled by examining the value held in the first source register.

The paper demonstrates that merging events provides a more accurate model of pipelined behavior and reveals conflicts within the pipeline by generating unprovable proof obligations. By strengthening guards, it is possible to circumvent such conflicts and introduce explicit constraints in the pipeline to ensure correct execution. An alternative solution could be achieved by redefining the abstract-level specification, but this would obscure the relationship between the formal specification and the informal description of the instruction set.