This academic paper discusses the concept of hardware-software codesign, which involves identifying hardware implementations for specific pieces of code in a source program, such as coprocessors or intellectual properties, and replacing the code with the activation of the hardware. The paper aims to propose a method for recognizing algorithm templates and understanding how the instantiation of these templates is carried out, an issue that has not been addressed previously in the context of algorithm recognition. The approach presented in the paper is based on a specific framework. The first step in the algorithm recognition process involves analyzing all dependencies in the source program. If the domains are bounded, the scheduling problem becomes decidable as long as the source program has no dependence cycle. However, for parametrically bounded source programs, the scheduling problem is undecidable. It is important to note that the schedules for such programs typically have a parametric latency. The paper focuses specifically on source programs with a schedule.

The paper further discusses the process of matching outputs of two scheduled source programs, with one source program serving as a template. This involves establishing bijections between output and input variables of the source programs, ensuring that corresponding variables have the same domain. The paper also aims to determine the substitutions for the variables in the template outputs. The authors demonstrate that this procedure is correct and complete, although it may require a parametric number of steps to terminate. The paper proposes addressing this termination problem by constructing an automaton in the next section.

The matching procedure discussed in the paper involves unfolding recurrences defined by the source programs, which may also take a parametric number of steps. The approach proposed is to implement the procedure with an automaton and analyze the automaton to construct the set of unifiers without executing it. The paper describes a specific type of automaton, a memory state automaton (MSA), for this purpose. It is emphasized that the MSA has the same transitions as the matching procedure and computes the same set of unifiers, as confirmed in the paper's correction proof.