In our previous research [10,7], we demonstrated the computational soundness of a non-confluent call-by-value calculus of records similar to the one examined in the current study. We introduced and employed a diagram-based proof technique centered on properties named lift and project. This approach has since been expanded and generalized to a set of abstract diagram-based proof methods. However, the system under consideration here allows for the inclusion of hidden components within records that are inaccessible from outside the record (see [citation]). Records are therefore identified based on the renaming of hidden labels. Nonetheless, our focus lies on establishing the computational soundness of mutually recursive components, which is distinct from the issue of hidden labels.

Lemma 3.4 asserts that if e1{r1}= e2{r2}, where r1 and r2 are redexes, then e1= e2 and r1= r2. Similarly, if m= e1{l1}= e2{l2}, then e1= e2, l1= l2, and m/= e{r} for any e and r.

It can be deduced from lemma 3.4 that there exists at most one evaluation step in any record component. For example, if a component is in the form of e{r}, indicating a term evaluation redex, it may not have a label in an evaluation context.

Introduced in [cite], elements of the same class have the same meaning (although they may be further distinguished by the context in which they are used). For instance, at the term level, it is logical to categorize constants 2 and 3 into different classes since their meanings are evidently distinct. However, it is customary to group all lambda abstractions into the same class since a function, by itself, is indistinguishable from any other function until it is applied.

This does not imply that substituting an abstraction with any other can be considered meaning-preserving. It is always possible to differentiate two semantically different abstractions by considering them within a record alongside a term that applies the abstraction to an argument. A transformation is deemed meaning-preserving if its outcomes remain unchanged regardless of the other components present in a record. Given the assumption that any abstraction bound to a label is applied to arbitrary terms in other components, transformations must uphold the actual behavior of abstractions. This notion is formalized through record contexts, which are not elaborated here due to space constraints.

Lemmas 4.1 and 4.2 ensure that the outcome is well-defined, as every record either possesses a unique normal form or diverges along all evaluation paths (we equate a label bound to a black hole with divergence). The outcome formalizes the idea that the meaning of a term stems from its evaluation.

Regarding the potential application of other diagram-based methods, the lift and project method has been extended and generalized in [citation]. While it is conceivable that a form of the approach presented there, known as lift/project when terminating (or LPT), could be applicable, we have yet to construct such a proof.

The meaning preservation property of a term reduction can be established using the lift and project approach alongside the apparatus of marked redexes and residuals. The proof resembles that for the call-by-value calculus in [citation]; further details can be found in [citation].

We demonstrate that substitution preserves the outcome of a record. A key concept in the proof is to utilize the efficient evaluation strategy (see definition 4.4) to ensure that each component is evaluated only once, specifically the first time it is required.

We have successfully established the computational soundness of the call-by-name calculus of recursively-scoped records. Our system captures the fundamental characteristics of mutually recursive components. We intend to investigate the applicability of our proof method to more complex systems involving potential cyclic dependencies, such as letrec calculi and more sophisticated systems modeling modules and linking. Additionally, we will explore how the context method compares to other methods for proving computational soundness.