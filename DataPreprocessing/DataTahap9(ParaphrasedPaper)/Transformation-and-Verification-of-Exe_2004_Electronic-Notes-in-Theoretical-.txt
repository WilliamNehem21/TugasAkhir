In addition to the frameworks (which are not discussed in this article), refinement proofs can also be carried out using model checking if the reachable system state space is finite (cf. [1,24]). The advantage of utilizing model checkers in the context of frameworks is that the proofs can be conducted in a highly automated manner. Given that UML-based system descriptions tend to represent systems in a relatively abstract manner, it is anticipated that the modeled state space of many real-life systems can be managed by a model checker. Consequently, the decision was made to employ the robust checker TLC (Temporal Logic Checker) [24,33] to perform the refinement proofs. Tools for transforming UML specifications into CTLA [9,11], and CTLA specifications into TLA, exist. This transformation extensively utilizes the compositional features of CTLA, as a UML diagram can be transformed into a separate CTLA process. Our approach complements other formalization approaches for UML diagrams by formal models (cf. [25,28,30,31]), which, however, do not employ compositionality in the manner explained in this paper.

A read-write action is used for accessing and modifying structural features such as object attributes and properties, creating and deleting objects, and managing links between objects. Derivations are structural feature actions for handling access to structural features, object actions for managing the lifecycle of an object, and association actions for operating on links and associations. An example of the first subclass is "readStructuralFeature," which retrieves the values of a uniquely identified and non-static structural feature of a specific target object. Object actions are responsible for creating and destroying objects. A "createObjectAction" is an action that creates an object conforming to a class. Object destruction is performed using a "destroyObjectAction".

Systems and subsystems are described as compositions of concurrent processes. Similar to the ISO/OSI Specification Language LOTOS, a set of processes interact in a rendezvous-like manner by jointly performing actions, and the data parameters of the actions can model the communication of values between processes. Each process encapsulates its variables and changes its state through the atomic execution of its actions. The system state is the vector of the processes, each object instantiated from the corresponding UML class according to its statechart diagram. Our transformation of a statechart to a CTLA process is based on the concept of run-to-completion semantics, which assumes that only one thread of control is active in an object at a given point in time. This concept necessitates the interleaving of concurrent processes.

The transformation is performed in two steps. Firstly, we flatten a state chart to another state chart containing only simple states and pseudostates, accomplished through the application of graph grammars. In this step, we also consider the actions defined in a state. Actions of entry activities are shifted to every activity of an ingoing transition, while an action of an exit activity belonging to a state is shifted to every activity of an outgoing transition. Do activities are not supported, as they invoke concurrent computations that can be interrupted at any point in time, which would violate our assumption of run-to-completion semantics for a state machine.

We include a state variable “sync” to block an object initiating synchronized calls. Additionally, we introduced the state variable "lifecycle," which describes the lifecycle state of an object. The possible values of "lifecycle" are "unborn," "alive," and "dead." Unborn and dead objects are unable to compute a result or take part in an interaction. For each pin of an action, we added a set of state variables, with one variable used to store the data transferred via the pin. For simplicity, we restrict the range of pin types to simple data types and introduce another variable to indicate if the pin is currently filled by data or a control value.

CTLA actions are utilized to change the value of the state variable "lifecycle" if the creation and destruction of objects is handled in the corresponding UML model. The CTLA action which creates an object sets the value of the state variable "lifecycle" to "alive" if it has the value "unborn," and an additional action is used to change the value of "lifecycle" to "dead" if an object needs to be destroyed and the value of "lifecycle" is "alive."

Similar to an operation call, the corresponding operation reply is also modeled by two coupled CTLA actions. In the UML, however, an incoming reply transmission is accepted by the same "callOperationAction" that triggered the initial call. Since this non-atomic behavior cannot be specified by a single CTLA action, we describe "callOperationActions" by two CTLA actions modeling the execution of an operation call and the acceptance of the reply transmission. In the process adapter, the actions "callControl" and "callControlReply" are both used to model a single "callOperationAction."