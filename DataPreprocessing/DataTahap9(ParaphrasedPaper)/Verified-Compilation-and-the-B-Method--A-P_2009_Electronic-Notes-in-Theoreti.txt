The b method is capable of spanning the development process from modeling to the algorithmic level. However, in order to move from the algorithmic model to a running implementation, it is necessary to synthesize the algorithm into a programming language and then compile the resulting code into the assembly language of the target platform. These last two steps cannot be formally verified using the formal verification approach provided by the b method because they involve mapping constructs between languages with different semantic underpinnings. Furthermore, compilation involves deep transformation of the code structure due to optimization and other transformations, which can potentially introduce bugs. To increase confidence in the generated code, industrial users of the b method employ a redundant tool chain with two distinct implementations of code synthesis and compilation. However, this pragmatic approach does not offer theoretically satisfying evidence of correctness and results in the execution of redundant programs.

The paper is organized as follows: Section 2 provides an introduction to the b method and compares it to a classical application of the method. Section 3 outlines the definition of a b model for the instruction set of a micro-controller. Section 4 presents the mapping of algorithmic language constructs to assembly language constructs and introduces the structure of an assembly program as a b implementation. Experimental results of applying this approach to commercial micro-controllers are also reported in this section. Finally, Section 5 draws preliminary conclusions on this work and outlines an agenda for future research in constructing a production-level verifying compiler based on the b method.

The b method for software development is based on the b abstract machine notation (AMN) and uses formally proved refinements to automatically generate programming code from a sufficiently concrete model. Its mathematical basis includes first-order logic, integer arithmetic, and set theory, and its constructs are similar to those of the Z notation. The method's structuring constructs are closely related to imperative modular programming language constructs. Industrial software for the development of b-based projects is widely available.

Implementation modules in the b method form a special case of refinement, similar to a programming language, and are used to define algorithmic models. These modules can be used as input to generate source code in conventional programming languages such as C or Ada.

A b module contains two main parts: a state space definition and the available operations, along with auxiliary clauses for practical purposes. The state components are specified in the variables and invariant clauses, where the former enumerates the state components and the latter defines restrictions on their possible values. Semantics of substitutions is defined by the substitution calculus, which formalizes how different substitution forms rewrite to formulas in first-order logic.

The target platform can be modeled with the b abstract machine notation, where the state of the machine represents the state of the platform (e.g., registers and memory), and each operation represents an assembly instruction. The algorithmic model is further refined into an assembly-level model by mapping state variables to platform memory addresses and translating algorithmic-level operations to combinations of operations defined in the platform model. The resulting assembly-level refinement needs to be proved compliant with the corresponding functional model, resulting in a software artifact at the assembly level that formally refines the initial functional model.

This refinement strategy is supported by a loop construct called the fetch loop, which halts when the program counter reaches the end marker. The fetch loop uses local variables to maintain the program counter and the end marker, and establishes a relationship between the variables of the RAM machine, the local variables of the operation, and the state of the RAM memory.

In conclusion, the paper discusses the potential future work needed to build a full-fledged tool chain based on the b method and target an assembly-level industrial platform. This includes defining and implementing formal rules for constructing assembly-level models from algorithmic models, addressing scalability issues in verification efforts, and addressing modeling needs for safety-critical systems. These goals may require relaxing the restrictions imposed by the b method on refinements, improving the automation of provers, and further development in the modeling viewpoint.