The paper introduces a method to address the bootstrapping problem, which involves obtaining a reliable binary of the c0 compiler from its c0 implementation, thereby enabling pervasive verification of the correctness of compiled c0 programs in a real system.

Compiler verification is a well-established field, with correctness proofs covering issues ranging from simple expression translation to compilers with optimizations. The VeriFix project has made impressive advancements in verifying correct compilers, such as presenting an elegant theory for translating intermediate languages to machine languages and partially formalizing the work in the PVS theorem prover. While the specification of an optimizing compiler back-end from the SSA intermediate language has been formally verified, the machine model used is not representative of a realistic processor, making it insufficient for bridging the gap between software and hardware for pervasive verification. Furthermore, complex languages such as those involved in modeling the semantics of expression evaluation with non-determinism make correctness proofs of larger programs infeasible in the context of pervasive verification.

The CLI project has produced a collection of verified programs primarily in low-level languages, and recent work has presented logics for the assembler-level verification of various types of low-level software. However, while some challenges for compiler verification have been addressed in isolation, the paper argues that there is a need to integrate individual solutions into a single framework to enable pervasive verification of complex systems. The paper is the first to present a comprehensive framework that addresses this need by integrating separate solutions into a single framework for pervasive verification of complex systems.

The paper outlines a method to solve the bootstrapping problem and presents the small-step semantics of the c0 language, a correctness proof for the compiler implementation, and a discussion of future work.

The paper also discusses the complexity of the full C language semantics and the benefits of using a language like c0, which has concise semantics that facilitate formal verification. It covers various features of the c0 language, such as dynamic allocation of zero-initialized heap memory, function calls, and generalized variables.

Notably, the paper describes the verification issues related to the compiler implementation and highlights the challenges involved in ensuring the correctness of recursive functions, dealing with differing recursion directions between the implementation and specification, and efficiently generating complex literals.

Finally, the paper provides an overview of the formal proofs and definitions involved in verifying the correctness of the compiler implementation, which consists of approximately 1,500 lines of c0 code and roughly 85,000 lines of Isabelle code covering the c0 small-step semantics, correctness proof for the compiler implementation, and simulation proof for the compiling specification.