Unfortunately, it is not practical to analyze password protocols under the assumption of ideal encryption, as most real-world encryption schemes deviate from this ideal. In practice, password protocols are designed to be secure when implemented with a specific encryption scheme, and their security against dictionary attacks depends on the chosen cryptosystem. The security of an encryption scheme is typically defined by certain properties that the ciphertexts adhere to. For example, an encryption scheme is considered repetition concealing if an adversary cannot detect two instances of the same message encrypted with the same key, which requires probabilistic or stateful encryption. Similarly, an encryption scheme is considered which-key concealing if an adversary cannot determine if two messages are encrypted under the same key. Additionally, each particular cryptosystem has its own unique characteristics that may provide useful information to an adversary. For instance, in the RSA public key system, the public key (n, e) can be distinguished from a random string because e is odd and n contains no small prime factors. This vulnerability allows for a dictionary attack over the encryption key exchange (EKE) when instantiated with RSA.

Our analysis revealed a vulnerability of the EKE when ciphertexts are identifiable as being encrypted under the same key. To address this issue, we propose a simple modification that, to the best of our knowledge, is a novel solution.

We introduce the notation v.{x= v} to represent a situation in which a term v has been sent to the environment, but the environment may not have the atomic names present in v. However, the environment can refer to v by using x.

In addition to names and variables, we employ the pairing constructor and its projections. Given a name k representing a private key, we can derive a public key pk(k) that can be used for public key encryption. We also define the hash constructor. Our constructors for encryption (both symmetric and asymmetric) take a name r as a randomness parameter to model probabilistic encryption. By explicitly considering the randomness parameter as a name, we can easily model repetition concealing versus revealing cryptosystems by restricting or not restricting r. On the other hand, decryption is deterministic.

In some specific cryptosystems, it may be possible for ciphertexts to be distinguishable from pure random noise, even when the plaintext or encrypting key is not leaked. For example, the length of messages can indicate the presence of a ciphertext, and in some encryption schemes, numbers close to each other can also reveal information about a ciphertext. Additionally, in the McEliece cryptosystem, every ciphertext is a codeword with a small vector error added to it, making the ciphertexts distinguishable from random noise.

The process ps models what happens after the session is successfully established, and the public key pk(ks) is exported in the variable pks. We assume that none of the values used during the protocol appear in ps, and ps never discloses ks. If the decryption fails, the process would abort.

Acknowledgements: We would like to thank Pieter Hartel and the anonymous reviewers for their helpful comments. We would also like to acknowledge Jonathan Herzog for mentioning a helpful comment that led to this work. This work was carried out in the context of the licensescript project, supported by the Telematica Instituut.