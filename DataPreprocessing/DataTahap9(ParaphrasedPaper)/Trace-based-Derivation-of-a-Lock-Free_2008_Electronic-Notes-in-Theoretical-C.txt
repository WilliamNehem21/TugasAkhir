Lock-free algorithms are designed to address issues associated with the use of locks for managing access to shared data structures. Instead of relying on mutual exclusion to prevent interference between processes, lock-free algorithms aim to ensure correct behavior in the presence of interference. While this approach circumvents the problems associated with locks, it typically results in more intricate algorithms compared to lock-based ones, allowing for more complex interactions between processes. Consequently, although the fundamental idea may be straightforward, the implementation of lock-free algorithms often involves subtle, challenging-to-understand code and is difficult to get right.

We examine a system comprising a finite set of concurrent processes that access a shared queue containing elements of type t. Each process intermittently performs operations on the queue, while also engaging in other activities unrelated to the queue. To model such a system, we abstract away from other behaviors and focus solely on the queue operations.

The attributes head, tail, value, and next are assumed to be encapsulated within a module, accessible to all processes performing queue operations but restricted from the rest of the system. Queue nodes (i.e., elements of value and next) can only be accessed through location values returned by newnode().

Certain actions, such as append and advance, do not commute with other actions that access these variables. For instance, we do not expect append to move, as it determines the new value of the abstract queue and serves as the linearization point for enqueue. Moreover, moving an advance over another advance would impact the update of the tail, thus affecting the behavior of the execution as observed by other processes. Therefore, we need to carefully consider how append and advance actions interact.

Next, we contemplate the implementation of tryappend. As previously mentioned, we must check whether next(tail) is null and, if not, attempt to update the tail before attempting to append the new node. However, if we advance the tail, another process may execute an append before this process gets to append its node. Consequently, we need to conduct the test again, which can occur multiple times. Hence, we establish that nextl = next0(tail) implies that next(tail) has not changed since it was read during the assignment to nextl. This is a result of the assumption that heap locations are not reused, and for any location l, next(l) is only assigned twice: once to null when it is allocated and once to a non-null value when it is the last node in the list upon appending a new node. Consequently, next(tail) cannot change from one value to another and then revert to the previous value again.