The technique of fault-based testing involves using test data to demonstrate the absence of specific faults. One well-known method within this approach is mutation testing, which involves injecting faults into a program by altering its source code and then designing test cases to detect these errors, with the assumption that other faults will also be identified. This paper applies the mutation technique to both specifications and programs.

The paper aims to complement existing theoretical knowledge in the field, which traditionally focuses on semantic aspects of programming. While existing theories concentrate on issues such as correctness, refinement, and algebraic properties of programming languages, a complementary testing theory should emphasize the concept of faults. The main idea behind fault-based testing is to devise test data that showcases the absence of predetermined faults.

The paper's structure includes a general introduction followed by a brief overview of the theory of designs and definitions of faulty designs in section 2. The subsequent sections present the main contributions of the paper. Section 3 introduces a method for constructing test cases to identify anticipated errors in a design, operating at the semantic level of designs. Section 4 outlines a purely algebraic test case generation technique based on the algebraic properties of a programming language. The paper concludes with a discussion of the results, related work, and an outlook on future research directions in section 5.

The study focuses on model-based specifications, specifically utilizing the design calculus of Unified Theory of Programming (UTP) to assign precise semantics to specifications. Designs, which are a specific form of predicates with pre- and postconditions and an alphabet, are employed. The section also discusses the relationship between test cases, designs, and programs in the context of refinement.

The paper shares that previous work by the first author has shown the importance of refinement in understanding the relation between test cases, specifications, and implementations. Refinement, an observational order relation typically used for step-wise software development, is crucial for ensuring that a correct implementation refines its test cases. The paper also presents an example related to finding the smallest element in an array to illustrate computation paths as guarded commands.

The paper introduces two test case generation laws: one provides a general criterion for fault-based test cases, while the other is more constructive and specialized for designs. It also discusses related work on fault-based test case generation, including algorithms proposed by other researchers for detecting different types of faults in program specifications.

Overall, the paper presents a comprehensive exploration of fault-based testing and introduces innovative approaches to test case generation for identifying faults in both specifications and programs.