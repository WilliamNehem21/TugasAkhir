In this paper, we propose a development strategy that differs from that of the cookbook in several key aspects (see section 5). We begin in section 2 by providing an overview of the event-b notation, which is supported by a specialized notation for abstract machines and serves as the core element of the development method. We explain our strategy and apply it to a control problem in section 3, and then discuss our results in section 4.

Event-B is underpinned by a specialized notation for abstract machines, which supports both the formulation of formal specifications and their refinement. In this section, we briefly outline some crucial aspects of Event-B. For a more comprehensive understanding of Event-B, we refer readers to additional resources.

It is essential to prove consistency between a concrete machine and its abstract machine. This is typically done on a per-event basis. An event of the concrete machine is considered a refinement of an abstract event if the guard is strengthened and the action of the concrete event can be simulated by the action of the abstract event.

In the final refinement of the environment model, we introduce trains into the system. The safety properties related to the trains all pertain to their position, making it a suitable candidate for a new variable. Thus, "pos" is introduced to map each train to the only block where it is located (as stated by inv3 0), consistently with env1. To prevent collisions (i.e., to enforce saf5), we introduce inv3 1, which states that each train is alone on its block. Finally, for consistency with the variable "occ," we introduce inv3 2 so that only trains can occupy a block.

We focus on the actuator of the in-switch on a specific platform (env13). Two new variables, "act in sw" and "act in sw plf," are used to model the actuator. The former is a boolean indicating whether there is a pending command for the device, while the latter specifies which platform the switch should change to.

Event "turn in sw" is refined accordingly using the command from the actuator. The concrete guard specifies that there is a command from the controller for changing the in-switch. As a result, the in-switch is set to the specified platform as commanded, and the actuator is reset after the switch changes.

Event "ctrl trigger in sw" specifies that the actuator "act in sw" can be set to instruct the switch to change to any platform "p" when the entry signal is red and both actuators "act in sw" and "act ent sgn" are unset. Event "ctr chg ent sgn" models the fact that the actuator "act ent sgn" can be set to command the entry signal to change to green, when the in-switch points to an unoccupied platform and both actuators "act in sw" and "act ent sgn" are unset. The guards of these events ensure that the newly introduced invariants are maintained.

Finally, since "in sw" is used in the guard of "ctr chg ent sgn," the controller needs to know the status of the in-switch when sending the command for changing the entry signal. The controller keeps a copy of the status of the in-switch with its variable "ctrl in sw." Note that variable "ctrl in sw" does not necessarily reflect the current value of "in sw." Indeed, they only need to be the same when there is no actuator command for the in-switch. "Ctrl in sw" is updated when the controller commands the corresponding switch to change with event "ctrl trigger in sw."

We have presented our development strategy for developing control systems together with a model of their environment. Our strategy begins with the modeling of the environment, followed by the introduction of the actuators, before the controller and sensors are modeled. Finally, further scheduling details are imposed on the controller as an optimization step for the system. Applying our development strategy reduces the difficulty in modeling this type of systems and results in models that are easy to understand and verify. We illustrate our approach by developing a simplified signal control system. Even though there are no code generators for Event-B yet, the controller variables and events in our final model are concrete and clear enough and can be used as a software low-level design.

The validation of control systems has been explored using other formal methods. Hansen validated a railway interlocking model using VDM. However, the paper only establishes a model of the environment without the controller. Haxthausen and Peleska presented an approach using RAISE for developing a distributed railway control system. Their approach consists of two stages. In the first stage, the model of the environment and controllers are developed globally together. Their second stage focuses on the design of a distributed controller corresponding to the model in the first stage. Our development strategy can be seen as a guideline for developing the model in their first stage.