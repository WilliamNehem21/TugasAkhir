Many efforts have been undertaken to reconcile the disparity between static and dynamic programming languages. Local type inference is employed in languages such as Scala, C# 3.0, OCaml, and Java 7 to alleviate syntactic burden. Various techniques such as gradual typing, soft typing, and hybrid typing have been devised to enable a transitional state where certain parts of a program are statically typed while others are dynamically typed.

Nullable references have posed a significant source of errors in languages like Java, where nullable references are often mistakenly treated as non-null references. To address this issue, several proposals have been made to rigorously differentiate between these two forms using static type systems.

Implementing these constructs in most statically-typed languages would lead to greater complexity and verbosity. In modern object-oriented languages like Java, expressions must still be explicitly retyped, necessitating the introduction of new variables and type aliases. For instance, after a test like "s instanceof Circle," a new variable "c" would need to be created as an alias for "s," with type Circle.

In Whiley, numbers on the JVM are represented similarly to Clojure, where integers and real numbers are represented using custom BigInteger and BigDecimal classes that automatically resize to avoid overflow. Whiley mandates that integers are genuinely treated as subtypes of real numbers.

When variable "d" is guaranteed to be a list of some sort, its type on entry is translated to "List" on the JVM. Consequently, Whiley cannot directly use an instanceof test on "d" to distinguish two cases, and must instead examine the first element of the list.

Similarly, when variable "r" is guaranteed to be a record of some kind, its type on entry is translated as "Object[]". In this case, implementing the type test using instanceof does not make sense, and it becomes necessary to check whether "r" has fields "x" and "y."

Distinguishing between different record types can be optimized by minimizing the number of field presence checks. The Whiley compiler generates the minimum number of field checks required to ascertain the present case.

Information flow analysis involves tracking the flow of information to restrict certain flows based on security reasons. Hunt and Sands adopt a flow-sensitive approach and present their system in the context of a simple while language. Russo et al. extend this system to compare dynamic and static approaches, demonstrating that a purely dynamic system may reject programs that are considered type-safe under the Hunt and Sands system.

Typestate analysis focuses on flow-sensitive reasoning about the state of objects to enforce temporal safety properties. Typestates, which are finite-state automata, can encode usage rules for common APIs and were pioneered by Strom and Yellin. Fink et al. and Bodden et al. present interprocedural, flow-sensitive typestate verification systems, which aim to minimize overhead and eliminate failure points statically while using dynamic checks when necessary. This approach was later extended to include a backward propagation step to improve precision.