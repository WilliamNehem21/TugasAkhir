Numerous contemporary program verifiers follow a two-step process of translating a program and its specification into an intermediate representation, and then computing verification conditions on this representation. Using an intermediate language enhances tool interoperability and simplifies the calculation of smaller verification conditions. Despite the critical importance of translating into an intermediate representation for the soundness of a verifier, this step has not been formally verified. In this paper, we establish the formalism of translating a limited subset of Java bytecode into an imperative intermediate language similar to BoogiePL. We demonstrate the soundness of the translation by proving that each bytecode method whose BoogiePL translation can be verified can also be verified in a logic that operates directly on bytecode.

Many modern program verifiers, such as ESC/Java, Boogie, Krakatoa, and Caduceus, verify programs in two steps. First, they translate the program and the specification into an intermediate representation, such as guarded commands, BoogiePL, or the WHY language. In the second step, they compute verification conditions for the intermediate representation and pass them to a theorem prover. Using an intermediate language improves tool interoperability. For example, Krakatoa and Caduceus translate Java and C code to the WHY language, allowing them to share the WHY backend. Additionally, simple intermediate representations facilitate the generation of small verification conditions through passification.

In this paper, we formalize the translation of Java bytecode into an untyped version of the intermediate language BoogiePL and prove the soundness of the translation by demonstrating that the verification conditions for the intermediate program are at least as strong as the corresponding verification conditions for the original program. Our formalization and proof cover a large subset of Java bytecode. Due to space limitations, we focus on a small but interesting subset in this paper.

In this section, we provide a brief overview of BoogiePL and present a WP-calculus. BoogiePL programs consist of a prelude and a list of procedures, where the prelude specifies a background theory in first-order logic using global variables, constants, axioms, and uninterpreted functions and the procedures contain a specification and an implementation. In our translation, we do not use the procedure specifications. The implementation of a procedure starts with the declaration of all local variables, followed by one or more blocks. A block has a unique ID, a body consisting of BoogiePL commands, and ends with a non-deterministic goto, which specifies all possible successor blocks in the control flow graph. BoogiePL provides commands such as assignment, call, assume, assert, and havoc. The havoc command assigns an arbitrary value to a given variable. We model local state using the global variable heap to represent the heap of the current execution state, and variables stacki and regi to model the operand stack and registers, respectively.

A transition along a back-edge always closes a loop in the control flow graph, so we can assume that the target of the back-edge has a local annotation for the loop invariant. In the translation, we eliminate the back-edge and instead generate an assertion that the loop invariant holds. A forward edge is simply translated into a goto. Furthermore, instructions such as branch and method call are translated into non-deterministic gotos to successor blocks, and exceptions are handled by assuming exceptional postconditions and jumping to possible exception handlers.

The Boogie verifier translates annotated CIL code to BoogiePL. Some aspects of this translation, such as back-edge elimination and the translation of heap-manipulating statements, have been proven sound. Our formalization and proof cover a larger language subset, including exceptions, which are not yet handled by Boogie. This work closes a gap in the soundness argument of several program verifiers, and the complexity of the translation and proof has been kept reasonable by using an identical heap model and a very similar state model for bytecode and the BoogiePL translation, relying on the guarantees and information given by the bytecode verifier.