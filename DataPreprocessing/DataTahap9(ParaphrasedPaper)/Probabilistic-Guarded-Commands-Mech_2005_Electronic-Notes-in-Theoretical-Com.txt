The second advantage of mechanization is the ability to utilize machine-readable PGCL theories to facilitate the development of automatic proof tools that employ weakest-precondition semantics for reasoning. For instance, the verification of PGCL programs often involves substantial numerical computation, which can be formally carried out by employing relevant theorems about real numbers. HOL4, as a theorem prover in the LCF family, offers a complete programming language (ML) enabling users to create such tools. Consistency is ensured by the logical kernel, a small module responsible for generating objects of type theorem using the inference rules of higher-order logic.

Several small tools were developed to expedite mechanization and program verification, including the aforementioned rewriting for real numbers. Additionally, a tool was implemented to take an annotated program C, precondition P, and postcondition Q as input and generate verification conditions ensuring partial correctness (Hoare triple {P}C{Q}). It proves as many of these verification conditions as possible, simplifies the remaining ones, and returns them to the user as subgoals for interactive proof.

The initial state does not lead to a definite final state but rather to a probability distribution over final states, reflecting the probabilistic branching in its execution. Demonic branching is indicated when the initial state is related to more than one final distribution. The use of relations instead of functions and probability sub-distributions is exemplified in the following example.

On the definition's left-hand side, 'switch' is included as a parameter of the contestant, which is used in the program on the right-hand side to determine whether to switch curtains in the final step. The postcondition is the contestant's desired goal and has been previously proven for PGCL. Additionally, simple techniques based on program variants have been derived. However, for the remainder of this paper, only partial correctness will be of interest, and questions of termination will not be addressed.

As a result, it is the user's responsibility to provide a useful loop invariant P in the 'assert' around the 'while' loop. After the initial subgoal is derived successfully using the prolog tactic, subsequently failed subgoals are turned into verification conditions without initiating backtracking. Therefore, each 'while' loop in the program generates one verification condition, ensuring that the supplied P is indeed a correct invariant for establishing Q. Nested 'while' loops function in a similar manner, with the invariant for the outer loop being propagated backwards through the body, and a verification condition generated upon encountering the inner 'while' loop.

The interpretation of a pre-condition with respect to a given postcondition implies that the expression on the right at (1), evaluated at an initial state s, yields the probability of establishing the postcondition (i.e., the existence of a unique winner). This must be at least the expression on the left, which is greater than or equal to 2/3 for all initial states except when i=0 (in which case the satisfaction of the postcondition would be impossible).

This work illustrates the advantages of mechanizing a theory of program semantics using a theorem prover, particularly the compatibility of the interactive theorem prover with the verification-condition generator. If subgoals that cannot be automatically proven arise, they can be passed on to the user for manual proof instead of causing a failure. Additionally, the LCF design of HOL4 was leveraged to maintain the consistency of user-defined tactics, ensuring a high level of soundness for any theorems created by the verification-condition generator.

Reference:
Huth, M. (2000). The interval domain: A matchmaker for ACTL and APCTL. In R. Cleaveland, M. Mislove, & P. Mulry (Eds.), USBrazil Joint Workshops on the Formal Foundations of Software Systems (Vol. 14, Electronic Notes in Theoretical Computer Science). Elsevier.