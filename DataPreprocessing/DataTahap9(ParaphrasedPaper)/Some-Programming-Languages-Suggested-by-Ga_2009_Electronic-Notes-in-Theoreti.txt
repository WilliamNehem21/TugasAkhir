For example, one can generally identify two approaches in this endeavor: either we take a language as given and seek a mathematical model to match it, or we take the model as given and seek a corresponding programming language. The latter approach may be motivated by its potential to provide intuitionistic linear logic. Each of these approaches leads to the creation of a Cartesian closed category, resulting in a total of seven models of interest, including the underlying category itself, which will be summarized in section 2.

The existence of these structures on G alone demonstrates the rich mathematical potential of this model. However, the aforementioned definitions may seem enigmatic, and the specific computational capabilities represented by the respective exponentials may not be readily apparent at this stage. The forthcoming programming language characterizations will provide greater insight into this matter.

One final piece of the puzzle is required. We have seen how the encaps operators offer a way to construct non-trivial strategies at types !2G and !3G (i.e., strategies that are not simply promotions of strategies for G), but we currently lack a means to do so for !1G. The following operator fills this gap.

The term grammar may be taken to be identical to that of FPC, but the typing rules differ in three ways. First, the type constructors × and → are replaced by * and -o, respectively, throughout the rules for pairing, unpairing, abstraction, and application. Secondly, as is typical in linear type systems, the treatment of contexts in multi-premise rules is...

We will introduce extensions of the aforementioned languages that are comprehensive for each of our models. As a result, the models are also fully abstract for these languages, as discussed at the end of section 2. Here, we provide only a high-level overview of the proofs, omitting many interesting details. A source file containing Lingay implementations for most of the claimed programs is available online.

The methodology of obtaining definability results through universal types has led us to a selection of primitive operators that shed light on the computational power of some natural mathematical models. This approach has led to the preference for data encapsulation over store cells as the fundamental mechanism for stateful behavior and coroutining over first-class continuations for a flexible approach to control. Additionally, our operators make use of the potential of a linear type system, offering the programmer valuable runtime security assurances with the lincatchcont operator, for example. Finally, our semantic approach emphasizes certain combinations of these operators that can coexist safely, such as the combination of powerful control operators with certain higher-order store constructs without sacrificing runtime safety. We propose that the primitives we have discussed could form the basis for the design of practically useful language constructs, a possibility we are exploring further in our ongoing work on Eriskay.