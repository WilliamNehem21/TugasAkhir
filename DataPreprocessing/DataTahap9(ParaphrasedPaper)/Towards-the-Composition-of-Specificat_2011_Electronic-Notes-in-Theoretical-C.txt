The system development process often begins with the creation of a specification. From this perspective, it is proposed that a specification can frequently be generated through the combination of specifications, which can be viewed as composition. Event-B is a formal method that enables the modeling and refinement of systems. However, the current support for the combination, reuse, and validation of component specifications in Event-B is lacking. To address this, we propose an extension of the Event-B formalism to incorporate shared event composition as a means of developing (distributed) systems. Refinement is employed in the development of specifications using composed machines, and it is demonstrated that properties and proof obligations of specifications can be reused to ensure the validity of composed specifications. The primary contributions of this work include the extension of Event-B to support shared event composition, refinement, and the inclusion of proof obligations for a composed machine.

Systems can often be perceived as a combination and interaction of several sub-specifications, referred to as sub-components, each with its own functional aspect. This view introduces modularity in the system, as changes in the sub-components can be more seamlessly accommodated in the system specification. Composition is utilized to structure specifications through the interaction of sub-components viewed as independent modules. Although the use of composition is not new in other formal notations, we specifically discuss how composition can be utilized (and reused) for building specifications in Event-B through sub-component interaction, leveraging their properties and proof obligations. The interaction of subcomponents, typically involving shared state, shared operations, or a combination of both, is predominantly focused on their visible events, akin to CSP. We adopt a shared event composition approach, where events are synchronized in parallel. This document explains the structure as follows: Section 2 briefly describes Event-B, Section 3 introduces the notion and properties for shared event approach, and Section 4 introduces composed machine, proof obligations, and the monotonicity property.

The semantics of the parallel composition of machines M and N corresponds to the set of failure-divergence for each individual machine in parallel. From the correspondence between action systems and Event-B, machines M and N can be refined independently, which is a crucial property inherited from CSP by shared event composition in Event-B. The monotonicity property for shared event composition in Event-B is proven through the proof obligation. When sub-components are composed, it is desirable to define properties that relate the individual sub-components allowing interactions. These properties are expressed by adding composition invariants to the composed machine, constraining the variables of all machines being composed.

Proof obligations play a significant role in Event-B developments. They are generated to verify the properties of a model. For simplicity, proof obligations are defined in terms of the composition of two machines that refine machine M0, but the rules can easily be extended to the composition of N machines. Additionally, the context elements in the formulas are not considered. The proof obligations defined for standard machines are also defined for composed machines. The additional proof obligations necessary to ensure that the composed machine satisfies all the standard proof obligations are defined. Well-definedness for expressions needs to be verified using proof obligations. For composed machines, well-definedness proof obligations are only generated for specific expressions. Other expressions are verified in the individual machines.

Monotonicity for single non-composed events that appear at both levels of abstraction also needs to be proven. This is achieved by utilizing machines M1 and M2. Additionally, new events can be added during refinement, respecting the 
refinement proof obligations. The refinement proof for new events is similar to previous cases but applied to a single event refined by a composed event. Due to space limitations, the detailed proof is not presented here.