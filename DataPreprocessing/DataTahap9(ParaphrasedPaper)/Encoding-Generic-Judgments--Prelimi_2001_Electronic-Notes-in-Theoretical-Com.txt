The use of implication in the bodies of definitional clauses must be restricted to ensure the hold of cut-elimination. To achieve this, we introduce the concept of level for each predicate symbol in the language, denoted as lvl(p), representing the level of the predicate. We then extend the notion of level to formulas and derivations. Specifically, the level of a formula b, denoted as lvl(b), is defined such that "\if b m m)+ v is provable then m+ v is provable" aligns more naturally with our intended proof. To explore this concept, we consider introducing a predicate that functions as an operator for provability, necessitating the differentiation of meta-level logic and object-level logic. We use the symbols 8, 9, ^, and & in the meta-level logic for universal and existential quantification, conjunction, and implication, while the object-level logic distinguishes between meta-level logical expressions and object-level logical expressions using the types o and obj, respectively.

Regarding the provability of m+ v, whether directly from its horn clause specification or indirectly via the use of an interpreter, both methods essentially yield uniform proofs. From a practical standpoint, this distinction does not confer any proof search advantages. Notably, Prolog, Elf, Isabelle, and Coq, implementing a form of Higher-order Abstract Syntax (HOAS), have been explored in earlier papers, with a tendency to consider richer calculi as foundations for HOAS, leading away from the originally exploited simply typed-calculus setting. Encoding a syntactic category of abstraction within rich function spaces can give rise to significant issues, such as undecidable unification and exotic terms, which may be inappropriate when seeking to develop a straightforward treatment of syntax.

The paper's presentation closely follows the treatment of the lambda-calculus outlined in a specific source, necessitating three primitive syntactic categories: name for channels, proc for processes, and action for actions. Constructors such as out and in represent output and input operations, and the-calculus expressions x y:p and x(y):p are encoded as (out x y p) and (in x y:p), respectively. Additionally, the match operator [=], and symbols # and ", are used to denote actions on named channels with named values.

The proof of this approach largely follows from propositions 4.1 and 5.1, with the induction needing slight strengthening to accommodate cases where the bound variable l in .l is free in the judgment, particularly when a universally quantified goal is interpreted. Modals and symbols are defined to encode various actions and possibilities, while natural numbers are encoded as a type with constants such as z and succ. The satisfaction relation is defined using predicates to help stratify the definition in the presence of negation in the assertion language.

The approach to encoding syntax and operational semantics is strongly influenced by proof theoretic considerations. Other approaches, such as model-theoretic or categorical-theoretic, have been explored recently for syntactic representations and comparing these approaches could be insightful. The paper acknowledges feedback and funding support from Catuscia Palamidessi, anonymous reviewers, and NSF grants.