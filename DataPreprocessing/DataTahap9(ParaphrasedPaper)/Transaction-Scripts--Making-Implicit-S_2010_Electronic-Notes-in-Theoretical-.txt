In this research paper, we present a novel method for managing dependencies between distributed and concurrent coordinator components of a long-running transaction using a true-concurrent approach. We previously introduced the translation of interactions specified in a scenario into a tuples-based behavioral description known as vector languages. Here, we demonstrate how analyzing order-theoretic properties of such languages can uncover missing behaviors that are not explicitly outlined in the scenario but are still possible. Our approach allows for the gradual refinement of interaction scenarios into a comprehensive set of behaviors that encompasses all desired execution orderings and eliminates any emergent behavior in the transaction.

Our method involves employing order-theoretic properties of vector languages to identify missing behaviors, which in turn reveal additional scenarios that were not initially considered in the design specification or indicate emergent behavior resulting from the interplay between concurrency and nondeterminism in the interaction. We effectively use this approach to elaborate the initial interaction scenarios into more comprehensive ones, gradually refining them to exclude emergent behavior and include all desired execution orderings.

It is important to note that each transaction vector provides a snapshot of behavior, capturing the actions that have occurred within a transaction. However, in describing the behavior of a transaction, we are specifically interested in the subset of vectors that represent the actions of the coordinator components during the execution of the transaction.

We focus on capturing the behavior of a transaction in terms of the actions of its coordinator components using column vectors, instead of considering all possible transaction vectors. Our goal is to obtain vectors through concatenations with column vectors, as this defines the behavior of the transaction in terms of the actions of its coordinator components and facilitates the coordination of the underlying services.

We have observed that transaction vectors are constructed through coordinate-wise concatenation and are built starting from the empty vector through a series of concatenations with column vectors representing actions. To ensure that the set of transaction vectors consists only of those obtained by concatenations with column vectors, certain properties must be satisfied. We introduce these properties in the subsequent section.

However, there are cases in which this rationale does not apply, particularly in the context of locations within different operands of an alt or par. These cases require different treatment, as they involve considering various possible execution sequences when encountering interaction fragments. The formal construction behind the translation is detailed further in the paper.