The syntax of transition labels in UML state diagrams comprises a triple event guard/action, where each of the three components may be absent. Our current style guidelines dictate the use of input operation names as events and output operation names as actions. Additionally, we allow a limited form of guard, denoted as [bcond], where bcond represents a literal for a boolean condition (possibly a negated name).

The semantics of output actions warrant attention as they simulate operation invocations on other server objects. However, we intentionally disregard the inclusion of the server object reference into the action itself. This decision stems from the localized nature of architectural unit testing, with collaboration between objects falling within the domain of integration testing. Concurrent state diagrams, interaction diagrams, and activity diagrams are potential models for specifying collaboration between objects, providing a suitable foundation for integration testing suites.

A LOTOS specification is defined by a set of inference rules and describes a system using a process hierarchy. Processes can execute internal, unobservable actions and interact with other processes through gates or interaction points. Complex interactions between processes are composed of elementary synchronization units called events, (atomic) interactions, or actions. A system consists of a set of interacting processes, and the system's environment may be viewed as an observer process, such as a human, always ready to observe any observable action at the system interface.

Verification and test case generation are based on a partial exploration of the labeled transition system (LTS) describing the behavior of the system under test. The semantics of an Input/Output labeled transition system (IOLTS) differ from those of an LTS due to the partitioning of the action alphabet into input/output and internal actions. In our methodology, as well as in IOLTS-based test generation tools, the action partitioning is declared outside the (basic) LOTOS specification.

Test purposes enable tools to constrain the specification graph exploration by taking a synchronous product of the specification with the test purpose. Actions specified in the test purpose that are not in the input/output alphabets of the test purpose IOLTS are considered internal actions of the specification. By prioritizing test purpose actions, an effective pruning of the specification graph is achieved.

The conformance relation is the Ioco| relation, which states that an Implementation Under Test (IUT) conforms to a specification according to a set of traces if, after every observable trace, the outputs of the IUT are included in the outputs of the specification. In our methodology, the traces conform to the subset of the traces of the specification that, according to the test purpose, lead to an accepting state.

To use the TGV tool, the specification must be defined as a binary coded graph (BCG) or as a LOTOS specification, while the test purpose must be described as a BCG or in Aldebaran format.

Following the style guidelines for architectural state diagrams, every nonempty transition label comprises only one of the three allowed components: event, guard, or action, corresponding to input, internal action, and output, respectively.

Upon creation, a trajectorygen object is in the idle state, awaiting new data and positions for the controlled robot(s). When it receives these data, the object moves to the check state to verify the final position's reachability (testposition) and to check for obstacles and potential collisions (testobstacle). If the verification succeeds, the object moves to the waitgett state; otherwise, it returns to idle.

In the waitgett state, the object waits for a gettrajectory input. Upon this input, the object transitions to either the compmodt or compnewt state based on the condition of whether the received position is a modification of a previous trajectory or a new position, respectively. Following the computation in either state, the object moves to the trajready state, where it outputs.

If the presence of a new obstacle is indicated, the object transitions to the control state, where it checks for a potential collision with the obstacle ([collisiondetected]). If a collision is possible, the object moves to the approach state to modify the previous trajectory, enabling the robot to approach the obstacle without collisions. The new trajectory is then output to the robot, and the trajectory generator returns to the check state to compute the new trajectory for reaching the final position from the newly reached point. If the new obstacle does not lie on the trajectory, the trajectory generator outputs the computed trajectory to the robot and returns to idle.

It is worth noting that the given translation is not an exact rendition of the provided state diagram due to an issue reported by the Caesar compiler regarding the translation of the composite state check and its outgoing transitions using the basic LOTOS disabling operator (>).

While a single experiment cannot provide a definitive assessment, there seems to be no principled impediment to conducting further experiments. Other tools such as TorX or Promela/Spin may be worth considering to address certain drawbacks identified in our initial experiment.

Future research could explore: 1) extending the methodology to other architectural testing scopes such as integration and system testing, involving other types of UML models, particularly those provided by concurrent state diagrams, interaction diagrams, and activity diagrams; 2) investigating relationships with testing at more advanced development phases, where models are constructed from a more prescriptive, possibly complete specification perspective; 3) on the formal side, extending the expressive capabilities of testing models to accommodate data, such as parameter passing in I/O operations, evaluation in internal actions, etc.