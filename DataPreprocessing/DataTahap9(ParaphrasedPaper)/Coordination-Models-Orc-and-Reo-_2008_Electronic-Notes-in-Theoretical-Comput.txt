While coordination languages and models have been in existence for some time, the recent surge of interest in service-oriented computing (SOC) and web-service choreography and orchestration has sparked renewed attention in the field. This has led to the development of new models and the exploration of new application domains for existing models. Service-oriented computing is predicated on the notion that software is comprised of services residing on external machines, with web services being a common manifestation of this concept. Since the conception of SOC, research efforts have focused on devising languages to coordinate and compose services into composite services or applications.

One such language, Reo, developed by Arbab, is a channel-based coordination language that revolves around the concept of channel composition. It distinguishes itself from existing models in that the composition propagates synchronization and exclusion constraints through connectors, resulting in the emergence of an expressive coordination language when combined with stateful channels.

The paper delves into the encoding of the Orchestrating Concurrent Systems (ORC) language into Reo, noting the challenges of embedding in the reverse direction. It also compares the two models on various aspects and discusses related work, concluding with an outlook on future research. Prior to that, the paper introduces ORC and Reo and provides a small example.

In ORC, a program consists of an ORC expression along with a set of definitions. Basic services, such as data manipulation, are assumed to be offered by primitive sites. An ORC expression can be a primitive site call, a reference to another ORC expression, or a composition of ORC expressions. Additionally, the paper provides examples of primitive sites and their respective behaviors within ORC expressions.

Reo, on the other hand, is a potent coordination model arising from the propagation of synchronization and other constraints imposed by individual channels through connectors formed by plugging channels together. The language also features mutual exclusive data merging and synchronous data replication through nodes. A key characteristic of Reo is the propagation of synchrony through composition, and the paper presents the semantics of Reo connectors in an adaptation of the q-automata model, which extends constraint automata.

The main result of the paper, Theorem 2.10, relates ORC expressions with their Reo encodings, supported by several lemmas and their respective proofs. Additionally, the paper discusses the use of more complex primitive site calls in ORC, drawing examples from previous work.

The paper also highlights differences between ORC and Reo in terms of component or service instantiation, dynamism, and their respective treatment of synchrony and asynchrony. It also notes that while synchrony presents potential benefits in distributed settings, its actual advantages are yet to be fully determined.