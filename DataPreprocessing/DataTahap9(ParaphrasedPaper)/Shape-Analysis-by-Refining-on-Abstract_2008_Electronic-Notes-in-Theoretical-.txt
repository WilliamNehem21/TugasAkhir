The algorithms for shape analysis are used to analyze a program and extract information about the heap-allocated data structures it manipulates. These algorithms are crucial for understanding and verifying programs. Abstraction is essential for efficient shape analysis, and various abstraction methods, such as k-limited heap abstraction, shape graph, and reference counts, are available.

Shape analysis can also be applied to detect memory leaks, which are common errors in programs written in languages with pointers. Memory leaks can lead to memory exhaustion and program failure, especially in large, memory-intensive, long-running programs. Various models and methods, such as ownership models and region-based methods, have been proposed to detect memory errors.

Dealing with complex expressions poses a challenge because the value of a complex expression cannot be easily defined in the abstract shape graph (ASG). To address this issue, we introduce the concept of abstract evaluation paths (AEP), which represent the possible access paths along which the value of an expression can be defined in an ASG. By using AEP, we can refine the ASG to make it easier to define the value of an expression.

In our approach to shape analysis, we adopt a more aggressive materialization strategy that allows pointers into the middle of structures, not just at the beginning. However, this may lead to the generation of more shape graphs than the program actually generates.

The remainder of the paper is organized as follows: Section 2 provides the definition of concrete shape graphs (CSG), Section 3 defines AEP and explains the algorithms for refining ASGs based on AEP, Section 4 presents the abstract semantics of statements on ASGs, Section 5 presents the experimental results, Section 6 discusses related work, and the conclusion of our work.

A shape graph is a directed graph used to represent memory structures and their connectivity. It differs from an ordinary directed graph in that it may contain different types of nodes to represent various data structures.

We establish a set of predicates, called pcore, to classify the possible infinite memory locations into different classes, thus reducing the infinite values to one abstract value. This allows us to generate a finite number of ASGs from any possible infinite number of CSGs.

The paper presents an algorithm with new functions for working with graphs, including the current attribute, node mapping, split for generating new nodes, and cut for deleting inconsistent edges and graphs.

In conclusion, the paper introduces a method for shape analysis that can handle complex expressions and allows pointers into the middle of structures. The use of AEP facilitates the refinement of ASGs, making it easier to define the semantics of statements and check for memory error conditions. Future work will focus on improving the method's efficiency, conducting more thorough experimental evaluations, and applying the results to verify the correctness of programs in the C language.