We present a novel straightforward trace logic for specifying local security properties, referring to individual participants in a protocol. This technique enables protocol designers to formally specify desired security properties and seamlessly integrate them into cryptographic protocol design processes. Additionally, the logic can be utilized for formal verification. We demonstrate the effectiveness of our approach by identifying new vulnerabilities in the well-known tmn protocol.

In contrast to existing methodologies, we introduce a logic that can articulate local security properties, pertaining to the specifications of individual agents. As demonstrated in subsequent sections, local security properties are sufficiently expressive to assert commonly sought-after properties in cryptographic protocols, such as nonce freshness.

The paper's structure is as follows: Section 2 outlines our security protocol model, while Section 3 presents our trace logic language. In Section 4, we conduct an analysis of the tmn protocol and unveil novel vulnerabilities. Section 5 explores related work, and finally, Section 6 discusses conclusions and future prospects.

The intruder can generate a term t using knowledge k, which may involve instantiating variables in t or k. For instance, t may unify with a term in k, indicating that t is already known by the intruder.

We denote Vernam encryption as v(t1, t2) 6, with keys r1 and r2 sent from a and b to s, respectively. Upon receipt of message 4, a can obtain r2, thereby establishing r2 as the shared key between a and b.

The final step involves determining the placement of fveshr1 and fveshr2 in the server role. This decision is straightforward: we position the formulas for checking the freshness of received values immediately upon their receipt. Thus, fveshr1 can be placed as f5, following the receipt of r1, and similarly, we set fveshr2 as f7.

Upon receiving messages 1 and 3, the server can authenticate a and b, respectively, as (by assumption) secrets sa and sb are exclusively shared between the server and the respective agents. To ascertain whether the protocol achieves the authentication goal of a and b to s, we translate this into a formula asserting that if s received a message m ostensibly from a (resp. b), then it was genuinely sent by a (b). The server authenticates a after receiving the message.

As part of future work, we aim to apply the methodology to more complex case studies, such as multicast protocols (e.g., LKH group communications protocol). Furthermore, we plan to explore the composition of local security specifications, which we believe represents a significant advantage of our approach compared to other global approaches.