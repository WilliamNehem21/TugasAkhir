In recent years, significant effort has been devoted to creating formal models of the java bytecode verifier. Some researchers have demonstrated that the problem of bytecode verification can be formally comprehended and described using type systems at static time. These proposals have been proven to exhibit type soundness properties for the considered bytecode fragments. Furthermore, the type inference algorithm has the potential to function as a correct bytecode verifier.

Regarding permissions and control flow analyses, it has been established that the permissions granted at the entry of a node are determined by the permissions granted at the exit of all its callers. Call nodes generate granted permissions only if they are privileged; otherwise, they propagate the permissions at their entry points. Similarly, a check node generates the permissions it enforces and those granted to all of its callers that may pass the check. For instance, we calculate the set of permissions granted to node n16 using the granted permission (GP) analysis.

Our work presents two control flow analyses for java bytecode. The first analysis provides a secure approximation of the permissions granted to bytecode at runtime, while the second one approximates the denied permissions. These analyses lay the foundation for minimizing the runtime overhead caused by stack inspection. Although our focus is on java bytecode, the same static techniques can be applied to address programming languages or systems with security architectures that rely on dynamic checking of permissions through stack inspection.

Several researchers have advocated for the utilization of static techniques to optimize security property checks. For example, Walker introduces the concept of typed compilation schemata, where types encode assertions about program security to prevent runtime violations of security properties. Another approach, proposed by Jensen, Le M`etayer, and Thorn, formalizes classes of security properties, including stack inspection, using linear time temporal logic. Subsequently, model checking is employed to demonstrate that local security checks uphold a given global security policy.