The CNOT operation is defined such that when the control qubit is in a superposition of true and false, the resulting state is a superposition of the outcomes that would occur if each branch of the conditional were evaluated independently. Specifically, if the control qubit is in a superposition of false and true, the resulting entangled pair is (false, false) + (true, true).

In the formal semantics of quantum machine learning (QML), it is important to note that the expression representing the CNOT operation does not result in cloning of quantum data, but rather in the sharing of one instance of quantum data. This means that the expression does not evaluate to (false + true, false + true), which would be impossible to realize. Instead, it evaluates to (false, false) + (true, true), which is a realizable outcome. Consequently, this interpretation allows for the duplication of variables bound to quantum data, as the type system imposes no restrictions on the use of the structural rule of contraction.

In the context of qml, the language in question lacks explicit constructs for measurement. Consequently, expressions that imply the discarding of quantum data, such as the expression where quantum data bound to y is discarded, are rejected. This decision is based on the understanding that the structural rule of weakening should not be allowed in situations where information may be lost. The only exception to this rule is the unit value (), which carries no information.

The types in qml are first-order and finite, with no higher-order types or recursive types. Therefore, the only types that can be represented are the types of collections of qubits.

In qml, the sharing operator is a partial operation, and it is only well-defined when the two contexts do not assign different types to the same variable. Whenever this operator is used, it is implicitly assumed that it is well-defined.

As noted in the typing rules, the sharing operator allows for the sharing of variables within a given context, subject to the condition that the two contexts do not assign different types to the same variable.