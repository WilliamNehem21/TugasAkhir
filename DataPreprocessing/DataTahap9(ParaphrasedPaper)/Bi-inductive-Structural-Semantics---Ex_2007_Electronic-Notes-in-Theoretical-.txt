The natural semantics focuses on defining finite behaviors and does not account for diverging behaviors. By interpreting the big-step evaluation rules as horn clauses in Prolog, the diverging behaviors are determined by the implementation, such as a Prolog interpreter with left-to-right evaluation.

To address this limitation, we propose a novel big-step trace semantics that provides operational meaning for both convergent and divergent program behaviors. This compositional structural definition combines induction for finite behaviors and co-induction for infinite behaviors, eliminating the need for duplicating rules for different cases. The big-step trace semantics specifically excludes erroneous behaviors. Other semantics are then derived systematically through abstraction.

The big-step trace semantics is initially abstracted to a relational semantics and then to the standard big-step or natural semantics. These abstractions are proven to be sound and complete, as the big-step trace and relational semantics describe the same converging or diverging behaviors, while the big-step trace and natural semantics describe the same finite behaviors. Furthermore, the big-step trace semantics is abstracted into a small-step semantics by capturing transitions along traces. This abstraction is shown to be sound but incomplete, as the traces generated by the small-step semantics describe convergent, divergent, and erroneous program behaviors, demonstrating the comprehensive information offered by trace-based operational semantics.

We also introduce a maximal trace semantics that describes both terminating and diverging computations. This trace semantics is then abstracted into relational and operational semantics, with each semantics defined using small steps or big steps of computation, and in fixpoint or rule-based form.