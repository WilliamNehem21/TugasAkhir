The traditional focus of automatic cost analysis of programs has been on a small number of resources such as execution steps, time, and memory. However, with the growing importance of analysis applications such as static debugging and certification of user-level properties, including for mobile code, there is a need to develop analyses for resource notions that are specific to the application. This may include metrics such as bytes sent or received by an application, number of files left open, number of SMS sent or received, number of accesses to a database, money spent, energy consumption, etc. In this paper, we propose a fully automated analysis for inferring upper bounds on the usage of a set of application programmer-definable resources by a Java bytecode program. We define a resource as a user-provided annotation that specifies the basic consumption of certain program elements for that resource. Our analysis derives functions that return an upper bound on the usage of that resource for the entire program and individual blocks, for any given set of input data sizes. In addition, we present experimental results from a prototype implementation covering a significant set of resources.

In our approach, a resource is a user-defined notion that associates a basic cost function with specific elements in the program, such as classes, methods, or statements. The objective of the analysis is to estimate the usage of the resource by the program.

Java annotations allow the definition of the resources to be tracked and provide cost functions for built-in and external (library) blocks that affect the usage of the resource. They also allow the definition of data size relations among arguments and the declaration of size measures. The resource usage expressions are defined using a specific language (referred to as "L") and include base cases, recursive cases, and virtual invocations of methods. The resource-related annotations are carried through the control flow graph (CFG) and are available to the analysis.

The CFG is composed of block methods, which are similar to Java methods but with specific characteristics. These characteristics include the absence of branching within the method, the potential existence of multiple block methods with the same name and formal parameter types in the same class, and the inclusion of formal parameters for the returned value and instance self-reference. Each statement in a block method is considered an invocation, including built-in invocations, which are treated as block methods of the class "builtin."

The analysis process involves the decomposition of the CFG into its strongly-connected components, followed by separate analyses of each component to estimate the parameter size relationships and the resource usage of each block method. The size analysis estimates parameter size relationships for each statement, while the actual resource analysis computes the resource usage of each block method in terms of the input data sizes. These analyses are dependent on each other, and data dependency analysis is employed to yield parameter size relationships.

The algorithm for estimating parameter size relationships is based on data dependency analysis, with the goal of representing input and output size relationships for each statement as a function defined in terms of the formal parameter sizes. The longest path-length of a variable is used as a measure to handle data types such as cyclic structures and arrays, and the set of measures is denoted as "m."

For non-recursive invoke statements, the resource usage function for the callee can be computed using a precomputed cost function or a user annotation that matches the given signature, or both. In such cases, the minimum between these functions is chosen as the safe upper bound for the resource usage, or a warning is issued.

In summary, we propose an automated analysis for inferring upper bounds on the usage of application programmer-definable resources by a Java bytecode program, which is independent of the particular resource and supported by Java annotations and control flow graph analysis.