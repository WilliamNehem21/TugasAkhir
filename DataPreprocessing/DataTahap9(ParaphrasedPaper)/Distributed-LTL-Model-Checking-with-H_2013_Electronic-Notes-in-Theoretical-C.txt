We have enhanced a distributed-memory explicit-state LTL model checking algorithm (OWCTY) by incorporating hash compaction. We have presented a detailed explanation of the improved algorithm and a theoretical proof of its correctness. Additionally, we have implemented the algorithm as part of the parallel and distributed-memory model checker Divine and conducted a practical evaluation, the results of which are reported in the experimental section of this paper.

The effectiveness of the nested DFS algorithm is attributed to the specific order in which the graph is explored, ensuring that states are not visited more than twice. The postorder problem, which is known to be P-complete, has posed challenges to the development of scalable parallel algorithms directly based on DFS postorder. Various solutions to address this problem in a parallel environment have been proposed, including the use of additional data structures, different search and distribution strategies, and running multiple instances of nested DFS with limited information sharing. Parallel algorithms for accepting cycle detection have been found to be linear in the size of the graph. Although the number of iterations can be at most linear in the height of the graph, it is typically very low in practice. Unlike algorithms relying on postorder, OWCTY is not dependent on postorder and can therefore be reasonably parallelized.

At the conclusion of the algorithm, we have introduced a new phase to verify the validity of any discovered accepting cycle. This phase operates similarly to the counter-example generation phase of OWCTY, with the distinction that it may fail due to the absence of an actual counter-example.

The described algorithm could be extended by incorporating accepting self-loop detection to enable early termination. However, as the reachability phase may visit states not discovered during the initialization phase, it is meaningful to add this heuristic to both phases. We opted not to use the heuristics based on the map algorithm, as it may, like OWCTY, produce false accepting cycles, and we have not identified a way to overcome this issue.

As proven in the subsequent section, if our algorithm reaches a fixpoint, the resulting set S is either empty or contains an accepting cycle. In such a scenario, the measures described in the last two points are unnecessary. Nevertheless, given that we cannot reliably detect reaching a fixpoint, premature termination of the iterative process necessitates the verification phase to prevent the reporting of a false counter-example.

All states in S are either on a cycle or reachable from a cycle in S. The correctness of OWCTY ensures that if a fixpoint is reached, this condition is always satisfied. However, if the algorithm terminates before reaching a fixpoint, this may result in the omission of a counter-example.

The verification phase can only return true if there is a path from a state a to itself, and state a was in the set Qacc. With the full representation of state a, the comparison is unaffected by hash compaction. This, coupled with the fact that Qacc can only contain reachable accepting states, guarantees that if true is returned, there exists a reachable accepting cycle, thereby validating the correctness of the verification phase.

In our experiments, the use of hash compaction did not lead to the false identification of any property as valid. However, this lack of occurrence may be attributed to the structure of the BEEM models, as counter-examples in any such model usually consist of multiple similar counter-examples. Nonetheless, this property is common in models of asynchronous systems in general, and we do not anticipate this effect to be significantly exacerbated by the selection in BEEM.