For applications running on standard PC hardware with general-purpose operating systems, threads are a crucial method for supporting concurrent programming. In contrast, low-end embedded systems, such as those based on microcontroller units (MCUs), primarily rely on interrupts to express concurrency. According to a Gartner report, billions of 8-bit and 16-bit MCUs were shipped in 2003, many of which were used in safety-critical applications like vehicle control and medical automation. The correctness of interrupt-driven software is essential, as evidenced by incidents like the therac-25 bugs, which were caused by race conditions involving interrupt handlers.

The verification of interrupt-driven systems to ensure the absence of race conditions is primitive, and understanding interrupts and their semantics is crucial in determining where thread verifiers can and cannot be applied. This paper aims to identify a minimal set of extensions to verifiers for thread-based programs that enable them to check interrupt-based programs. A secondary objective is to leverage interrupt semantics to enhance the speed and precision of checking.

The paper operates on the assumption of POSIX-style thread semantics, focusing on preemptively scheduled blocking threads with fixed priorities. However, the source code examples use a simplified syntax rather than verbose POSIX calls.

While interrupt code can preempt non-interrupt code, the reverse is not true. Interrupts are often scheduled using fixed priorities, resulting in asymmetrical preemption relations among interrupt handlers. Some hardware platforms enforce priority scheduling of interrupts, while on other systems, prioritized interrupt scheduling must be implemented in software.

In contrast to thread locks, which use blocking to control concurrency, interrupts cannot be blocked once they start to execute. Concurrency control for interrupts involves preventing an interrupt from starting to execute, achieved by selectively disabling interrupts that might interfere with a specific computation.

Interrupt handlers in the avrX system are reentrant to avoid missing ticks. However, reentrance comes with unavoidable costs, including increased average latency for later parts of the handler and practical difficulty in ensuring proper functioning when used recursively.

The paper also discusses the creation of a plugin for CIL that converts a TinyOS application into a POSIX threads program, which is then checked for race conditions using Locksmith. Additionally, it addresses the need for a principled way to reason about heterogeneous concurrency models, as various kinds of locks exist to protect against different subsets of concurrency abstractions.

In conclusion, the paper underscores the importance of understanding interrupts and their semantics in designing and verifying interrupt-driven systems. It also emphasizes the need for advanced methods to detect and prevent bugs in interrupt-driven systems beyond race conditions.