Peercheck offers a novel approach to symbolic execution, employing a lightweight library-based method to conduct symbolic execution on object-oriented languages without requiring modifications to the analyzed code. Unlike traditional symbolic execution engines, Peercheck builds symbolic semantics as an external library that runs in conjunction with the target program. In this approach, the specific features of the Python programming language enable the implementation of symbolic values using class objects. However, the initial approach is restricted to symbolic execution on primitive types. This paper introduces an extension that allows for symbolic execution with user-defined class objects. Additionally, a new verification tool called pef is developed, which implements the described technique and extension, and is utilized for verifying programs written in Python. The tool is developed in Python and is built on top of the Z3 SMT solver. The paper also presents the evaluation of the tool by testing well-known algorithms and data structures.

To address the limitations of existing approaches, Peercheck introduces a novel peer architecture, where the symbolic execution engine operates alongside the program. This architecture takes advantage of the capabilities provided by dynamic and pure object-oriented languages, allowing for dynamic dispatch of primitive operators such as arithmetic operators, array accesses, and conditional branch tests.

Despite criticisms directed at the peer architecture for its limitation to programs implemented with primitive types, this paper demonstrates the feasibility of extending Peercheck to handle user-defined class objects. The extension opens up new possibilities for effortlessly building verification tools, constrained only by the capabilities of automated provers like SMT solvers.

The paper further presents the technique applied to Python programs, highlighting the need for thorough testing of Python programs due to the lack of static type checking in the language. Moreover, the methodology developed in this work can be applied to other object-oriented programming languages.

The rest of the paper is organized into sections that provide an overview of the symbolic execution technique, describe the pef architecture and its subsystems, present the implemented contract system, showcase the application of the tool to verify its own code, demonstrate the results of applying the tool to well-known algorithms and data structures, discuss related work, and present the conclusions and implications of the research.

Overall, the paper introduces a novel approach to symbolic execution, extends the capabilities of the Peercheck tool, and demonstrates its utility through the development of the pef verification tool for Python programs. It also highlights the potential for future improvements and applications, such as the implementation of symbolic global variables.