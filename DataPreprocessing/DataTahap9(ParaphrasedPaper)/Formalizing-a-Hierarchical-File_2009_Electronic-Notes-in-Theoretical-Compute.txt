In this note, we present the concept of an abstract file system as a partial function mapping absolute paths to data. This file system determines the valid paths and allows reading and writing at these paths, as well as executing Unix operations for removal (rm), creation of directories (mkdir), and moving (mv). We establish axioms for these operations.

We refine this specification towards a pointer implementation in two steps to address the issues associated with partial functions. Initially, we refine towards a pointer implementation with total functions, followed by a refinement that allows partial functions. We verify the correctness of these refinements through a set of invariants, particularly focusing on the invariants needed for the pointer implementation.

Formal verification employs mathematical techniques to ensure functional correctness of designs, regardless of their level of abstraction. The approach helps to identify and eliminate design errors that could lead to complications in later stages.

We formalize the fundamental aspects of a hierarchical file system, such as reading, writing, deleting, creating, and moving files, in a top-down manner, starting from a user's perspective without knowledge of the implementation. This is further refined to include directories holding subdirectories.

During formalization, the issue of partial functions arises. In the first refinement step, we address this by requiring the functions to be total. In the second refinement step, we acknowledge the partial nature of our functions, which is crucial for addressing potential unallocated pointers in the implementation.

We utilize the proof assistant PVS for formalization and verification of the refinement relations, and the PVS proof script containing our definitions, theorems, and proofs is available. Our notation is partly based on PVS syntax, supplemented with concepts from Haskell and standard mathematical notations.

We address the problem of unreachable nodes in the tree and how garbage collection minimizes these nodes in a total store. We provide proofs for the preservation of invariants by operations such as write, delete, create, move, and garbage collection.

In a theorem prover like PVS, working with partial functions presents technical challenges that are essential to address at the theoretical level, as they correspond to implementation issues with unallocated pointers.

We also narrow the focus to permissions for executing, reading, and writing, ensuring that users can only access and modify data according to the granted permissions. The details of how these permissions are represented in the data are not explicitly discussed, as our focus is on specification and verification.

Due to space constraints, the definitions of write, create, and move at this level are omitted. We prove refinement theorems for the user-adapted functions of this level using the invariants j 0,â€¦, j 3, and all the details are provided in the PVS proof script.

Finally, we demonstrate with PVS that the refinement function from the implemented store to the total store also respects the user-adapted versions of read, write, ls, create, delete, and move. The details of the proof are available in the proof script for this work.

Throughout this work, a total of 204 lemmas were proved with the proof assistant PVS, indicating its efficiency compared to other approaches. The details of the PVS proof can be found in the proof script for this work.