The process of testing is a method used to verify and identify any faulty behaviors in a system, either during its development phase or after the final version has been released. It remains one of the most practical methodologies for ensuring the expected behavior of software, especially in the face of increasing system complexity. However, the challenge of reducing its cost and time consumption remains significant due to strong industrial demand.

The rest of the paper is structured as follows: Section 2 provides an explanation of the underlying theory of j-post, while Section 3 describes the toolchain itself. In Section 4, an experiment conducted with j-post on a travel agency application is detailed, and Section 5 presents conclusions and perspectives stemming from this work.

The formulas of logic L are built upon a finite set of n-ary operators (denoted as fn) and a finite set of predicates {p1, p2,..., pn}. The abstract syntax of this logic is defined as follows: formula::= fn(formula1, formula2,..., formulan)| pi.

Test controllers (denoted as tf n) are associated with each n-ary operator fn of the logic L. Their purpose is to control the execution of the test process associated with each of their operands using basic signals (start, stop, loop) and to collect their verdicts, ultimately producing a resulting verdict corresponding to this instance of operator fn. Controllers for several logics can be found in the research reports provided.

The test designer of j-post serves as a user assistant that aids in developing formal requirements and corresponding test modules through dedicated editors available within the Eclipse Modeling Framework. Each test module is stored in an XML file, which represents their internal representation in j-post. Furthermore, the test designer provides a tool (based on Graphviz) for visualizing the test modules in a more understandable manner, thereby avoiding error-prone manipulations of XML files by the user.

The first stage involves constructing a communication tree obtained from the abstract syntax tree of the formula. This tree depicts the communication architecture between the test processes that will be produced by the test generator. Its leaves are abstract test modules (ATMs) corresponding to the atomic predicates of the formula, sourced from the library. Its internal nodes are (copies of) generic test controllers, corresponding to the logical operators appearing in the formula and obtained from a finite set of generic controllers provided by the logic plugin. Finally, the root of this tree is a special test process called the testcaselauncher, which initiates the test execution and delivers the resulting verdict.