The nature of isolated software components makes it inherently impossible to conduct model checking due to the absence of a complete program with an explicit starting point. To address this challenge, it becomes necessary to construct an environment for the component, which is the target of the model checking process. Our approach introduces an automated method for environment generation based on behavior protocols, which, to the best of our understanding, is the sole environment generator specifically designed for model checking of software components. We compare this method with the approach employed by the bandera environment generator tool, which is designed for model checking sets of Java classes.

State space size is a significant obstacle in the formal verification of software systems, particularly in the context of model checking. One potential solution to this challenge is the partitioning of a software system into smaller, well-defined units or components.

The subsequent sections of this paper are organized as follows: Section 2 provides a practical example to illustrate the issue of environment generation, while Section 3 introduces the bandera environment generator (BEG). Section 4 offers an overview of behavior protocols and presents our approach to the specification and generation of environments based on behavior protocols. Section 5 compares the two approaches and briefly discusses our proof of concept implementation. The remaining sections cover related work and a conclusion.

Creating an environment manually is a complex and laborious task, even in straightforward cases. One possible solution to this problem is the automated generation of the environment from a higher-level abstraction than that provided by the code. In Sections 3 and 4, we present two solutions based on this principle.

The bandera environment generator (BEG) consists of several modules, including the model extractor, model translator, environment generator, and model checker. The tool originally supported the spin and Java Pathfinder model checkers, but it is currently intended primarily for a bandera-specific model checker named Bogor.

BEG provides an automated method for generating environments for Java classes. When using the BEG tool, the user must decompose a complete Java program into two parts—the tested unit (i.e., the classes to be tested) and its environment. Since the environment component is typically too complex for model checking purposes, it is necessary to create an abstract environment, which can be generated from a model created.

The BEG tool also allows for the specification of parameter values for method calls on the tested classes. If the value of a parameter is not specified, it is non-deterministically selected from all available values of the given type during model checking. It is even possible to use a variable defined in the instantiations section as a parameter for a method call.

Behavior protocols include several operators such as the sequence operator (;), repetition operator (*), and or-parallel operator (||). They also support alternative operator (+) and and-parallel operator (|). The or-parallel operator is effectively a shortcut; for instance, a || b stands for a + b + (a | b). The | operator denotes all possible interleavings of traces corresponding to its operands.

Each component has a frame protocol associated with it, and a composite component can also have an architecture protocol. The frame protocol describes the external behavior of a component and can only contain events on the component's external interfaces. The architecture protocol describes the behavior of a component in terms of the composition of its subcomponents at the first level of nesting.

When checking a component application specified via ADL with behavior protocols, it is necessary to verify compositional compliance of subcomponents at the first level of nesting and compliance of a frame protocol with an architecture protocol for each composite component. For each primitive component, it is essential to verify that an implementation of the component conforms to its frame protocol. These verifications are carried out using the protocol checker developed in our research group and a tool created in cooperation with the Java Pathfinder (JPF) to check compliance of protocols.

Our environment generator accepts all syntactically valid frame protocols with the exception of protocols of the form ?a+!b and !a*;?b. The reason for not supporting frame protocols of the form ?a+!b is that the environment, driven by inversion of such a protocol, cannot determine how long it should wait for the !b event to occur before emitting a call that corresponds to the ?a event and thus disables the other alternative (!b). Protocols of the form !a*;?b are not supported for a similar reason—the environment cannot determine when the repetition !a* is going to finish. It is recommended to use protocols of a different form.

Our approach to specifying the possible values of method parameters involves the user defining the set of values to be considered as parameters. These sets are implemented as a special Java class serving as a container for all the sets of values. Later, the value of a method parameter of a certain type is non-deterministically selected from the set of values considered for that type and method. It is also possible to define sets of values that are specific to a particular method or interface.

Furthermore, there are tools designed to automatically generate environments for fragments of procedural programs, such as drivers and libraries. One example is the SLAM model checker, which is part of the Static Driver Verifier (SDV) tool for verifying device drivers in the Windows operating system. The SLAM tool creates a boolean abstraction of the program and uses the principle of refinement to verify if desired temporal properties hold for the abstraction. The environment for device drivers is defined by the interfaces provided by the Windows kernel.

Our tool for environment generation is partially based on a tool described in a thesis designed for the bandera tool set, which also employs the idea of the inverted frame protocol and is focused on components compliant with the Fractal component model. However, we decided not to use this tool mainly because it increases the size of the state space significantly and does not employ the transformations described in Section 4.3, nor does it provide a means for specifying method parameter values—making it almost impractical for practical use.