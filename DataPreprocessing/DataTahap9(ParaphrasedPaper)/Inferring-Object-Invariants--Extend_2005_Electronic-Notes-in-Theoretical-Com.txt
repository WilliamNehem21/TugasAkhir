The issues with classes b and c mentioned above persist even when there are no problems related to aliasing. The examples demonstrate that our analysis must simultaneously keep track of the state of multiple objects (such as this.x, b.x in b.m, and c.x in c.m). This complexity arises because there is no limit on the number of different objects, and all of these assumptions were introduced in the boogie methodology for object invariants. These assumptions are utilized in the object-oriented spec# programming language. It's important to note that the pack and unpack statements may not necessarily be explicitly provided by the programmer; they could be implied by rules in the source language or by rules in a stylized use of the language (e.g., unpack on method entry and pack on method exit).

Our proposed technique for inferring object invariants involves two complementary analyses. The first analysis, known as the local analysis, proceeds flow-sensitively and infers properties of the program at each program point, determining properties of local variables and heap locations reachable from the local variables. The second analysis, the global analysis, proceeds flow-insensitively and infers properties of all valid classes. 

In this section, we outline our technique for inferring object invariants using the abstract interpretation-based framework discussed in the previous section. This framework is parameterized by various traditional abstract domains, determining the type of invariants inferred about objects. To simplify the discussion, we focus on a single abstract domain known as the policy abstract domain, providing a flexible mechanism for inferring object invariants and leaving the choice of policy and the precision of the analysis to the user.

Let p represent the given policy domain. Building upon our previous work, we can extend the policy domain to infer properties about heap structures using the framework. The abstract domain given by this extension is denoted as c(p, s), where s indicates the presence of the abstract domain that handles the heap succession predicate for heap updates.

Inferring properties of object-oriented programs presents several challenges, including aliasing of objects and the context of other objects. Various pointer analyses have been developed to address these issues, which can be used alongside languages in the presence of aliasing and a context of other objects. Lahiri's recent PhD thesis considers inferring quantifications whose bodies are boolean combinations of predicates p(k), where k is the quantified variable and p comes from some fixed set of predicate symbols. This technique also involves a join operation to weaken the body of the quantifier by new facts inferred in a flow-sensitive manner.