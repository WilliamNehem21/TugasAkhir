We have examined the issue of collateral evolution in the context of Linux device drivers. Currently, collateral evolutions in Linux are primarily conducted manually using a text editor, sometimes with the aid of tools like grep. However, given the large number of Linux drivers, this approach is time-consuming and error-prone, leading to subtle errors when modifications are not consistently applied.

In our prior research, we have identified collateral evolution as a phenomenon where an evolution affecting the interface of a generic library necessitates modifications, known as collateral evolutions, in all library clients. We have specifically studied this phenomenon in the context of Linux device drivers.

In this paper, we introduce a declarative transformation language called SMPL (Semantic Patch Language) to precisely and succinctly express collateral evolutions of Linux device drivers. Since Linux programmers are familiar with exchanging, reading, and manipulating patch files that document previously made changes, we have based the syntax of SMPL on the patch file notation. Unlike traditional patches, which record changes at specific sites in specific files, SMPL can describe generic transformations that apply to multiple collateral evolution sites. These transformations are defined in terms of control-flow graphs rather than abstract syntax trees, and hence follow not the syntax of the C code but its semantics. Consequently, we refer to the transformation rules expressed using SMPL as semantic patches.

The remaining sections of this paper are organized as follows. Section 2 describes a set of collateral evolutions that serve as our running example. Section 3 illustrates how one of these collateral evolutions is expressed using standard patch notation.

The collateral evolutions in the proc info functions were prompted by the decision that it is undesirable for drivers to directly use the functions `scsi_host_get()` and `scsi_host_put()` to obtain access to a representation of the device, as any incorrect use of these functions can compromise the integrity of associated reference counts. To address this, starting in Linux 2.5.71, these functions were no longer exported by the SCSI driver support library. To compensate for this change, the proc info functions were then passed a representation of the device as an extra argument, and an existing parameter that was used as the argument of `scsi_host_get` was also removed. These collateral evolutions affect 19 SCSI driver files in 4 different directories within the Linux source tree.

While a patch file is typically applied to a file that is identical to the one used by the Linux developer to create it, it is possible to instruct the patch tool to ignore line numbers or some lines of context to apply a patch to a similar but not identical file. However, this approach is error-prone due to a lack of semantic analysis of either the meaning of the patch or the affected source code. Moreover, in practice, patches are often fragile, and variations in the source code may render parts of the patch inapplicable.

To express collateral evolutions, we propose a new language, SMPL, as a means of extending patches to semantic patches. A semantic patch is a specification that visually resembles a patch but applies based on the semantics of the code to be transformed, rather than its syntax. The complete language is defined in the appendix. Here, we present SMPL through an example, a semantic patch expressing the collateral evolutions described in Section 2. We develop the semantic patch incrementally, illustrating successive excerpts that each demonstrate a feature of SMPL. Unlike a patch that applies to only one file, a semantic patch can be applied to all files in the Linux source tree, selected files, an individual file, or even files outside the Linux source tree.

As we have shown in the previous rules, the proc info function's parameters may vary from one driver to another in practice. To make the rule insensitive to the choice of names, we replace the explicit names with metavariables. These metavariables are declared before each transformation and match terms in the original source program. The rule is then expanded to contain both a parameter and a local variable declaration, allowing us to express a naming strategy by using the same metavariable in both cases.

The collateral evolution described in this section introduced some bugs in the Linux 2.5.71 version. For example, in two files, the `hostno` parameter was not dropped, resulting in a function that expected too many arguments. This issue was resolved in Linux 2.6.0, which was released six months later.

The design of SMPL was influenced by various sources, including the world of Linux device drivers, the structured search and replace facility of the IntelliJ IDEA development environment, and the work of De Volder on jQuery that uses Prolog logic variables in a system for browsing source code. Additionally, we were inspired to base the semantics of SMPL on control-flow graphs rather than abstract syntax trees by the work of Lacey and De Moor on formally specifying compiler optimizations.

In conclusion, SMPL is a language based on the familiar patch syntax used by Linux developers but allows transformations to be expressed in a more general form. Moreover, SMPL addresses all elements of the taxonomy of collateral evolutions in Linux device drivers identified in our previous work.