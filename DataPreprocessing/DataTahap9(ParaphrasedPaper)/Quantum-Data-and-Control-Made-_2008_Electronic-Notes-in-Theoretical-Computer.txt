The convenience of use of quantum programming languages like NQML comes with certain trade-offs, such as the need to address practical challenges like imperfect quantum hardware, quantum error correction, and the necessity to approximate some unitary transformations. Similar issues were a concern for classical programming models in the past, but those problems have since been resolved and abstracted from modern high-level programming languages. The paper suggests that the same approach should be adopted for quantum programming languages, with these issues being addressed by the architect of the quantum computer, the designer of its operating system, and to some extent, the compiler designer.

The paper is organized as follows: Section 2 discusses related work, Section 3 describes the syntax and semantics of NQML, and Section 4 provides examples. Section 5 discusses the extension of NQML with polyifm, which performs quantum branching based on the result of a measurement on a qubit.

The paper also covers the semantics of the let construct, product introduction and elimination, if statements, and conditional measurements. Additionally, it presents examples of NQML programs and discusses the use of macros for parametric expressions. Furthermore, it outlines plans for extending NQML with a polymorphic type system to support higher-order functions. The paper suggests that it may be feasible to extend NQML with polymorphic higher-order recursive functions, as proposed by Selinger and Valiron. The type system presented here sets the groundwork for such an extension.