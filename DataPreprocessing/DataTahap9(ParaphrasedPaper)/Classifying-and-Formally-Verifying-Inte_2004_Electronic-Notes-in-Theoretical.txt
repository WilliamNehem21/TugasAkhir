Constant folding is a well-known compiler optimization technique that involves evaluating constant expressions at compile time. However, for constant folding to be valid, the results obtained by the compiler must match those that would be produced at run-time by the target machine arithmetic. This paper presents a classification of different arithmetics and derives a general condition for replacing target-machine arithmetic with compiler arithmetic. In particular, the paper explores integer arithmetics as a special case, which can be described by residue class arithmetics forming a lattice. The paper establishes a criterion for determining when constant folding can be performed in a residue class arithmetic different from that of the target machine. The proofs are formalized in the Isabelle/HOL system, and the paper provides examples discussing the validity of constant folding for Java and C integer arithmetics, while also highlighting potential issues with C compilers.

To underscore the importance of compiler arithmetic, the paper recounts a humorous anecdote about a major city bank in the UK in 1994. The bank discovered that all their Pentium processors, as well as other machines, exhibited the Pentium bug after compiling a test program. The compiler's constant folding had computed the expression intended to reveal the bug at compile time, leading to erroneous results being hardwired into the translated machine program. This story emphasizes the critical need for the arithmetic of the compiler to match that of the target machine to ensure the optimized program behaves as intended.

The paper introduces a general framework for the substitutability relation between arithmetics, with a focus on integer arithmetics, resulting in an efficiently decidable criterion for determining substitutability between different integer arithmetics. Additionally, it discusses the notion of arithmetics and substitutability, particularly in the context of constant expressions.

The paper also addresses the verifix project in Germany, which aims to construct correct compilers and has made progress in establishing the feasibility of building provably correct compilers within the standard framework. However, the paper points out that existing approaches to constructing correct compilers, such as proof-carrying code and verification of compiler optimizations, do not specifically tackle the problem of different arithmetics in programming languages and their compilers, nor do they establish a general substitutability criterion between different arithmetics.