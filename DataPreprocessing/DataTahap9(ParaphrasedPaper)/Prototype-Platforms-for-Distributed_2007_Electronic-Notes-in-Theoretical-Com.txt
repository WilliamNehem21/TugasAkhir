In this research paper, we focus on a typical situation within mobile ad-hoc networks (MANETs), where agent mobility exists alongside dynamic infrastructures and network topology. MANETs are characteristic of wireless environments for small mobile units and their associated infrastructures, such as emergency teams, medical teams, security units, press and information groups, hi-tech research, and business meetings, where numerous local agents are involved, including laptops, PDAs, and last-generation mobile phones. As a case study, we examine a rescue unit consisting of a central base and multiple teams, each led by a leader and comprising several operators. The basic premise is that after exchanging a series of messages, each team member can either confirm their commitment to the assigned task or terminate the negotiation if the designated activity cannot be completed. Importantly, team members often possess limited knowledge about other participants in the task, only being familiar with those individuals they have interacted with through message exchanges.

The components, consisting of Jocaml and Perl code, are structured into three layers. The bottom layer contains the distributed transaction manager written in Jocaml, while the other two layers (GUI and coordinators) are written in Perl due to its simplicity for prototype development. Components written in Polyphonic C adhere to the object-oriented paradigm, with instances of the class D2PC responsible for executing the commit protocol.

At the application level, programs are responsible for managing the involved parties and initiating the agreement protocol. The execution of the commit protocol is shielded from the application level (and consequently, from team members), and is handled either by the lower Jocaml and Perl layers or by the class D2PC in Polyphonic C. This abstraction separates the application level from the coordination of the agreement, making the negotiation mechanism reusable for developing new applications.

Following the exchange of messages, all operators have unanimously confirmed their participation. In this scenario, the leader (L1) selects two operators, provides them with detailed instructions for carrying out the activity, communicates the decision to the excluded operator, informs the base about the successful assignment of the activity, and finalizes the negotiation.

Upon exchanging messages as part of an agreement, a user will then make a commit or abort vote after a finite amount of time. If a user votes to abort, the entire agreement is terminated, and the graphical interface immediately reflects this status. Furthermore, all remaining users in the agreement are informed about the abort after casting their votes.

At the application level, when a user sends a message to another user, both the sender and the receiver update their synchronization sets with the other participant's identity, thereby including both participants in the same negotiation. Messages at the application level follow a specific format.

The D2PC algorithm processes all information about the commit protocol locally, while messages to and from other nodes are managed and forwarded by the coordinator layer. Although the communication between components could be integrated into the D2PC algorithm, these two functionalities are kept separate to ensure that the D2PC algorithm remains independent of the communication model used by parties. For example, components could utilize UDP sockets instead of TCP sockets by simply modifying the middle layer.

Jocaml, an extension of Objective Caml (OCaml), provides abstractions for processes, channels, and join-patterns. Channels in Jocaml correspond to join names, and there are two types: synchronous and asynchronous. The syntax for defining channels involves the commitment of all applications: first, User1 presses the commit button, followed by User2 and then User3, in a specified order. Following the local initiation of the protocol, each application sends a 'put' message to the manager, which includes the list of contacted parties during the GUI phase. The 'lock' messages are then sent by the managers according to the D2PC algorithm. Once the execution of the D2PC concludes, every manager will inform its application layer of the final decision.

Parties have also been implemented in the object-oriented language Polyphonic C#. This language extends C# with asynchronous methods (declared with the keyword 'async') and synchronization patterns called chords (defined by the keyword 'when'). A call to an asynchronous method is guaranteed to complete almost immediately, as the caller never blocks. A chord is defined by a header (set of method declarations) and a body, and the body is executed only once all the methods in the header have been called.

The User Interface class handles interactions with users, while instances of D2PC execute the commit protocol. The communication between classes within a component is achieved through method invocation rather than socket communication.

In Jocaml and Polyphonic C implementations, the manager starts the commit protocol voting for abort only when it receives the abort vote from the associated user, instead of autonomously initiating the commit protocol with a vote commit. This modification does not compromise the correctness and completeness of the D2PC protocol, as long as every participant in the agreement votes after a finite amount of time.

Neither Jocaml nor Polyphonic C provide mechanisms for non-linear pattern matching, although an extension of the join calculus with linear pattern matching has been proposed. In our implementation, we impose all notifications to be sent before accepting a vote from a manager, which satisfies all the properties of the protocol. This is achieved by using an auxiliary port to avoid non-linear pattern matching.