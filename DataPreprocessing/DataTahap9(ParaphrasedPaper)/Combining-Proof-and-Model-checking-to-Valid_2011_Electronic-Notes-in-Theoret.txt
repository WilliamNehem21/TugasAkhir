The rest of the paper is structured as follows. Following an illustrative example in section 2, the paper introduces the b method and its associated tools in section 3. The authors formally define a generic b model of component architectures in section 4, which is then applied to validate a specific architecture in section 5. Section 6 introduces ftpl for automatically verifying temporal properties and discusses its translation into LTL. The paper concludes in section 7 before exploring related work.

The b method is a formal software development approach used for modeling systems and reasoning about their development process. When creating a b model, the aim is to express system properties that always hold true after each evolution step, which is specified by b operations. The verification of model correctness involves confirming the preservation of these properties after each system evolution.

Tool supports, such as b4free or atelierb 3, automatically generate proof obligations (POs) to ensure consistency in the context of b. Some POs are straightforward, while others may need to be proven interactively if not fully automated by the embedded provers in atelierb. Another tool, prob 4, enables users to animate b specifications for debugging and testing. On the verification side, prob contains a constraint-based checker and an LTL bounded model-checker with specific features to identify various errors in b specifications [18,19].

The add(subcomponent, composite) operation must ensure that both components are instantiated, and that composite is a composite component (i.e., a component without parameters). Additionally, subcomponent must not be a sub-component of another composite, nor already in use—none of its interfaces can be bound or delegated—and the modification should not introduce a cycle into the parent.

The unbinding primitive operation is specified as follows: the precondition for this operation is that the interface in question is provided by an instantiated component, and this provider must be inactive. Furthermore, a required interface bound with the specified interface must exist, after which the specified interface is removed from binding.

The FTPL property presented in Example 1 has been translated into the LTL formula provided below. This formula was partially checked with prob in 126 milliseconds. The model checker generated 2002 atoms and 16064 transitions, with a maximum of 1000 new states.

In a fractal-based framework, previous work has defined integrity constraints on a graph-based representation of fractals to specify the reliability of component-based systems. In contrast, the model presented in this paper outlines only general architectural constraints, thereby offering operational semantics to other component-based systems. On the integrity constraints side, the FTPL logic allows for specifying more complex architectural constraints than architectural invariants.

To ensure software robustness while incorporating adaptive behavior, another study proposes a formal framework for the fractal component model, named fracl. Similar to the b-based proposal in this paper, the fracl static approach enables verification of application architecture consistency. However, the proposed model in this paper facilitates automatic checks for consistency and monitoring of temporal properties.