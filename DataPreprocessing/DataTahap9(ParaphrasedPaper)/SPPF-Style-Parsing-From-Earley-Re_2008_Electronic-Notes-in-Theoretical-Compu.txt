A grammar serves not only to outline the syntax of a language, but also as the foundation for establishing its semantics. However, the grammar that supports semantic definition may not always conform to the lr(1) standard. This is exemplified by the evolution of the Java standard. The initial version of the Java language specification emphasized the necessity to adjust the grammar, used to define both syntax and semantics, to make it lalr(1) for compiler generation purposes. In the third iteration of the standard, the compiler version of the grammar was articulated using the Extended Backus-Naur Form (EBNF) and, albeit unnecessarily, was ambiguous.


The paper outlines an algorithm for converting the recognizer described therein into a parser, yet, as currently articulated, this algorithm produces spurious derivations in addition to correct ones. Furthermore, the recognizer detailed in the paper is not suitable for grammars with hidden left recursion, whereas the closely linked riglr algorithm is fully comprehensive, functioning as a recognizer at worst case cubic order. Although a corresponding parser version aptly constructs SPPFs (Shared Packed Parse Forests) of tomita-style, the parser operates at an unbounded polynomial order.


The structure described above can be traversed in a similar manner as outlined in the preceding example. However, to form a binarized SPPF, additional nodes must be introduced for grammar rules with lengths longer than two, rendering the final algorithm marginally more intricate.


In a binarized SPPF, each non-packed node has at most O(n) packed node children, and there are at most O(n^3) packed nodes. Non-packed nodes act as the source of at most O(n) edges, while packed nodes generate at most two edges, resulting in at most O(n^3) edges in a binarized SPPF.