This paper begins by providing background information on two application areas (section 3), focusing on routing algorithms and highlighting the modular nature of the language as well as the importance of parallelism and functional complexity. The target architecture is briefly outlined to allow for a more comprehensive introduction of the language (section 4) and a detailed discussion of the compilation process (section 5). The paper demonstrates the use of a unification-based method to extract specific functionalities for hardware building blocks in the rule-evaluation engine. The compiler is required to detect functionalities spread across multiple rules in the user program to maintain hardware independence.

In the context of routing in parallel computer networks, Summerville et al. propose an architecture for a bit-pattern-associative router and describe their routing algorithms in a pseudo-language similar to the basic pattern used in Reral. The proposed routing engine employs a pattern-matching circuit array similar to a ternary content addressable memory (CAM) and can perform only simple routing algorithms without a significant increase in association circuitry, as it lacks dedicated arithmetic circuits or other specialized components.

Routing algorithms typically address several independent aspects. Two crucial aspects, deadlock and livelock avoidance, ensure the finite transport of messages to their destinations. Deadlock results in prolonged waiting times due to cyclic interdependence between routers, while livelock occurs when messages continuously circulate without reaching their targets. Livelock avoidance involves knowledge of network topology, particularly the routers' ability to determine a path to the destination for a given router address. Additionally, routing algorithms include local scheduling to resolve resource conflicts, and considerations for avoiding overloaded and broken routers or links. The language and its application in defining routing algorithms are described, with rules forming the central building block. Rules are executed in parallel, and conditions are evaluated with respect to the global state, with commands altering the global state also in parallel. 

The paper explains that the declaration of a subbase in the language predefines a function returning a value to its caller, improving readability. Rule bases are described as a form of case distinction, expressed through predicate logic expressions. The compilation process and the resulting implementation of the rule-based hardware specification are resource-intensive, with memory size and logic gates constraining the number and complexity of processable rules. Utilizing functions that conserve resources can enable the implementation of more rules by the routing engine. However, the unification-based optimization used has a high mismatch ratio due to the commutativity of certain functions, necessitating the sorting of operands by length to reduce mismatches.