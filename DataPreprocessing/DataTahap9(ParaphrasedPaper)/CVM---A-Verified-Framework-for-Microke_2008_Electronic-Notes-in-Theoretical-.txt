Initially, the daunting task of creating a small and reliable kernel may seem unattainable due to the extensive size of operating system implementations. For instance, the Linux 2.6.0 kernel, released in late 2003, contained nearly 6 million lines of code. Nonetheless, the concept of a compact and dependable kernel is not novel and has prompted the development of so-called 2nd generation microkernels like L4. These microkernels possess fundamental yet adequate functionality, allowing them to be relatively compact. For example, they can be utilized as a trusted platform to support the operation of two operating systems, with one serving critical applications while the other handles conventional tasks.

In the context of the Cross Verification Method (CVM), devices are employed in two primary ways. Firstly, the page fault handler described in section 5.3 uses a hard disk as a swap device. Secondly, a selection of typical devices accessible to user processes through specialized kernel calls are supported, including hard disks for memory virtualization and timers for scheduling.

For the purpose of achieving memory virtualization, the Virtual Address Memory Protection (VAMP) operates in two modes: user mode and system mode. In user mode, all addresses are virtual and necessitate translation before accessing memory, while in system mode, physical addresses can be utilized without translation. In this scenario, the microkernel operates in system mode, while user processes operate in user mode.

The transition function is contingent on the special purpose register mode, where mode= 0 represents system mode and mode= 1 represents user mode. In system mode, the transition function is straightforwardly defined by the instruction to which cphys.dpc points. In contrast, in user mode, memory accesses undergo address translation, either resulting in a page fault or being redirected to the translated physical address pma(cphys, va) for a given virtual address va.

Additionally, when implementing the abstract kernel, it is necessary to incorporate functions that are not initially visible in the abstract kernel, such as cvmdispatch, as well as add certain extra global variables that are not required in the abstract kernel.

Moreover, a mapping of addresses to content, denoted by sm: nz, is established. Apart from the architecturally defined physical memory address pma(cphys, va), a software swap memory address function, sma(cphys, va), is maintained by the page fault handler, mapping virtual addresses to addresses in cdevs(1).sm.

Transforming the abstract kernel into the concrete kernel involves simulating the former using the latter. As the concrete kernel is a c0 program and cannot be directly executed on the hardware, it relies on compiler correctness, necessitating a simulation relation between c0 machines and physical machines.

The concrete kernel is coded in c0 with inline assembler portions, and the translated object code is executed on the hardware. Thus, it is imperative to establish a formal definition of what constitutes a correct translation of c0. In this context, the Verisoft project uses the Verisoft simple non-optimizing c0 compiler and the consistency relation it provides, although alternative approaches such as translation validation are also viable and have been successfully applied in other projects.

Future work encompasses the verification of additional cvm primitives, particularly those related to device operations. The handling of devices in block mode, such as reading and writing large chunks with a single kernel call, presents significant challenges, including managing interrupts that may occur during such accesses.

The new hypervisor project in Verisoft XT addresses even more unexplored research issues. This project involves a multi-threaded virtualization layer, the hypervisor, running on a multi-processor architecture with a weak memory model and compiled using a highly optimizing compiler. Given the substantial differences in design and complexity of this endeavor, it seems unrealistic to anticipate the reuse of components from CVM. Nonetheless, the experience and knowledge gained by the individuals involved in this work are expected to be valuable.