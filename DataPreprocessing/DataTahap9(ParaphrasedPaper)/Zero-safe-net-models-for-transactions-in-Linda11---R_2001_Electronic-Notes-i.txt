The components of the set "fn" are referred to as arcs, and the notation "x fn y" is used to represent the tuple (x, y) belonging to fn. We will denote sn[ tn as simply "n" and will omit subscripts when there is no potential for confusion. The pre- and postsets of an element x in n, denoted as pre(x) and post(x) respectively, are defined as the sets of elements y such that y f x and x f y, where f is the given function. It is assumed that t is not equal to the empty set for all t in T.

It is helpful to consider the function f as f:(s t)[(t s)! f0; 1g, where f(x, y) 6= 0, and similarly, for petri nets, we can represent both f and w as the multiset relation f:(s t)[(t s)! n. For any transition t in T, pre(t) and post(t) are defined as multisets over s, where pre(t)(a) = f(a, t) and post(t)(a) = f(t, a) for all a in s. The notation t: u! v denotes a transition t with pre(t) equal to u and post(t) equal to v.

The paper also discusses the identification of the concurrent kernel of a behavior, which represents a minimal set of events that form a valid proof of concurrent behavior and cannot be further decomposed. When these conditions are met, the concurrent kernel of the behavior is identified, and all steps can be generated from it. The abstract net can be defined according to either the collective or the individual token philosophy, resulting in the same step relation but different abstract nets.

Finally, the paper introduces five predicates for handling message passing: (1) the output of a message "out(a)"; (2) the reading of a message without consuming it "rd(a)"; (3) the fetching of a message "in(a)" after which the message is no longer available in the tuple space. Additionally, two more predicates, rdp(a) and inp(a), enable (4) checking for the presence of a message without consuming it and (5) atomically testing and consuming the message if it is present. These predicates can be utilized as the boolean component of conditional constructs.