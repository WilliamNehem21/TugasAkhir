We present a formal proof of completeness for the dpll proof system and derive a dpll satisfiability solver from it. The resulting program, when applied to a propositional formula in conjunctive normal form, yields either a satisfying assignment or a dpll derivation demonstrating unsatisfiability. To enhance performance, we use non-computational quantifiers to eliminate redundant computational content from the extracted program. This formalization is conducted within the minlog system.

Program extraction involves generating formally verified programs from constructive proofs. Early work on program extraction was carried out in the nuprl system, while examples of program extraction in minlog can be found in [5,3]. Other interactive theorem provers supporting program extraction include coq, based on the calculus of inductive constructions, and isabelle, a generic theorem prover with logic-specific extensions [22,21]. Recently, there has been a focus on interactive theorem provers based on dependent types, such as agda [pm80].

In the realm of isabelle, considerable efforts have been made in verifying and integrating various decision procedures into the system. The formalization of the dpll algorithm was achieved and the automatic theorem prover metis was formally verified within isabelle, enabling the reconstruction of proofs from faster external procedures used in sledgehammer.

In the context of both coq and isabelle, formalizing a dpll sat-solver involves explicitly specifying the algorithm for verification. In contrast, our approach involves proving a theorem asserting that each formula in conjunctive normal form is either unsatisfiable or has a model, and then synthesizing the program from the proof. Our ultimate goal is to integrate automatic verification techniques into minlog, and the extraction of a sat-solver in minlog represents a step towards this objective.

The program extraction procedure takes into account different quantifiers by excluding any information related to the quantified variable in the non-computational case. Strict variable conditions are imposed on the proof rules for the non-computational quantifiers, ensuring that the omitted information is unnecessary in the extracted program. Minlog can automatically identify the maximum set of quantifier occurrences in a proof that can be made non-computational without compromising proof correctness.

To apply the solver practically, it is necessary to translate the extracted minlog term into a functional programming language such as scheme or haskell. While a translation mechanism from minlog into scheme currently exists, it does not extract inductive definitions and general recursion. We aim to extend this translation to encompass these definitions. Having our dpll solver as a haskell program would allow us to explore how lazy evaluation impacts performance.