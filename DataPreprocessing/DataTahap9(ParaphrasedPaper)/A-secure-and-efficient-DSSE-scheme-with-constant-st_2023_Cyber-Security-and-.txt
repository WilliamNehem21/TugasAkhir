Building upon the concept of rc-ii, we present a framework with limited privacy in forward updates and strong security in backward operations. The implementation of both strong and weak forward update privacy ensures that updated data remains separate from the index in the cloud service provider (CSP), even during subsequent searches. To achieve a balanced trade-off between security and performance, our framework prioritizes poor forward update privacy. Furthermore, our scheme is capable of mitigating replay attacks.

To execute an update operation, the update token acts as the update data, and both the file and its corresponding update token are transmitted to the server. The CSP utilizes the update token to update the index in the cloud, thereby completing the update operation. A formal description of the algorithm is provided below.

Dynamic searchable symmetric encryption (DSSE) typically includes seven algorithms (setup, keygen, enc, srchtokengen, search, uptokengen, update) and involves two main entities: the data owner and the CSP. The data owner sends encrypted data and an index to the CSP. When the owner wishes to retrieve documents containing a specific keyword, a search token containing the keyword information is sent to the CSP. The CSP uses the search token to navigate the index and return the search results matching the keyword. In the event of data updates, the owner generates the index for the updated data.

In our index structure, we have designed the search control node to enable user control over retrieval operations. During the search phase, the user has the option to retrieve only the most recently updated chain, ensuring weak forward update privacy. For backward security, a symmetric encryption algorithm with proven security is employed. By symmetrically encrypting the identifier information during the update phase, we guarantee that the index will not disclose any information even if it is compromised.

To detect malicious behavior within the system, we utilize set hash in our protocol. Specifically, the detection of malicious behavior from device and service peers relies on the metadata they upload on the chain, while monitoring malicious behavior in the CSP relies on the validation data stored in the service peer. We posit that if the set hash we employ is sufficiently secure, the likelihood of an adversary evading detection is negligible. Our scheme can operate correctly, and even in the presence of malicious behavior, we can detect it and take appropriate action.

To demonstrate the viability of our scheme for smart devices, we evaluate its performance and highlight its advantages compared to other schemes. The experiments are conducted in Python 3, employing HMAC for the pseudo-random function and SHA-256 for the set hash function. The symmetric encryption scheme used for encrypting identifiers is AES. The experiments are conducted on a computer with an Intel(R) Core(TM) i5-10210U processor and 8GB of RAM running on Windows 11. We aim to establish the reliability of our scheme applied to smart devices in terms of storage cost, computation cost, and communication cost.

In our experiments, we set the number of sub-keywords to 1, resulting in heavier local storage overhead in practical scenarios. While some previous schemes have proposed structures to decrease local storage costs to a constant, they face limitations concerning the maximum number of updates. Additionally, clients need to allocate more computing resources under their protocol (which will be elaborated in section 8.3).

Sai Ji received his BS degree from Nanjing University of Information Science and Technology (NUIST), Nanjing, China, in 1999, and his MS degree from Nanjing Aeronautics and Astronautics University (NUAA), Nanjing, China, in 2006. He is currently serving as an associate professor at NUIST, specializing in computer measurement and control, structural health monitoring, and wireless sensor networks (WSNs). He has authored more than 20 journal/conference papers and is a principal investigator of three NSF projects.