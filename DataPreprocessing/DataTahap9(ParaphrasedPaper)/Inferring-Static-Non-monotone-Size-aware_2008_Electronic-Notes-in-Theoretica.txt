To investigate the dependency on size, the method proposes hypotheses for increasing degrees of polynomials. For each degree, a polynomial is defined by a finite number of points. Drawing on interpolation theory, this paper establishes an upper bound on the number of test runs and an optimal selection of test data to ensure the identification of all polynomials representing the sizes of output lists. Subsequently, the resulting hypothesis is validated using an existing type checking procedure.

The procedure is not restricted to the current size-aware type checker. The size-aware type of a function is inferred if it exists and is validated by a size-aware type checker. For terminating functions, our size-aware type inference procedure is comprehensive in terms of type checking: if a function is well-typed, then the inference procedure concludes and yields corresponding size dependencies.

In this paper, we concentrate on the automation of deriving precise output-on-input size dependencies of function definitions in a program. The rationale behind precision will be elucidated later in this section, while a potential relaxation of this precision is contemplated in section 5.

Several examples are considered. The function 'progression' appends all tails of an argument list. For instance, given the list [1, 2, 3], it produces the list [3, 2, 3, 1, 2, 3]. Consequently, the size of the output list corresponds to the sum of all integers from 0 to the size of the input list (arithmetic progression).

The function 'cprod' computes the cartesian product of two lists. It generates pairs of elements, with one element taken from the first list and the other from the second. Defining 'cprod' necessitates an auxiliary function 'pairs'. The function 'sqdiff' returns the cartesian product of an argument with itself if another argument is empty. If both arguments are non-empty, it recursively calls itself on their tails.

We have recently developed a size-aware type checking algorithm to formally verify polynomially size-aware types (see section 2). Given a size-aware type, the algorithm automatically verifies if the function definition satisfies that type. However, inferring such types is considerably more challenging than type checking, and the type system approach does not straightforwardly extend (see section 2.3). Therefore, an alternative method of inferring size-aware types has been proposed in this paper.

By combining hypothesis generation and type checking, a procedure is presented that can infer the size-aware type of a function (see section 4). The procedure generates hypotheses for increasing degrees and determines hypotheses for all polynomial size expressions in the output type for each degree. The resulting size-aware type is then checked using the size-aware type checking procedure, thus enabling a comprehensive approach to size-aware type inference for shapely functions based on reducing inference to size-aware type checking.

The zero-order types considered include integers, strictly sized lists of integers, and strictly sized lists of strictly sized lists, among others. A strict list of length "n" is defined as a list precisely of length "n" (not of some length up to "n", as seen in other sized types). For lists of lists, the element lists must be of the same size, and it would be more accurate to refer to them as matrix-like structures.

As usual, "q" denotes the set of all rational numbers. Size expressions considered in this context include polynomials with rational coefficients, although not necessarily integers. Only those polynomials that map non-negative integers into non-negative integers have a semantic meaning in the type system (see section 3). An example of a size expression with non-integer coefficients is the polynomial for the 'progression' function mentioned earlier.

The formal rules are designed conventionally for ML-like syntax. It is important to note that the empty list [] is denoted by 'nil', a list "x:xs" is represented as 'cons(x, xs)', and pattern matching and case-expressions are presented as a match-construct. For illustrative purposes, examples are provided in a Haskell-like syntax.

We have formulated a syntactical condition that is sufficient to make type checking decidable for this system. Pattern matching and case expressions are only permitted for function parameters and variables bound to them by other pattern matchings and case expressions. For example, 'cprod' and 'sqdiff' satisfy this condition, since only program arguments are matched. Case expressions on tails (of tails of...) of function arguments are also allowed.

The type checking procedure outlined in section 2 and the size hypothesis generation outlined in section 3 are combined into an inference procedure for increasing degrees of polynomials. This procedure is semi-decidable, as it only terminates when the function is well-typable in the type system of the type checker used. In this sense, the procedure is comprehensive with respect to a type-checker: if a function definition is well-typed, the type will be determined.

Based on the results of section 3, a theoretical maximum on the number of tests is defined. Let "m" be the maximum among {m1,...,mk}. The theoretical maximum is the upper bound (1 + km)n. In practice, the number of tests needed to define all the output polynomials for a given function is often much closer to the theoretical lower bound defined by m+n, which is the number of coefficients of the polynomial with n variables and degree m.

Another potential source of non-termination is the iteration over increasing degrees of polynomials. If none of the generated types is accepted by the checker, either because the function definition is not shapely or due to incompleteness, the procedure may not stop in principle. However, in practice, an upper bound can often be placed on the degree because only size expressions of low degree are desired.

The current hypothesis generation procedure is contingent on the restriction to shapely programs, where output sizes need to be precisely polynomial in the input size. However, in practice, many programs are not shapely, but still have a polynomial upper bound. For example, consider inserting an element into a set, which increases the set size by one only if the element was not in it. The actual upper bound in this case could be determined.

To extend our approach to such upper bounds, we are exploring program transformations that convert an unshapely function into a shapely function with the strict size dependency corresponding to an upper bound of the size dependency of the original function. For instance, the 'insert' function would be transformed into a shapely function that always inserts the element. We believe that in many practical cases, the testing approach combined with program transformations will be successful in providing good upper bounds.

We have developed a procedure (and a demonstrator for it) to infer static nonmonotone size-aware types by interpolating data from run-time tests. The dynamically generated types are only accepted after validation by a formal type checking algorithm. As a result, the types are static, and the size expressions hold for every possible future run of the program.