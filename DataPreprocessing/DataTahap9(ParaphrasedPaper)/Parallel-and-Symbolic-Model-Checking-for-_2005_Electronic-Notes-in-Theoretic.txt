This paper focuses on the model checking problem for the modal fixpoint logic known as FLC, which can define nonregular properties. The paper introduces enhancements to a symbolic model checker and discusses the parallelization of this algorithm. It presents a prototype implementation of the algorithm in Glasgow Parallel Haskell (GPH) and evaluates its performance on a workstation cluster.

Currently, model checking for (temporal) logics is widely recognized as a crucial method in verification. However, the state space explosion problem poses a significant limitation to the efficacy of model checking for verification. To address this issue, symbolic methods are employed, which operate directly on process descriptions and typically achieve superior performance.

The GPH implementation models a virtual shared heap, enabling program variables to be accessed as if they were located on the same processor. The runtime system facilitates automatic data transfer between processors when necessary. This virtual shared heap allows for the development of architecture-independent programs capable of harnessing a large number of processors, in contrast to physical shared memory machines, which are often limited to a few dozen processors due to hardware constraints.

An essential language feature for this application is the Foreign Function Interface (FFI) provided in Haskell, which enables the utilization of existing, optimized C code for basic Binary Decision Diagram (BDD) operations. However, since the BDD library used manages its own heap, interaction between the Haskell heap and the C heap is essential. On the Haskell side, a BDD is represented as a foreign object, constructed outside the Haskell heap, using a pointer to the C heap and a finalizer routine executed when it is no longer in use from the Haskell heap.

A significant advantage of the parallelism employed is its coarse granularity, transforming the entire test set generation into a parallel thread. This parallelism involves producer-consumer (or pipeline) parallelism, where the producer and consumer work in parallel on the same data structure. Furthermore, it could be combined with the extensive divide-and-conquer parallelism in version PMC1. Additionally, the test set itself could be computed in parallel, as there are a finite number of functions for which the closure of a set of BDDs needs to be computed.

An important objective in designing the parallel algorithm is to achieve scalability, ensuring that a larger number of processors than those currently utilized can be harnessed without requiring changes to the code. However, this property necessitates more data transfer between heaps than is strictly necessary. An implementation using laziness to avoid these operations unless parallelism is definitively required could improve single-processor performance but is challenging to implement. Embedding an explicit order of evaluation into the code is the primary reason for its complexity, despite an otherwise simple model of parallelism. Therefore, the authors are working on an approach that extends the structure of a foreign object with a marshalling function, automatically triggered as part of the graph packing algorithm used by the runtime system to transfer computations between processors. This approach ensures that data transfer between heaps is only performed when required for parallel execution, eliminating this complexity from the parallel GPH code.