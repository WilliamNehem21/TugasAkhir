As indicated in previous studies [29,31], similar to separation logic, matching logic can serve as a program logic within the framework of conventional axiomatic semantics, allowing for the easier specification of structural properties concerning the program state. However, this usage of matching logic comes with a significant drawback, which is also inherent in hoare logics in general: it necessitates the redefinition of the formal semantics of the target language axiomatically, as well as the arduous task of conducting soundness proofs. In contrast, we adopt an alternative approach as outlined in prior works [28,27,26], which enables us to utilize the operational semantics of the language for program verification.

This section delves into the utilization of the "k" system in the context of program verification. It begins by providing a brief overview of the programming language used for illustration in Section 4.1, followed by an explanation of how the "k" system can be employed for symbolic execution in Section 4.2. Section 4.3 demonstrates the application of the "k" system in checking the implication of matching logic formulae, while Section 4.4 introduces abstraction patterns.

The patterns can be reformulated using rules from both "s" and "c"; however, the verifier exclusively employs the rules from "c." Specifically, only a loop devoid of a specification is unrolled, and a function lacking a specification is the only one that is called. Furthermore, if the current pattern implies that the application of an abstraction axiom would lead to a more specific pattern, the tool applies the corresponding axiom. For instance, knowledge that the head of a linked list is not null results in automatic list unrolling.

Regarding tree data structures, for each function, the tool ensures that it upholds the data structure invariant and that the multiset of elements conforms to expectations. It is worth noting that the AVL insert and delete programs collectively require approximately 3 minutes to execute because some of the auxiliary functions, such as "balance," do not have specifications and therefore their bodies are executed, leading to a larger number of paths to analyze.

The Schorr-Waite algorithm, which is utilized for graph marking and is particularly challenging for verification [17,21], computes all nodes in a graph that are reachable from a set of initial nodes by performing a depth-first search and reversing and then restoring pointers. We analyzed both the original algorithm and a simplified version in which the graph is essentially a tree, and for both cases, we established that a node is marked if and only if it is reachable from the initial nodes, and that the set of nodes remains unchanged.

Shape analysis enables the examination and verification of properties pertaining to heap structures and has proven to be effective when reasoning about heaps. The concepts of shape analysis have also been integrated with those of separation logic to swiftly infer invariants for programs operating on lists. It is probable that they can also be merged with matching logic to infer patterns.

In this paper, we have introduced MatchC, a matching logic verifier for a deterministic fragment of C based on the "k" framework. We have outlined the implementation details of the key components of the verifier and have justified their soundness based on the matching logic reachability proof system. Furthermore, we have assessed MatchC using a wide array of programs, including some that pose significant challenges from a verification perspective.