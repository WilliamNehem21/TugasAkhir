Linear Statechart Languages (LSCs) provide a means to differentiate between potential and mandatory behaviors, as well as to express prohibited behavior, which are known as anti-scenarios. Since their initial introduction, LSCs have evolved to incorporate additional features such as time, symbolic instances, and classes. This paper focuses on the fundamental aspects of LSCs, including assignments, conditions, subcharts, and forbidden elements, and does not delve into the specifics of these additional features. A comprehensive description of LSCs and their (partial) implementation in a tool called the Play Engine can be found elsewhere.

In LSCs, synchronization can be achieved through various means. Precharts and main charts serve as default synchronization points, where all instances enter the prechart simultaneously, and the main chart can only be entered once all instances have successfully completed their activities in the prechart. Similarly, the beginning and end of a subchart act as synchronization points for all participating instances, allowing for entry into the subchart only when all relevant instances have arrived at its initial location, and exit only once these instances have completed their activities or when a condition within the subchart evaluates to false.

In the context of LSCs, there exists no partial order between events and conditions in the chart body. When an instance reaches a condition and it evaluates to true, the instance can progress beyond the condition. LSCs enable the synchronization of the progress of one or multiple objects with the evaluation of a condition, ensuring that none of the synchronized instances may progress beyond the condition until all of them reach it and it is effectively evaluated.

LSCs allow for the definition of anti-scenarios, representing scenarios that the system should not execute. This is accomplished through universal charts, where the forbidden scenario is specified in the prechart, and the main chart exclusively consists of the hot condition false. If the forbidden scenario is executed, the main chart is activated, and the hot condition is evaluated. As the hot condition is guaranteed to fail, it leads to a violation.

Furthermore, LSCs involve the communication of messages between instances, conveying information with the expectation that subsequent actions will occur. These messages are depicted as horizontal arrows from the lifeline of one instance to another, specifying the nature of communication between instances, as well as the sender and receiver event occurrences associated with it.

It should be noted that the preceding description may be incomplete and ambiguous. For instance, it is unclear whether multiple guard expressions in an alt operator evaluating to true should be possible, and if so, how to determine or enforce the execution of a particular operand in such a scenario. Additionally, when using a neg operator, it is unclear when a trace becomes invalid (negative), although it could be expected that a prefix of the negative trace remains valid and therefore positive.

In previous versions of UML, there was no way to express that a specific scenario should not occur at any time. However, a new operator called neg was introduced in UML 2.0 for this purpose. To model an anti-scenario in LSCs, it can simply be placed inside an interaction fragment within the scope of a neg.

The provided diagram illustrates an interaction between a user and three system instances, highlighting the sequences of events and constraints governing their execution. Notably, the usage of message expressions in OCL 2.0 in the context of operational semantics and their role within an AE template is discussed. Similarly, considerations related to liveness constraints in certain cases are addressed with respect to the lifeline of a specific instance.

In summary, the paper outlines the fundamental principles and functionalities of Linear Statechart Languages, addressing synchronization, message communication, anti-scenarios, and various constraints and scenarios governing the behavior of system instances within the context of LSCs.