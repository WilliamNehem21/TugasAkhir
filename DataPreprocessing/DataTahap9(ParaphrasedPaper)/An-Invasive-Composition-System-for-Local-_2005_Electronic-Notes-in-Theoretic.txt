Transformation systems are well-suited for implementing modular rules that convert language features from a source language into one or a combination of features in a target language. However, in practice, writing transformation rules to convert a single source language feature into multiple target language features at different locations in the output program is complex and tightly interconnected, which imposes significant constraints on maintenance and evolvability. This paper presents four main coupling problems in current-day implementations and proposes an extension of the rewrite rule system to address these problems. The extension enables the elimination and reduction of these coupling issues and introduces abstract, reusable algorithms and mechanisms to enable a semi-automatic process for implementing local-to-global transformations.

The paper discusses the complexity and tangling associated with implementing local-to-global transformations solely through rewrite rules and explains that existing extensions of transformation systems to the rewrite rule paradigm with data acquisition techniques have not effectively reduced the tangling. The paper then delves into the fundamental problem that leads to tangled rewrite rules and introduces a solution architecture in detail. It evaluates the architecture and discusses its implications before considering related work and concluding.

The paper emphasizes the importance of minimizing tangling and coupling within an implementation to facilitate evolution and maintenance. It highlights the challenges of tight coupling between secondary traversals and rewrite rules and the outcome of primary rewrite rules, as well as the scheduling problems of secondary traversals and rewrite rules to avoid violating context conditions. The paper details a strategy to address these issues, including the use of nonlocal nodes with custom relocation paths and the execution of relocation processes driven by the grammatical rules and custom semantics of the target language. Additionally, the paper discusses mechanisms for integrating non-local statements into the target language and presents rules for combination and correspondence between nodes in the abstract syntax tree. 

The paper outlines the benefits of the proposed solution, such as the decoupling and disentangling of the implementation, which facilitates maintenance and evolution by localizing the impact of changes to specific modules. However, it also acknowledges limitations, such as the limited scope of automatic relocation and the incremental nature of the integration process, and discusses ongoing experiments to validate the proposed approach.

In conclusion, the paper argues that the proposed solution architecture addresses the complexity and tangled nature of implementing local-to-global transformations, resulting in a more maintainable and evolvable system. By utilizing modular and simple rewrite rules, as well as reusable integration, correspondence, and combination rules, the proposed approach significantly reduces the implementation effort and positively impacts maintainability and future evolvability.