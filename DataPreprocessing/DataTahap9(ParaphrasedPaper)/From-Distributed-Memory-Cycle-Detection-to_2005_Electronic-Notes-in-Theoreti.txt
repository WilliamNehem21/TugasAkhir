In this scholarly article, we introduced a parallel graph algorithm designed to identify cycles in large directed graphs distributed across a network of workstations. The algorithm utilizes back-level edges computed through breadth-first search. Our paper outlines the process of transforming the algorithm into a distributed memory LTL model checker, which includes the detection of accepting cycles, generation of counterexamples, and partial order reduction. We elaborate on these extensions and present experimental findings.

The remainder of the paper is structured as follows. We begin by revisiting the main concepts of the graph algorithm in the subsequent section. The subsequent sections address accepting cycle detection, counterexample generation, and partial order reduction, respectively. Furthermore, we summarize the experimental assessment of the algorithm in a separate section.

A distributed graph refers to a graph whose vertices are divided into disjoint sets corresponding to participating workstations. A partition function is introduced to assign each vertex to a workstation, with that workstation taking ownership of the vertex. The distributed computation is initiated and terminated by one of the involved workstations, referred to as the manager.

The graph is assumed to be implicitly given, with an initial vertex and a function that provides immediate successors for a given vertex. During the algorithm's computation, all generated graph vertices are stored on their respective workstations, thus maintaining each workstation's segment of the distributed graph. If exploration leads to a vertex owned by another workstation, a message containing the vertex is sent to the owning workstation, and local exploration of the vertex is skipped, with the destination workstation processing the vertex further.

Before delving into the algorithm's concept, we reiterate the definition of a back-level edge. Essentially, a back-level edge in the graph does not increase the distance from the initial vertex. We assume that all vertices in the given graph are reachable for simplicity's sake.

It is evident that for every cycle in the graph, there exists a maximal value, k, such that the cycle contains a vertex from level k. Furthermore, any edge on the cycle leading from a vertex in level k must be a back-level edge. Since all cycle vertices have a successor, it follows that each cycle in the graph contains at least one back-level edge.

The cycle detection algorithm functions as follows. It alternates between two procedures: a primary procedure and a nested procedure. The primary procedure seeks all back-level edges by gradually exploring the graph level by level, while the nested procedure tests each discovered back-level edge to determine if it is part of a cycle. The primary procedure is executed as a level-synchronized breadth-first search of the graph. Upon the completion of a level's exploration, nested procedures are initiated for all back-level edges emanating from a vertex on the current level (referred to as current back-level edges) to detect cycles. If at least one nested procedure succeeds, the presence of a cycle is confirmed, and the algorithm terminates. Otherwise, the primary procedure continues with the exploration of the next level. Each nested procedure searches for its target in a depth-first manner, without marking vertices as visited, and revisiting is allowed. Notably, the search space of nested procedures can be constrained to the vertices visited by the primary procedure.

The fundamental idea behind detecting accepting cycles in partially accepting components is to prevent the algorithm from identifying non-accepting cycles. To achieve this, each nested procedure maintains an additional bit to indicate whether it has passed through an accepting state since its last passage through a current back-level edge. This bit is set to true upon reaching an accepting state and set to false upon passing a current back-level edge, with an initial false setting.

We outline the approach to identify accepting cycles in partially accepting components by comparing scenarios where one nested procedure arrives at a state before another. Furthermore, we provide a detailed illustration of how the algorithm can correctly detect the existence of an accepting cycle.

The proof leverages the correctness of the distributed back-level edge detection algorithm presented earlier, in addition to considering several key facts. It is established that if an accepting cycle exists in the graph, at least one complete cycle is explored by a nested procedure because either all queues are emptied before the next level of the graph is processed, or the presence of an accepting cycle is reported. Additionally, it is asserted that no nested procedure can infinitely pass through a non-accepting cycle. We refer readers to the full version of the paper for a more comprehensive proof.

We also discuss generating short counterexamples as a feature of the model checking algorithms. Specifically, for each vertex v, the parent of v in the breadth-first search (BFS) and nested search is stored, denoted as par(v) and par-dfs(v), respectively. These values are used to traverse the BFS and nested parent graphs and enable the identification of short counterexamples.

Our algorithm's notable feature is its capacity to produce short counterexamples, owing to its reliance on breadth-first search exploration. We provide examples in the experiments section to illustrate this characteristic.

We generate a reduced state transition system using a modified algorithm that explores only a subset of transitions enabled at each encountered state, termed an ample set. Conditions are established to relate the generated full state transition system to its corresponding reduced version, ensuring that a state s is fully expanded when ample(s) equals enabled(s).

To employ partial order reduction within our distributed memory on-the-fly algorithm, we adopt a similar approach to that used in the model checker Spin, combining the construction of the state space with checks for satisfying the specification by exploring the product graph. The key condition of concern is the cycle condition C3BFS, which is verified with respect to cycles of the product. We confirm the effectiveness of this method through experimental results, demonstrating reductions in both space and time.

Our experiments show that the generated counterexamples are considerably shorter than those returned by the nested DFS algorithm, attributed to the breadth-first nature of the state space generation. However, the time required to find the counterexample is generally longer, with a greater number of states needing exploration. Emphasizing the importance of short counterexamples in facilitating debugging.