The issue of visibility is a significant challenge in computational geometry, with relevance to various subproblems such as finding the shortest path in a plane with obstacles and the hidden line elimination problem. Visibility is crucial in applications like video games and robotic motion planning. This paper aims to present an efficient parallel algorithm designed for modern parallel architectures, such as those found in current GPUs, focusing specifically on visibility from a point into a set of segments.

Previous work by Shoja and Ghodsi addressed the visibility problem on GPUs with a parallel algorithm that solves the point visibility problem on a simple polygon in O(log n) time using O(n) processors. In this paper, we extend this to solve the problem for a broader set of obstacles—non-intersecting segments—taking the same computational time, which is optimal for the visibility of line segments.

Our algorithm builds upon the technique provided by Atallah et al. for solving computational geometry problems using a divide and conquer paradigm for the CREWPRAM computational model. Additionally, we incorporate several visibility concepts from the work of Asano et al., where they developed a data structure to find a visibility graph in O(n^2).

Let "S" be a set of "n" arbitrarily oriented segments on the plane "P" that are allowed to intersect only at their endpoints, and let "Q" be an arbitrary query point. The visibility region "VS(Q)" is defined as the set of all points on "P" that are visible from "Q". A point "P" is visible from "Q" if the segment "PQ" does not properly intersect any of the segments in "S". Two segments are said to "properly intersect" if they share exactly one point, and this point lies in the interior of both segments.

Our proposed algorithm is based on the cascading divide and conquer technique, modeling the solution process as a binary tree, where each node represents a sorted list of some type. We simplify the problem by assuming that the segments have already been translated so that the query point is the origin and that collinear segments with the query point have been removed, as well as segments that cross the positive x-axis have been broken into two. We then explain how we can query in logarithmic time whether a point is inside the visibility region or not using the resulting data structure. The section ends with insights on how parallel merge works and how it can be used for the parallel version of the algorithm.

The time complexity of the visibility merge algorithm is the same as that of a regular merge, O(n), as the additional operations take constant time to compute. Similar to mergesort, in order to merge all the elements, we need to perform O(log n) passes, with each pass taking a total of O(n) time. This results in a final time complexity of O(n log n) to find the visibility region.

Given the similarity of this algorithm to mergesort, we use parallel merge to parallelize it. However, a challenge arises with parallel merge in that the workload is not evenly divided, and processors have a different amount of elements to merge. This is not efficient for GPU architectures due to synchronization issues. To address this, we employ GPU merge path, which divides the lists into sublists.

The CUDA programming model is used, invoking C functions on the GPU, called kernels, that are executed n times in parallel on n threads. Visibility regions are computed at two levels: first at a block level where the visibility region of the "nv" segments assigned to each block are independently computed using GPU merge path, and secondly at the level of all segments, where the visibility regions are merged by cooperating between blocks. Finally, the CUDA code is compiled with specific version and additional flags to target the Tesla K80 GPU.