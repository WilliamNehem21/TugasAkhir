We propose a model of handshake protocols using Petri nets, where these protocols enforce properties such as absence of transmission interference and insensitivity to delays in signal propagation. We introduce the concept of a "handshake Petri net," which is a Petri net with a specific external interface. We demonstrate that the set of observable quiescent traces generated by such a net captures the properties defining a handshake protocol, and conversely, for any handshake protocol, we can construct a corresponding net. Additionally, we examine different subclasses of the model and provide numerous examples.

The asynchronous style of computation involves subunits acting independently of each other, contrasting with the synchronous style where a central clock governs operations. When working with asynchronous systems, undesirable situations include transmission interference, which can happen when two consecutive messages clash on the same channel, and computation interference, where a message is sent to an unready receiver.

Given these challenges, we sought alternative models, considering the graphical representation as a natural choice for dealing with asynchronous circuits, as composition is straightforward when everything else works properly. Previous works have taken a similar perspective, and Dan Ghica developed a language for asynchronous hardware design inspired by the geometry of interaction and handshake circuits. However, his focus was on improving previous hardware design languages rather than capturing all handshake behaviors.

The model we present in this paper is based on Petri nets, which are widely used as models of asynchrony and are closely related to the context in which the handshake communication protocol originated. However, the specific properties of delay insensitivity and absence of transmission interference had not yet been formally represented graphically. We refer to our model as "handshake Petri nets" and demonstrate that they precisely capture the behavior of handshake protocols, in that the behavior of every net corresponds to a handshake language, and vice versa.

In the subsequent sections, we define the notion of a handshake language as a set of traces, introduce handshake Petri nets and some of their subclasses, and emphasize deterministic behaviors as well as nondeterministic behaviors that cannot be expressed as sums of deterministic components. Finally, we provide an interpretation of handshake Petri nets into handshake languages and demonstrate the correctness and completeness of this interpretation, with the completeness of deterministic handshake Petri nets with respect to deterministic handshake languages following as a corollary.

We assume basic knowledge of Petri nets, and throughout the paper, we consider unsafe nets, which allow places to contain multiple tokens simultaneously, as this is necessary for our construction. We also note that the nets we consider are generally not finite and may have infinitely many places and/or transitions.

Marked graphs are significant as they facilitate the identification of places with communication channels and allow the representation of all and only circuits that can be constructed from channel, synchronization, and fork operations. Additionally, they hold special historical significance for the handshake protocol, and we refer to a handshake Petri net that is also a marked graph as a "handshake marked graph."

While marked graphs express only deterministic behaviors, not all deterministic behaviors are captured by marked graphs, and as far as we know, no structural characterization of determinism in Petri nets exists in the literature. We propose a definition that completely characterizes determinism in the context of handshake nets.

Furthermore, the graphical representation may guide the development of a more standard notion of syntax, such as a process calculus. Van Berkel previously proposed the handshake process calculus, but their focus was not on capturing all possible handshake behaviors, and a complete process calculus of handshake circuits is still desired.

Future directions for research include conducting a deeper analysis of data exchange, as the current paper focuses primarily on data-less communications. Additionally, it would be interesting to explore subclasses that allow for finite representations of specific subsets of handshake languages, as briefly mentioned in Section 3.1.

Lastly, we provide a less significant, yet still useful, definition, wherein for a given handshake Petri net H, transitions t and t' are defined as complements of each other when they belong to the same port. We also establish that hl(H) is receptive, where handshake DB nets are unsafe and allow places to contain an unlimited number of tokens, such that every time an input transition is enabled to fire, it can. Furthermore, the enabling of an input transition depends only on the alternation with its complement output transition.