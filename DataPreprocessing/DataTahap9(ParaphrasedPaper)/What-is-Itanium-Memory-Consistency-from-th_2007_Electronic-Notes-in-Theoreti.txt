Several other frameworks have been proposed to describe memory consistency, but this paper does not focus on them. The framework developed by Adir, Attiya, and Shurek is similar to the one presented in this paper and predates it. Arvind and Maessem have also proposed a framework for serializable memory models, but the practical application of these frameworks is not known to us.

Itanium provides a distributed shared memory (DSM) architecture where each processor maintains a replicated copy of the shared address space. In this paper, the shared memory consists solely of shared variables, with instructions either loading or storing a shared variable. Loads are satisfied by retrieving the value from the local replica without any communication with other processors. However, stores are executed by updating the local replica and broadcasting the update to all other processors to be applied in their replicas. The channels between processors are not necessarily First-In-First-Out (FIFO) when multiple instructions are applied to different variables, leading to complex behaviors governed by rules that dictate processor execution and inter-processor interaction.

In our context, an instruction is considered complete upon invocation and receipt of a response. For store and fence instruction invocations, the response is an acknowledgment and is disregarded. For load invocations, the response is the value returned by the invocation. The computation of a multiprocessor system based on Itanium's architecture is explained.

The Itanium memory consistency model is defined at the architectural level without a reference architecture implementation. While this low-level specification is valuable for chip verification, it is not user-friendly for programmers and algorithm designers who typically reason about their programs at a higher level. This paper attempts, but falls short of, providing a programmer-centric description of the Itanium memory consistency model. Instead, it presents two similar definitions (stronger and weaker than Itanium) that bound the official lower-level specifications, differing in the implementation of load-acquires in the presence of write-buffers.

Although these definitions do not perfectly capture Itanium, they are still useful for programmers. For example, to prove that a problem cannot be solved with Itanium, it suffices to show that it is not solvable using the strong Itanium definition. To prove the correctness of an algorithm for Itanium, it suffices to demonstrate correctness under weak Itanium. However, these definitions do not replace a single programmer-centric description that accurately captures Itanium's behavior. This paper demonstrates that achieving this goal is a genuine challenge, and we hope that the techniques presented in this paper will help us to attain it.