In our efforts to address this issue, we found that reinterpreting the aforementioned diagram within the context of concrete categories yields numerous new insights. Firstly, it enables us to establish functional bisimulations in the concrete category of prefix orders with partial orders as the base category. Secondly, the natural choice for the subcategory \(p\) of paths turns out to be the subcategory of embeddings. Thirdly, the existence of cospans of these embedding-open maps coincides with branching bisimulation when the prefix orders are the sets of runs generated by a labelled transition system. Finally, this reinterpretation introduces a combination of syntax and semantics, in which we consider morphisms in the concrete (base) category as implementations (observations).

We tend to view the objects of \(m\) as concrete models of behavior and the objects of \(s\) as semantic models of behavior. A morphism \(a : f \to b\) of \(m\) represents a way of implementing the behavior of \(b\) (the specification) as the behavior of \(a\) (the implementation). On the semantic level, a morphism \(c : g \to d\) describes how the behavior of \(c\) can be observed as part of the behavior of \(d\).

In the context of embeddings, which were also referred to as extensions, we explored the possibility of using embeddings as the subcategory of path-extensions. Our conviction grew when we discovered the similarity between the definition of \(p\)-open maps and that of \(p\)-injective objects as defined in [source]. In particular, the observation that an object is an absolute retract if and only if it is an injective object in any category that has enough injective objects (see Proposition 9.10 in [source] for the original definitions) translated nicely to the setting of open maps as well.

It should be noted that in the case of transfinite executions, this definition also relates to zeno-points and other limit behavior, thereby generalizing the solution to a problem prevalent in the study of timed and hybrid systems [18,10]. Additionally, this definition slightly differs from the one in [source] in which zeno-choices were not explicitly considered yet. However, for executions of more common models of computations, such as labeled transition systems, they coincide.

There are other proposed definitions of functional bisimulation in the literature. It is also history-preserving, thus a morphism in \(pfx\), and taking \(b = \{0, 1\}\) and \(a = \{0\}\) gives us a commuting square of history-preserving maps. Nevertheless, no history-preserving diagonal \(k\) can exist for this square. The fact that there does exist an order-preserving \(k\) in this case led us to investigate the possibility of a concrete category-theoretic approach.

In the preceding section, we have established a way to define bisimulation through cospans categorically. What remains to be shown is that the embedding-open maps indeed give the desired notion of bisimulation. In order to do this, we consider prefix orders as a concrete category over the category of partial orders.

From a philosophical perspective, using a concrete category for behavioral models means that we are distinguishing implementations from observations in such a way that we assume all implementations to be observable. Interpreting the result in Theorem 3.4 along these lines, we see that \(x\) is bisimilar to \(y\) if any conceivable extension of \(x\) that implements additional behavior of \(y\) is already observable in \(x\) (although it may have been implemented differently). However, it depends on the concrete category which implementations are actually extensions, i.e., which are the embeddings that need to be preserved.

In the pursuit of a unified approach to modeling computations and other dynamic behavior, the next logical step seems to be to study split faithful functors over \(pfx\). This may provide insight into which embeddings are and are not to be taken into account. In a sense, we have already studied such a split in Section 5 by examining the runs of labeled transition systems rather than the transition systems themselves. However, a more general theory may be found here. For example, consider any category of syntactic computational models \(m\). We expect the executions of a model in this category to form a prefix order, meaning that implementations in \(m\) can be mapped to history-preserving maps in \(pfx\) and order-preserving maps in \(pos\). From a philosophical standpoint, the syntactic constructs of \(m\) are the actual implementations, and the order-preserving maps of \(pos\) would serve as observations. The definition of bisimulation for \(m\) would then come from open maps in the concrete category of \(m\) over \(pos\), but the expectation that this forgetful functor splits over \(pfx\) can be leveraged when studying bisimilarity of models in \(m\). Indeed, in such a split, there are fewer embeddings in \(m\) than there are in \(pfx\), so the notion of bisimulation can only have become weaker (there is less to preserve). This implies that two models in \(m\) are bisimilar whenever they are bisimilar in \(pfx\). The reverse does not necessarily hold, for example, because open maps in \(pfx\) check for zeno behavior, while there may not be any zeno-embeddings in \(m\).