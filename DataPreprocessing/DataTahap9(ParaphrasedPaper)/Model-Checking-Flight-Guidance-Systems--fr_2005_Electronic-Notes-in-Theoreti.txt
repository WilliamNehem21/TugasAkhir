However, the selection of an appropriate model checker has posed a longstanding challenge throughout the project. Comparative evaluations of various model checkers within the application domain are scarce, leading to decisions being based on anecdotal case studies. Despite the project's success, there remains a lingering uncertainty regarding whether alternative choices might have been more effective. In particular, the decision between symbolic and explicit model checking lacks clarity, with limited comparative arguments. Although it has been suggested that symbolic model checking is better suited for synchronous systems with hardware-like characteristics, and explicit model checking is preferable for asynchronous systems with multiple communicating processes, direct comparison of the two techniques is deemed very difficult, if not impossible. Some experiments even indicate that a symbolic model checker may outperform explicit model checking for asynchronous systems, contradicting some existing arguments.

Moreover, a system can exhibit both synchronous and asynchronous aspects depending on the specific context and how the system's behavior is interpreted. For example, the fgs system comprises two fgss, an active fgs and a passive fgs for back-up, operating in parallel. When considering the system's two communicating processes running concurrently, it is deemed an asynchronous system. Alternatively, when focusing solely on the mode logic of one-sided fgs, it can be viewed as a synchronous system with complex mode logic challenging the model checking technique. 

The rest of this paper is organized as follows: Section 2 reviews existing related work with a focus on comparing symbolic and explicit model checking techniques. Section 3 introduces our motivation with a brief overview of the existing work related to model checking flight guidance systems. Section 4 describes our direct and modular translations to the spin model alongside their performance data. We conclude with a discussion on the implications of the results in Section 5.

Eisner and Peled investigated the widely accepted argument that symbolic model checking is more suitable for hardware systems, while explicit model checking is better for software systems, in the context of verifying the software of a disk controller using the symbolic model checker rulebase and the explicit model checker Spin. Their findings demonstrate that the rulebase is capable of model checking a 2-process system with 10150 states, whereas Spin encounters limitations after checking 108 states with 2g of memory. This result challenges the notion that explicit model checking performs better for software verification, especially for communicating processes.

Regarding the use of macros, it should be noted that RSML-E provides macro and function constructs to enhance the readability of specifications. In the fgs specifications, macros are extensively employed as an alternative representation of synchronous events, offering a concise method for specifying system properties in temporal logic. The use of macros simplifies logic expression significantly, thereby enhancing the usability of model checking.

From our experiences, it becomes apparent that symbolic model checking can be potent and user-friendly, but only up to a certain extent. The technique relies on exhaustive state-space search and does not offer alternative options when it reaches its limitations. Conversely, explicit model checking typically provides greater flexibility in handling large state-spaces, sometimes prioritizing efficiency over exhaustiveness. Our hope is that the flexibility of explicit model checking may provide a certain level of verification capability even for larger systems that symbolic model checking cannot handle. To realize or refute this hope, we establish two goals for the investigation: the first is to explore the possibility of using the explicit model checker Spin for verifying fgss, and the second is to devise a systematic approach for translating RSML-E to the input language of Spin to enable full automation and improved usability, if the first goal proves achievable.

We commence with a translation of the RSML-E model of one-sided fgss with invariants into the input language of Spin, Promela. We hypothesize that Spin must be capable of handling the synchronous one-sided fgss in order to be scaled to the asynchronous two-sided fgss. Our initial attempt at a direct translation proves to be overly inefficient for model checking. In order to achieve improved performance, we adopt modularization and encapsulation by utilizing the Spin message passing mechanism and modifying macros to accommodate the structural change. The outcome of these changes is quite promising.

Input variables and message channels are declared as global variables in Promela, as they need to be accessible to both the fgs model and the environment model. Fgs state variables and their corresponding history variables are translated into local variables within the fgs process, and their transition relation is translated using the Promela if statement. User-defined enumeration types are translated to the Promela mtype. Macros are declared as C-style macros in Promela, and Spin performs pre-processing for C-style macros, thus, not introducing additional variables for macros.

However, there are a few Promela-specific issues that need to be navigated. Firstly, the environment of the system must be explicitly specified, necessitating the modeling of the possible values for all 13 input variables in a non-deterministic manner to simulate random inputs from the open environment. Secondly, in order to model the fgs with only one side, we also need to explicitly model the possible inputs from the other fgs with constraints. Fortunately, modeling pure non-deterministic input is relatively straightforward for boolean or enumeration variables, as Promela does not support imposing invariants on the model itself, enforcing constraints on the non-deterministic input values from the other side fgs can be quite challenging. One approach is to restrict the non-deterministic value assignment with constraints and verify that the constraints are satisfied by the model using the assertion statement or the LTL verifier.

Verification is conducted on an 800 MHz Linux machine with 768 MB of memory. We set the memory limitation to 600 MB in Spin. With the hash-compact option and compression, the verification process terminates using up 625 MB of actual memory after 24 minutes. The maximum search depth was set at 1,000,000, yet Spin reported the search depth as being too small. The situation is similar or worse with other Spin verification options. 

The primary source of the state-space explosion of the directly translated version of the fgs lies in the large number of global variables, particularly the input variables and their history variables, in addition to the numerous local state variables in the fgs process. Global variables, in particular, are resource-intensive in Spin verification, as Spin needs to track all their values in the state transition graph. To optimize performance, we explore systematic ways to minimize the number of variables, both global and local, as one of our goals in this investigation is to support a practical verification process, necessitating any modification of the original model for the purpose of optimization to be systematic and automatable in future work.

One potential approach to handling the usage of macros is to pre-process all the macros by replacing all the references to a macro in the specification with their value expression. However, as macros are specified by practitioners to match their languages used for communicating with pilots, and many of the properties (98 out of 298) to be verified are specified in terms of macro names, we prefer not to make changes unless absolutely necessary.

Our experiment indicates that Spin performs less effectively than NuSMV on the one-sided synchronous fgs model, although it scales better to the asynchronous two-sided fgss once we manage to handle the one-sided fgs. However, we do not intend to place emphasis on performance differences for two major reasons: the use of the bit-state hashing option can render the result from using Spin unsound, and performance can be highly dependent on the level of optimization performed by the modeler. We believe that our initial optimization approach serves as a starting point, and that vastly improved optimization is possible as we gain a better understanding of the model checker. We also do not dismiss the possibility of using NuSMV for the two-sided fgss through aggressive optimization and/or abstraction in the future.