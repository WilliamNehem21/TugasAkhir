Switching graphs, as an extension of ordinary graphs and a natural abstract domain for representing practical problems, were expected to be the subject of widespread study. However, it seems that this has not been the case. In a slightly different concept of switching graphs, switches are essentially omitted, which unifies nondeterminism with switches. Additionally, proof nets are proposed as structures closely resembling switching graphs, except that switches move in pairs. Other concepts in the literature, such as switch graphs, bidirected graphs, and skew-symmetric graphs, also deal with making choices while excluding other options, but they appear to be of a different nature than switching graphs.

As we found switching graphs to be inherently interesting as a natural abstract model for many problems, in section 5, we list several problems for which the complexity is unknown (at least to us). It should be noted that these are just a subset of the interesting questions surrounding switching graphs.

In this section, we examine the complexity of various problems on a fixed directed labeled switching graph (DLSG) G = (V, E, S, L). For many problems, there exist straightforward and efficient algorithms. Hence, we often only state the complexity and outline the algorithm without further elaboration.

Regarding the proof, a simple depth-first search suffices where both branches of each switch are treated as regular edges. When a path from vertex v to vertex w is found, no vertex, and thus no switch, occurs on this path more than once. The switch setting f is then adjusted accordingly, with those switches not on the path being able to be set arbitrarily.

For the subsequent proof, vertices are marked in a backward manner from vertex w in a breadth-first fashion. A vertex u is marked if an outgoing edge leads to a marked vertex, or if both branches of a switch with root u lead to marked vertices. This marking algorithm terminates in linear time. The switch setting is obtained by setting the switches such that they point to an unmarked vertex. Switches that point to vertices that are both marked or unmarked can be set arbitrarily.

Lemma 3.4 concerns two switches s and s'. If for all switch settings f with f(s) â‰  f(s') and l(f) = 1, then there are no switch settings g and h such that g(s) = g(s') = 0, h(s) = h(s') = 1, and l(g) = l(h) = 0. 

The parity loop problem is the question of whether a switch setting f exists such that all f-loops in G have an even number as the lowest label. This problem is very similar to the v-parity loop problem. Notably, no polynomial algorithm is known, and it is also not possible to synchronize switches in this setting.

The parity loop-through-v problem is the question of whether a switch setting f exists such that all f-loops through vertex v in G have an even number as the lowest label. This problem allows switches to be synchronized using a rather contrived construction, indicating that finding a polynomial algorithm for this problem is likely even more challenging than for the v-parity loop problem.

A simplification of the parity loop problem is the 1-2-loop problem, where the labels are restricted to the values 1 and 2. For this special case, we are able to provide a polynomial time algorithm. It is a weight improvement algorithm inspired by [8, 16].

In this section, we present reductions from the "bes" problem to the v-parity loop problem and vice versa. For the proofs, we need to be able to eliminate every disjunction from a bes in 2-CNF by selecting one of the disjuncts and eliminating the other one, resulting in a conjunctive "bes". This operation resembles obtaining the f-graph GF from a DLSG G and a switch setting f.