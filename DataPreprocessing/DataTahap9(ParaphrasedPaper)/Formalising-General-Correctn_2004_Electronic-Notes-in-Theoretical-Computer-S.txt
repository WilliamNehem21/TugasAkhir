Usually, a command or program is represented as a function that operates on the machine state. A deterministic command that is expected to terminate can be depicted as a function that simply provides a new machine state as output. On the other hand, a deterministic command that may or may not terminate can be modeled as a function that returns either a new state or nothing, representing the scenario where a non-terminating command yields no result. However, representing a nondeterministic program as a function that returns a set of new states does not allow us to capture non-termination as one of the potential outcomes.

The specific structure of a command does not contribute to defining its behavior, allowing us to demonstrate that two commands behave similarly without taking their structures into account. The work in this section is based on this premise. It should be noted that the results are contingent on the condition that two abstract commands are indeed distinct if their structures differ. We believe that the relevant proofs regarding command structures would be relatively straightforward.

Based on these definitions, we have established more direct characterizations of the three notions of refinement. It is worth noting that the characterization for general correctness is simpler than the other two, even though it is defined in terms of both of them. This explains why the general correctness semantics often appear simpler than either partial or total correctness semantics. Furthermore, the general correctness relation is anti-symmetric, unlike either total or partial correctness.

Moreover, the notation "f(x:=e)" in Isabelle denotes the function that resembles f except for the fact that its value at argument x is e. The first of these results links substitution for a variable in an expression to assignment to that variable in the state. The second result states that if two syntactic expressions have the same meaning, then making the same substitution in both of them yields expressions with the same meaning as well (credit to Dunne for highlighting the necessity of this result).

We are now prepared to define assignment and establish its properties. We define "assignv" and "assigne" for the assignment of a value and a (semantic) expression to a variable, respectively. We also define "assignvs" for the assignment of values to a set of variables.

For this purpose, we require somewhat different definitions of "@" and "a", involving a set of logical variables x', one for each program variable. Hence, we use a second state function "primed" which provides the values of these logical variables, and "a" will rely on both state functions.