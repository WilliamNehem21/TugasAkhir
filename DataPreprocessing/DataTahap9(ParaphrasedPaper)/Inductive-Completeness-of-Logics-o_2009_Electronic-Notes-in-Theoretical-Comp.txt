The denotational semantics of a regular program can be understood as a relation, which can be easily defined through structural induction on programs. By employing the framework of canonical theories for inductive definitions, we examine the first-order theory for program semantics, with generative clauses serving as construction rules and their dual templates as deconstruction rules.

This first-order approach is highly accessible conceptually, expositorily, and for the utilization of automated theorem proving tools. It also harmonizes well with the longstanding tradition of defining program semantics inductively. When an inductive definition is provided for a programming language, the corresponding first-order inductive-definition theory is automatically obtained, enabling the consideration of the completeness of a logic for that theory.

To narrow down the focus, we specifically consider guarded iterative programs, which are regular programs with tests and assignments as atomic actions. This allows for a clear separation of basic programming concepts. The language is generic in relation to an underlying vocabulary consisting of a finite set of constant, function, and relation identifiers, each assigned with positive arities as appropriate.

Standard methods for associating first-order inductive theories with a given set of inductive definitions are well-established. The semantics of regular programs are defined in a particularly simple form of inductive definition, utilizing atomic production rules, i.e., natural-deduction inferences with atomic premises and conclusions.

We denote the inductive theory by indn(reg), which is obtained from the universal closure of the aforementioned formulas. Two weaker theories are of interest: the elementary inductive-theory, ind0, which has restricted inductive-elimination to first-order eigen-formulas, and the generative theory, gen, which only includes inductive-introduction rules without inductive-elimination. Notably, gen is inherently a first-order theory, lacking templates intended to approximate a second-order rule.

A notable point of interest is that first-order proofs of t + ind0 obtained in the proof of theorem 2.1 do not utilize the generative (data introduction) rules of the inductive theory ind. A similar observation applies to total correctness assertions (theorem 3.1).

Relative completeness presents challenges not only for structures that lack expressiveness (for which inductive completeness is unproblematic) but also for programming languages with undecidable termination problems for finite structures. In contrast, providing inductive definitions to the semantics of such programs is straightforward, albeit requiring auxiliary constructs (e.g., stacks). Moreover, different forms of computational formulas correspond to different program constructs, and the second-order framework does not offer a universal solution for all constructs. The inductive framework examined here is therefore more appealing and generic: the programming construct directly guides the inductive definition, and once this is established, a match with a program logic is obtained.