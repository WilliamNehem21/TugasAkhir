A doris segment comprises a collection of nodes, categorized as slow or fast, linked by a shared medium. These segments may be interconnected through switches or routers, but the focus of this study is restricted to a single doris segment. Each node is equipped with a server responsible for transmitting hard real-time and best-effort messages. Slow nodes are limited to sending hard real-time messages, while fast nodes have the capability to transmit both hard real-time and best-effort messages. Servers at each node are tasked with managing a hard queue for storing hard real-time messages to be dispatched. In addition, fast servers are equipped with a soft queue for managing outgoing best-effort messages. It is important to note that although only one server is present in each node, the paper defines hardserv[i] and softserv[i] as the two server threads of node i handling the hard and soft queues, respectively. Local priority policies for scheduling messages from various applications are beyond the scope of this paper, which is solely focused on communication aspects.

The medium access control of doris hinges on an implicit token that traverses the hard and soft rings (section 2.1) based on timing and/or logical conditions derived from observed communication activities. A pure TDMA scheme is employed to segregate the two rings of doris. For the soft ring, the management of process group membership is dynamically handled through a mechanism whereby elementary messages contain a bit that, when set, signifies the sending server's participation in the soft ring. When the soft queue of a server undergoes a state transition, as defined by the action [v' = v + 1] in the given example, the next-state relation from state i to state f is determined by the set of actions defined at that step.

The field cons of hardstate[i] constitutes a tuple of flags tracking the elementary messages received by each server. Entry cons[j] is set to 1 when an elementary message sent by server j is received by server i or when server i= j sends its elementary message. In the event that an elementary message sent by j is missed by server i, the corresponding entry of tuple hardstate[i].cons[j] remains null, enabling the detection of failure. The action nexttick resets all values of cons[shared.chipcount] to 0.

When server i is not in norecvset(m), message m is received normally, and the fields of hardstate are updated accordingly. Message m is then appended to the msg list of incoming messages, and the associated timer executes with a setting that corresponds to the maximum processing time of m if it was not previously set. The entry m.id of cons is set to 1 to denote the successful reception of an elementary message, and the res field is updated in line with the res set piggybacked on m.

Deadlock prevention is automatically verified by TLC, while type invariance, basic properties, are specified elsewhere. This section focuses on relevant properties of the doris protocol, including its ability to provide communication isolation and avoid collisions.

Although the protocol specification offers insights for implementing doris, it was not directly applicable to the implementation process, given the complexity of the Linux-based real-time operating system on which doris was implemented. However, most protocol functions could be adapted from the specification to fit within the operating system infrastructure. As such, the task of implementing a specified protocol using an existing complex software, such as an operating system, requires a more automatic approach. The development of doris, along with its formal specification, can serve as a valuable case study for research in this area.