The increasing concurrency, timing, and distribution of modern software lead to non-deterministic behavior, presenting challenges for generating effective tests. In response to this, the paper proposes test generation methods that rely on fault modeling by mutation and utilize both closed and open model checkers. While test generation from deterministic specifications using verification techniques is well-established, the prevalence of non-determinism in modern systems introduces complexities that need to be addressed. The paper discusses how non-determinism arises from various factors such as asynchrony, concurrency, multithreading, and limitations of modeling languages, and proposes methods to tackle this issue. It also explores the problem of coping with non-determinism in protocol testing.

The paper establishes a connection between two types of testing and presents an approach to derive tests that combine specification coverage and fault propagation, with a focus on mutant-killing tests. It discusses the challenges of test generation for finite state machines (FSMs) and highlights the use of model checking technology to address the state explosion problem. The paper then provides necessary definitions for test, module, model checking, and module checking before delving into discussions on test generation from counterexamples, handling multiple mutants, and related work. It concludes by introducing the notion of a module, which is described as a Kripke structure with a partition of atomic propositions onto input, output, and internal elements, and explores the potential use of LTL or CTL model checking techniques for incremental test derivation.

The paper acknowledges the limitations of traditional model checking techniques for non-deterministic specifications and mutants, highlighting the expected exponential growth in computational effort and complexity. It also suggests the possibility of incremental test generation through consecutive verification of test candidates, but raises concerns about the efficient organization of memory consumption in this approach. Finally, the paper discusses the specific challenges in generating strong tests for multiple mutants and provides examples to illustrate the complexities involved.