Consider a prominent rule in hoare calculus used to prove the correctness of a recursive procedure 'p' with a given precondition 'P' and postcondition 'Q'. The rule assumes that for all recursive calls to 'p' within its body, the precondition 'P' and postcondition 'Q' hold, if 'p' always terminates.

The hoare calculus rule for procedures consists of two overlayed rules: one for the terminating case with a postcondition, and the other for the non-terminating case where the precondition holds at each procedure entry. This overlaying of rules is also evident in natural semantics.

Natural semantics is a deductive method for defining program semantics, using axioms and inference rules to specify semantic properties in relation to abstract syntax. The semantics of an abstract syntax tree is defined as a state transition from the initial state to the final state, which is compositionally defined in terms of the state transitions of the direct subtrees of the abstract syntax tree. The rules for the while-loop serve as an example of this compositional definition.

Traditional interpretations of natural semantics are based on finite derivation trees, resulting in a unique final state. This traditional view aligns with an inductive or least fixed point interpretation. However, we argue in this paper for the suitability of a greatest fixed point or coinductive interpretation, which accommodates a semantics for non-terminating programs while preserving the inductive semantics for terminating programs.

The coinductive definition principle, which works for both finite and infinite trees, allows for a possibly infinite marking process to be well-defined at each step, in contrast to the structural induction principle, which defines unique markings on finite trees.

Analogous to the proof of theorem 3.3, the proof of a statement can be conducted by contradiction, assuming the negation of the statement and reaching a contradiction. We illustrate how this works through a detailed example.

We demonstrate that each natural semantics defines an abstract data type and show that it is a specification in a given sense. Additionally, we prove that the least fixed point of such a specification describes the execution of all terminating programs, while the greatest fixed point defines a semantics for all non-terminating computations.

We note that there are cases in which no final state can be computed, giving rise to a "stuck computation." However, we do not delve into such situations in this present discussion.

We also discuss translating the natural semantics into a small-step format and using induction to reason about the resulting finite and infinite state transition sequences. However, we emphasize that induction is not the appropriate method for reasoning about the state transition behavior of programs, and highlight the distinction between inductive and coinductive reasoning.
