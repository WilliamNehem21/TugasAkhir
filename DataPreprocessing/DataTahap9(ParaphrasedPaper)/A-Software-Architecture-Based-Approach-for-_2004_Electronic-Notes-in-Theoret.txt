The quantity of open specifications for middleware systems and middleware services is on the rise. Despite their complexity, these specifications are typically conveyed using APIs (the operation signatures) and informal prose (the behavior). This approach often results in ambiguities and hinders a thorough understanding of the content. In this paper, we propose the utilization of software architecture principles to structure middleware and the LOTOS language to formalize their behavior. The application of software architecture principles makes the structural aspects of the middleware explicit, while formalization allows for the validation of the middleware's behavioral properties. To illustrate this approach, we present a LOTOS specification of the well-known object-oriented middleware CORBA and its transaction service. 

Our approach involves the use of software architecture principles to structure middleware systems and the adoption of LOTOS to specify the behavior of these software architectures. Initially, the middleware architecture is defined in terms of software architecture elements such as components and connectors. Subsequently, the LOTOS language is utilized as an Architecture Description Language (ADL) to formally describe the middleware behavior. It is important to note that we are not focusing on any specific middleware product or model.

Previous work has employed formal description techniques for specifying middleware within the Reference Model of Open Distributed Processing (RM-ODP), where the trader service is formally described in LOTOS. More recently, the Z notation and high-level Petri nets have been used for specifying CORBA services, such as the naming service, the event service, and the security service. However, these approaches do not integrate software architecture principles for structuring service descriptions. While some ADLs accommodate behavior description, such as Wright, there is a lack of tools to validate behavior properties. Additionally, despite observations of the convergence of middleware and software architecture principles by Medvidovic, a formal approach has not been adopted. Considering the widespread use of software architecture principles in building distributed applications, it is noteworthy that their benefits are seldom applied to the middleware that connects them.

The remainder of the paper is organized as follows: Section 2 outlines how the middleware architecture is defined in terms of software architecture elements. Section 3 presents the use of LOTOS for describing the middleware software architecture. In Section 4, we apply our approach to specify CORBA. Finally, the last section presents the conclusions and potential directions for future work.

When considering these guidelines, several points should be kept in mind. Firstly, since middleware systems do not perform application-specific computations, they are naturally modeled as connectors. Secondly, in addition to the communication service, middleware provides other services, indicating that it may not simply be considered as a connector. However, in the software architecture discipline, only components (and not connectors) are traditionally decomposed into smaller elements. Lastly, the communication service facilitates the interaction between other services (components) and applications, which sets it apart from other services and necessitates its modeling as a connector.

A LOTOS specification describes a system through a hierarchy of active components, or processes, which are entities capable of realizing non-observable internal actions and interacting with other processes through externally observable actions. Atomic interaction between processes is facilitated by events, which correspond to synchronous communication among processes that are able to interact with one another. Events are atomic, occurring instantaneously without consuming time, and take place at a point called a port. These events may or may not involve the exchange of values, and a process has a finite set of shareable ports.

In accordance with Section 2, the concrete software architecture of the middleware involves explicitly decomposing the middleware services into client and server parts. The client part represents the middleware service interface (remotely accessible), while the server part constitutes the service implementation. Notably, the communication service is a connector and is not designed using the client/server approach. Hence, the same communication services operate on both sides of the architecture. The top-level LOTOS specification of the concrete software architecture is presented.

CORBA is a widely adopted standard for implementing middleware products. In addition to the communication service, known as ORB, the CORBA specification indicates that fourteen distributed services should be provided by the middleware, including persistence, externalization, events, transactions, properties, concurrency, relationships, time, licensing, trader, query, collections, lifecycle, and security. While these services are not typically implemented in a single product, at least the naming, life cycle, and communication services are available in CORBA-compliant products.

As defined in Section 3.2, the LOTOS process "serviceordering" is not an architectural component but is defined to constrain the way the services interact. In this case, a key ordering constraint is related to the naming service (process naming), as every distributed service must be registered in the naming service before being used by clients.

According to the COS transaction specification, the transaction service is specified through six interfaces, namely "current," "transactionfactory," "terminator," "coordinator," "recoverycoordinator," and "resource." Each interface is modeled by a component in the software architecture.

Due to space constraints, we only present the concrete software architecture of the CORBA transaction service. The top specification is very similar to the one shown in Section 3.3, which is a parallel composition of "serviceinterface" and "stateproc." The "serviceinterface" models the interfaces of the transaction service, which consist of the six previously mentioned interfaces.

The use of LOTOS for describing the middleware allows for the validation of behavior properties (accomplished using the CADP toolbox) of each individual middleware and middleware service specification. This capability is not possible when an ADL is used instead of LOTOS. Although LOTOS was not originally designed as an ADL and has limitations such as the lack of proper abstractions to model components, connectors, and interfaces, and the inability to define architectural styles, its powerful capability for describing behavior and the availability of tools compensate for these limitations.