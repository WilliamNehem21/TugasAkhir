One approach to programming random systems involves using a classical deterministic language in conjunction with a random procedure, allowing for non-deterministic behavior by relaxing deterministic behaviors. However, the authors of this paper have taken the opposite approach, achieving non-determinism by constraining chaotic behaviors. In other words, the language proposed in this paper is primarily relational, rather than functional.

Related work in the field of models for non-deterministic (or stochastic) concurrent systems includes input/output automata and their stochastic extension, as well as the stochastic extension of process algebra. There are also connections with concurrent constraint programming, particularly in works that adopt a synchronous approach to time and concurrency. These models are typically designed for analyzing stochastic dynamic systems, such as model checking and probabilistic analysis. In contrast, the language described in this paper, lutin, is intended to be a user-friendly programming language. While it allows for the concise description and execution of a wide range of scenarios, it is generally impossible to determine whether a particular behavior can be generated, let alone with what probability.

The paper provides an example program to illustrate the language, which involves receiving boolean and real inputs and producing a real output based on certain conditions. The language is designed to build scenarios by combining atomic reactions and temporal statements, and it introduces the concept of the "trace" type for typing expressions made of temporal statements. The program demonstrates the use of temporal operators to create a scenario with non-deterministic behavior.

The paper also discusses the concept of the well-founded loop principle, which dynamically forbids empty iterations in loops to avoid excessive restrictions and tediousness for the user. Additionally, the paper introduces the concept of synchronous parallel composition in lutin, where each branch produces its local constraint simultaneously, and the global reaction must satisfy the conjunction of all the local constraints. This approach is similar to temporal concurrent constraint programming.

Further developments planned for lutin include introducing a notion of signals (events) to describe values that are not always available, as well as allowing the definition of (mutually) tail-recursive traces to enable a new programming style based on explicit concurrent, hierarchical automata.

The execution of lutin programs takes place within an environment that stores variable values (inputs and memories) and performs constraint resolution, weight evaluation, and random selection. The paper mentions the use of a solver developed for the testing tool lurette, which covers boolean algebra and linear arithmetics, and resolves constraints by building a canonical representation using binary decision diagrams and convex polyhedra. The paper also discusses the importance of ensuring fairness between solutions and the complexity of achieving uniform selection within a polyhedron. Finally, it mentions that resolution capabilities and random generation may vary between different implementations and are not part of the reference semantics of lutin.