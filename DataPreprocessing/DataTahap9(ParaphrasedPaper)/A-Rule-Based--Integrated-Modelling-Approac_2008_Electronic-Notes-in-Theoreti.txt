The Unified Modeling Language (UML) has emerged as the predominant modeling language for object-oriented software development. However, the behavioral techniques offered by UML lack a method for declaratively specifying rule-based modifications on object structures, and the interconnection between different behavioral techniques is addressed only superficially in the UML specification due to its attempt to accommodate numerous usage and interconnection scenarios.

A second layer focuses on modeling local state changes using a variant of single-pushout graph transformation rules customized for UML. Other techniques like object-based graph grammars and object-oriented graph grammars also utilize graph transformation rules to describe the behavior of object-oriented systems, but they are standalone specification techniques unrelated to UML.

The Fujaba tool suite uses story diagrams, which combine activity and collaboration diagrams, to specify object-oriented system transformations, similar to the approach proposed in this paper. However, unlike Fujaba, which uses Java source code for specifying low-level expressions, we utilize OCL expressions that are integrated into the UML family of languages and contribute to platform independence. Additionally, our approach emphasizes a strict separation of concerns with transformation rules and flowcharts specified in separate diagrams, as opposed to Fujaba's integrated story diagrams. This separation facilitates the reusability of transformation rules in different flowcharts and of flowcharts in other flowcharts.

It is also feasible to employ graph transformation systems as the semantic domain of object-oriented modeling techniques, as demonstrated in other studies where UML class, object, state, collaboration, and use case diagrams are translated into graph transformation systems. This approach complements the one presented in this paper, as graph transformations are used as an additional modeling technique on the syntactical level.

Furthermore, in addition to the left-hand side (LHS) and right-hand side (RHS), negative application conditions (NAC) can be defined for a rule. NACs are non-injective extensions of the LHS that prohibit the identification of certain elements by the match, and extensions are used to forbid auxiliary object structures. If the NAC can be compatibly matched with the LHS, then the rule is not applicable.

In this section, we utilize structured flowcharts defined by Nassi and Shneiderman to describe control flows. The flowcharts are constructed based on the queries and rules defined in the previous sections. By delegating the details of state changes to the rule-based operation specifications, the control flows are kept concise and understandable.

Additionally, the paper discusses the merging of lists, with the actual number of sorted lists stored in a variable and then merged pairwise to reduce the number of sorted lists in each pass until only one list remains. This final list is then transferred to the self list.