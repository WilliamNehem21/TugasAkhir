The process of access-based localization involves two main steps: first, estimating memory locations accessed in code blocks using a conservative flow-insensitive preanalysis, and second, running the analysis with input states restricted to the determined sets of accessed memory locations to improve performance of fixed-point computation. Additionally, smaller input states can lower the number of necessary iterations, as only changes to parts of the abstract state that are not accessed in the procedure require reanalysis.

It has been demonstrated that an interval-based analysis of function g, considering access-information, only needs to consider x in order to achieve a sound over-approximation. Similarly, it is sufficient to restrict the input state of function h to the interval that describes x, as variable y is not accessed in these functions.

The first approach presented, which directly derives the transferred input state from access-information, is named the access-based approach. Taking dependencies into account, the second approach is named the dependency-based approach. The third approach uses the variable xslack as an anchor to relate x to its input value, and is referred to as anchoring.

The set of constraints in o that are significant for function f is referred to as sigf(o). Considering significance, the constraints passed to a callee depend on the state of the octagonal abstraction. An octagonal constraint is propagated into a callee using the dependency-based strategy if it is both dependent and significant.

Analyzing a concrete procedure f with an octagonal input state o involves applying the abstract counterpart f# of f to o. The output of the analysis is f#(o)= oout. Localization refines this approach by applying f# to a sub-state of o, which is often strictly smaller than o.

The authors implemented different localization strategies for octagons in Java, and observed that without localization, the analyzer runs out of memory after a few minutes. However, the use of localization led to improved runtime and precision in the analysis.

The results of the localization strategies are presented in a table, showing that the access-based, dependency-based, and anchoring approaches have varying effects on runtime, the number of procedure contexts found, and the precision of the analysis.

Previous approaches to localization mainly focused on reachability, which is a much coarser criterion than considering access-sets. The paper discusses related work in this field, and also mentions the concept of bypassing to mitigate the effect of unnecessarily carrying global variables along many nodes in the call-tree.

The paper also discusses the use of variable packing to make relational domains feasible in terms of memory consumption and analysis time. Octagon packing, based on observable dependencies in the program, has been successfully integrated into static analyzers to reduce memory consumption while maintaining precision. The paper compares this approach to their own, which guarantees maximal precision.

The authors revisit access-based localization and identify drawbacks of approaches that use either only access-sets or syntactic dependencies between variables. They introduce a dependency-based technique that focuses on significant constraints, as well as an anchoring approach based on auxiliary variables to track differences between input and output values of a procedure.