Our work aligns closely with the application of deductive methods based on the calculus of weakest preconditions. The tools Caduceus/Why and Caveat are utilized to verify critical applications written in C, striking a balance between automation and confidence. However, they do not supply a proof of correctness for the original program that can be verified by an independent certified prover. Caveat makes use of internal decision procedures and simplification rules, while Caduceus/Why transforms the original program before generating verification conditions, thereby guaranteeing correctness. The creation of checkable proofs is addressed in the Proof-Carrying Code Architecture (PCC) and its foundational extension (FPCC), involving the verification of an untrusted program's formal proof before implementation.

Our work has been inspired by previous research on FPCC [1,9], but we differ based on two important points guided by the criteria of convincing proofs: 1) we avoid defining an operational semantics for all constructions and operators of C; 2) optimized proof-checkers for compact proofs are complex and challenging to certify, hence our focus is on the transparency of the proof-checker, leaving the compactness of proofs for future work. To the best of our knowledge, this paper represents the initial attempt to produce a checkable proof in foundational logic of a non-trivial program (a protocol for an event-driven system), reasoning directly on non-transformed C code and minimizing the trusted computing base to include only a compiler and a machine.

The remainder of the paper outlines our implementation of this framework to produce a convincing proof of correctness for a complex communication protocol written in C. Firstly, the logical proof-system is augmented with derivation rules defining the semantics of the protocol. Secondly, the validation of these rules by the evaluators and their translation into Prolog yield a certified proof-checker. Finally, evaluators deliver a summary.

In this section, we briefly introduce the protocol utilized to illustrate our notion of convincing proofs. The protocol is employed to implement multi-tasking real-time data-flow applications on an event-based operating system with priority and pre-emption features. It is designed for an avionics control system comprising a pool of tasks running on a single processor, each task being triggered by the environment upon the arrival of an event. The system reads available inputs from other tasks, performs computations, and outputs results to all other tasks.

The development of the control system operates under the assumption that computations take no time, simplifying the focus to the data-flow between tasks. Consequently, the actual implementation ensures that a task reading the output of another task obtains the correct output with respect to the data-flow ordering, regardless of the computation time of each task.

A significant portion of the proof was automated with the assistance of a symbolic interpreter of C programs developed for this purpose. The interpreter engages with the user for conditional instructions and records the derivation steps in a proof-term created during guided execution. The resulting proof-term contains proof obligations which must be fulfilled subsequently. Inductions and the proof of independency were conducted manually with the aid of lemmas.

While using a prover such as PVS or B would have offered simplifications and decision procedures for arithmetic, it is not feasible to produce an independent proof-term using these provers. Consequently, the prover would have to be included in the trusted computing base (TCB). Initially, we utilized the Coq proof-assistant, which generates proof-terms, but the overhead, formalization complexity, and numerous proof obligations led us to conclude that Coq was inappropriate for our purpose, despite providing tactics to reduce the proof activity. Furthermore, the Coq proof-checker is not yet certified.