The Whiley compiler is capable of producing basic C code, but the resulting code is inefficient due to its use of infinite integers and dynamic array sizes. Our project aims to develop a compiler that can translate Whiley programs into efficient OpenCL code by employing fixed-size integer types and arrays, facilitating parallel execution on GPUs. This paper introduces an abstract interpretation-based approach to bound inference and symbolic analysis for Whiley programs. The process involves analyzing the source Whiley program using a symbolic analyzer to identify patterns and perform necessary program transformations. Subsequently, a bound analyzer is used to analyze the transformed program and make use of primitive integer types instead of third-party infinite integer types, such as those provided by the GMP arbitrary precision library. The results of the bound analysis provide conservative estimates of the ranges of integer variables and array sizes, enabling the generation of efficient code and the prevention of integer overflows. The bound analyzer combines the bound consistency technique with a widening operator to efficiently solve program constraints and converge to a fixed point. The paper also includes examples to illustrate the bound analyzer algorithm and the program transformation.

Static program analysis techniques are essential for ensuring consistency between software specifications and program behaviors using mathematical methodologies. However, creating a compiler with automated static analysis capabilities for object-oriented programming languages poses challenges due to issues such as side effects and non-deterministic results.

Whiley is a new programming language designed to address verification issues that commonly arise in object-oriented programming languages. A verifying Whiley compiler can identify bugs at compile-time and convert programs into bug-free Java or C code. Nevertheless, translating high-level Whiley programs into efficient implementations presents challenges, including the performance slowdown caused by the use of unbounded integers.

The structure of this paper includes a review of related works in section 2, a description of the bound inference procedure, fixed-point approximation using the widen operator, and pattern matching along with program transformation in section 3, an illustration of the bound analysis algorithm with example programs and a demonstration of the performance of generated C code with and without program transformation in section 4, and a conclusion and discussion of future work in the final section.

Loop bound analysis is a compiler optimization technique used to determine the number of loop iterations and verify loop termination. It can also unroll loops to reduce compiler memory consumption, commonly employing techniques such as pattern matching and counter increment.

The bound analyzer is implemented as a Java plug-in within the Whiley project. It infers the bounds of integer variables in two phases. First, it evaluates the semantics of each Whiley Intermediate Language (WyIL) code to extract constraints on the abstract domain. Then, it computes bounds using the bound consistency technique and converges termination time using the abstract interpretation-based widening operator.

The analyzer constructs a control flow graph (CFG) for each function by processing the WyIL code semantics, categorizing them into different types of CFG blocks based on the WyIL code type, and placing the bound constraints into the CFG blocks.

The gradual widening operator broadens an increasing upper bound to the minimum of possible maximal thresholds and updates a decreasing lower bound to the maximum of minimal thresholds. This process is repeated until all bounds have stabilized. The inferred bounds allow the code generator to determine the smallest fixed-sized integer data type, such as using short integers to store variables within a specific range.

The paper also discusses typical while-loop patterns, such as incremented, decremented, and build list patterns, and introduces a transformer that changes while-loop structures to the for all pattern for program optimization.

Results from different test cases show that the bound analyzer achieves precise bound results, and the support for program transformations improves the efficiency of generated code. The paper concludes by asserting that the use of symbolic and bound analysis enables the code generator to produce efficient code that uses fixed-size integers and lists, thereby avoiding integer overflows, out-of-range list errors, and reducing memory usage.