Programming languages serve as the crucial connection between computers and the software that operates on them. While programming languages typically have a formally defined syntax, their semantics are not always clearly specified. The semantics of programming languages are often expressed in natural language, such as in a reference manual or reference implementation, and are rarely articulated using mathematical formalisms. However, without a formal language semantics, it becomes difficult to rigorously reason about programs written in that language. Furthermore, a formal semantics of a language functions as a specification that provides users and implementers with a solid foundation for agreeing on the meaning of programs. Nevertheless, providing a complete formal semantics for a programming language is a daunting task due to challenges related to mathematics, inadequate tool support, and limited scalability of frameworks in terms of modularity at a definitional level and in terms of simulation, execution, and analysis time.

In addition to predefined semantic categories like computations, lists, sets, bags, and maps, the K tool offers several built-in syntactic categories/datatypes and semantic operations for them. The list of these built-in operations is continually evolving and can be found in the files from the include/builtins directory from the distribution. Presently supported built-ins include booleans (bool), unbounded integers (int), floats (float), strings (string), and identifiers (id).

K contexts can be leveraged to address this issue by generalizing strictness annotations. They enable users to declare that a position in an arbitrary term should be evaluated. K contexts are akin to evaluation contexts. For instance, a context declaration is needed for the context above.

However, the unrestricted use of heating/cooling rules may lead to an overwhelming and often impractical number of possibilities to analyze. For performance reasons, the K tool adopts a default arbitrary yet fixed order for evaluating the arguments of a strict language construct. This approach, similar to refocusing semantics, results in potentially missing behaviors due to overlooked interleavings.

To recover these missing interleavings, the K tool provides a superheat/supercooling process, allowing users to adjust the level of strictness-based nondeterminism available. While these processes do not have any theoretical significance in terms of affecting the language semantics, they hold practical relevance specific to the implementation of the K tool. Notably, productions with attributes specified as superheat during compilation indicate a desire to exhaustively explore all nondeterministic evaluation choices for the strictness of the corresponding language construct. Similarly, rules tagged with an attribute specified as supercool during compilation prompt the K tool to reset the current context, initiating the search for a redex. Subsequently, the rules defining the descent towards the next redex have the opportunity to select another evaluation order.

Upon recompiling the K definition with "kompile-superheat"plus", the program p3.exp((print(1)+ print(2))+ print(3)) can be executed using the --search option of krun. The tool identifies four solutions, differing only in the contents of their out cell, containing strings "213," "123," "321," and "312." The absence of any supercool rule limits the output to four different outputs instead of six. Without a supercool rule, superheat only provides nondeterministic choice. Consequently, once an argument of a construct is chosen to be evaluated, it will be fully evaluated. To observe complete nondeterminism, rules with observable behavior—such as the output rule—must be specified as supercooling.

Furthermore, several other platforms and tools exist to assist language researchers in experimenting with various designs and features closely related to this research. Rascal and Spoofax target the development of IDEs for domain-specific languages with Eclipse integration and code generation features. Plancomps focuses on modularity and on the development of a component-based framework for the design, specification, and implementation of programming languages. Redex focuses on specifying and debugging operational semantics and allows for interactive exploration of term reductions using randomized test generation.