Over the past few decades, two different formal approaches have emerged for precise and accurate software development. Model-based languages such as Z concentrate on the data aspects of systems, while not explicitly providing constructs to model behavioral aspects. On the other hand, CSP, along with other process algebras, focuses on the behavioral aspects of systems but lacks support for describing complex data aspects in a concise and elegant manner.

Several formalisms have attempted to combine constructs for specifying both data and behavioral aspects of systems. For example, combinations of Z with CSP, Object-Z with CSP, and new notations like RAISE have been efforts to integrate the two formal approaches. However, to the best of our knowledge, none of these attempts have a related refinement calculus. This gap has led to the development of the Circus concurrent language, which characterizes systems as processes and integrates constructs for describing both data and control using Z notation for data aspects and CSP for behavior.

In a paper by Cavalcanti and Woodcock, a semantic model for Circus based on the Unifying Theories of Programming (UTP) framework was presented. While this model is useful for reasoning about systems specified in Circus, it is not suitable for proving properties of Circus itself due to being a shallow embedding, with Circus constructs mapped to their semantics as a Z specification using another language as a meta-language.

For this reason, the authors redefined the Circus semantics and mechanized it using ProofPower-Z, a Z theorem prover. Based on the new definitions, they successfully proved over ninety percent of the one-hundred and forty-six proposed refinement laws, covering all aspects of the language including data simulation laws.

The paper includes sections presenting the Circus language, the UTP and reactive designs, the main contribution of the redefined Circus denotational semantics based on the UTP, a discussion of the library of lemmas and theorems created during the work, and some conclusions. Additionally, the paper includes detailed definitions and explanations of constructs and operators used in Circus, such as guards, stop, communication, divergence, synchronization, and interleaving.

The authors also emphasize that their work represents the first mechanized refinement calculus for a specification language of concurrent systems, and they plan to mechanize the proof of the theorems, lemmas, and refinement laws to provide academia and industry with a tool for formal development of state-rich reactive programs.