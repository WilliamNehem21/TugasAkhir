The assessment of characteristics with respect to an attribute grammar can be achieved by iteratively computing a function that expresses the reliance of the synthesized attributes on inherited attributes. This approach, which leverages higher-order functional programming, is well-suited for implementation using a language with lazy evaluation, such as Haskell. However, while the resulting evaluation functions are not easily amenable to optimization rules, an alternative first-order functional interpretation of attribute grammars is presented in this paper. This approach involves replacing the input tree with an extended cyclic tree, where each node is cognizant of its context as an additional child tree. It is demonstrated that these cyclic representations of zippers are natural extensions of doubly-linked lists to trees over an arbitrary signature.

The input trees form a regular set of trees, representing abstract-syntax trees of a context-free grammar or, in the case of an emphasis on the abstract tree structure, a set of terms built from a multisorted signature. Attribute values are defined with recursive definitions, through the semantic rules of the attribute grammar. For non-circular attribute grammars, where there are no cyclic dependencies between attributes, the value of each attribute can be computed using a topological sort of the dependency graph. Alternatively, an order-algebraic approach based on least fixed-points can be used to compute attributes for potentially circular attribute grammars and potentially infinite input trees.

General attribute grammars employ both synthesized and inherited attributes, providing information from the subtree stemming from the given node and the context of that subtree. While attribute grammars with only synthesized attributes result in primitive recursive schemes, making it straightforward to compute attribute values by structural recursion on trees, the manipulation of contextual information in general attribute grammars is more complex. However, it has been recognized that attribute grammars with only synthesized attributes can still be utilized, with attributes represented as functions expressing the dependencies of the synthesized attributes on inherited attributes. This approach reduces attribute grammars to structural induction on trees at the cost of using higher-order values, allowing for efficient implementations in a higher-order lazy functional language like Haskell.

Despite the advantages of the higher-order functional approach, the resulting evaluation functions are not easily amenable to optimization techniques based on first-order representations of functions, such as short-cut fusion. As such, an alternative first-order functional interpretation of attribute grammars is presented in this paper, involving the replacement of the input tree with an extended cyclic tree where each node is aware of its context as an additional child tree. This approach requires a preprocessing phase to unfold a tree into its extended cyclic version. It is also demonstrated that these cyclic representations of zippers are natural extensions of doubly-linked lists to trees over an arbitrary signature.

The organization of the rest of the paper is as follows: Section 2 provides a review of basic definitions on attribute grammars and presents a variant of the higher-order functional interpretation. Section 3 introduces zippers and the evaluation of attributes based on zipper representations, while Section 4 describes the cyclic representation of zippers and the unfolding of a tree into its cyclic representation. Finally, Section 5 presents our first-order interpretation of attribute grammars based on the cyclic representation of trees.

The approach to attribute grammars outlined in this paper follows the methodologies presented in previous works, drawing inspiration from fixed-point semantics and lazy evaluation. The implementation in Haskell allows for the definition of attribute computations on potentially infinite data structures, such as streams. The paper also discusses the representation of context-dependent information through zippers and the process of unfolding a rooted tree into its cyclic representation.

In conclusion, the paper highlights the need for a transparent and streamlined approach to working with attribute grammars, aiming to encapsulate the complexities of cyclic representations into a structure of monad or a structure of arrows, thus providing a domain-specific language embedded in Haskell for specifying attribute grammars and related tools.
