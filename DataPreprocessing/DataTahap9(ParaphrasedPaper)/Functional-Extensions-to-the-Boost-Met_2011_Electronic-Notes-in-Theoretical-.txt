An increasing number of C++ applications are now utilizing template metaprograms directly or indirectly, often relying on libraries that are based on this concept. Given the intricate nature of template metaprogramming, developers require libraries to provide support. The most prevalent of these is the boost template metaprogramming library, which offers an extensible and reusable implementation of commonly used compile-time algorithms and meta-data structures. However, despite the widespread use of template metaprogramming and its association with the functional programming paradigm, the boost::mpl library lacks certain essential features for directly supporting functional style. This paper assesses the extent to which boost::mpl supports functional programming and introduces new elements for its enhancement.


Over the past fifteen years, considerable effort has been invested in establishing the foundations of template metaprogramming, including meta data structures and algorithms. Boost, being one of the most pivotal C++ library collections, is extensively employed across various application domains. It heavily leverages templates and is an influential source of research and development in the field of metaprogramming in C++. The library provided by boost assists in constructing template metaprograms in a structured manner, implementing commonly used utilities and algorithms in a way that is extensible and reusable, thereby reducing the amount of boilerplate code in C++ template metaprograms.


For adhering to the functional paradigm, tools must be designed with functional programming in mind. We have developed a sophisticated template metaprogramming library that heavily relies on the functional paradigm, utilizing the boost metaprogramming library. However, we encountered a deficiency in some commonly used functional language tools, which are not yet available for C++ template metaprogramming. This paper evaluates certain functional aspects of the boost metaprogramming library and proposes new elements to offer more direct support for functional programming. These new elements have been implemented and incorporated into the complex template metaprogramming library we have constructed.


In this paper, we introduce extensions to the boost metaprogram library that align with the functional paradigm. Section 2 discusses the implementation of lazy evaluation of compile-time selection, while Section 3 covers the (meta)function composition, and Section 4 provides an overview of currying. Related works are explored in Section 5, and the paper concludes with a summary of our results in Section 6.


When it comes to accessing the value of a nullary metafunction, it must be done explicitly. Upon accessing the value of a nullary metafunction, one is required to access a nested type of the nullary metafunction known as "type." Upon the first access to this nested type, the C++ compiler evaluates the metafunction, and this value is subsequently reused each time the nested type is accessed again during the same compilation. This implies that certain classes, serving as nullary metafunctions, can be passed to other template metafunctions and also represent data values.


While offering a solution to a problem, it is important to keep the business logic centralized in one place. Nevertheless, implementing certain functions, especially those that involve a chain of operations on an argument, can be cumbersome, necessitating the use of complex tools. This contrasts with functional languages where such operations are often facilitated by specific language constructs or standard library functions. Given the functional nature of C++ template metaprograms, incorporating similar functionality into template metaprogramming has the potential to simplify the code in metaprograms.


In our approach, we use the "compose" function to establish the composition of two metafunctions applied to an argument. This is a lazy evaluation, ensuring that the functions are applied only when the condition of "eval if" evaluates to false, thereby avoiding compilation errors. Similarly, incorporating currying into a function by hand introduces a significant amount of syntactical overhead, necessitating the creation of considerable boilerplate code. To mitigate this, we propose a template metafunction that automatically builds the curried version when provided with another template metafunction as an argument.


The proposed function collects its arguments in a compile-time list and maintains this list internally. Once all the arguments are available, it applies the complete argument list to the original template metafunction. However, utilizing such functions requires the creation of various curry functions to handle template metafunctions that accept different numbers of arguments. For instance, handling a template metafunction with four arguments entails the use of the "curry4" function. In particular, we had to rely on helper functions from the boost::mpl library to achieve this.


In summary, while the field of C++ template metaprogramming continues to evolve, there is a need for adequate supporting tools to enable the development of software aligned with the functional paradigm. As the development of template metaprograms differs from that of runtime programs, it is essential to have specific tools that address the unique requirements of template metaprogramming when following the functional programming paradigm.