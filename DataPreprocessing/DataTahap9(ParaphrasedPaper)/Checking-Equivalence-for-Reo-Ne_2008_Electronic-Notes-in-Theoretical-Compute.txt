Reo, an exogenous coordination language based on channels, was developed to serve as the connecting code that describes the communication and coordination among component instances. It has been utilized in the modeling of various complex systems. The fundamental view in Reo is that systems are comprised of component instances located in different places that communicate with each other through connectors. The key concept is to define a basic set of channels and their behavior, with more complex connectors being constructed through the combination of these simple channels.

In the design of constraint automata, we encounter an issue where there is no way to differentiate between incoming and outgoing ports, necessitating the use of two distinct operations to mimic the merge semantics of Reo nodes. At the automata level, we employ the product automata operator to join a source node with another node, regardless of their types. Subsequently, a merger automaton is utilized to simulate the merging behavior of multiple combined sink channel ends. This merger automaton can be considered a new primitive connector in the Reo circuit, inserted before the old node, and performs a non-deterministic choice on its source ports, forwarding the selected data to the old node. Its semantics can be represented by a constraint automaton with only one state and self-loop transitions for every incoming channel-end.

A constraint automaton is provided to describe the desired behavior and the behavior of the constructed Reo circuit is compared to determine if the Reo circuit is a correct implementation, a process known as a homogeneous approach to verification (model checking). There exists a strong connection between this issue and the bisimilarity of constraint automata. An algorithm computing the bisimulation relation can be extremely helpful in dealing with larger Reo circuits. We begin by introducing some notations required for introducing bisimulation for constraint automata.

To achieve compact BDD-representations of constraint automata, careful consideration must be given to the variable ordering. A detailed explanation of our heuristics for determining a suitable variable ordering exceeds the scope of this paper. However, it is worth noting that our heuristics aim to place variables representing constraints close to variables representing states with transitions that rely on those constraints.