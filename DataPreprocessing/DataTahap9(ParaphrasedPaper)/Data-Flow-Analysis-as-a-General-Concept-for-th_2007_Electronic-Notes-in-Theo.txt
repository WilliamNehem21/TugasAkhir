This academic paper proposes the use of program annotations to enhance the code generation and verification process of a just-in-time (JIT) compiler. Program annotations refer to additional code information added to mobile code during its generation, which can be utilized by the consumer side of a mobile system to expedite optimizations or bolster the security of a given program. However, the verification of these annotations poses a challenge, as they are derived from the program and are not inherent to the underlying mobile code. Despite the complexity of verifying program annotations, many projects assume the soundness of these annotations and do not subject them to further scrutiny. Yet, the reliance on incorrect annotations by the code consumer can lead to semantically incorrect transformations and potentially harmful behavior.

The paper presents a technique for verifiable program annotations, which is grounded in data flow analysis and can be employed for transmitting program information modeled through a data flow framework. This technique involves deriving information of a program on the producer side using a well-known general iterative data flow algorithm. After the analysis, parts of the derived data flow information, termed annotation points, are added to the transmitted code format. On the consumer side, the full data flow information is reconstructed from the transmitted annotation points using a modified version of the same general data flow algorithm. This modified algorithm can detect non-accurate transport of program annotations, such as manipulation, by identifying cases where a fixpoint of the considered data flow problem cannot be reconstructed from its annotation points.

The paper is structured as follows: section 2 provides a brief introduction to monotone data flow analysis, and section 3 outlines the conceptual functioning of the program annotation technique. Implementation details and results are presented in section 4, while section 5 discusses related work. Finally, section 6 concludes with a summary.

The paper also introduces the concept of monotone data flow frameworks (MDF), which are critical for the correctness of the algorithm. In the initial phase, each instruction, except for the start node, is assigned an outgoing data flow information corresponding to an element of the semilattice. The start node of a method is assigned a special element "null," representing the information that arrives at the start node from different call points of the method. In the iteration phase, the algorithm derives the outgoing data flow information for each instruction from its direct predecessor nodes, ultimately terminating and yielding a result.

To restore data flow information items, the start node of the control flow graph is initially set to null. Subsequently, similar to the general algorithm, the data flow information for each instruction is iteratively calculated from its predecessor nodes. To ensure that the restoration of data flow information can be performed in one pass during the recovery process, the nodes of the control flow graph are traversed in a reversal postorder. This traversal order guarantees that when an entry node of a loop is the runtime, the general iterative algorithm's complexity will rise due to the higher complexity of semantic functions, meet-and-compare operators. Additionally, there may be a higher workload for loading and decoding annotations of complex data flow problems. Nevertheless, it is expected that the time overhead introduced through loading and decoding will comprise a small portion of the overall compilation time. Consequently, the proposed algorithm should outperform a standard data flow analysis, even when dealing with more complex applications.