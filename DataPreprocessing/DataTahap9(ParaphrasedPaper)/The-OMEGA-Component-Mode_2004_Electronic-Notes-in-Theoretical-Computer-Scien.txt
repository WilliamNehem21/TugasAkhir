In an object-oriented (OO) setting, an application always has an underlying class diagram. Similarly, a component-based application designed with our component model also has a class diagram as its foundation. The Omega deliverable D1.1.2 has previously presented a formal reduction from a hierarchical component model to a flat class diagram. This paper will further present a formal justification of our component model in terms of compositional trace semantics and its corresponding logics in section 5.

In our component model, component interfaces are organized into ports, which serve as the only interaction points between components. At runtime, all communication between components occurs through instantiated ports. In our model, a port serves as both a class and a type specification for one or more runtime objects, which are ultimately instances of classes in the underlying class diagram due to our model being designed in an object-oriented setting.

Syntactically, the components in our model share similarities with the components in the UML 2.0 submission by U2Partners in 2002 and 2003. However, there are semantic differences which will be discussed in this paper. Notably, in our model, it is the component ports that are instantiated as instances of UML classes, whereas in the U2Partners' submission, a component itself is instantiable. Another difference is that our model does not explicitly model connectors and does not define new UML entities for connectors in order to keep the model small, simple, and elegant. As a result, users of our component model have the option to either extend our model and use UML 2.0 connectors or model connectors as components themselves.

A port in our component model is a specialization of both a UML class and a UML interface. It can be considered as a UML class, with the interface of the class known but the name of the class unknown. Creating an instance of a port means creating an object with a known interface but without the need to know the class of the object.

A basic component in our model consists of classes and their relationships as defined in the Omega kernel model. Some of these classes are associated with ports, either depending on them or realizing them. The basic component is a specialization of a blackbox component.

To provide a semantic basis for the compositional verification of components, this paper outlines the formal trace semantics of components, which describes the external observable behavior of a component as determined by its ports. Additionally, the enforcement of an encapsulation condition and the explicit inclusion of the caller as a parameter imply that all interaction between components is via their port instances. Internal objects of a component are not allowed to call the provided services of a port instance of another component.

The paper also discusses practical aspects of modeling applications with components in Omega, including the correspondence between component diagrams and class diagrams, and the use of object diagrams to model architectural diagrams. Furthermore, the additional structuring and abstraction mechanism provided by the notion of component allows for a considerable simplification of the underlying kernel model language in Omega.

It is also noted that components are not units of instantiation and do not require a unique runtime identity. Having ports as instantiable interfaces allows for the existence of multiple ports with the same set of interfaces per component at runtime, providing advantages over the recent component model proposed by U2Partners for UML 2.0. These runtime links are modeled as connectors in UML 2.0.