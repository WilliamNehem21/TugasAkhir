We examine key aspects of the meaning of higher-order functions that are commonly encountered when there is local state, exceptions, names, and type abstraction. We present a set of examples that complement those provided by Stark, demonstrating that certain behaviors of higher-order functions can only be observed when they are given arguments that internally call the functions again. We also illustrate the need for the observer to accumulate values received from the program and generate new names. These examples indicate the necessity of complex conditions for functions in the definition of environmental bisimulation, which differs in significant ways from that of applicative bisimulation.

While several recent bisimulation semantics for languages with higher-order functions are based on environmental bisimulation, there has not been sufficient justification for the added complexity of this definition. In this paper, we investigate whether this complexity is necessary, and our findings confirm that it is.

In a stateful language (or a language with names), the need for accumulating values seems reasonable, as a function may return a different value when applied multiple times. However, the necessity of resourceful arguments appears more questionable, especially in a language with exceptions and polymorphism.

We examine two versions of environmental bisimulations - one with no accumulation and one without resourceful arguments - and emphasize the bisimulation without resourceful arguments, as it is more subtle. Through examples, we demonstrate that these bisimulations are unsound in various languages that use state, exceptions, names, and polymorphism. We identify common aspects in the behavior of higher-order functions in these languages and introduce the concept of private locations to capture their behavior.

When the context calls a function, the public state provides additional communication between the function and its context, serving essentially as another argument and another result that needs to be ultimately pattern-matched. Private states, on the other hand, remain inaccessible to the context.

We present examples showing that certain pairs of terms are no-accumulation bisimilar, and close-argument bisimilar, and discuss the implications of these results. Furthermore, we discuss unsoundness of an accumulating but closed-argument form of bisimulation for the nu-calculus, and how the addition of infinitely many global name references makes the bisimulation sound and complete.

Our findings have implications for the understanding of higher-order functions in various languages and provide insights into the necessity of environmental bisimulation and the behavior of functions in different language contexts.