The use of recursive descent (RD) parsers is widespread due to their alignment with grammar structure, simplifying the writing and debugging process. However, their applicability is restricted to a limited class of grammars. Backtracking methods may broaden this scope but can lead to high computational times and are incapable of handling left-recursive grammars. While tomita-style Right Nulled Generalized LR (RNGLR) parsers are comprehensive, they lack the direct association with grammar observed in RD parsers. We introduce the Generic Language Recognizer (GLL) parsing technique, which shares similarities with RD parsing in terms of the parse following grammar rules closely, but uses RNGLR-based mechanisms to manage non-determinism. These recognizers operate with a worst-case cubic time complexity and can be constructed for left-recursive grammars.

Motivated by the limitations of existing techniques, we apply the principles developed for RNGLR and Right Generalized LR (RIGLR) parsing to devise a general RD-style algorithm. Our algorithm can be organized to mimic either a depth-first backtracking RD parser or to synchronize all putative parses concerning input reading, resulting in a more GLR-like behavior. The latter approach facilitates memory-efficient construction of call stacks and associated parse trees. In this paper, we focus on the former organization.

To implement the GLL algorithm in a standard programming language, the conventional goto statement in the main for loop can be replaced with a Hoare-style case statement. Each label in the algorithm is associated with a unique integer, which is used in the descriptors. Furthermore, we can substitute the appropriate lines of the algorithm in the case statements and eliminate the need for goto statements by incorporating break statements.

As elements are only added to R once, the set R can be efficiently implemented as a stack or queue. When implemented as a stack, the resulting parse trace follows a depth-first approach, with the exception of left-recursive calls being terminated at the start of the second iteration, resulting in a flow similar to that of an RD parser.

The Riglr algorithm can be customized by selecting non-terminal instances in the grammar that generate an automaton call, allowing for a trade-off between execution time and automaton space. In the space-efficient sRiglr version, all non-terminal instances generate a call, and we have used Gated Tree Automata Builder (GTB) to construct sRiglr recognizers, which have been compared to corresponding GLL recognizers.

We have demonstrated that GLL recognizers are relatively straightforward to construct and are also practical. They exhibit the desired qualities of recursive descent parsers in terms of the parser structure aligning with the grammar structure. Additionally, the GLL algorithm can be extended to Extended Backus-Naur Form (EBNF) grammars, enabling factorization and the use of iteration in place of recursion to enhance parser efficiency.

Although the discussed version of the GLL algorithm is only a recognizer and does not produce any derivation, it explores all derivation paths, and modifications can be made to produce tomita-style Shared Packed Parse Forest (SPPF) representations of all derivations of an input string. The modification process is essentially the same as that applied to turn an RIGLR recognizer into a parser, as detailed in the original paper.