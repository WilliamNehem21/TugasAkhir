To perform a computation involving c(0) and c(1), it is necessary to start by computing a partial value for c(0) or c(1), and then continue the computation by using f(c(0)) or f(c(1)), resulting in d(0, 0) or d(1, 1). It should be noted that in this context, d(0, 1) and d(1, 0) are not valid values for the expression f(c(0), c(1)). Modern functional-logic languages like Toy or Curry utilize call-time choice to address this issue.

One notable feature of Maude, leveraging its reflective nature in rewriting logic, is its systematic and efficient use of reflection through its predefined meta-level module. This characteristic allows Maude to be highly extensible and enables advanced metaprogramming and metalanguage applications. Furthermore, Maude offers a loop-mode module, which facilitates specifying input/output interactions with the user, thereby enabling implementation of program transformation, execution, and user interactions within Maude itself.

While Maude provides commands for executing expressions in modules represented at the meta-level, the highly non-deterministic nature of the programs obtained through transformation hinders practical use. To address this challenge, we have developed a natural rewriting strategy that selectively evolves only the necessary terms in the execution of an expression, avoiding unnecessary term rewritings. This contribution represents the first implementation of an on-demand strategy for Maude system modules and serves as a preliminary step toward on-demand execution of general rewrite theories.

The tool reads the module and applies the pst transformation, which simulates plural semantics using ordinary rewriting. The resulting transformed module can be viewed using the command "showtr.". By utilizing the command "is sound," the default depth-first strategy can be changed to a breadth-first strategy, with the guard "if match(c(0), c(1))" ensuring that at least one of the values of the argument matches the original pattern for soundness of the step. Subsequently, after resolving the guard, different evaluations of occurrences of "project(c(0), c(1))" lead to the expected final values d(0, 0), d(1, 1), d(0, 1), and d(1, 0) for the expression in the original program under plural semantics.