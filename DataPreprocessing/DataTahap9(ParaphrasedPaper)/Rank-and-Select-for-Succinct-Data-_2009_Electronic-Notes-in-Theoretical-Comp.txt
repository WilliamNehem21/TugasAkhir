The if statement can be replaced with a skip loop condition, and empirical evidence indicates that this optimization enhances the performance of the loop when there are not many instances of the specified byte 'c'.

As anticipated, the greater availability of memory for storing blocks leads to increased efficiency of both base(b) and base(sb). In our practical implementation, we allocated as much additional memory for base(b) and base(sb) as wt(sb) requires. Nonetheless, the impact of the amount of available memory for holding blocks on the efficiency of base(b) and base(sb) approaches is presented in the concluding part of section 6.

When focusing on the selectc(y) operation, wt(sb) once again demonstrates strong performance (refer to table 6), yielding nearly identical results as in selectc(1). Concurrently, base(sb) also improves its performance across all scenarios. It is noteworthy that base* emerges as a considerably faster choice compared to wt* when performing selectc(y). Under these circumstances, wt* proves to be too inefficient to be considered as a viable alternative. As expected, the 256-bm technique is again the swifter option for obtaining selectc(1) and selectc(y).

Given that each block contains 256 counters (each consisting of 4 bytes), each block effectively squanders 1024 bytes. Consequently, it is feasible to easily adjust the number of blocks utilized for the base(b) technique. As predicted, the use of a greater number of blocks enhances the efficiency of base(b).