Furthermore, in section 3, we outline mechanisms for organizing different levels of reasoning called vertical structuring. This involves defining abstractions that specify the relationship between reasoning objects at higher and lower levels, as well as introducing the concept of refinements, which govern how higher-level reasoning processes can be implemented by lower-level ones. This encompasses the refinement notion encoded in a method of a proof-planner like [10,2], where the tactic encapsulated within a method determines the refinement of the abstract rule described by the method's pre- and postconditions. Building on the general notion of refinement, we define the refinement of an abstract proof in a consistent manner.

Finally, in section 6, we introduce a basic programming language to define reasoning and refinement procedures and illustrate how to combine them to organize overall proof search. These procedures are based on the intuitive reasoning rules provided by window inference reasoning and have explicit failure and success semantics.

A reasoning level comprises the objects to be reasoned about as well as the fundamental reasoning rules, and the reasoning procedures that organize the proof search within a given reasoning level. The former are specified by a signature and a set of formulas with respect to some logic. Thus, the reasoning objects and rules of a reasoning level are represented as a pair (Σ, Γ), where Σ is the signature and Γ is a set of "axioms", denoted as a representation. This corresponds to the notion of a specification in formal specification languages, which are used to define abstract data types and functions about abstract data types. For a reasoning level, the signature determines the syntax of the reasoning objects, and the available basic reasoning rules are determined by the "axioms".

For example, to address the formula (∀x)(x = 0), we use an abstraction called tla-states&transitions, which consists of states and state transitions. This representation is an abstraction of the transition made by the program, such as x0 = x1. Finding a proof plan for (∀x)(x = 0) consists of finding a proof for h0i on the abstract representation tla-states&transitions.

The second component of a reasoning level is the reasoning procedures, which organize the proof search within the reasoning level. We adopt a general notion for a reasoning procedure, defining it as an algorithm in some programming language that interacts with the proof by applying basic inference rules. Additionally, a reasoning procedure includes a notion of success and failure to reflect on its own behavior.

Of a high-level reasoning procedure, some planning algorithm computes a proof plan from methods. This proof plan is a "proof" on the reasoning level of the proof-planning procedure, and consists of the application of basic rewriting rules defined by the pre- and postconditions of the methods. We can associate to this planning procedure a refinement procedure, which takes the generated proof plan and refines it by calling the tactics wrapped inside the different methods. In this scenario, the refinement information is associated with each basic reasoning rule of the higher reasoning level via the methods. A method describes that an abstract proof step satisfying a certain pattern (described by the pre- and postconditions of the method) could be refined by the tactic wrapped inside the method. The refinement procedure exploits this knowledge to refine a proof plan. In general, it is not possible to describe this refinement information by patterns. To handle the general case, we allow the association of a refinement procedure to some reasoning procedure. Such a refinement procedure takes the proof generated by the reasoning procedure as a proof plan to compute a proof on the lower reasoning level (using the lower-level reasoning procedures). Similarly to reasoning procedures, refinement procedures come with an explicit success and failure semantics to reflect on their own behavior.

Note that a refinement procedure for some reasoning procedure p can also be interpreted as some kind of abstraction, where all the (lower-level) reasoning procedures used by the refinement procedure are abstracted to the reasoning procedure p. This notion of abstraction is different from the notion presented above, since it is an abstraction of reasoning procedures while the former is an abstraction of objects and axioms. Furthermore, refinement procedures exploit knowledge about object abstractions during the refinement, giving rise to a notion of refinement. The reason why we introduced abstractions mainly for objects and refinement mainly for reasoning procedures is because this is the usual way those are used.

For the design of reasoning and refinement procedures, we support an intuitive reasoning style. To this end, we aim to focus the reasoning process on arbitrary sub-expressions of some actual expression and to have strong support of contextual reasoning inside a focus. Window inference has been introduced as a formalization of an intuitive and hierarchical reasoning style.

To ensure the soundness of the case analysis, the condition h[h]` a _ bi+ is generated as an additional goal. To allow for an intuitive design of reasoning procedures, we integrated window inference reasoning with indexed formula trees by annotating positions in the indexed formula trees with windows. As focusing on subexpressions is along the tree structure, opening a sub-window corresponds to adding a window on the respective position, and leaving a focus means removing the window from a position and returning to the previous position.

Instantiable variables of some window are simply all variables that are bounded on some-type position in the formula tree. To check the admissibility of the instantiation of a variable, we check the l-admissibility of the substitution (i.e. the irreversibility of the new induced ordering).

The overall proof search inside the framework is organized by the reasoning and refinement procedures, and some additional language constructs to combine them. The reasoning procedures are based on windows and interact with the proof in two manners: first, the content of a window can be modified by applying a replacement rule from the context of the window, and second, they can introduce a case analysis over some arbitrary formulas a1 _::: _ an at any stage of the reasoning process. Following the intuitive reasoning paradigm, reasoning procedures can focus the proof search on some sub-window by calling another reasoning procedure on the sub-window. Finally, they can invoke the reasoning on some higher reasoning level by calling a reasoning procedure on some abstraction of the actual window. In case the abstract reasoning procedure succeeds, the refinement of the (abstract) proof is achieved by calling the refinement procedure of the abstract reasoning procedure. Only if the refinement procedure succeeds, the proof planning attempt is successful.

[Citation: Julian D.C. Richardson, Alan Smaill, and Ian M. Green. System description: Proof planning in higher-order logic with-CLAM. In Claude Kirchner and Hélène Kirchner (Eds.), Proceedings of the 15th International Conference on Automated Deduction (CADE-98), LNAI 1421. Springer, 1998.]