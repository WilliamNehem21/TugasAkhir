This paper explains our approach to parsing a k definition, which is challenging due to the nature of the k-framework. In this framework, users can define the operational semantics of a language by inserting pieces of concrete syntax in the k code in a natural way. Our main contribution demonstrates how to utilize the Syntax Definition Formalism (SDF) and disambiguation mechanisms within the context of the k-framework.

The current tool supporting k, k-maude, has proven to be scalable and applicable to real-world programming languages such as Scheme, Verilog, Java 1.4 and C, with ongoing efforts to support additional languages. However, k-maude relies on the Maude parser to parse k definitions, which can lead to ambiguities when new definitions are introduced. To be translated into Maude, these definitions need to be syntactically correct, so it is preferable to have a parser capable of handling k definitions. Designing such a parser is complex, as k definitions are intricate, combining k syntactical constructs with fragments of syntax from the defined language. After experimenting with various approaches, it became clear that scanners preceding the parser do not offer the generality required to parse different styles of programs embedded into one another. The solution to this challenge came in the form of SDF and its scannerless generalized parser. We generated several parsers for different purposes: one to extract syntax declarations from a definition, another to parse programs, and the last to parse the semantic rules, which is the most complex as it must handle constructors from two languages simultaneously.

The paper is organized into six sections. In Section 2, we introduce a representative example to illustrate the main problem we aim to solve. Section 3 presents an abstract view of the selected solution as a means of addressing ambiguities in languages that embed other languages. Section 4 provides a more detailed explanation of the technique used and its underlying details that led to the chosen method. Section 5 presents some tools that have similar solutions.

The backend of the k tool is designed to accept k definitions represented as a collection of abstract syntactic trees (ASTs). An AST is the collapsed representation of the parse tree resulting from parsing a text. Working with the AST facilitates the handling of input by eliminating unnecessary information in the parsing process, such as white spaces and comments that have no semantic meaning to the language. To obtain the AST, a tool capable of parsing definitions, resolving ambiguities, inferring types for each construct, and transforming them into pure k definitions using ASTs is required.

The current implementation of the k-tool has a front-end that transforms an annotated Backus-Naur Form (BNF) definition of a language into a Maude module, which is then used to parse the k rewrite rules. This approach often leads to ambiguities due to mixfix operators and the preregularity property that needs to be satisfied by the ordered sorts. The lack of support for resolving ambiguities and conflicts provided by Maude proved to be a significant limitation.

The embedding of language constructs in the k syntax is facilitated by the sort k, which can be extended with new syntactical constructs from the defined language. For the rewrite rules, meta-variables are necessary, as they can take the place of non-terminals in syntactic constructs. Combining all these elements is challenging because the objective is to provide users with easy access to concrete syntax while maintaining the integrity of the definition.

The chosen method is similar to the one used in ASF+SDF, as we add new transitions to connect the k grammar and the grammar defined by the user. For each user-defined non-terminal x, we add two new productions: x -> k and k -> x. This technique allows for matching syntactic constructs in contexts that would not normally be allowed by the type system. The aim is to allow users to write rules in a way that resembles the AST representation, but with the convenience of concrete syntax (mixfix form), which can be more intuitive in some cases. More details about this approach are presented in Section 4.2.

The k syntax declarations are a rearrangement of the SDF syntax to be closer to the BNF style. It starts with the keyword "syntax," followed by an identifier specifying the sort of the constructs and a list of production rules. The list of production rules can be separated by ">" to specify the priority of productions. Inside a priority block, other productions can be specified, separated by "|," and considered to have the same priority. Syntactic productions and blocks can be annotated with typical SDF disambiguation filters.

The steps involved in the front-end of the parser include generating a grammar similar to the one for programs and adding transitions to and from the sort k to allow users to insert and replace parts of code from their language. To prevent the parser from entering an infinite cycle, their use is limited using the priority system.

The final step is responsible for compiling the grammar described in Section 4.2 into a new parser that can recognize the k definition. From the obtained abstract syntax tree (AST) at this step, the k intermediate language is generated in the form of XML.

Future work in this direction includes developing a user-friendly interface for editing and testing by leveraging the strong connection between SDF and Eclipse with the help of Spoofax. Efforts are also underway to provide more intuitive error messages by working with more permissive grammars that accept a broader language, while employing more complex disambiguation filters to achieve similar results.