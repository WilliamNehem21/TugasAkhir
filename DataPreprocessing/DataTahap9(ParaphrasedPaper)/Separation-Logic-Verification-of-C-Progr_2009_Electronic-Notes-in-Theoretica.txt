Separation logic, as outlined in previous literature [17, 24], presents a novel method specifically designed for specifying and validating properties of heap allocated data. It facilitates local reasoning by enabling concise specifications that only pertain to memory footprints, thus making it possible to specify how a particular piece of code operates by addressing only the portion of memory that the code actually accesses. This often results in simpler specifications and proofs compared to other formalisms.

Additional detailed discussions on separation logic have been provided by Leroy and Blazy, who describe a formal verification of a memory model for low-level imperative languages like C; Moy, who demonstrates the encoding of unions and casts as structure subtyping; and Norrish, who formalizes various aspects of C semantics in HOL. Promising results in verifying both high-level procedural programs [4, 5] and object-oriented programs [7, 14] have already been observed, indicating the potential of separation logic in program verification. The design of our verification tool has been influenced by existing work, while the programming language constructs for specifying contracts have been adopted from Spec# and VCC. Similar conceptually aligned work involves the verification of Cminor programs using separation logic, as well as research in shape.

Furthermore, the use of SMT solvers for automated verification of heap properties is not a new concept, as evidenced by related work [6, 18]. A closely related work involving the use of an SMT solver for checking the validity of separation logic formulae employs the solver for verifying the validity of pure formulae, albeit not for congruence closure computation.

The succeeding sections of this paper are organized as follows: we commence with illustrating the motivation behind our approach through an example in section 2. Section 3 expounds on our representation of the C memory model using rewrite rules. Subsequently, we delineate the architecture of our prototype tool in section 4, followed by a description of its key components: the symbolic interpreter in section 5 and the theorem prover in section 6. Finally, section 7 offers concluding remarks and discusses future work.

Moving on to a more compelling example, our objective is to specify, implement and validate the operations of a queue data structure. Due to page constraints, we present the final annotation for one operation only while elucidating all the components.

This section elaborates on the C memory model utilized in our approach, wherein the memory model pertains to the formal depiction of the memory layout of various C objects, including primitive types, structures, unions, and arrays. The critical aspect involves determining how to furnish adequate aliasing and anti-aliasing information about objects in memory to enable operations based on pointer arithmetic.

In contrast to type-safe languages like Java or C#, which view memory as a collection of objects and restrict aliasing between objects to occur only if two pointers of the same type point to the same object, such an approach is not sound for C since objects in C can overlap nearly arbitrarily. However, it can be extended to become sound and complete with respect to the byte-level C memory model, as discussed in detail elsewhere. A pivotal element involves having a means to represent when an object is a structural descendant of another, a step that we also adhere to.

The symbolic interpreter symbolically executes the control flow graph of each function in the core C* program, and the state of the heap is updated based on the rules of symbolic execution. As the states of the heap are represented with separation logic formulae, the assistance of a theorem prover is required.

This paper has expounded a methodology for the automated modular verification of C programs against specifications expressed in separation logic, which has been implemented in a prototype tool. The tool is currently in an early developmental stage and has been tested on only a few small examples, demonstrating a reasonable speed of operation; for instance, the queue example from section 2 takes approximately 8 seconds to verify.

A notable limitation is the absence of termination guarantees. If the tool stops, it has either proven the correctness of the program against the specifications or identified a failing point, but it may potentially loop indefinitely. To ensure termination, it would be prudent to apply abstraction in the spirit of abstract interpretation, as has been done in the JStar tool.