The internet has given rise to a distinctive application domain in the form of multi-threaded server applications, which are increasingly crucial for handling interactions with numerous clients concurrently. Illustrative examples include FTP (File Transfer Protocol), email transport, DNS (Name Servers), Usenet news, chat servers, distributed file-sharing, and the widely used HTTP servers, which employ the Hypertext Transfer Protocol for transporting web pages over the internet.

Methods such as asynchronous I/O, POSIX real-time signals, and kernel event queues have emerged as means to mitigate the challenges associated with using select(). These methods, though relatively new and not universally supported across operating systems, offer alternatives to implementing select() with minimal effort.

User-space threads essentially entail an implementation of a thread abstraction within a single process, or potentially over a small number of operating system threads. Programmers are provided with concurrency primitives through the language, while the user-space threads implementation supplies support for low-level time-sharing and I/O multiplexing. Various implementations of user-space POSIX threads are available for Unix.

Concurrent Haskell, specifically the implementation in GHC, aligns with this model; the Haskell runtime system operates within a single operating system process and handles multiple Haskell threads simultaneously. To facilitate concurrent I/O operations by multiple Haskell threads, the runtime system may adopt one of the I/O multiplexing options identified in the preceding section, keeping this choice concealed from the programmer.

The process of generating and writing log entries to a file is performed by a distinct thread, while worker threads communicate with the logging subsystem through a global unbounded channel, invoking logaccess. The logging thread retrieves items from the channel and generates log entries, which are subsequently written to a log file.