Rewriting arbitrary propositional formulas into conjunctive normal form (CNF) can lead to a worst-case exponential increase in the size of the formula if the number of propositional variables is to be preserved. To overcome this issue, practical verification environments employ satisfiability-preserving transformations that result in linear-size encodings by introducing a linear number of auxiliary variables. However, introducing a linear number of auxiliary variables can lead to a worst-case exponential increase in the size of the search tree during backtrack search. It has been noted that both causes of blow-up can often be avoided, as the Davis-Putnam-Loveland-Logemann search procedure for satisfying valuations generalizes smoothly to zero-one linear constraint systems (ZOLCS), which are the constraint components of zero-one linear programs. Zero-one linear constraint systems are capable of facilitating a linear-size encoding of gate-level netlists without the use of auxiliary variables (Audemard et al., Bemporad et al.).

There are different approaches to achieving this, each with its own strengths and weaknesses. However, all reasonable approaches involve the emergence of numerous structurally similar sub-formulas resulting from the iterative application of the transition relation and the continuous evolution in the k-fold unrolling. To illustrate this, we present a specific form of such unrolling, which bears similarities to the approach used by Audemard et al. for MathSAT-based BMC of linear hybrid automata and by Bemporad et al. for MILP-based BMC of linear hybrid automata.

Similar to pure backtracking algorithms, the classical DPLL procedure can suffer from thrashing, characterized by repeated failures due to the same reasons. To address this issue, modern SAT solvers employ conflict-driven learning, which aims to derive general reasons for encountered conflicts and stores them for guiding future search. The standard scheme traces the reason back to a minimal number of triggering assignments and stores this reason as a conflict clause in the database. State-of-the-art SAT solvers, such as the one integrated in HySAT, enhance the basic DPLL procedure with sophisticated heuristics for selecting assignments, non-chronological backtracking, random restarts, and lazy clause evaluation to expedite the proof search.

After each deduction phase without encountering a boolean conflict, the SAT solver checks for new constraints added to the linear program. If new constraints are found, the linear programming routine is called to assess the feasibility of the constraint set. If the linear program is inconsistent, a conflict is reported to the SAT solver; otherwise, the solver can proceed to the next decision step.

It should be noted that BMC is not entirely symmetric due to the initialization properties of runs and perhaps the verification goal. As a result, only conflict clauses inferred from facts independent of such asymmetric formula parts may be replicated soundly. This dependency can be efficiently traced by marking initialization/goal predicates and dominantly inheriting such marks upon all inferences to prevent isomorphic inference when encountering a mark.

When conducting BMC incrementally for longer unrollings, consecutive formulas submitted to the solver share a large number of clauses. Thus, when transitioning from the k-instance to the (k + 1)-instance, the conflict clauses derived when solving the k-instance can simply be conjoined to the formula for step k + 1. However, this is permissible only for conflict clauses inferred from clauses common to both instances, based on simple syntactic criteria. More elaborate schemes have been explored for propositional BMC.