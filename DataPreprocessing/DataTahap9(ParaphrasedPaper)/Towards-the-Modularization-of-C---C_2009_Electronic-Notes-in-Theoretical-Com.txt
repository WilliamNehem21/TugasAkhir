The remainder of the paper is structured as follows: in section 2, we examine the language constructs associated with the concept and concept map. Section 3 presents the concept map modularization problem that will be addressed in the paper. Section 4 outlines our proposed solution to the problem and the preprocessor that will implement our approach.

The logging section of the concept map includes multiple redundant lines of code. This results in lengthy function bodies within the concept map, potentially causing the original function calls (e.g., c.f() and c.g()) to be obscured within the extensive code. Introducing a separate helper function call at these points may be beneficial; however, finding a suitable location to place these functions is challenging. While placing the helper functions in the global namespace is an option, this approach could lead to confusion and make the code harder to comprehend, especially if the functions are only relevant to the concept map.

At present, the conceptgcc compiler is the only compiler that implements concepts for C++. Our intention is not to develop a new concept compiler, but rather to create a preprocessor that transforms our code into valid concept C++ code while retaining our newly established structural advantages. Our approach involves placing the private and protected sections of the concept map into a unique namespace and positioning the namespace scope before the function calls in the public section. We have developed a pre-compiler-like program to facilitate this transformation. Upon completion of the transformation, the resulting code is as follows:

In Example 9, it is evident that the concept map itself can be a template. In this scenario, the template argument may appear within the helper functions. The transformation of such concept maps is more complex than in the previous example. When the definition of helper functions is moved from the body of the concept map to the unique namespace, the template arguments of the concept map become unknown types. Consequently, it is necessary to convert these helper functions into template functions with the same template arguments as the concept map. Furthermore, these helper functions must be explicitly instantiated in the public section of the concept map, as the template arguments may not be part of the function parameter list. Subsequently, we create a new concept map (which includes helper functions) for the concept stack defined in Example 9.

If the concept map is not a template, the helper function can be defined in a separate file. It is essential to place the external definition into the same namespace as the concept map. In the subsequent example, we demonstrate implementing the logger functions outside the concept map.