In recent years, there has been significant research on behavioral protocols of components and methods for automatically verifying protocol conformance in component-based systems. Many of these verification approaches employ model-checking techniques to either confirm protocol conformance for all executions or provide example executions that might lead to protocol violations. However, it has been discovered that when behavioral abstractions consider unbounded concurrency and unbounded recursion, the problem of protocol conformance checking becomes undecidable. To address this challenge, two potential solutions have been proposed: further abstraction to finite state systems, or a conservative approximation of the protocol conformance checking problem. However, both approaches may result in spurious counterexamples due to abstractions or approximations leading to executions that can never occur.

This paper delves into the second approach and presents a heuristic that reduces the occurrence of spurious counterexamples by eliminating search branches that are unlikely to contain real counterexamples. The development of software heavily relies on reusing previously developed components, which may pose challenges due to variations in factors such as development time, programming languages, and distribution methods. In cases where a protocol violation is identified, a counterexample demonstrating the violation is provided. However, since the abstract behavior of a component is an abstraction, it may model execution paths that are theoretically possible but never executed, resulting in false negatives. Positive answers from the verification process guarantee that no protocol violations occur.

The paper discusses two basic approaches for ensuring abstract component behavior: the top-down approach where developers specify and refine abstract behavior, and the bottom-up approach which derives abstract behavior from source code. The bottom-up approach is considered in this work. Moreover, the paper explores three potential solutions to address the undecidability of general protocol conformance checking: further abstraction to finite state systems, bounded checking, and approximation. However, each approach has its drawbacks, such as potentially introducing more false negatives or false positives. This work focuses on approximation of the protocol conformance checking problem to mitigate these issues.

The paper is structured as follows: Section 2 introduces the use of process rewrite systems for abstractions, Section 3 presents the approach of approximate protocol conformance checking and analyzes reasons for spurious counterexamples, while Section 4 demonstrates how to avoid these spurious counterexamples by using a specialized search strategy. Section 5 showcases the results of a case study, and the paper concludes with a discussion of related work in Section 6, and the conclusion and future work in Section 7.

Furthermore, the paper discusses an abstract execution model based on process rewrite systems for concurrent execution of potentially recursive programs and motivates their use. The approach also introduces a specialized search strategy called round-robin reachability to reduce false negatives and improve the efficiency of the verification process. The verification approach aims to ensure properties based on interaction protocols of programs, including unbounded recursion and parallelism, leading to higher software quality by allowing protocol conformance checks before deployment.

The paper also highlights the application of the approach in an industrial case study of component-based systems written in Python and C/C++, with plans to extend the application to BPEL, PHP, and Java in the future. Additionally, it discusses the use of a graphical user interface (GUI) or a Python interface providing an API for the verification process, which includes the implementation of web services for multi-user support. Finally, the paper outlines the early validation results of the approach, demonstrating its capability to detect errors and unexpected behavior in real programs.