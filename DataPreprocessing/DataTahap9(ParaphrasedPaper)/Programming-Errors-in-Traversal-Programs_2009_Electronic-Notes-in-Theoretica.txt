Traversal strategies offer a well-established method for describing automated queries, analyses, transformations, and other complex computations on deeply structured data, including data representations of software artifacts such as programs. However, the resulting traversal programs are susceptible to programming errors beyond the classic type errors, including divergence of traversal, unintentional extent of traversal into data, trivial traversal results, and inapplicability of constituents of a traversal program. In response to these issues, we provide a taxonomy of programming errors and begin to address some of them through refinements of traversal programming.

Despite advances in this area, the use and definition of programmable traversal strategies have remained limited to experts rather than gaining wider usage. This could be due in part to the need for language, library, and tool support. However, we argue that the primary obstacle to wider adoption is the severity of potential pitfalls, which make it challenging to use strategies in practice. Some of the programming errors that arise are familiar, such as type errors, but others are of a novel nature, which could deter newcomers and limit the productivity even of experienced strategists.

Haskell, with its infinite and partial data structures, presents challenges in discussing strategy semantics and properties, particularly termination, in the presence of these structures. We are currently focusing our discussion on finite, fully defined data, while recognizing the potential for future work on coinductive strategies over coinductive types.

We introduce a taxonomy of programming errors related to traversal strategies and their strategy parameters, and present a simple example to illustrate the consequences of misunderstanding success/failure behavior. Misunderstood success/failure behavior in traversal programs can lead to incorrect output and defensive, convoluted code, affecting both correctness and performance.

We define infallible strategies as those that do not possibly fail, and discuss their properties and implications. Additionally, we explore the application of an advanced Haskell library, hlist, for specifying the constituents of a traversal scheme as a family of monomorphic cases, and introduce parametrized schemes leveraging the original schemes.

We propose that constrained forms of traversal programming may be less prone to the discussed errors, and discuss the potential for fully programmable traversal schemes with static error analysis. Furthermore, we note the need for domain-specific optimization and checks, and aim to leverage techniques such as dead-code elimination and termination checking for functional programs in the future. Finally, we express our aspiration to map the declarative style of strategic programming to highly optimized code, drawing inspiration from previous work on fusion-like techniques for traversal strategies.