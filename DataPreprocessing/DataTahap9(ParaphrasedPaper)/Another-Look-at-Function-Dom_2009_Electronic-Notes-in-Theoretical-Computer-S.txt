In this paper, we introduce a novel approach for handling partial and general recursive functions without relying on inductive-recursive definitions, while retaining the advantages of the method developed by Bove and Capretta. Our approach begins by inductively defining the graph of the function, from which we subsequently define the domain and the type-theoretic version of the function. We demonstrate two methods for proving the formal specification of functions defined using this new approach: one involves induction on the graph, while the other utilizes an induction principle akin to the one associated with the domain predicates of the Bove-Capretta method.

As previously mentioned, the type-theoretic version of the function following the Bove-Capretta method (referred to as f91) includes an additional argument that constitutes a proof of the input's inclusion in the function's domain (denoted as dom91). We analyze the definition of f in order to discern its domain, observing that the function terminates for any element n such that 100 < n. Furthermore, if n <= 100, the function terminates on n if it terminates on the arguments n+11 and f(n+11). From this analysis, we ascertain the interdependence between the function and its domain in the presence of nested recursive calls.

In a system like Agda, structural induction can be directly expressed through pattern matching. According to the Curry-Howard isomorphism, a proof by structural induction corresponds to a function definition by structural recursion, where recursive calls correspond to the use of induction hypotheses. This method of writing proofs is quite convenient, as pattern matching simplifies the process.

In cases where n < 100, we analyze an intermediate result, considering either 100 < n+11 or n+11 <= 100. If 100 < n+11, we invoke res-100< on the argument of the first recursive call and perform induction on the argument of the second recursive call. If n+11 <= 100, we conduct induction on the arguments of both recursive calls.

The new proof of res-<=100 bears resemblance to the one presented in the previous section. We can choose to either employ an auxiliary function with direct pattern matching on the graph argument, or use a single function with pattern matching on the domain argument followed by its graph component. In section a.2, only the latter alternative is demonstrated.

It is worth noting that if we use the induction principle associated with the dom91 predicate to prove this property in reference to the function f91, we obtain almost the same code as in section a.3, with the only difference being the need for a proof that n satisfies dom91 (as opposed to dom91) to be passed as an argument to res-==100. This observation indicates that the disparity in the structure and readability of the proof does not hinge on the new approach, but rather on the utilization of the induction principle to obtain the proof, as opposed to pattern matching and structural recursion on an inductively defined argument, for which the Agda system is designed.

We have presented an alternative method to define partial and general recursive functions in constructive type theory. Here, instead of defining an inductive predicate characterizing the domain of the function, we inductively define the graph of the function. From the graph, we define the domain of the function and subsequently its type-theoretic version, which includes an extra argument with a proof that the input satisfies the domain.

Over the past decade, there have been numerous proposals for addressing partial and total recursive functions in a total setting. A comprehensive survey of these ideas is provided in the related work section of a previous paper. Since the publication of that article, several papers have explored the use of co-inductive types to model partiality [9, 7], and a recommendation to extend type theory with a type of partial recursive functions. For an overview of other approaches to defining a type of partial functions in type theory, please refer to the introduction section of the latter article.

In a work by McKinna, the issue of proving properties of a pre-existing function is tackled. McKinna, in collaboration with C. McBride, puts forward the idea of utilizing graph induction for this purpose. While the presentation showcases how the epigram system (a system akin to the Agda system used here) can be employed to construct proofs, the matter discussed is not precisely what is addressed here; our point of departure is how to define the function that we will subsequently verify.

Barthe et al. present a tool for defining and proving properties of recursive functions in Coq. This tool generates the graph of a function from its pseudo-code, containing essentially the same information as the graphs used in our approach. From this graph, the tool by Barthe et al. can define the function in two different ways. In one approach, the domain and the function itself are defined in a manner similar to the Bove-Capretta method. In the second approach, the user must specify a measure and provide proofs that each recursive call is performed on smaller arguments according to that measure. The tool automatically generates proof obligations for the user based on the graph and the measure. Utilizing well-founded induction, the tool can then define the total function described by the graph. However, this second approach is solely applicable to total functions. Additionally, an induction principle is generated for the function, among other features.

With the tool developed by Barthe et al., partial functions can only be represented using the first approach, where the domain and function are defined similar to the Bove-Capretta method. As the Coq type system does not support simultaneous inductive-recursive definitions, nested recursive functions cannot be formalized with this tool. Consequently, there is currently no means to address partial and nested recursive functions using this tool.

There are several reasons behind the less readable code produced using the Agda system, some of which are related to the fact that Agda has primarily been designed to work with definitions by pattern matching rather than with induction principles and recursive combinators. Firstly, Agda does not offer a means to perform case analysis on the right hand side of a definition, and although the result of analyzing cases on the expression (e.g., co 100(n+11)) is essentially the same as the result of employing an||-elimination on the same expression, the code is more readable when using the former approach. Moreover, using an||-elimination instead of pattern matching on a proof that n <= 100 makes the code lengthier and more challenging to comprehend. Finally, in the case where n == 100 (the last case), obtaining a proof that n satisfies dom91 from the information available from the induction principle is somewhat cumbersome.