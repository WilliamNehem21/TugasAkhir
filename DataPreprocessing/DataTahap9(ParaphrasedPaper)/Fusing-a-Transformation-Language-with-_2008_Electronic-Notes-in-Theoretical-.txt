The practical applicability of our prototype in addressing a range of common, framework-specific analysis and transformation issues is discussed in section 4. Section 4 also covers the implementation details of our prototype, while section 5 addresses related work. In section 6, we explore the trade-offs associated with our technique before presenting our conclusions in section 7.

Our prototype system is available as a stand-alone command-line application based on Eclipse, as well as a reusable Eclipse plugin. In stand-alone mode, the system performs source-to-source transformations, where the user provides the project path and a script for execution. The scripts use FFI to traverse project directories and parse source files to obtain their AST. Once rewritten, the scripts utilize FFI to write modified ASTs back to disk as source code. In plugin mode, interpreter patterns are written using prefix notation.

We delve into the motivational aspects of the applicability of our system by demonstrating some framework-specific analyses and transformations. These examples illustrate what an advanced framework developer with a solid understanding of language processing and Stratego could achieve. However, it is important to note that Stratego is capable of performing more advanced analyses and transformations than what has been presented here.

For instance, we discuss the concept of totem propagation, which involves marking variables in the source code with annotations and subsequently utilizing these annotations for other analyses and transformations. Moreover, we illustrate how our system can address issues related to the dimensions of matrix operations in software projects.

The where clause, for example, is a rewriting condition that ensures the correctness of operations and dimensions in a given context. Additionally, we discuss adapting the ECJ AST hierarchy to the term interface expected by the rewriting engine using the POM adapter.

We also emphasize the use of languages for refactoring such as Jungl and Contract, which provide both program analysis and rewriting capabilities. These languages offer different language features and challenges that should be carefully considered before use.

Finally, we highlight the trade-off associated with using a domain-specific language for scripting, emphasizing the need for extensive documentation and a substantial corpus of similar code to facilitate learning and adoption.