Refactoring involves enhancing the design of a program without altering its functionality. It is beneficial to separate general software updates into changes in functionality and refactoring. This process is supported by both documentation outlining the effects and conditions of refactoring steps, as well as by tools. These tools can validate refactoring steps by automating the process of checking for refactoring conditions and applying the refactoring itself, thereby reducing the challenges and potential for errors associated with refactoring.

The initial release of hare included a range of single-module refactorings related to scope, with multiple-module versions of these refactorings added in hare 0.2, and various data refactorings added in hare 0.3. This version of hare has been restructured to provide an API for implementing refactorings and more general transformations of Haskell programs in our infrastructure.

In worker, applytp, once butp, failtp, and adhoctp are type-preserving strategy combinators from strafunski. The function once butp traverses the abstract syntax tree (AST) in a bottom-up manner, terminating after its argument function succeeds at one node. In the case where its argument fails at every type except hsexpp, it invokes the function inexp, which transforms the current expression into a case expression if the expression refers to the same occurrence as the user-selected expression; otherwise, it fails. Consequently, the overall effect is to transform the first (and only) occurrence of exp.