Estimating the dependability of a software system at an architectural level in the early stages of design is important for enhancing system reliability and avoiding costs associated with addressing implementation issues later on. Current reliability prediction methods for component-based systems rely on markov models and assume that software architects can provide transition probabilities between individual components, which may not be feasible if the components are black boxes during the design stage or not available for testing. In this paper, we introduce a new modeling formalism that incorporates parameter dependencies into software component reliability specifications, allowing the software architect to solely model a system-level usage profile. This approach alleviates the need for software architects to estimate transition probabilities within the architecture model, thus improving the accuracy of reliability predictions.

We propose a new method where component developers provide component reliability specifications using stochastic regular expressions (SRE), which extend regular expressions with probabilistic attributes to describe call propagation through a component service dependent on input parameter values. Software architects can combine these parametrized specifications using tools and incorporate their application-specific system-level usage profile, with a transformation tool resolving parameter dependencies within the component reliability specifications to deduce component transition probabilities based on the system-level usage profile. Our approach eliminates the need for software architects to estimate transition probabilities inside the architecture model, resulting in more precise reliability predictions.

We demonstrate the practicality of our approach by modeling the reliability of component services in a retail management system using tools for the Palladio Component Model (PCM). We conduct predictions with varying system-level usage profiles and exhibit the sensitivity of overall system reliability to individual component failure probabilities and usage profile parameters.

The paper is organized as follows: Section 2 provides a survey of related work, Section 3 outlines the steps of our method and elucidates the roles of the involved developers, Section 4 defines our formalism on stochastic regular expressions and presents the transformation algorithm to derive a markov model from the formalism, Section 5 demonstrates our approach in a case study, followed by a discussion of assumptions in Section 6, and Section 7 concludes the paper.

The field of reliability prediction for component-based software architectures has been reviewed in [5, 4, 7]. The approach presented in this paper falls under the category of state-based methods, which assume that the control flow between the components of a software architecture can be modeled using a markov chain. It is noted that most existing approaches rely on estimations of transition probabilities between components, whereas in our approach, no estimation is required as each component specifies its call propagation in relation to its own usage profile.

One of the initial approaches for architecture-based reliability modeling was introduced by Cheung in 1980, who highlighted that a system is more reliable if the unreliable parts are seldom used. He employed a markov model to describe the control flow through a component-based software architecture, computing system reliability by analyzing the markov chain and incorporating transition probabilities between different components, so that rarely used components only marginally contribute to system reliability.

Hamlet et al. specified reliabilities and call propagations for each individual component, with resulting models intended for reuse across different architectures and system-level usage profiles. However, the approach necessitates the software architect to execute each component against the desired usage profile, effectively reducing the approach to testing, without making the dependency of transition probabilities and input parameters explicit.

Each software architect assembles the component specifications in the same manner as the component implementations, providing a usage profile for the entire system based on direct interaction with the user or other systems. A tool traverses the architectural model and resolves the parameter dependencies in the component specifications based on this information.

The paper presents our model for component reliability specifications (section 4.1), system modeling (section 4.2), the necessary transformation steps to derive a markov model from the specifications (section 4.3), and how to solve the markov model to obtain reliability predictions (section 4.4).

The algorithm creates a markov model as a side effect while traversing the abstract syntax trees of the SREs. This model includes a failure state, taken if an internal action fails, and the transition probability from a state representing an internal action to the failure state is its failure probability. Upon traversing an external call, the algorithm creates a new usage profile for the called SRE and resolves the parameter dependencies on the inputs and outputs of the call. The control flow of the operation is described, with individual failure probabilities and parametric dependencies also considered for reliability predictions.

Our method abstracts from the specific faults that may lead to a failure and assumes the failure probabilities of internal actions to be stochastically independent fixed constants. It aims to aid component developers in specifying component reliability and to assist software architects in quickly assembling component reliability specifications for different usage profiles without requiring knowledge of the components' internals.

While our approach can potentially enhance existing component-based reliability prediction methods and can be applied to other compositional quality attributes, such as performance, further work is planned to incorporate information about underlying hardware resources, reliability models for network connections and connectors between components, and determine valid failure probabilities. Additionally, we aim to accommodate factors like system or component state at runtime, previous service calls, and control flow in future work.

Overall, our approach presents a promising path for accurately assessing system reliability during early development stages, thereby averting high costs associated with late lifecycle system modifications.

We acknowledge that the nature of our approach may overlook certain failure factors, such as changes in component state over time or failures caused by concurrency. However, we believe that our method provides a valuable foundation for further research and development in this area.