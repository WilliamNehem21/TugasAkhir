The traditional approach to model-checking involves examining a fixed system and a specification of its behavior. Typically, the states and transitions of the system are depicted in a transition graph (Kripke structure), and the only dynamic aspect is the change of state, captured through execution paths or, if there is branching behavior, computation trees. Specifications entail defining desired properties of execution paths or computation trees.

The field of model-checking over dynamic structures is still in its infancy. Some notable references include [15, 3, 13], where data structures with dynamic behaviors, such as programs or UML state machines, are efficiently encoded (e.g., as lists or trees) for use with established model-checking methods. The objective of this paper is to introduce and present initial results on a simple yet robust framework.

Specifications for dynamic networks typically aim to ensure desirable properties of networks. In this paper, the focus is solely on the properties of connectivity and biconnectivity (a graph is biconnected if removal of any node still results in a connected graph). There are other similar properties, such as k-connectivity, having a small diameter, or having a certain minimal degree for all nodes, among others.

Prior studies on dynamic networks addressing adversarial agents have centered around routing problems. In such studies, it was either assumed that the network under consideration remains connected or that the network's connectivity occurs infinitely often over time (cf. [6, 1, 2]).

In our model, two players, destructor and constructor, take turns (destructor starts), and they are permitted to skip moves. Plays are generally infinite but may be considered finite when neither player can move, or when a given winning condition is met.

In the context of solitaire games, only constructor makes moves and maintains control of network evolution. Deletion and restoration moves are not allowed, and the permissible moves involve creating or relabeling nodes. A variant proposed by the solitaire model involves constructor also executing deletion moves, corresponding to a scenario where network evolution is entirely controlled by one agent.

A potential criticism of our framework is the significant advantage given to destructor over constructor. This can be addressed through natural conventions, such as assuming that destructor remains silent (i.e., skips) for certain periods of time until a deletion is executed. The balance between constructor and destructor can be adjusted based on the relevant application area. In the context of fault tolerance, which is our motivation, it is natural to assume that the deletion actions of destructor are undesirable, and the creation and restoration actions of constructor are desirable. In other domains, the opposite could be feasible.

For each Turing machine M, we construct a solitaire game (i.e., an initial connected network G and a set R of rules) such that M halts when started on the empty tape if and only if constructor can reach a biconnected network from G by applying the rules of R.

For the proof, it suffices to observe that only finitely many distinct networks (over the unchanged original vertex set V) can be generated from the initial network. If there are N such networks, each play will result in a repetition after at most N steps. Therefore, for deciding the winner (and providing a winning strategy), it suffices to construct the game tree up to a depth of N.

Remark 4.3: In order to keep the model simple, we do not consider scenarios where the deletion and insertion of edges are allowed. Since the number of possible edges in the non-expansive case is bounded by |V|, the absence of edge insertion and deletion is inconsequential for the decidability of the model-checking problem.

One might have the impression that the high complexity in the case without node creation is solely due to the consideration of information flow or labeling rules. However, even without these rules, simple questions such as connectivity present computational challenges. We present a corresponding PSPACE-hardness result in Theorem 4.6 below, using a reduction to sabotage games. For readers who prefer a reduction to a standard problem, we also include an NP-hardness proof (invoking the vertex cover problem).