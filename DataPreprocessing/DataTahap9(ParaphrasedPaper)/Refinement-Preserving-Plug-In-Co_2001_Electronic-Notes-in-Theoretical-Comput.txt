A formal method refers to a mathematically-based theory used for describing and reasoning about the behavior of a computer system. The application of a formal method involves specifying the system in a chosen formal notation, analyzing and verifying key properties, and refining the system step by step to achieve a correct implementation. It is widely recognized that using these techniques during the development process can greatly enhance the quality of software and hardware systems in terms of correctness and maintainability. For instance, the use of a general-purpose specification notation like Z has been shown to facilitate the early detection of design flaws.

In contrast to safety properties, liveness properties are not preserved by certain operators, as illustrated by example 5.1. Our focus is on plug-in relationships among components, where a component q is considered to plug into a component p if q does not cause p to deadlock when they are executed in parallel. We formalize this notion as a desirable behavior for a plug-in component and demonstrate, by example, that more deterministic refinements of processes satisfying such a relationship do not necessarily satisfy the relationship.

CSP models a system as a process that interacts with its environment through atomic events, with communication being synchronous. CSP serves as a process algebra that emphasizes communication through synchronized events rather than shared variable assignments as the fundamental means of interaction between agents.

We consider q as a plug-in to p if their joint behavior expressed by p q behaves desirably. However, not every process that returns keys should be considered a plug-in to p. For example, consider r. It may be tempting to generalize Theorem 6.6 to claim that q is a plug-in to p on channels t and r if q is a plug-in to p on t r, but this is not generally true, as illustrated by the following example.

Another reason for refining the CSP specification is to analyze the behavior of a chosen protocol with regard to security, such as its robustness against deliberate or inadvertent attacks by intruders. Demonstrating security or the lack thereof may involve modeling attackers as processes with certain constrained behavior. For instance, Lowe and Roscoe identify potential security issues with the TMN key exchange protocol, revealed by counterexamples provided by FDR showing that attackers could perform operations specifically disallowed by the CSP specification. However, a disadvantage of action systems for this type of analysis is that automated deductive reasoning tools generally cannot provide counterexamples for flawed conjectures.

CSP-like descriptions are translated into machine-readable B specifications, which can then be verified using a deductive tool. Event-based CSP descriptions and state-based action system-like ones are combined into a single B machine, with appropriate proof obligations to ensure the liveness properties of the system.

In contrast, our goal is to modularize both specification and analysis from the outset to reduce effort and space explosion for systems where it is feasible. Treharne and Schneider provide techniques for using CSP and the B-method, defining CSP control executives for state-changing operations based on the B-method. They identify WP-formulated proof obligations on the CSP specifications to ensure that appropriate preconditions and guards (which they distinguish) are not violated. As a result, independent analysis of the separate specifications is possible.

Our primary motivation is to address the inherent scalability issues associated with applying formal techniques to large applications. Much of the current research aims to combine different formal approaches to address various aspects of a given system. However, there is a risk that combining techniques for a particular system may introduce excessive complexity. Our objective is to mitigate potential complexity by structuring separation-of-concerns specifications early in the development process, allowing for effective independent analysis. Finally, while our techniques are formulated using action systems and CSP, we believe that the concepts we have identified are generally applicable to other formal and semi-formal specification techniques.

In the context of program construction, the event a represents the most basic program constructor. It waits to perform the event a, and after this has occurred, it behaves as process p. The same notation is used for outputs (c!v p) and inputs (c?x p(x)) of values on named channels.