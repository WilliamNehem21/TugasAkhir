The process of static analysis can be divided into two phases, where the analysis problem is first converted into a set of constraints and then solved to obtain the desired analysis result. These constraints can be specified in a language tailored to the specific problem or in a general-purpose constraint language. In this paper, we focus on the latter approach and examine alfp, which is an extension of datalog. AlfP has been successfully utilized as a constraint language for complex analyses of various programming paradigms, including imperative, functional, concurrent, and mobile languages, as well as for model checking.

While multiple analysis problems can be reformulated using the same constraint language, it is not guaranteed that they will all benefit from the same solver techniques. Certain solver techniques may be more effective at handling specific types of input formulae due to the use of specialized data structures. Therefore, it is important to be able to experiment with different data structures and algorithms for solving the constraints.

The remainder of this paper is structured as follows. We begin by providing background information on alternation-free least fixed point logic in Section 2. Section 3 outlines the overall structure of the algorithm shared between the two solver algorithms. Sections 4 and 5 detail the data structures and the algorithms of the differential and the BDD-based algorithms, respectively. In Section 6, we present experiments that utilize model checking to verify a number of properties. Finally, we conclude in Section 7.

Regarding the handling of assertions, the specifics depend on the actual algorithm, which will be discussed later. The treatment of conjunction is straightforward as both clauses need to be inspected. When dealing with implication, we utilize the function check, which takes the continuation execute(cl) as an argument in addition to the precondition and the environment. For universal quantification, a recursive call is made using an updated environment, the details of which depend on the specific algorithm.

In this section, we present the main data structures and the details of the differential worklist algorithm. The algorithm computes the relations in increasing order of their rank, and the presence of negations does not pose any obstacles. It combines the top-down solving approach of Le Charlier and Van Hentenryck with the propagation of differences, an optimization technique for distributive frameworks. The main data structures are env and result, representing the (partial) interpretation of variables and predicates, respectively.

The formulation is based on abstractions of the actions that annotate the edges of a program model. Assignment statements (x:= e) are abstracted to actions modx, while all other statements are abstracted to actions use. Intuitively, the formula verifies whether there exists a path, ef, not modifying variable x, leading to a state labeled l with an outgoing transition, ex, that modifies x. The actl formula is then translated into the alfp formula.

Based on the experimental results for modalities ex and eu, both algorithms were slightly slower for the second case. This can be attributed to the greater length of the formula for modality eu and the nesting of quantifiers, which is the same in both cases. Additionally, the results indicate that the differential algorithm outperformed the BDD implementation by a factor of two in both cases. This is because when resuming computations, the differential algorithm only propagates the differences, whereas in the current implementation of the BDD-based algorithm, entire clauses are recomputed.