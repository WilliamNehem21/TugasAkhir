To establish formal foundations for contemporary web service technologies, we have introduced a formalism called "cows" for specifying and orchestrating services while representing their dynamic behavior. The cows formalism aligns with a broader line of research aimed at developing process calculi capable of capturing fundamental aspects of service-oriented systems and potentially supporting the analysis of qualitative and quantitative service properties. 

The paper is structured as follows: Section 2 presents the syntax of cows and its informal operational semantics. Section 3 demonstrates how cows can be utilized for concurrent constraint programming. Section 4 describes simple communication protocols facilitating the generation of constraints through synchronization between two parties. Section 5 outlines the specification of a web hosting scenario, which represents a typical service-oriented architecture (SOA) environment where service level agreements (SLAs) among organizations are commonly employed. Section 6 introduces variations of the concurrent constraint programming constructs presented in Section 3. Finally, Section 7 concludes the paper with some observations.

We provide insights into the constraint system used in cows. In this system, a constraint represents a relation among a defined set of variables, providing information about the possible values those variables can take. This information is typically incomplete as a constraint may be satisfied by multiple assignments of values to the variables. For example, constraints such as those presented later in the paper can be employed.

Given the potential for divergence in the protocol (i.e., an invoke can synchronize infinitely often with the same receive without modifying the store), a fairness assumption is essential to ensure progress properties: if an invoke can synchronize with multiple receives and at least one synchronization produces consistent constraints, then eventually this synchronization will succeed.

Activities such as storing and releasing the store, as well as synchronizing invoke and receive actions, are integral to the system. The encoding of receive actions reads the store and, if the value remains unchanged, adds new constraints; otherwise, it restarts the terms. The encoding remains divergence-free, meaning that whenever the terms are restarted, the value of the stored constraints differs from that in the previous state.

While it is possible to define robust protocols that avoid issues such as starvation, they would need to rely on synchronization among more than two entities simultaneously, which goes against our decision to balance expressiveness and implementability.