Compilers for languages featuring type inference algorithms often generate confusing and misleading type error messages, typically providing a single error location that is often far removed from the actual location of the type error. Prior attempts to address this issue have failed to encompass the multiple program points contributing to the type error, often reporting tree fragments that have no correspondence in the user program and providing incorrect type information and diagnoses. In response to these challenges, we introduce Skalpel, a type error slicing tool designed to offer programmers all the relevant information pertaining to a type error, thereby significantly aiding in the diagnosis and resolution of type errors. Skalpel consists of a novel constraint generator that is linear in size and a terminating constraint solver, effectively addressing the limitations of existing approaches. 

The automatic detection of type errors in programming languages presents a formidable challenge, and successful solutions require addressing constraint systems. While some initial attempts have been made using constraint-based approaches, these have been limited to basic languages. A more promising approach has been taken in a different context, but the scope of the languages used to demonstrate the key ideas remains modest. Furthermore, existing proposals to improve type error reporting have primarily involved repetitive calls to the compiler and alteration of the untypable program, which has proven to be ineffective. Addressing the problem of identifying type errors and providing meaningful error reports is an extremely complex task, and automating the process further compounds the difficulty. It necessitates the automatic labeling of every syntax component in the program, the automatic generation and resolution of constraints, as well as coping with new constraints that can lead to a combinatorial explosion in constraint size.

To overcome these challenges, we have developed Skalpel, a tool that addresses the aforementioned problems. Skalpel associates program points with generated constraints, enabling the reporting of the labels attributed to the constraints when unification fails, to provide a comprehensive description of the error. By annotating constraints with these labels, Skalpel can precisely describe the program points associated with a specific constraint. When tasked with checking a program for type errors, Skalpel leverages its sophisticated constraint generator/solver, which operates linearly in size and terminates. In cases where constraint solving fails, indicating an error in the code, Skalpel employs an automated process to isolate the parts of the program responsible for the error, ultimately generating a type error slice that identifies the minimal amount of relevant information contributing to the type error in the code. This approach enables users to focus on the highlighted regions, offering confidence that the type error may be addressed within these specific locations while disregarding non-highlighted portions that do not contribute to the error. Our contributions in this paper include a detailed discussion of the notation used (Section 2), the technical details of Skalpel (Section 3), and insights into our constraint representation, which was instrumental in overcoming the challenges associated with constraint size explosion when dealing with entire programming languages such as SML. We conclude in Section 4.

In contrast with the Skalpel core, which handles identifier statuses in Section 14.1 for fully correct minimal error slices, we distinguish between value variables and datatype constructors by defining two disjoint sets valvar and datcon. Additionally, for the sake of simplicity in presenting the Skalpel core within this paper, we have limited datatypes to only one constructor and one type argument.

Our primary objective is to establish environments that prevent duplication during initial constraint generation or when solving constraints. It is important to note that previous systems are too restrictive to represent module systems, as they only support very limited cases of our binders. In contrast, with our constraints, we can readily define a compositional constraint generation algorithm.

We have structured the core in a manner that limits the complexity of the core by enforcing constraints that ensure datatype declarations only have one constructor, as evidenced by rules (g17), (g14), and (g16). In rule (g13), we stipulate that datatype names have exactly one type variable argument. 

Upon close inspection of the rules, we find that for a polymorphic (let-bound) function (rules (g2), (g6), and (g17)), we refrain from eagerly copying constraints for the function body. Instead, we generate poly and composition environments, and binders force the resolution of constraints for the body before copying its type for each use of the function (rule 2 (g21)). When performing a constraint generation run during cstgenj(pl, v), it is determined whether pl is atomic or not. If not, recursion with cstgenj(plj, v j) occurs, focusing on plj inside pl such that plj is strictly smaller than pl. The rules that involve recursion with strictly smaller parts of external syntax include (g2) (let syntax removed in recursive call), (g3) (application syntax removed), (g4) (fn syntax removed), and (g8).

Additionally, we delve into the analysis of some notable constraint solving rules. Rule (c1) illustrates how we manage composition environments, first addressing the constraints within the first environment before turning attention to the second. Polymorphism is addressed in rule (p1), wherein we make a binder polymorphic by quantifying over the type variables that are to be made polymorphic, and creating a new binder with this information.

A pivotal characteristic of Skalpel is its ability to present all possible points where the user might rectify the error while excluding any irrelevant program points. We achieve this through a minimization process. In instances where the constraint solver terminates with an error containing program points (l), the minimization algorithm verifies the labels present in the reported error. This involves removing a program point l from the program, replacing it with a dummy expression, and rerunning the constraint solver. If this operation concludes successfully, the label was crucial to the error and must be presented to the user. Conversely, if the constraint solver terminates successfully without the label, it is considered irrelevant, and thus excluded from the presentation to the user.

Skalpel is particularly effective in large codebases, as it can highlight potential areas for fixing type errors that require global changes across an entire project. Furthermore, when working with large codebases where the type error is confined to a few small functions, Skalpel can effectively eliminate irrelevant portions of the program for the user, unlike existing compilers that fail to exclude irrelevant information and only pinpoint the location where unification failed. This effectiveness is attributed to two factors: accurately calculating which program parts to highlight (i.e., labels involved in the error) through the attachment of label sets to each constraint and a process of minimization, which ensures that no irrelevant parts of the program are highlighted to the user.