The Lp(ciao) program, as derived from the class reader, incorporates bytecode instructions for all methods within the classes {class 1,..., class n}. These instructions are structured as a collection of bytecode facts, and a single class fact summarizing the remaining information from the .class files (e.g., class name, method and field signatures). Each bytecode fact follows the format bytecode(pc, methodid, class, inst, size), where class and methodid identify the class and method to which the instruction inst belongs. The program counter (pc) and size are used to compute the subsequent value of the program counter. The form of the class fact is not pertinent to this work but is available for scrutiny.

To ensure the termination of the unfolding process in the construction of the SLD-trees, it is feasible to opt out of further unfolding a goal and instead leave a leaf in the tree with a non-empty, potentially non-failing, goal. The resultant SLD is termed a partial SLD tree. It is worth noting that despite the finiteness of the SLD trees for all possible queries, the SLD built during partial evaluation may be infinite. This is because the specialization SLD tree can have more branches (including infinite branches) than the actual SLD tree at run-time due to unknown dynamic values at specialization time. The selection of which atom to choose from each resolvent and when to halt unfolding is governed by the unfolding rule.

A systematic extraction of a partial evaluation of p with respect to s can subsequently be derived from the resulting set of atoms t. The concept of resultant is leveraged to create a program rule associated with each root-to-leaf derivation of the SLD trees for the final set of atoms.

With regards to the efficiency of the partial evaluation process, it is important to note that the use of control strategies based on embedding introduces a substantial overhead, as it necessitates the tracking of ancestors and the execution of costly embedding checks for each atom argument.

The introduction of the "const" type, denoting constant, is primarily aimed at enhancing the efficiency of the specialization process. This type should only be applied to arguments expected to always be instantiated with the same value during specialization. While its usage does not impact the control strategy, it eliminates the need to repeatedly test the embedding relation on arguments that remain constant throughout the decompilation process, such as the "program" argument.

The question arises as to whether it is possible to consider the past generalization history when abstracting an atom at the global control. The notion is to retain information that has been reluctantly discarded during the partial evaluation process and promptly discard it for all new atoms resembling those handled previously under certain criteria. This approach is motivated by the likelihood that such information will ultimately need to be disregarded, with the aim of improving specialization times and the size of the residual program. The paper proceeds to propose the enumeration of pairs of numbers with different signs. Additionally, it utilizes four benchmarks that extensively utilize object-oriented features such as instance method invocation, field accessing and setting, object creation and initialization, etc. The operations add, exp, and simp pertain to distinct computations over rational numbers represented as objects, while forward is invoked on an object representing a date and advances it by one day.