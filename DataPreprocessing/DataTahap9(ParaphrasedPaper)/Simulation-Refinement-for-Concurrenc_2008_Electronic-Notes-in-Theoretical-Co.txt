In recent times, we have expanded upon the theory proposed by Abadi and Lamport (1991) regarding the existence of refinement mappings. This paper provides an overview of various extensions to the theory, as well as recent applications for practical verifications. The paper also presents a summary of the results on semantic completeness and discusses the relationship between semantic completeness and methodological convenience.

The problem with concurrent algorithms often starts with their specification, as they are typically reactive programs that begin in an initial state, interact with the environment, and may terminate unexpectedly. These programs cannot be captured solely by preconditions and postconditions.

The paper outlines the fundamental formalism, including specifications, executions, behaviors, invariants, strict implementations, and simulations. It also discusses a range of (non)atomicity conditions, followed by the verification of a lock-free implementation of a row of atomically modifiable variables.

A visible specification k is considered to strictly implement another visible specification l if every observed behavior of k is also an observed behavior of l. To prove such an assertion, it is necessary to introduce simulation relations.

It is widely recognized that refinement functions alone are insufficient to establish all simulation relations. The concept of forward simulations is introduced as a natural method to demonstrate that one specification simulates another by constructing corresponding behaviors inductively.

Apart from concurrent algorithms, the paper also addresses problems related to shared variables, including the potential chaos that can arise when multiple processes concurrently access a shared variable. Furthermore, the paper discusses avoiding the ABA phenomenon and implementing atomically modifiable variables of arbitrary types.

The correctness of algorithms involving shared variables is addressed, along with the modeling of assumptions regarding the consistency and safety of array elements. The discussion also incorporates the notion of prophecy, which involves extending concrete specifications with a ghost variable to align with an abstract specification.

The paper also introduces conditions for forward and backward simulations, as well as nonstrict implementations and simulations, to account for the order in which phenomena occur during concurrency.

In conclusion, the paper emphasizes the importance of semantic completeness and its distinction from methodological convenience. Additionally, it extends the repertoire of tools used for practical verifications and presents a refinement criterion for atomicity of read-write variables. The authors also discuss the use of theorem provers in the context of verification projects, highlighting the need for refinement in addressing proof obligations.