Functional and functional logic languages typically utilize external data types for numbers and rely on the default implementation of the underlying language, such as C, for arithmetic operations like addition, subtraction, and comparison. This approach ensures efficient handling of complex arithmetic computations within the high-level language.

Nevertheless, in the context of functional logic languages, this method has a major drawback: it does not support guessing numbers through narrowing. Semantic extensions, such as residuation, enable the use of restricted logical features in conjunction with numbers. Residuating functions involving externally defined number operations are suspended on unbound free variables and need to be combined with a generator that specifies all possible values of a free variable. For instance, in the case of determining Pythagorean triples (a, b, c) with the equation a2 + b2 = c2, the search suspends the test for a combination of a, b, and c as a Pythagorean triple due to the inability to guess natural numbers, and the programmer must provide effective generator functions to enumerate the search space efficiently.

It is important to note that this approach yields a partial function, as it does not define a Peano representation of negative numbers. By employing narrowing, a solution for the constraint add r m =:= n generates a binding for r, representing the result of the substitution.

Regarding termination, due to laziness, functions are typically defined on infinite numbers, leading to two categories of termination, which apply specifically to deterministic expressions. When considering the result type ordering as a simple enumeration type, head normal form (HNF) termination and normal form (NF) termination coincide, and we simply refer to it as termination. The function compnat terminates whenever at least one of its arguments is NF-terminating and the other is at least HNF-terminating. It is noteworthy that the comparison only requires as many steps as the size of the smaller argument, which contributes to efficiency.

Moving on to the implementation of arithmetic operations for functional logic programming languages, we propose a different approach. We demonstrate that a binary encoding of integers as an algebraic datatype eliminates the need for explicit generation of free variables in arithmetic operations. We define all standard arithmetic operations on this datatype and illustrate that our implementation supports narrowing of unknown arguments to these operations. Practical experiments confirm that our implementation incurs significant overhead compared to primitive operations, but we argue that the benefits of narrowing outweigh this overhead.