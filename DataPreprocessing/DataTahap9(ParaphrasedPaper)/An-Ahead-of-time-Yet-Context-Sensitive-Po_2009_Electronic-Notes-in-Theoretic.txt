Concurrent behaviors pose challenges for program analysis on bytecode due to the absence of control flow structure and the explicit stack-based design. To address this, we conducted an analysis within the Soot compiler framework, utilizing the weighted pushdown system (PDS) library as the backend analysis engine. This analysis operates on Jimple, a typed three-address intermediate representation of bytecode supported by Soot. The results of the analysis can be embedded into the class file as attributes for further analysis or verification on bytecode.

Points-to analysis for Java aims to identify the set of heap objects, such as instances of classes or arrays, that may be referenced by reference variables at runtime. Many applications, including program understanding, program verification, and static analysis, rely on points-to analysis to understand the underlying control and data flow of Java programs. Due to dynamic object-oriented features like dynamic dispatch, points-to analysis is interdependent with call graph construction. Consequently, the construction of the call graph can be done either on-the-fly, as the points-to sets of call site receivers are computed, or ahead-of-time based on syntactical information of the program, such as CHA and RTA (Rapid Type Analysis).

Due to the lack of control flow structure and an explicit operand stack-based design, static analysis on bytecode is challenging. As a solution, we designed and implemented the analysis as a sub-phase of the compilation process within the Soot framework. Soot is an open-source compilation and optimization framework for Java, originally designed to simplify the development of new optimizations for Java bytecode and supports three kinds of intermediate representations of bytecode.

The paper is organized as follows: Section 2 introduces weighted pushdown model checking. Section 3 formalizes our abstraction and modeling of heap operations. Section 4 presents our ahead-of-time points-to analysis as an all-in-one weighted pushdown model checking. The framework for ensuring soundness property is outlined, and a prototype implementation is provided. Section 5 compares related work, and Section 6 concludes the paper with a discussion on future work.

In our paper, the encoding of programs as finite model checking involves representing program states as the product of global variables, local variables, and program execution points, encoded as states of finite automata. For pushdown model checking, the pushdown stack can simulate the runtime stack of program execution. The pushdown stack can be encoded to store calling contexts for procedure calls, similar to the program execution on a stack machine. We follow the convention defined in Definition 2.6.

The dynamic dispatch of a call edge necessitates the runtime type of the heap object pointed to by "s" to be compatible with the type "t" with respect to the method "m." This judgment on types should exactly conform to (such as Definition 3.5) or soundly approximate the Java semantics for dynamic dispatch.