Due to the increasing demand for processing power and the physical limitations on CPU clock speed, multi-threaded programming is gaining greater importance in current applications. However, these programs are susceptible to programming errors, particularly race-conditions and deadlocks, which are difficult to locate. Existing tools for detecting these faults are either hard to use, have limitations on the size of the code they can handle, or generate too many false warnings. This paper presents experiments using the publicly available tool Helgrind to debug a server application consisting of 500 kloc, and discusses the improvements made to the runtime analysis of C++ programs, resulting in a significant reduction of false warnings.

Runtime methods scale well but are limited in that they can only detect faults on the execution path, making it impossible to detect all possible data races. An efficient lock-set based runtime algorithm called Eraser was implemented in the open-source tool Valgrind, which is available for all Linux-x86 based environments. However, the number of falsely reported possible data races for C++ applications is too large, making the tool difficult to use. The solution presented in this paper combines both static and runtime analysis by automatically and transparently annotating the program. This annotation provides the runtime method with additional knowledge gathered from the source code structure, reducing false positives and enabling the analysis of programs where only parts of the source code are available.

The paper is organized as follows: Section 2 provides an overview of runtime methods for fault detection in multi-threaded programs and details the runtime detection implemented in Helgrind. Section 3 presents the method of source code annotation to make runtime analysis more accurate and describes the general environment for the experiments. Section 4 presents the results from the experiments, and finally, in Section 5, the paper concludes with a discussion of the results.

The paper further presents definitions of faults unique to concurrent programs and provides an overview of runtime methods for detecting these faults, followed by a detailed description of the algorithms implemented in Helgrind. Experiments with a data structure containing two elements are discussed to illustrate potential inconsistencies in the locking strategy and its impact on application performance. Additionally, the paper highlights the limitations of existing algorithms for detecting data races and discusses the combination of lock-set and djit algorithm to improve data race detection capabilities.

The need for both on-the-fly and offline analysis of race detection algorithms is discussed, as well as the advantages and drawbacks of each approach. The paper also addresses the impact of thread safety on system functions and provides insights into the detection of real bugs in analyzed programs during experiments. Finally, it discusses the limitations of existing race detection algorithms and the challenges in implementing these algorithms for real-world applications, such as the need to support the full ISO C++ language.