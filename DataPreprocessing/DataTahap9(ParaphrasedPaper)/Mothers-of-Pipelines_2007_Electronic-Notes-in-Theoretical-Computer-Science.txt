A wide range of implementations are possible for MOP, including out-of-order or in-order, speculative or non-speculative, superscalar or non-superscalar, etc. This approach allows for the separation of implementation-independent proof obligations related to ISA and MOP from those that depend on the details of microarchitecture (MA), potentially distributing proof efforts across different designs. 

The rules governing program counter (PC) updating, namely "pc update" and "speculate," are responsible for updating the PC. The former is based on the next PC value of the last parcel and follows the regular ISA flow, while the latter involves practically unconstrained speculative updating of the PC based on an arbitrary branch predict function. 

Approximately 400 goals were individually proven using CVC Lite. For the MA, the textbook DLX model was used and proven to be simulated in MOP by constructing and verifying the chains using CVC Lite. 

An example of Burch-Dill correctness was proven by Shen and Arvind using the flushing function defined as the normal form in a confluent system. They modeled an abstract out-of-order processor and a simple specification machine as term rewriting systems, with their implementation model similar to the intermediate specification MOP. Our work extended theirs by proving stuttering bisimulation. MOP serves as an intermediate model that allows reasoning about deterministic and more realistic implementations. 

As an example, a concrete intermediate model for a simple load-store architecture, MOP, was specified and proven to be correct. The textbook machine DLX was also verified against it, although MOP contains more than needed for verifying DLX and is designed for simulating microprocessor models with complex out-of-order execution. This area, along with improvements to the methodology and performance comparison with other methods, is left for future work.