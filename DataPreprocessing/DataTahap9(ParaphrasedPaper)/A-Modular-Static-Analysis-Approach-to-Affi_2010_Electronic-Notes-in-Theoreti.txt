Specifically, our method for abstraction utilizes affine constraints, or polyhedra, to describe pre- and postconditions as well as state transformers. We introduce an algorithm to calculate the transitive closure of such a state transformer, and demonstrate its efficacy through multiple examples. Our approach is straightforward, employing discrete differentiation and integration, in contrast to the typical abstract interpretation fixed point computation based on widening. We conduct experiments using previously published examples and obtain equivalent results without applying any heuristics.

Each program command, whether elementary or compound statement or procedure call, is approximated by an affine transformer, extending the underlying mechanism from states to state transitions. The notion of transformers is broad and is also utilized by Boigelot et al.

A command's precondition defines the set of possible program states before its execution, while its postcondition defines the set of program states after execution. The postcondition is the result of the precondition being transformed by the command transformer. A valid affine abstract postcondition encompasses the actual postcondition, constituting an over-approximation.

We consider a hypothetical scenario, as detailed in and recently reused by, where a robot car is required to autonomously follow a track painted on the floor. If it loses the track, it must avoid colliding with a wall; however, it should not come to an immediate stop as the track may be rediscovered. Additionally, the car should not accelerate excessively while searching for the lost track. The safety controller must ensure a limited time and bounded speed for searching the track, rendering the car safe if the track is sufficiently distant from the walls.

While we do not claim to achieve more precise results than others by using polyhedra instead of Presburger arithmetic, our approach prioritizes real-life cases over artificial or contrived examples. We assert that our simple and direct algorithm yields the same outcomes as iterative approaches like widening.

The concept of abstract acceleration introduced by Gonnord in has a similar goal to our algorithm, but it is implemented by pattern matching for specific cases, whereas we can handle function calls and any control construct as the loop body transformer is calculated modularly. Furthermore, the exploitation of accelerated cycles is heuristic-based and not a program transformation as in section 3.5, with the final result obtained iteratively. Our algorithm successfully processes all examples presented in., including the swimming pool scenario.

Kelly et al. present an algorithm for computing the transitive closure of a relation encoded by a Presburger formula. This heuristic involves the concept of a d-form relation that leads to an explicit transitive closure. It is suggested that any relation can be converted into a d-form at the expense of accuracy. However, we demonstrate that it is not essential to convert the relation into a d-form to achieve an explicit transitive closure. We elucidate a method for transforming any relation into constraints on state evolution and outline how to obtain precise results by deferring convex hull operations.

A dual technique has been developed to derive predicates over arrays, corresponding to those found in., by the application of monotonicity analysis. Monotonicity analysis has also been employed to broaden induction variable detection, the inverse transformation of strength reduction. Essentially, assignment statements nested in loops are considered monotonic if the assigned value increases from one iteration to the next, and the precise value of the difference is abstracted by its sign. This information does not lead to loop invariants, but it is valuable for dependence testing and array bound checking. We could extract similar information from T+ by introducing difference variables and eliminating program variables.

We present a simple algorithm for computing affine invariants over integer scalar variables in while loops. Its development and enhancements have primarily been driven by practical applications, targeting the domain of automatic program analysis and transformation. Its low complexity is crucial for addressing large scientific codes of up to 100 kloc. While it performs well on standard program test cases, it is less effective on complex automata whose states and transitions do not lend themselves to straightforward C encodings.