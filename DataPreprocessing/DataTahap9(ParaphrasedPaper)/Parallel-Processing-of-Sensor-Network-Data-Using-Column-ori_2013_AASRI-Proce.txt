The remainder of the paper is structured as follows: in Section 2, we review related work. In Section 3, we introduce a new join algorithm based on column-oriented databases and parallelism. The performance of the proposed algorithm in comparison to traditional join algorithms for sensor networks is evaluated in Section 4. The concluding remarks are presented in Section 5.

The region near the base station is critical for join operations in sensor networks. One approach to address this challenge is the Synopsis Join (SNJ) algorithm. This approach utilizes sensor reading synopses to eliminate irrelevant readings from the join results. Another technique is the Record Filtering Using Bit-Vector (RFB) algorithm, which leverages bit vectors generated after performing semi-join to filter unnecessary data before transmitting data from each node to the join region.

Optimization techniques play a crucial role in enhancing the performance of column-oriented databases. Materialization strategies, including early and late materialization, are crucial for query reconstruction. The Invisible Join extends previous work on optimizing star schema queries using a column-oriented layout. A join algorithm based on column-oriented databases, referred to as EM, has been proposed for processing join operations in sensor networks. The EM algorithm is based on an early materialization strategy within a column-oriented database.

In this study, we assume that sensor data are stored in a column-oriented database rather than a relational database. Column-oriented databases store data column-wise, which differs from the row-wise storage in relational databases. This storage approach is more efficient for read-only queries, as it only accesses the attributes or columns required by the query from the disk. There are two materialization strategies, early and late, in column-oriented databases. Materialization, also known as tuple stitching or tuple construction, involves combining single-column projections into wider tuples and is essential for outputting row-style tuples to support standard-compliant relational database interfaces such as ODBC and JDBC. In the early materialization strategy, each column is added to the intermediate query result to form tuples if the column is needed. In the late materialization strategy, the accessed columns do not form tuples until after a portion of the query plan has been processed.

The proposed algorithm is a distributed algorithm involving the R-region, S-region, join region, and the sink node. The R (S) region contains multiple sensor nodes, each storing a portion of relation R (S). Additionally, the join region F also contains several sensor nodes that collaborate to execute distributed join operations. The join algorithm, which adopts a late materialized strategy, operates in three phases: the selection phase, the join phase, and the result phase. In the selection phase, the join column values are initially sent to the join region F. During the join phase, a semi-join is performed between the join columns of R and S to transmit only qualified column values from the R-region and S-region to the join node F. In the result phase, the qualified column values of R and S are stitched together to construct tuples, which are then transmitted to the sink node.

The result phase of the proposed algorithm comprises two steps. In the first step, at each node in F, the position list and bitmap from the first step of the join phase are used to stitch together the column values of R and S to construct tuples. The tuple stitching occurs in parallel at each node in F. It is assumed that metadata is present to map the column values of R and S given the position list and bitmap. In the second step, the constructed tuples from each node in F are transmitted to the sink node as the query result.

Given that sensor nodes in the sensor network are independent, this architecture provides a natural platform for utilizing a shared-nothing architecture to perform parallel processing. It is straightforward to adapt the distributed algorithm described to a parallel algorithm, assuming a shared-nothing architecture for the sensor network. The hash-based distribution ensures that tuples with the same join attribute value are always sent and joined at the same join node, enabling parallel execution of both the join and tuple stitching at each designated node.

To evaluate the cost-effectiveness of the proposed join algorithm, a performance analysis is conducted, comparing it with the existing SNJ, RFB, and EM algorithms. While SNJ and RFB algorithms are based on relational databases, the EM algorithm utilizes an early materialization strategy in column-oriented databases. The different algorithms are compared in terms of communication cost, which is measured by the number of bytes transmitted to various nodes to obtain the join result.

To streamline network traffic analysis, it is assumed that no failures occur during message transmission. The size of the message and tuple is assumed to be 40 bytes each. Additionally, for the given query, the size of the resulting join tuple (i.e., query result) is assumed to be 30 bytes. For column-oriented databases, the size of each column is assumed to be 10 bytes.

Although experimental data for the query response time using different join techniques for sensor networks is not included in this paper, it is deemed that the primary performance criterion for sensor networks is the total communication cost. However, it is evident that the query response time using the parallel version of the proposed algorithm is faster than other algorithms not based on parallel computing. With our algorithm, the involvement of more sensor nodes in query processing leads to a faster query response time, as both the join and data shipment can be performed in parallel.