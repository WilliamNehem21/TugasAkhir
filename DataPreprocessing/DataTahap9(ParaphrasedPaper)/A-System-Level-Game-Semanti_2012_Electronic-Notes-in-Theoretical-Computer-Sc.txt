We investigate a relaxed game model utilizing an idealized type-free C-like language. The concept of an available move is captured through a notion of secret akin to that used in models of security protocols and formally represented using names. This results in an opponent with omnipotence but limited omniscience, capable of making any available move in any order, but with the ability to have certain moves hidden from its view. This parallels the Dolev-Yao attacker model of security.

Upon calling a non-local function, control is transferred to the system, which corresponds in game semantics to a proponent question and is an observable action. Subsequently, all names that can be reached transitively from public names in the store become public, providing both control and information to the system. The observability of this action is marked by a label on the transition arrow, which includes a tag.

However, the private portion of the store (with domain in n\p) cannot be modified by s. Therefore, s has no constraints on its ability to interact with known names, but it is unable to manipulate private names it does not know. The restrictions on the continuation are hygienic, as previously explained.

Two programs, or libraries, implement a modulo-3 counter as an abstract data structure, employing private hidden state x. The environment can increment the counter (inc) or read its value (get) but no other operations are permitted. The first implementation counts up, while the second counts down.

Furthermore, we aim to demonstrate that a meaningful and useful notion of context for the execution of terms can be constructed outside the syntax of the language. This offers several advantages, including modularity, realism, and simplicity. It provides a semantic foundation for studying security properties of programs in a manner that is less reliant on syntax and more modular.

The study is carried out in compositional compiler correctness. While our focus is primarily analytical, seeking to characterize arbitrary (if not unrestricted) environments and operationally examine the behavior of open terms in such environments, compositional compiler correctness is primarily a synthetic concern, aiming to define constraints on machine code that permit safe composition between code generated via compilation and code generated in arbitrary ways. We regard these two approaches as two facets of the same problem and believe that a deeper understanding of their relationship should be pursued.

Semantic composition introduces a notion of private names: internal continuation names passed between the two modules to synchronize their mutual function calls. As shown by the previous lemma, these names remain private throughout the computation. Therefore, when checking bisimilarity for such reduction systems, special caution must be exercised to ensure that these private names cannot be captured by external system transitions. This is achieved by selecting only these names from the auxiliary set naux.