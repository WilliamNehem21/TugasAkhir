The remainder of this paper is structured as follows. In section 2, we provide a brief overview of mutation testing principles and discuss the barriers to its broader adoption. This is followed by section 3, which presents an outline of incremental mutation testing and formally demonstrates the soundness of this approach. Subsequently, in section 4, we introduce an instantiation of incremental mutation testing and offer an initial evaluation of the concept. Finally, section 5 presents a review of related work in the literature, while section 6 draws conclusions and discusses future plans in this area.

Additionally, we make the assumption that when given the composition of two programs, the mutation operator applies itself to each part sequentially, i.e., it does not span across both parts. This assumption allows us to independently reason about the sub-parts in the subsequent proofs. It is important to note that simple mutants were applied through mutation testing in all three scenarios. For each scenario, consisting of two code versions, v1 and v2, with v2 occurring chronologically after v1, traditional mutation testing was conducted on v2, while incremental mutation testing was performed on the differences between v1 and v2. In each case, we collected data on the total number of generated mutants, the number of killed mutants, and the execution time of the end-to-end process, including static analysis to determine which tests to execute.

JunitMax 8 is a unit test runner designed to provide continuous feedback to developers as they work. When a developer writes and saves code, JunitMax automatically checks for changes in the code and non-intrusively executes relevant test cases in the background. If there are any failures, the developer is promptly notified. This process significantly shortens feedback loops and leads to faster resolution times, as failures are likely related to recent changes made by the developer. This approach is reminiscent of incremental mutation testing in that it aims to provide regular, incremental feedback on the quality of a test suite as code evolves. Symbolic execution and automated static code analysis are both valuable techniques, but like mutation testing, they encounter scalability challenges. Efforts to address this issue have leveraged the incremental nature of software development to efficiently perform symbolic execution and selectively display results of automated static code analysis that developers are likely to find pertinent. While incremental mutation testing is not directly associated with these fields, we integrate these ideas to optimize the computational efficiency of mutation testing and expedite feedback to developers.