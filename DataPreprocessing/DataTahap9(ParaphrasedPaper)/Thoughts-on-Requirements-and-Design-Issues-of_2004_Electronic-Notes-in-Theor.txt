The gradual evolution of proof assistants differs from the less systematic development history of theorem prover user interfaces. While numerous projects in the literature of the 1990s had little impact and only attracted small user groups, some surviving systems, including proofgeneral and user interfaces for pvs and imps, are based on (x)emacs, indicating their popularity.

Most theorem provers have been built using functional programming languages from the ML and Lisp families, which lack graphical user interface (GUI) toolkits and provide limited support for lightweight concurrent processes compared to other languages such as C++, Java, or BASIC. To address these shortcomings, several projects have aimed to integrate functional languages with frameworks offering better GUI facilities, such as SML Tk and recent OCaml bindings for Tk and GTK+. Despite these efforts, the resulting development environments remain more cumbersome than using modern commercial GUI builder tools directly.

Due to the challenges mentioned above, only few academic institutions have the resources to develop and maintain fully customized user interfaces (UIs). Even these institutions would benefit from increased reuse to save developer time, indicating the importance for the academic theorem proving community to create reusable UI components and UIs.

An interactive proof involves initiating a logical formula (the initial goal) for proof, followed by a series of proof steps where the user analyzes the proof state and issues proof commands, which are executed by the prover to advance to the next proof state.

For example, when adding a new logical constant to an existing theory, the system should display relevant messages for illegal or failed proof commands, successful proof completion, warnings during proof step execution, proof step cancellation, and abortion of proofs. Additionally, functional programming languages should implement these categories as types, similar to how modern theorem prover systems organize their code around structures that group types and associated operations, akin to classes in object-oriented programming languages.

Auto-completion, intelligent object naming, and context-sensitive completion are beneficial for naming objects such as theories, theorems, and proof commands. Hiding irrelevant information and sorting items based on their usefulness can further reduce effort and improve user experience.

Other HCI design principles for theorem prover support include providing complementary views of proof constructions, ease of undo operations, flexibility in articulating commands to a prover, and support for concurrent proof constructions.

Graphical user interfaces (GUIs) have significantly transformed the use of computers, especially for novice and non-expert users, with their direct manipulation metaphor and the ability to manipulate complex objects. Hence, offering a choice between text-based and graphical interaction in the UI, as well as customization at different levels, is essential to cater to individual preferences and improve user experience.

Using a standard web browser for reading theories allows for reuse possibilities, hyperlinking, and user familiarity, while MathML promises to simplify the rendering of mathematical formulas. Representing theories as XML documents enables easy customization of presentations, either through XSLT or by transforming to HTML combined with CSS style sheets.

Basic validation of user inputs, awareness of textual commands, and direct parsing of formulas by the proof assistant can help improve the efficiency and accuracy of the UI. Furthermore, utilizing XML processing and web service standards for communication between generic UIs and proof assistant backends offers benefits in terms of extensibility and platform independence, despite potential performance drawbacks.