The paper introduces a new approach called linear concurrent constraint programming (LCC), which draws inspiration from linear logic and linear logic programming. This approach allows for the use of linear constraints, which are constraints that are removed from the global store once they are used by an agent. In contrast, Saraswat et al. proposed timed CCP (TCC), an extension of CCP with time modalities, and Knight et al. recently introduced another CCP-based language with spatial (SCCP) and epistemic (ECCP) modalities. These systems are designed to represent agents that can update or change the content of distributed spaces, and by changing the underlying subexponential structure, different modalities can be incorporated into the modeling and programming process. Additionally, the use of the linear logic meta-theory for reasoning about such systems is now possible.

The paper discusses two potential directions for further exploration. One approach involves proposing richer subexponential signatures in the context of SELL, which could lead to different computational behaviors. For instance, using the [0, 1] interval as the initial signature results in a calculus with a probabilistic flavor, suggesting the possibility of employing more complex topological spaces such as Hilbert spaces to achieve interesting concurrent systems.

A key distinction of the approach introduced in the paper is that, unlike standard presentations of linear logic, the proposed approach allows for an unbounded number of logically distinct prefixes, such as !i or !i?j. Agents are shown to have an internal structure, with their local store being divided into locations identified as different subexponential indices in the signature. Unlike SCCP, unbounded linear locations are permitted in this approach to specify spaces where information can be updated.

Similar to most process calculi, the language of processes of DCCP features a small number of constructors that can express interesting behaviors of concurrent and distributed systems. Common to all languages based on CCP, constructs are included to add (tell) new information to the store, hide (local) variables, and compose processes in parallel. Free variable quantification is allowed in ask processes, and information consumption occurs when evolving due to the linear nature of the store. The subexponential structure can be modified to specify persistent and linear stores. Additionally, processes can be confined to specific spaces in DCCP, and the creation and communication of shared communication spaces between agents is possible. The ability to create shared spaces is given a declarative meaning with the connectives d and a in SELL.

The paper also discusses two types of restrictions: restriction (i) prevents agents from executing processes in the space of other agents, while restriction (2) disallows agents from reading from the store of another agent. Furthermore, processes such as tell([c]g(l)) in the agent f are interpreted as asynchronous communication from f to g.

The rule rs is introduced to explain the processes [tell(c)]l and [ask c then q]l. For the process [tell(c)]l, the constraint [c]l is added to the store, confining the output to the space l. In the case of [ask c then q]l, determining whether q should be executed requires inferring whether c can be deduced from the information in location l. The new store in that location, represented by dj, is placed at location l as shown in the conclusion of the rule.