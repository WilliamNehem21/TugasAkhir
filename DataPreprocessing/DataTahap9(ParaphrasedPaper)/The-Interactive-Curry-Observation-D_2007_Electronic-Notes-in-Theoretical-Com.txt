Code modifications are automatically made before execution to enable step-by-step evaluation of data structures and functions in a separate window, aiding beginners in understanding the lazy execution semantics of Curry. This approach offers the advantage of implementing independent system processes for all views, which can be distributed across multiple computers to prevent slowdown or memory shortage during observed executions. Additionally, observation sessions can be saved and reloaded for debugging purposes. The tool is developed in Curry using libraries for GUI programming [10, 11] and meta programming available for the Curry system PAKCS.

The function observe acts as an identity on its third argument while generating a trail file representing the evaluated part of the observed data as a hidden side effect. To differentiate between different observations, observe takes a label as its second argument. After program termination, all observations are presented to the user based on their respective labels. Furthermore, observe requires an observer as its first argument.

Explicit annotation of the observer for each type is required, as Curry does not conceal these observers from the user as Haskell does with type classes under the hood. However, the explicit annotations also offer a benefit - it allows for the use of different observers for the same type, enabling selective masking of substructures in large observed data structures. For instance, the predefined observer "oopaque" presents every data structure with the symbol #.

Observing functions can aid in detecting bugs, especially in larger programs, although it often requires an iterative process of adding and removing observers to locate the bug, similar to the debugging session sketch for the sublists example. There is a need for a tool that supports the programmer in adding and removing observers.

One of the challenges of using Coosy, especially for beginners, is defining observers for newly introduced data types. Although Coosy offers useful abstractions for this task, defining corresponding observers for every user-defined data type is necessary to observe values of that type. Our tool addresses this by automatically deriving these observers, not only for defined data types in the program, but also for data types imported from other modules. This automatic derivation generates generic observers for all data structures defined in the program and is applied to imported data types, streamlining the process of adding observers.

Observing subexpressions in the right-hand sides of rules can be necessary to locate a bug, and ICode provides a tree representation of the entire program, allowing the user to select arbitrary subexpressions to be observed. ICode automatically generates labels for the observers, simplifying the identification of observations. It also supports adding observations to different modules of a project and checks for the availability of an observer version for each imported module to be executed.

With the increasing popularity of distributed programming, ICode utilizes a client/server architecture for showing the observation steps in separate viewing tools. Each observation label in the trace file contains information about observed values and is displayed in separate trace windows, enabling the programmer to track the progress of the execution for each observed expression. The generation of observations for each observation label in the trace file follows a bottom-up approach, but a top-down algorithm is needed for continuous updates of observed data terms, allowing extensions in all possible leaf positions of the presented data structure.

In addition to observing functions, ICode provides a feature that allows the programmer to follow the order of program execution and to mark the corresponding position of the actual expression in the viewer. This technique serves as a light-weight implementation of program slicing and can be used for improving debugging.

Distributed programming facilitates the sending of observed expression information through a socket and displaying computed expressions in trace windows in parallel. The trace windows separate the display of observation steps for selected expressions and offer a clear result for programmers. Observations of desired expressions are automatically added by ICode, and a tree containing all program expressions is provided for the programmer to activate automatic annotation writing in a separate file without altering the original program.

For future work, the focus will be on improving observations of polymorphic functions and investigating how the tool can be used as a platform for other development tools for Curry, such as refactoring, test environments, and program analysis. Moreover, the tool's meta-information about debugged programs could potentially be leveraged to improve debugging by automatically adding observations to many program functions and deriving information about the connection between different observations.