The emerging field of quantum computation and quantum information is still in its early stages, primarily due to the absence of a practical quantum computing device. However, the theoretical potential of such devices is widely recognized. Currently, the only feasible approach for computer scientists to explore quantum computing is through the use of quantum computer simulators.

Several quantum simulators, including tools for analyzing quantum circuits and interpreters for quantum programming languages, are available. The work presented here is closely related to that reported in previous research and addresses the challenges associated with the design of quantum programming languages. Our work contributes a more comprehensive suite of tools comprising distinct but interacting parts for compilation and simulation, as well as the capability to store compiled code.

The classical component of our system consists of two separate memory locations for programs and data. We have opted to deviate slightly from the traditional von Neumann model, in which programs are treated in the same way and stored in the same location as the data they manipulate. The CPU maintains the current instruction in a program through the program counter, which indexes a location in the program store.

The operational cycle of the system begins with the initialization of the program counter, local base, and stack top to 0. An instruction is retrieved from the location indicated by the program counter, executed, and the process is repeated. Most instructions cause the program counter to be incremented, while some, such as jumping and halting instructions, have different effects. Program execution concludes when the program counter exceeds the end of the program store.

The example predominantly illustrates quantum instructions, with the functions performed by classical instructions being familiar to most readers. A quantum programming language provides a graceful blend of classical control structures and quantum operations, which is challenging, if not impossible, to implement in the standard quantum circuit model. The use of quantum programming languages aligns well with the model of computation used by our system and most quantum algorithms, providing a computational model more familiar to computer scientists than the circuit model, thereby facilitating the development of new quantum algorithms.

The inability to clone an unknown quantum state directly impacts statements involving assignment, including direct assignment and passing values to functions. Additionally, a transformation is applied to a quantum data type using the "=" operator.

In implementation, the system only provides operations corresponding to universal gates, and the decomposition of any quantum operation into these gates is the responsibility of the compiler. The compiler's work encompasses bringing together a variety of prior research on the decomposition process and providing an analysis of its efficiency.

The activated cnot gates are consistent with the control qubit being 0, rather than the more conventional 1. The generation of a series of cnot gates rearranging the computational states in the appropriate manner is facilitated by a solution involving the use of gray codes.

This paper avoids discussing the specific physics involved in building a quantum computer; however, it indicates integration of physical constraints, such as those related to using the ion trap technique, into the system's design.

The QPL compiler currently implements only a subset of QPL, focusing on those parts necessary to test the ideas presented in this paper. Future work will entail further development of classical control structures, expanded support for lists, and the incorporation of features for concurrency and communication. Additionally, there are plans to include support for CQP in the QPL compiler, as the simulator has already been updated to support it.