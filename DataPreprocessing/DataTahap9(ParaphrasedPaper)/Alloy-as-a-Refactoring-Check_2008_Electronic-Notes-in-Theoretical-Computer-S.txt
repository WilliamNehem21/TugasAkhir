Furthermore, in addition to denoting the actual process of modifying software, refactorings also serve as generic descriptions of recommended modifications to the program. For instance, a well-known book by Fowler outlines a collection of 72 refactorings meant to systematically enhance the structure of object-oriented code. However, it should be noted that refactorings are not confined to programs exclusively, as they are also employed in other areas such as modeling, including the refactoring of UML models and formal specifications.

In the subsequent section, we provide an example of a minor Z specification and demonstrate its translation into the Alloy language. Section 3 addresses the reasons why the Alloy analyzer is unsuitable for verifying refinements and identifies the conditions under which refactorings can nonetheless be checked. We elaborate on the limitations of the translation in section 4 and conclude in the final section, along with a review of related works.

The declarative specification language "Alloy" was developed by the software design group at MIT CSAIL and is based on first-order logic, enabling automatic analysis. The Alloy analyzer offers fully automatic simulation and checking of specifications written in Alloy. It translates a given model into a boolean formula and submits it to a SAT solver, which then attempts to find a model of this formula. The examples presented in this chapter relate to the Alloy analyzer version 4.0 rc11, which is available for free.

Working with integers in an Alloy model has certain limitations. For instance, the treatment of "int" as a signature means that it does not directly represent integers but rather atoms representing numbers. Furthermore, specifying the range of integers to be used is not straightforward, as the scope of "int" is set to 4 int by default, encompassing 16 integer values ranging from -8 to 7. This limited support for integers is attributed to technical considerations, as encoding numeric manipulations into CNF and converting from "int" to "int" (and vice versa) is costly.

Alloy signatures allow some form of inheritance, which is advantageous. However, this concept cannot be generally utilized to implement the schema operations available in Z. In order to enable a translation, it is suggested to resolve all schema calculus operations on state schemas before translating the Z specification. It is important to note that information about schema operations will be lost in the event of a retranslation.

This paper explores how Alloy can be used to verify the preservation of behavior in refactorings. The translation from a Z specification into the Alloy language is found to be straightforward and intuitive, yet it has its limitations. The existential quantifier poses challenges within the translation and complicates the verification of refinements. Nonetheless, it is demonstrated that the Alloy analyzer can be employed to verify the correctness of refactorings under the assumption of a total bijective representation relation between the original specification and the refactored one, which is applicable to many refactorings.

The Z specification language has been criticized for its lack of verification tools, which is partially addressed by Alloyâ€™s automatic analysis capabilities. The high level of similarity between the two languages facilitates the translation process, supporting the specification writing process. However, in the context of developing a refactoring tool that uses Alloy or another model checker only as a back-end system, the elegant translation might not be as critical. Instead, it is important to assess whether the assumption of a total bijective representation relation hinders the verification of practical refactorings. Furthermore, a performance analysis comparing the Alloy analyzer to other model checkers like SAL would be a valuable area of future research.