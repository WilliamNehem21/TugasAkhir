Due to the known complexity of the subgraph isomorphism problem, which is NP-complete in general, the graph pattern matching step is recognized as a critical aspect affecting the overall performance of a graph transformation engine. The diversity of tools is predominantly distinguished by the various strategies utilized for graph pattern matching, which can be broadly categorized into two main groups.

A dataflow network, structured as a directed acyclic graph, is formed based on the conditional parts of rules. This network initially receives basic facts through its input channels, with compound facts composed of elementary facts serving as inputs for internal nodes. When a fact reaches a terminal node, the associated rule becomes applicable, and modifications to the set of basic facts may be carried out according to the then part. As each node maintains a record of its input facts, only modifications to these facts need to be tracked at each step.

In the realm of relational databases, incremental updates for views are feasible. A database view represents a query on a database that computes a relation not explicitly stored in the database. However, in the view materialization approach, the view is explicitly maintained as a stored relation. When a base relation changes, the views dependent on it may require re-computation.

This paper presents initial experiments involving the mapping of models and metamodels into an off-the-shelf relational database to implement the incremental update technique for the dining philosophers problem. It is noted that while the integration of database and graph transformation techniques has a longstanding tradition, previous approaches have predominantly used graph-oriented databases, unlike the relational databases employed in our study.

The metamodel defines the abstract syntax of a modeling language and can be formally represented as a type graph, with nodes representing classes. Inheritance and associations define relationships between classes, where inherited classes possess the properties of their parent class and may contain additional attributes.

An example rule is illustrated wherein a philosopher tries to grab their right fork when already holding the left fork, provided the right fork is not held by another philosopher. This constraint is expressed by the negative application condition (NAC), and the rule specifies the action of the philosopher grabbing the right fork as the outcome of rule application.

In the context of pattern matching, considering negative application conditions without involves significant speed differences; inc mode without negative conditions is 7.9 times faster than fs mode, and this difference increases to 56 times when negative conditions are considered. When all five rule applications are taken into account, the overall execution time is 22 times faster in inc mode with negative conditions and 3.3 times faster without negative conditions. Despite the inclusion of an initialization phase, inc mode still demonstrates a two-fold advantage.