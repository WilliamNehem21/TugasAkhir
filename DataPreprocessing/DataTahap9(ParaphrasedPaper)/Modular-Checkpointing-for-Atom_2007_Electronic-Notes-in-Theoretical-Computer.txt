Transient faults that occur in large-scale software systems can often be resolved by re-executing the code in which they occur. However, providing a meaningful interpretation for safe re-execution in multi-threaded code can be challenging. For a thread to correctly re-execute a section of code, it must ensure that all other threads that have observed its unwanted effects within that section are also reverted to a consistent earlier state. Failure to do this properly can lead to data inconsistencies and other undesired behavior. However, automatically determining what constitutes a consistent global checkpoint is not straightforward, as thread interactions are a dynamic property of the program.

In this paper, we introduce a safe and efficient checkpointing mechanism for concurrent ML (CML) to recover from transient faults. We propose a new linguistic abstraction called stabilizers, which allows for the specification of per-thread monitors and the restoration of globally consistent checkpoints. Our checkpointing abstraction provides atomicity and isolation. We demonstrate the use of stabilizers for large server applications written in concurrent ML and present a case study on extending stabilizers into transactions to provide atomicity and isolation guarantees during the execution of monitored code.

To address the challenges of defining and restoring safe and efficient checkpoints in concurrent functional programs, we propose stabilizers as a middle ground between operating system or compiler-injected checkpoints and user-injected checkpoints. Stabilizers ensure that a thread is rolled back to a consistent state, and they provide a means for identifying program points where local checkpoints should be taken. The implementation of stabilizers involves tracking shared memory updates and communication events among threads, as well as implementing a fast restoration procedure.

We conduct a detailed evaluation of the costs and overheads of using stabilizers for transient fault recovery, and we demonstrate their potential effectiveness in mitigating the complexity and improving the robustness of highly multi-threaded applications. We extend stabilizers into open nesting to support the combination of transactional software with classically synchronized libraries.

In addition to stabilizers, we discuss other approaches for fault recovery, such as the use of continuations and micro-reboot. We compare stabilizers to other checkpointing schemes and assert their effectiveness in simplifying program structure, error handling, debugging, and consistency management. Our results indicate that stabilizers can be implemented with minimal overhead and are well-suited for implementing higher-level abstractions such as transactions.