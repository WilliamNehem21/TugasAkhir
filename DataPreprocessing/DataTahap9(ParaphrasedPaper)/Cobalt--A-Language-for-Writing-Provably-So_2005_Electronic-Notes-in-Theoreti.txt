This section provides an overview of the current state of the cobalt language. It informally introduces cobalt and outlines the method for demonstrating the soundness of cobalt optimizations through a small example. Further details regarding the language, the automatic soundness proof technique, and the implementation of the language and its soundness checker can be found in a previous paper. Section 2 discusses the current and future directions for enhancing the expressiveness of cobalt while maintaining automated soundness checking, while Section 3 covers related work. The paper concludes with Section 4.

In addition to optimizations, cobalt enables users to create pure analyses that do not perform transformations. These analyses can be utilized to compute or verify properties of interest in a procedure and to supply information for use by subsequent transformations. A pure analysis defines a new label, and the result of the analysis is a labeling of the given control flow graph (CFG). For example, a "does-not-point-to" analysis can be defined, leading to the annotation of CFG nodes with labels such as "doesnotpointto(x, y)." This new label can then be utilized by other analyses, optimizations, or label definitions, such as in making the definition of "maydef" in Section 1.2 less conservative in the presence of pointer stores.

A forward pure analysis resembles a forward optimization, except that it lacks a rewrite rule or a profitability heuristic. Instead, it includes a "defines" clause that assigns a name to the new label. The method for proving the soundness of a pure analysis is a slight variation of the approach for proving the soundness of a forward transformation pattern.

Current efforts on cobalt are focused on enhancing expressiveness while retaining the ability to automatically reason about soundness. A second version of the language, cobalt v2, is being designed to incorporate lessons learned from the first version, cobalt v1, while significantly enhancing its capabilities. This section provides a simple example to illustrate what cobalt v2 will look like, with a focus on pure analyses, which best showcase the advantages of cobalt v2, though transformations can also be easily adapted to the cobalt-v2 style.

In cobalt v1, a pure analysis states the conditions under which a node should be annotated with a particular label, also known as a dataflow fact. Global conditions are appealing because they succinctly describe the nodes that should be annotated with a given dataflow fact. However, to automate soundness reasoning, restrictions must be imposed on these global conditions, and in cobalt v1, only one stylized form of global condition is supported. In cobalt v2, the main idea is to provide the analysis writer with stylized local conditions, which can then be combined in flexible ways to achieve various kinds of global conditions.

Another advantage of cobalt v2 is that the local if-then rules can be viewed as flow functions, whereby they determine the outgoing dataflow facts to propagate based on incoming dataflow facts. This interpretation provides a familiar explanation of cobalt in terms of concepts already known to many analysis writers, making the language more accessible. Furthermore, because the flow-function formalism aligns with the commonly used formalism in the analysis community, much previous work on dataflow analysis should seamlessly adapt to cobalt v2.

The authors emphasize the similarity between cobalt v2 and previous work on composing and staging dataflow analyses, as well as deriving interprocedural analyses from intraprocedural ones. The paper also discusses the whitfield and soffa's work on the Gospel language and its similarities and differences with cobalt.

The paper concludes by highlighting the potential of cobalt as a step toward user-extensible compilers, enabling programmers to add unusual or domain-specific analyses and optimizations easily and safely.