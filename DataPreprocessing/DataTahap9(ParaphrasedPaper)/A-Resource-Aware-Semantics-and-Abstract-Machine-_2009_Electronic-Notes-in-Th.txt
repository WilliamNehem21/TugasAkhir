The programming language Safe is characterized by its first-order eager nature, support for heap regions, and unique features such as programmer-controlled destruction and copying of data structures. These regions, which are distinct parts of the heap used for allocating data structures, eliminate the need for a runtime garbage collector. The language and its associated type system ensure that destruction facilities and region management are carried out safely.

In this paper, we begin with a high-level big-step operational semantics for Safe and proceed to derive its compilation to an imperative language and imperative abstract machine through a series of semi-formal steps. Once the memory requirements of the machine are determined, we enhance the semantics with memory consumption annotations and establish the correctness of the enriched semantics with respect to the translation and the abstract machine. We carefully derive each step to enable a clear understanding of the translation and to formally establish its correctness.

The allocation and deallocation of regions are tied to function calls, with a region being allocated upon entering a function call and deallocated upon exiting it. Within a function, data structures can be constructed and destructed using destructive pattern matching denoted by "!" or a "case!" expression, which deallocates the cell associated with the outermost constructor. Recursion allows for the deallocation of recursive portions of the entire data structure.

The function insertd represents the destructive version of insertion in a binary search tree, while mktreed precisely consumes the space occupied in the heap by the list. Copying of data structures is denoted by "appending@" to a variable, where only the recursive part of the structure is copied, while the elements are shared with the original instance. This feature is useful for creating non-destructive versions of functions based on the destructive ones, such as defining treesort as treesortd(xs@).

Polymorphic algebraic data types are defined through data declarations, and after region inference, additional type variables indicate the regions where the constructed values of that type are allocated. Region inference also adds region arguments to constructors, enforcing the restriction that recursive substructures must reside in the same region as their parent.

A new region is allocated during the evaluation of a bound expression, denoted by rule app. The body of the function is executed in a heap with k+2 regions, and the local region is deallocated after function application. The current environment is extended with new bindings as soon as let-bound or case-bound variables become free variables in scope in the continuation expression, as well as in rules copy and reuse with a fresh program variable "y".

Overall, the paper presents a detailed exploration of the operational semantics, compilation, and memory management of the Safe language, and establishes the correctness of its enriched semantics with respect to translation and abstract machine execution.