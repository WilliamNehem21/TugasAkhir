The difference in grammars raises the question of whether the rules that determine the order of operations in one grammar are compatible with those of another. This is often not clear due to the complexity of precedence rules in some languages, and because the semantics of precedence rules for certain parser generators are operationally defined, making it difficult to understand their impact on the defined language. This paper introduces a method and tool for comparing the precedence rules of different grammars and parser generators. While it is undecidable whether two grammars define the same language, this tool provides support for comparing and recovering precedence rules, especially valuable for reliably migrating a grammar from one formalism to another. The effectiveness of the method is evaluated through its application to non-trivial mainstream programming languages, such as PHP and C.

Various parser generators feature different parsing algorithms and grammar formalisms, often providing ways to specify the precedence of operators, given the importance of priority and associativity in defining the syntax of programming languages. Aho and Johnson recognized early on that for many languages, the most natural grammar is not accepted by the parser generators used in practice, as the grammar does not fall into the class of context-free grammars for which the parser generator can produce an efficient parser. This paper argues that precedence rules need to be disentangled from the specifics of particular parser generators, with a focus on advancing an engineering discipline for grammarware. While the idea of liberating grammars from concrete parser generators is not new, precedence rules have not previously been studied independently of specific parsing technologies or parser generators.

The paper presents a method and its implementation for recovering precedence rules from grammars, based on a formalism that is independent of specific parser generators. The recovered precedence rules are then compared using a common representation achieved through grammar transformations. The evaluation of the method is carried out by applying it to non-trivial mainstream programming languages, C and PHP. The method's effectiveness is supported by the identification of discrepancies and errors in the precedence rules of the grammars during the evaluation.

The paper outlines a formalism for precedence rules and its independence from specific parsing techniques. It also discusses the need for comparison of precedence rules between grammars and the challenges involved in such comparisons, emphasizing the need for adequate methodology and tools in this area. The paper concludes by highlighting the value of the method and tools presented, especially in aiding the semi-automatic recovery of grammars from language references and existing compilers. The approach is positioned as a step towards addressing the need for proper foundations and practices for grammar engineering, with potential for advancing more automation in grammar recovery processes.