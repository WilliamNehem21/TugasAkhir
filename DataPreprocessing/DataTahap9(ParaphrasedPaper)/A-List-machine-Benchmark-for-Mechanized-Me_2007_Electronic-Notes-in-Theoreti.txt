We propose a new standard to evaluate theorem-proving systems based on their ability to express proofs of compiler correctness. Unlike previous standards, which focused on demonstrating proofs, we highlight the connection between proofs and compiler implementations. Additionally, we emphasize that many tasks can be accomplished without the need for binders or alpha-conversion. We establish specific criteria for evaluating mechanized metatheory systems and provide solutions in both Coq and Twelf metatheory. Furthermore, we draw conclusions regarding the effectiveness of these two systems in particular.

We will assign a list type to each live variable at every program point in the context of a type system. To ensure the safety of certain operations, we offer refinements of the list type for nonempty lists and empty lists. Specifically, fetch-field operations require that their list argument has a nonempty list type, and the branch-if-nil operation is enforced.

In the LF system, it is possible to perform computations on the derivation trees themselves. For instance, consider writing a Prolog program (set of clauses) that takes a derivation tree for type-checking as input and produces a derivation tree for safe (non-stuck) execution as output. If this program is total (that is, it successfully terminates on any input), we can constructively prove that any well-typed program is safe.

When reasoning about this meta-program, we use machine-checked %mode declarations to clarify the inputs and outputs of the derivation transformer. We also employ machine-checked %total declarations to ensure that our meta-program covers all potential cases and does not enter into an infinite loop. An example of such a proof is provided in section 6, items 6 and 7.

Both Twelf and Coq make it straightforward to represent inductive definitions similar to those found in structural operational semantics (SOS). In Coq, we also have the option of representing operations over mappings (e.g., lookup and update in stores) either as relations (defined by inductive predicates) or as functions (defined by recursion and pattern matching).

Deriving an example of type-checking is straightforward in Twelf, as the type system can be run as a logic program. However, it is not directly possible in Coq because the specification of the type system is not algorithmic; it utilizes universal quantification over all variables to specify environment subtyping.

In the context of the logic program, the modes of the program specify which arguments are considered as inputs (+) and which are outputs (-). Formally, given any ground term p1 whose type is lub t1 t2 t3, our clauses must, if they terminate, produce outputs p2 of type subtype t1 t3, which are also ground terms.

We ask the metatheorem to check our claim that no execution of lub-subtype-left can result in an infinite loop with the %total p1(lub-subtype-left p1 p2) declaration. We verify that the execution either fails or produces a derivation of subtype t1 t3 and that all cases are covered. The use of p1 in two places in our %total declaration combines the thing to be proved with part of the proof, indicating that the induction should be carried out over argument 1 of lub-subtype-left, not argument 2.

To state the soundness theorem for the type system, in Coq, it is expressed as a statement of ordinary mathematics. In Twelf, the theorem is formulated by writing a logical predicate that relates a derivation of type-checking to a derivation of runs-or-halts, and then making the appropriate %mode and %total claims for the Twelf system to verify.

In the Coq environment, the type-checker is defined as a function from program typing and programs to booleans. To prevent an nÂ² algorithm, we represent environments and program typing as finite maps implemented by radix-2 search trees, which results in a typing algorithm with O(n log n) complexity.

Coq has the capability to automatically generate Caml programs from functions expressed in Coq, resulting in code that closely resembles what a Caml programmer would write manually when restricted to the purely functional subset of the language.