In the past ten years, the computing community has exhibited a growing interest in parsing techniques that go beyond conventional methods. There are numerous parser generators that enhance both top-down and bottom-up approaches with features such as backtracking and lookahead constructs. Some of these parsers, like precc, pccts, antlr, and javacc, exhibit unexpected issues, particularly in matching strings against ordered grammars, leading to difficulties in specifying the language matched by the parser. Despite the potential for exponential parse times in worst-case scenarios, the modern hardware can still support the use of such parsers. For instance, several Eiffel compilers employ Earley parsers to accommodate their flexible use of expression separators. Additionally, tools like ASF+SDF emphasize generality and can parse ambiguous languages with the support for shared packed parse forests. ASF+SDF uses generalized LR parsing to achieve this. Furthermore, the introduction of a generalized LR mode in GNU Bison indicates the incorporation of general techniques into mainstream parser generators.

Our aim is to introduce a structured approach to translator implementation that allows for reproducible experiments between competing techniques. To achieve this, we propose a script that can open up the degrees of freedom in translator implementation, similar to widely used parser generators like yacc or RDP. This script, called gtb, offers the capability to handle multiple grammars simultaneously and to extract multiple grammars from a rule set using different start symbols. It also provides functionalities such as grammar augmentation and the extraction of grammars from a particular start rule. Additionally, the gtb script can be used to generate sentential forms or sentences of a grammar, providing options for leftmost, rightmost, or random selection of the nonterminal for expansion. Moreover, it allows the specification of an upper bound on the number of outputs, if desired.

The design of programming languages such as Pascal and C reflects the top-down and bottom-up language design paradigms. Although Pascal is commonly associated with LL(1) parsing and C with LALR parsing, in reality, Pascal closely resembles LL(1) parsing, despite some ambiguities. For instance, lexical backtracking is required to distinguish between a real literal and an integer range in Pascal.

The difficulty of working with certain grammars is exemplified by the IBM VS-COBOL grammar, which posed challenges in terms of memory usage. Various transformations and annotations are required to convert extended Backus–Naur Form (EBNF) grammars into Backus–Naur Form (BNF) grammars. The tool 'ebnf2bnf' is used for these conversions, which involves constructing a rules tree from the original grammar and performing tree transformations under the control of annotations before writing the transformed grammar. This kind of operation has been supported in ASF+SDF, where the authors describe the EBNF-to-BNF conversion as "yacc-ification." Our tool prioritizes ease of use and traceability of the basic operations.