The process of combining components may result in the creation of multiple instances of the same component. Certain components, such as those relying on a unique external resource, may only be able to have one instance loaded at a time. To address this issue, we introduce an abstract component language and a type system that ensure the safe instantiation of components. The language includes features for instantiation, composition, and a simple scope mechanism for handling instances.

The binding mechanism for components in our approach bears resemblance to the "let" binding in functional languages like ML, as well as to lambda abstraction and application. However, the types used in our system are entirely different. To some extent, we were able to develop our type theory along the lines of pure type systems (PTSs), which increased our confidence in the chosen abstractions and demonstrated the generality of PTSs.

The underlying concept of our types shares some similarities with linear types, which typically express that a value will be used exactly once within its scope. In our case, the difference is that our system allows for at most one use. This distinction is reflected in our weakening and start rules.

This paper is structured as follows: in the next section, we introduce the component language along with its terms and operational semantics. Then, in section 3, we define types and the typing relation. Section 4 presents some properties of the type system, while in section 5, we outline a polynomial time type inference algorithm. Finally, we conclude with some remarks on future research, reserving technical proofs for the appendix.

A component expression "e" may utilize multiple components, some of which persist for the entire lifespan of "e," while others only exist temporarily before being discharged. To represent the type of a component expression, we use two sets: "xi" collects all components instantiated during the expression's lifespan, and "xo" consists of components with surviving instances after the expression's execution.

For instance, we provide the type derivation tree for {new b new d}new a, and we further define a well-typed program as one that can be typed in a basis built from its declarations. We also include an invariant theorem and its correctness corollary, which relate the type system to the operational semantics. Some technical proofs of lemmas are delegated to Appendix A to enhance the readability of this section.