An essential tool that we anticipate having in any advanced programming environment is a language-specific interactive debugger. In this paper, we showcase the potential applications of tide, a versatile debugging framework that is linked to the asf+sdf meta-environment. Tide can be utilized for different levels of debugging involved in language design.

Developing sophisticated programming environments for small languages, such as domain-specific languages, is generally impractical due to the substantial development and maintenance overhead. The creation of a parser, interpreter, or compiler already requires a significant amount of effort. The asf+sdf meta-environment aids in prototyping (domain-specific) languages at both the syntactic and semantic levels. Once a language specification is developed, tools such as parsers, interpreters, and pretty printers can be derived from it.

The asf+sdf meta-environment serves as a platform for defining languages and manipulating programs. It can be interactively used to define languages and generate tools based on these definitions. A language specification in asf+sdf typically encompasses syntax definition, pretty-printing, type-checking, and program execution.

In this demonstration, we specifically focus on the asf formalism, which is a declarative language based on conditional rewrite rules. It is a first-order strongly typed language with features for list matching and tree traversal. Asf is closely linked with sdf, as it utilizes the syntax defined in the sdf part to obtain user-defined (concrete) syntax.

Tide offers various features to the user, including stepping through the program, setting breakpoints, and inspecting variables and stack frames. The applicability of tide's features depends on the specific language being debugged.

For tide to function at breakpoints, it requires the source location of the current point of execution to be known and passed to the tide library. For additional features, the nesting depth (i.e., stack depth) and a serialized representation of a variable environment can also be passed to tide.

The asf interpreter sets 21 logical breakpoints during the interpretation of a specification. For instance, it logically identifies two breakpoints for rewrite rule application: one before matching the left-hand side and another just before constructing the right-hand side. The marshalling of the asf value environment to tide is accomplished with 350 lines of C code, enabling a fully functional asf debugger.

When a language is defined in asf+sdf, obtaining a tide-based debugger for the language should not be challenging. We provide a generic asf+sdf module that encapsulates and abstracts the tide adapter API. By adding calls to this module in any language specification, an asf+sdf specification can be instrumented to obtain a debugger which supports stepping through a program and setting breakpoints, as demonstrated in the extension of the pico language specification with calls to the tide-step function.

While this approach may not offer the same level of expressivity as manually writing a tide adapter, the provided interface offers a functional level of abstraction. The design of the asf+sdf debugging module is a trade-off between automation (requiring less coding for the user) and expressivity (requiring more coding for the user).