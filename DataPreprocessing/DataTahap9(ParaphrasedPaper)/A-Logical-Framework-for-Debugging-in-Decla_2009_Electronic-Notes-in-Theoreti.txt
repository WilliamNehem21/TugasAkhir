Debugging tools are essential for identifying the causes of incorrect computations. Traditional debugging techniques that rely on inspecting low-level computation traces are not well-suited for declarative programming paradigms with complex operational details, such as constraint solving and lazy evaluation. To address this issue, declarative diagnosis employs computation trees (CTs) to represent the structure of a computation, with the top-level outcome considered as an error symptom by the user.

Each node in a CT represents the computation of an observable result based on the results of its child nodes. Declarative diagnosis searches for a "buggy" node within the CT, which computes an incorrect result from correct child results, indicating an incorrect program fragment. An external oracle, often the user with some semi-automatic support, provides reliable declarative knowledge of the expected program semantics, known as the intended interpretation, to aid in the search for the buggy node.

The remainder of the paper is structured as follows: Section 2 presents a debugging example to illustrate the approach, which is used throughout the paper. Section 3 explains the Cflp(d) scheme, providing the necessary background for understanding the theoretical results. Section 4 introduces a correct method for the declarative diagnosis of erroneously computed answers in any soundly implemented Cflp(d)-system. Section 5 describes the debugging tool DDT, and additional formal goal-solving calculi, including recent proposals such as the Cdnc(d) calculus, are discussed.

For example, the computed answer shown in Example 2.1 is incorrect according to the intended model for the program, as discussed in Section 2. Computed answers typically include constraints on variables from the initial goal, but goal-solving systems for Cflp(d) programs also maintain internal information on constraints related to variables used in intermediate computation steps. This information is relevant for declarative debugging purposes.

Other formal goal-solving calculi for Cflp(d), such as Cppc(d), are also sound, and it is reasonable to assume soundness for implemented goal-solving systems like Curry and Toy, whose computation model is based on constrained lazy narrowing. Any Cppc(d)-sound goal-solving system is semantically sound.

The paper proposes using abbreviated Cppc(d) proof trees as CTs for declarative diagnosis. A node in the abbreviated proof tree is considered "buggy" if the computation statement at the node is not valid in the intended interpretation, while the statements at the children nodes are valid. This approach ensures correct detection of program errors, as proven in the appendix.

The paper presents a logical and semantic framework for the declarative diagnosis of incorrectly computed answers in Cflp(d). The proposed diagnosis technique represents the computation that has produced an incorrect answer using an abridged proof tree, and the method's logical correctness is formally proven based on the connection between abbreviated proof trees and program semantics.