In the last decade, the significance of formal verification within interactive or automated theorem provers has grown. This is primarily due to several reasons. Firstly, machine proofs ensure that no specific cases have been overlooked, consequently ensuring that the verified properties are valid under all specified circumstances. Secondly, mechanized theorem provers enable the management of large correctness proofs for intricate systems that would be unmanageable by humans alone, owing to their sheer complexity. Lastly, the increased efficiency and user-friendliness of theorem provers in recent years have made them viable for real-life verification problems. However, there are numerous unresolved issues, particularly regarding the formalization of proofs in theorem provers.

Recently, there has been increased interest and importance in the application of coalgebraic methods, particularly coinduction, in the specification and reasoning about state-based systems. In subsection 3.1, we provide a summary of the key concepts in this domain. Subsequently, in subsection 3.2, we demonstrate the utilization of coinductive definition and proof principles in the Isabelle/HOL theorem prover.

The Isabelle/HOL extension described in facilitates the use of coalgebraic types. This extension utilizes coinductively defined sets, a definition principle available in Isabelle/HOL, to define lazy lists. For instance, the coinductive definition of possibly infinite lists specifies the set of lazy lists llist(a) over a given set a.

More recently, coalgebraic methods have been effectively employed in the specification and reasoning about programming languages and systems. For example, the semantics of object-oriented programming languages have been established coalgebraically in [7, 9]. The vfiasco project aims to verify an operating system using coalgebraic methods. Additionally, [citation needed] describes the coalgebraic class specification language CCsl. While coalgebraic proof methods are not the sole formalism capturing the semantics of non-terminating programs, labeled transition systems can also be employed.

In our own research, we have validated the correctness of a dead code elimination algorithm, as used in compilers, using bisimulation on Kripke structures. We have also described how coalgebras and coinduction can be employed in compiler verification. Furthermore, our work on formalizing and transforming data flow dependent computations indicates, akin to the work presented in this paper, that the choice of formalization is crucial for the success of proofs when theorem provers are employed.