When evaluating the expression e1 # e2 within a process p, a new child process q is generated, along with two communication channels. The parent process p feeds the value of e2 to its child process q via the input channel. Process q then evaluates e1 # e2 and returns the result to its parent via the output channel. This process is illustrated in the diagram below:

The syntax of the kernel of eden is defined using Maude by employing sorts and subsorts to represent different syntactic categories and their relationships. By using different sorts, we can concretize the patterns utilized in rewrite rules by utilizing variables of the most suitable sort in Maude. The syntax includes sorts for ordinary variables (std), channels (cha), and a union of both sets (var). Additionally, two sorts are used to distinguish between expressions that are in weak head normal form (whnf) and those that are not (nonwhnf), both of which are eden expressions (exp).

In addition, the process constructor has four arguments: a string corresponding to the process identifier, a heap, and two counters, one representing the number of children of this process and the other indicating the maximum number used to build new variables (which is incremented when renamings are needed due to the generation of new variables). There is also a union operator (with empty syntax) for building systems.

A strategy, 'strategy-par->', is applied to each process in a system. This strategy is recursive and terminates when the rest of the system (represented by the variable s:system below) is empty. The strategy 'strategy=par=>' receives as an argument the variables corresponding to the threads returned by the function et applied to the entire system. 'Strategy-par->' is called with the set of evolvable variables of process p, calculated by the function inters.

A process is blocked if there is a dependency on values that need to be communicated. The function nf (needed free) collects the dependencies derived from the free variables. Taking into account the example expression given in section 3, after the application of the (let) local rule, the resulting heap is as shown in the preceding section, where different alternatives can be experimented by selecting the appropriate definition of the functions nf and et. These functions could be defined in various ways, resulting in different semantics for eden. In the current implementation, each definition is placed in a different Maude module. By instantiating the module defining the semantics rules with a module containing a concrete definition of nf and a module with a concrete definition of et, a complete specification of eden is obtained.

Initially, the term being rewritten is extended with the actual values of the measures. One possible way to achieve this is through a set of attributes together with their values. One of these attributes contains the eden system (sys), which will be rewritten by the semantics rules shown in the previous sections. Examples of these attributes are shown as follows.

Then, rewrite rules need to be defined to describe the modification of these measures. For instance, the rule 'addpc' increments by one the number of processes, and the rule 'addet' updates the total work that has been done as well as the maximal thread parallelism. These updates are determined by the variable 'cardet', which will be instantiated by a strategy.

Finally, the strategies need to be modified to apply these rules together with the semantics rules. Two of these new modified strategies are shown below. 'Strategy=pc=>' now applies rule 'addpc' after applying rule 'pc' (process creation), and 'strategy==>' updates the values of measures 'maxpar' and 'work' using the number of evolvable threads computed by expression 'size(et(s:system))'.