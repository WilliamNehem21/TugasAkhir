This research paper demonstrates the implementation of intraprocedural control-flow and data-flow analysis of Java source code in a declarative manner using reference attribute grammars augmented with circular attributes and collection attributes. The approach is built on top of the jastadd extensible Java compiler and has been applied to medium-sized Java programs. The paper illustrates how the analyses can be constructed using small, composable modules and how they offer extensible frameworks for further source code analyses. Preliminary findings suggest that there is minimal difference in execution time between the declarative data-flow analysis and an imperative implementation.

The paper presents an approach for performing control-flow and data-flow analysis directly on the abstract syntax tree (AST) used in a compiler frontend while maintaining good performance and a compact specification size. The approach is entirely declarative, allowing for modular and extensible specifications. The analyses are implemented on the jastadd extensible Java compiler using extended attribute grammars, focusing on intra-procedural analysis. Extending the technique to support inter-procedural analysis is ongoing work.

To evaluate the efficiency and scalability of the approach, an analysis for detecting dead assignments to local variables in Java has been implemented. The control-flow framework consists of fewer than 300 lines of code, the data-flow framework has fewer than 30 lines of code, and the dead assignment analysis adds less than 8 lines of code, totaling less than 340 lines of code. The dead-assignment analysis has been executed on real Java applications of approximately 40,000 lines of code, with execution times of less than 9 seconds, including static-semantic checking. Initial experiments indicate that there is little difference in execution time between the declarative implementation of data-flow analysis and an imperative implementation using explicit fixpoint iteration.

The paper also outlines the organization of the remaining sections, introducing some of the key concepts involved in control-flow analysis and data-flow analysis, and provides a detailed examination of various attributes and their evaluation in Java AST.

In addition, the paper discusses the use of synthesized and inherited attributes to propagate information in the AST, including techniques for dealing with break, continue, and return statements, and how they are matched against each other to control the flow. Furthermore, it explores the efficiency and scalability of the approach through an analysis for detecting dead assignments of local variables.

The paper also discusses the soot framework, a more comprehensive tool for optimizing, analyzing, and annotating Java bytecode, and contrasts it with the approach presented in the paper.

In conclusion, the paper highlights the effectiveness of reference attributed grammars augmented with circular attributes and collection attributes for declaratively specifying control-flow and data-flow analysis. It also discusses potential future directions for the work, including extending the approach to more advanced analyses and applying similar techniques to domain-specific source level analyses.