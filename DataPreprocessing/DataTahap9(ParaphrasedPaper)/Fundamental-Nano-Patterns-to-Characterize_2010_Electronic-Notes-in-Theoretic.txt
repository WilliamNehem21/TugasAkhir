We have created a tool for detecting nano-patterns in Java bytecode class files through a command-line interface, leveraging the asm bytecode analysis toolkit. The tool takes the name of a class file as input and outputs a bitstring representing the nano-patterns exhibited by each method in the class. It is implemented in Java and consists of just 600 lines of source code. Our tool employs data structures and visitor code from the asm API to detect specific nano-patterns in two different ways.

Automating the generation of ASM-based detection code for specific nano-patterns could be feasible with a formal specification of the nano-pattern characteristics, possibly using a meta-language like JTL. However, we have not addressed this issue in our current research.

Methods for storing nano-patterns are enclosed in library container data structures. Despite the introduction of generics in Java 5, type casts still persist in Java bytecode for retrieving objects from container data structures, reflecting an idiomatic artifact of the Java source-to-bytecode transformation.

Certain methods take a single argument, write the value to a field of the current object, and return void. Such patterns are expected in well-written programs in any object-oriented language.

Our research indicates that certain combinations of low-level features can serve as potential indicators for higher-level design patterns, although the discovery of design patterns is generally acknowledged to be challenging. We have also shown that a large and varied corpus of code can yield high-confidence association rules, which, if violated in new code, can be flagged by an online interactive checker as potential bugs.

The SpecJVM98 benchmark suite was originally created to assess the performance of commercial Java virtual machine (JVM) implementations but is now primarily used for academic research, such as points-to analysis. The Dacapo benchmark suite, assembled by an academic research group, has been proposed as a potential replacement for SpecJVM98, due to its higher proportion of object-creating methods and type-manipulating methods. The authors claim that Dacapo is superior for these reasons.

A potential limitation of our study is that our nano-pattern catalogue does not currently capture all object-oriented behavior, such as method overriding via virtual method calls and distinctions between accessing object fields through a "this" pointer versus other pointers. It is possible that a more comprehensive set of nano-patterns would provide a clearer understanding.

We assert that similar methods should exhibit similar nano-patterns, and these patterns can be used to indicate similarity between methods. The Dacapo benchmark suite criticizes the SpecJVM98 benchmarks for being overly similar, and the authors demonstrate a greater spread of programs in the 4-d space for Dacapo compared to the concentrated programs in SpecJVM98.

It is worth noting that our analysis based on nano-patterns is solely static, whereas a comparison between benchmark suites would benefit from considering both static and dynamic behavior. Although the Dacapo study focused on dynamic behavior and we have only explored static behavior, we arrive at similar conclusions regarding intra-suite diversity.

The comparison of benchmark suites in isolation is valuable, particularly in the context of using Java benchmarks to compare static analysis techniques, wherein static object orientation and diversity are the main considerations.

Clustering is a form of unsupervised learning used to group data points based on a similarity measure, often a distance metric, into a variable number of clusters. In our context, we aim to cluster similar methods based on nano-pattern bitstrings to facilitate program comprehension. Previous work has utilized clustering to analyze Java methods, but our set of static method features appears to be more comprehensive than in earlier work. This analysis is primarily focused on program comprehension.