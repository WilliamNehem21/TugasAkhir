The present study introduces an innovative method for implementing a graph transformation engine as an EJB3-specific plugin using EJB QL queries for pattern matching. The core idea of this approach involves creating an EJB QL query for the precondition of each graph transformation rule. The pattern matching and updating phases of a rule application are executed in a public method of a stateless session bean by running the prepared EJB QL query and manipulating persistent objects, respectively.

The paper is structured as follows: Section 3 provides an overview of the EJB3 platform and the syntax of its query language. In Section 4, the authors outline how to encode preconditions of graph transformation rules into EJB QL queries. Section 5 reviews related work, and the paper concludes in Section 6.

A search graph is described as a directed graph with specific properties, including the mapping of pattern nodes to nodes in the search graph and the inclusion of a center node denoted by a hollow circle. The details of edge selection and navigation in the search graph are also explained.

The Java 2 Enterprise Edition (J2EE) platform is described as having a layered architecture for scalable, distributed application development. It utilizes enterprise Java beans (EJBs) as fundamental building blocks for representing business data and functionality. The deployment and execution of an enterprise application on the J2EE platform are carried out by an application server, which provides various high-level services beyond application execution.

The paper presents details about the generation of entity bean classes based on the metamodel, including mapping class attributes, inheritance relations, association ends, and unique identifier representation.

Processing of to-one and to-many navigation edges, as well as injectivity constraints and constraints for embedded NAC patterns, are discussed in the paper. Additionally, the mapping of graph transformation rules to public methods of the stateless session bean is outlined.

The paper proposes that the approach shows potential for better run-time performance and reduced memory consumption in the application server compared to solutions using pure SQL for specifying queries. However, it also emphasizes the trade-off between portability and run-time performance when database-specific query optimizations are enabled. The authors plan to conduct further experiments to validate their expectations on both run-time performance and memory consumption aspects of the approach.