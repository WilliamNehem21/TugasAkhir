Partition refinement can effectively decrease the size and complexity of composite component interaction automata. However, there are cases where partition refinement leads to unexpected outcomes, notably an increased occurrence of non-deterministic transitions in minimal composite component interaction automata, even in the absence of such transitions previously. These non-deterministic transitions can be problematic, as their elimination is required for consistent behavior.

In the original definition, the sets of provided actions (p) and required actions (r) come from a separate specification outside the formalism of component interaction automata. Integrating these architectural constraints into the specification of component interaction automata does not impact the underlying composition rules but instead formalizes the relationship with the associated automata, facilitating composition. If an automaton is enabled in all actions, the annotation can be abbreviated in a natural way, and the corresponding specification can be omitted.

We can represent customer, store, and bank as component interaction automata, denoted as (customer), (store), and (bank). These automata are primitive components with an opaque structure, meaning they have no explicit hierarchical relationships.

The composition of component interaction automata is defined as the crossproduct over their state spaces. Additionally, the sets p and r determine the input and output transitions that occur in the composite system, i.e., its interface with the environment. If any state becomes inaccessible in the composite automaton, it is immediately removed from the state space to obtain the most concise result. The behavior of the composite automaton is fully characterized by its reachable states.

All states in v are considered start states. The action prefix generator for prefix state q is denoted as ap[q]. If wp is the set of all prefix strings accepted by ap[q] in q, we refer to wp as the action prefix language of ap[q] and write l(ap[q])= wp.

Furthermore, the outcome of partition refinement can be further improved by making the analyzed component primitive before refinement, thereby removing information about the underlying composition hierarchy. Although the composition of multiple instances of the same component can generate identical sub-structures in the resulting composite automaton, the use of unique component identifiers to disambiguate shared actions prevents partition refinement from simplifying common sub-structures into a single unified structure. This difficulty can be overcome by creating a fresh image of a given component interaction automaton in which all component names are the same. However, this approach leads to the loss of information regarding which synchronizations define guards for component interactions with the environment. Nevertheless, this paper presents a viable solution to restore pre-conditions in reduced automata when necessary, despite partition refinement removing synchronization cliques from the specification of a given component interaction automaton.