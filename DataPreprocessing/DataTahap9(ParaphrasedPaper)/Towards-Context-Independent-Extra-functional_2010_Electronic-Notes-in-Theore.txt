This paper is structured as follows: The following section gives a brief overview of technologies and research methods related to extra-functional properties. Section 3 outlines the fundamental principles of our work, delineating how we define extra-functional properties (EFPs) and their connection to deployment contracts, and presents the modifications we have made to existing approaches. This is followed by detailed information about our registry system. The final section offers a case study demonstrating how our proposed method can enhance a current system developed by a Czech company.

A novel approach suggested by Aagedal is the CQML language, which encompasses a complete syntax for an EFPs language and introduces a UML profile for quality attributes. This language is versatile for the general description of EFPs and defines basic types such as number, enum, and set. Moreover, it offers derived properties, although it only extends existing simple properties or composes derived properties from others without further specification on how this composition is handled. CQML allows for handling properties both before deployment and after a component is deployed. While properties are typically treated differently in different phases, the profile comprises a set of qualities with a set of quality of service (QoS) properties. The quality enables the encapsulation of context-dependent values, but when considering c contexts and n QoS properties, it may result in up to 2n quality records and 22n different profiles, with each profile needing to be created for c contexts. This could lead to a significantly unmanageable number of records.

CQML+ extends the syntax of the original CQML rather than offering a more generalized approach. It focuses on the field of service-level agreements, wherein EFPs also play a significant role. Slang, another approach, utilizes XML to describe EFPs and distinguishes between vertical and horizontal service-level agreements, wherein vertical agreements pertain to different infrastructure and horizontal agreements cover various layers of abstraction. Each layer of abstraction encompasses a different group of EFPs, enabling the use of different EFPs for different layers. However, a weakness of these approaches lies in their specific focusing on particular cases and development of a limited set of properties, unlike our aim of providing a general solution.

Moreover, while ProCom attributes are intended for use throughout the entire system lifecycle, motivating the introduction of multi-valued attributes, we are interested in describing EFPs of the final black-box components. An intriguing concept in ProCom is the utilization of registries to store EFPs, with the main reason for introducing registries being to gather attribute types.

PECT concentrates on real-time quality attributes and their predictions, while RoboCop 4 employs a variety of models with specific information about the system, including an EFPs model (e.g., reliability, CPU, and memory usage). However, both of these models do not allow for context-independent specification of EFPs. For instance, it is not possible to parametrize an EFP with a particular platform.

The Component Quality Model compiles a list of EFPs suitable for defining a set of EFPs for a specific system, whereas Performance Trees aim to provide an easy-to-use graphical representation of stochastic systems, enabling the expression of performance queries as graphical trees, which is beneficial for modeling EFPs of performance-demanding systems.

Upon considering the above analysis of related work, we discern that there is no consistent understanding of how extra-functional properties should appear, where they should be stored, and how they should be defined. In our perspective, EFPs entail additional information about components and their features, serving to enrich component specifications and extend the possibilities of component verification.

To ensure comparable properties, a shared understanding between different component vendors and users about the available properties and their characteristics is imperative. Apart from employing standards such as the CQM, such understanding can be facilitated by a technical infrastructure encompassing a general repository that houses all available properties within the domain of usage, enabling the assumption that properties are defined before a component is created. Vendors can then use this repository to affix properties with the same meaning to components.

This repository comprises records detailing the name and type of each property, defining the properties themselves without containing their values. The global registry is applicable to all contexts specified by the domain of the registry, containing the definition of all meaningful EFPs as defined by a domain expert, who could be a program working with a domain specification or a human knowledgeable about the domain.

Each context has one local registry, linked to the domain global registry, storing values valid for the context and linked to the definitions provided by the global registry. A component to be deployed in a specific context links to a local registry, thereby binding context-dependent values to its properties, as derived from the global registry.

It is optional to have a record in the local registry for every property. Properties that are not inherently context-dependent can have values assigned directly in a component descriptor, typically occurring in every deployment contract or other EFPs (e.g., physical values like t = 0Â°C and gravity = 6.67, or context-independent ones like price and marketability).

In our approach, we differentiate between two types of extra-functional properties: simple properties and derived properties. A simple property pertains to any measurable property that often has a measuring unit, while a derived property is predicated on a set of simple or derived properties using logical expressions.

We have also generalized deployment contract properties to align with our (simple or derived) properties. The provided generalization defines a deployment contract in the same manner as extra-functional properties, diverging when they are utilized on components. EFPs bound to a component strictly express a relation to other components, while deployment contracts bound to a component purely express a relation to a runtime environment, despite no differences in their definitions.

An additional component, a database of addresses, stores all addresses in the Czech Republic and can provide them through web services. Data about citizens, provided by the ministry, may contain errors. To address this, data about addresses are synchronized through the import process, and mistakes are rectified. When the functioning address component is present, it must continuously provide valid addresses.

We have defined two simple properties, "data transferred" and "time to process," concerning the speed and volume of transferred data for the database import. Both properties are referenced by a derived property, "performance." The system relies on an installed database engine, which we define as a deployment contract because it is an external resource. The presumed correctness of addresses is expressed by a "data correct" property.

As this work is still in progress, several issues require further research. Finding a suitable solution for the actual location of context registries is necessary. One option is to store this information as a component of the global registry file, while another involves providing physically separated registries per individual context and linking them to the global file.

We have formalized the deployment contract attributes employing the original algorithm presented in [citation needed], but we aim to simplify the algorithm. While the original work enables the inclusion of properties not only on components and services, but also on methods, parameters, and return types of methods, we wish to restrict it to components and services. We assume not to use every attribute of the original work, as some are weakly related to deployment (e.g., reentrance and state of methods), and some are challenging to manage (e.g., the ability to store a browser cookie).

While this paper has established a fundamental mathematical model for the static definitions of EFPs and deployment contracts, the technical means required for practical application of the model have yet to be developed. Presently, we are developing a tool that uses XML to construct a registry and a Java GUI that functions as a registry editor. Our immediate goal is to complete a tool that verifies the model.

This paper has introduced an approach to defining extra-functional properties and deployment contracts targeted at the field of reusable software components. Our study of existing approaches has demonstrated that some of the languages describing extra-functional properties developed earlier serve as a useful foundation for further development. Our proposed system builds on CQML and nofun, simplifying their syntax and extending them in a few directions to better align with our requirements. Additionally, we have employed the approach to formalize the existing, informally defined deployment contracts.