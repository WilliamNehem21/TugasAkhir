Genomic rearrangements are events that alter segments of genomes. A rearrangement model, denoted as M, represents a set of valid rearrangements that are utilized to estimate the evolutionary distance between genomes. Two well-known types of genome rearrangements are reversals, which involve the reversion and flipping of the orientation of elements in a genome, and transpositions, which entail the exchange of positions of two adjacent segments in a genome.

Genomes are represented as permutations of integers, where each element corresponds to a genomic fragment shared by the genomes being compared. This representation assumes no duplicate genes. If the orientation of the genes is known, a signed permutation is used, where each element has a sign to denote its orientation. In cases where the orientation is unknown, the signs are omitted, and an unsigned permutation is used.

The problem of sorting unsigned permutations by reversals is known to be NP-hard, with the best-known algorithm providing an approximation factor of 1.375, as proposed by Berman et al. Conversely, as demonstrated by Hannenhalli and Pevzner, the problem of sorting signed permutations by reversals is polynomial. Sorting(unsigned) permutations by transpositions is also NP-hard, and the best-known algorithm has an approximation factor of 1.375, as presented by Elias and Hartman.

In scenarios where the rearrangement model incorporates both reversals and transpositions, the problems of sorting signed and unsigned permutations by reversals and transpositions arise. The computational complexity of both problems remains unclear. For unsigned permutations, the most reliable result is a 2k-approximation algorithm, where k represents the approximation factor for the cycle decomposition of breakpoint graphs. For signed permutations, Walter et al. introduced a 2-approximation algorithm.

It is worth noting that the distance is O(n^2) because any permutation can have at most n inversions. Furthermore, the variation in the number of inversions caused by a short rearrangement can be computed in constant time, as at most three elements are affected. Given that there are O(n) possible short rearrangements, the algorithms require O(n) time to select the best rearrangement to apply at each step. Therefore, all three algorithms have a time complexity of O(n^3).