Graph transformation systems (GTSs) are widely acknowledged as a potent formalism for specifying concurrent and distributed systems, offering a more general framework than petri nets. Extensive research has been conducted on the truly concurrent behavior of GTSs, resulting in the development of a well-established theory of concurrency. Notably, various semantics of petri nets, such as process and unfolding semantics, have been extended to GTSs (refer to [8, 26, 1, 2]). However, unlike the numerous approaches available for automated verification of petri nets, including invariants calculus and model checking based on finite complete prefixes, the literature on GTSs lacks substantial contributions to the static analysis of such systems (see [20, 21, 14]). Notably, it is interesting to observe that several formalisms for concurrency and mobility can be represented as graph transformation systems, suggesting that verification techniques for GTSs may extend to these formalisms.

The proposed type system is easily demonstrable to be correct, but it is not comprehensive. In fact, it can be proven that the set of closed first-order formulas preserved or reflected by edge-bijective morphisms is undecidable. Consequently, not all L2-formulas that are preserved or reflected are encompassed by the aforementioned type system.

We have introduced a logic for specifying graph properties, which is useful for verifying graph transformation systems. A type system enables the identification of formulas in this logic that are reflected by edge-bijective morphisms, and these can consequently be verified on the covering, i.e., on the finite petri graph approximation of a GTS. Additionally, given an approximation of the original system, we can perform quantifier-elimination and encode these formulas into a boolean combination of atomic predicates on multisets. When combined with the approximated unfolding algorithm, this approach offers a method for the verification and analysis of graph transformation systems. This form of abstraction differs from traditional forms of abstract interpretation as it abstracts the structure of a system rather than its data. A comparison can be made with shape analysis, which abstracts the data structures of a program (refer to [24, 27]).