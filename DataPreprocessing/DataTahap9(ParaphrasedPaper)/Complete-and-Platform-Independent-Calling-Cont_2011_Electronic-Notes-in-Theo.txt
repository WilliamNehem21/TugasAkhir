The process of calling context profiling involves gathering statistics individually for each calling context. Having accurate and comprehensive calling context profiles is crucial for a thorough analysis of program behavior, which in turn is important for understanding programs, reverse engineering, and characterizing workloads. Many existing calling context profilers for Java rely on sampling or incomplete instrumentation techniques, resulting in incomplete profiles. Others depend on modifications to the Java Virtual Machine (JVM) or are only compatible with specific JVMs, compromising portability. This paper introduces a new calling context profiler for Java that addresses these shortcomings by ensuring completeness of profiles and full compatibility with any standard JVM. To minimize measurement perturbation, our profiler collects platform-independent dynamic metrics, such as the number of method invocations and the number of executed bytecodes. Unlike existing calling context profilers, our tool can differentiate between multiple call sites within a method and supports selective profiling of certain methods. We evaluate the overhead introduced by our profiler using standard Java and Scala benchmarks on various JVMs.

Unlike a context-insensitive Dynamic Call Graph (DCG), a Call Chain Tree (CCT) can theoretically capture the complete context of a call. However, CCTs generated by current profilers lack information found in the labeled variant of DCGs, specifically details about the individual site at which a call is made. Many calling context profilers are unable to distinguish between multiple call sites within a single method while tracking various methods in entire call chains.

Our tool supports several variations of CCT, including representations of calls to the same method from different call sites in a caller using either the same node or different nodes in the CCT. Additionally, for recursion, the depth of the CCT may be unbounded, representing each recursive call to a method by a separate CCT node, or recursive calls might be stored in the same node, limiting the CCT's depth and introducing back-edges.

This paper describes the design and architecture of our tool, starting with a discussion of both the design and weaknesses of a previous version of the tool. It then presents our new design implemented in the JP2 profiler, and explains how JP2 deals with native methods. JP2 provides a mechanism to temporarily disable the execution of instrumentation code for each thread, addressing the potential issue of infinite recursions caused by the use of methods from the already instrumented Java class library. The paper also discusses the Probabilistic Calling Context (PCC) approach by Bond et al., which maintains a probabilistically unique value representing the current calling context with low overhead, but may not always produce completely accurate profiles due to its probabilistic nature. Recent research has shown that it is often possible to reconstruct a significant amount of context offline.

This paper introduced JP2, a new tool for complete platform-independent calling context profiling. JP2 relies on bytecode transformation techniques to create CCTs with platform-independent dynamic metrics, such as the number of method invocations and the number of executed bytecodes. Unlike existing profilers, JP2 can distinguish between multiple call sites within a method and supports selective profiling of certain methods. The overhead caused by JP2 was evaluated using standard Java and Scala benchmarks on a range of different JVMs.