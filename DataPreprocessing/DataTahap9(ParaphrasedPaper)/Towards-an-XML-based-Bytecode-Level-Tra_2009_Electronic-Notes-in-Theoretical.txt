The use of programs for manipulating virtual machine bytecode is on the rise. The tool bat2xml utilizes XML to represent Java bytecode, enabling the leveraging of XML technologies for processing and manipulation. It offers a feature for easily injecting and extracting Java bytecode, allowing for analysis and optimization. However, it only supports Java bytecode and does not cater to CLR bytecode.

This paper proposes an approach that heavily relies on XML technologies to establish a framework for generic bytecode manipulation. By utilizing XML, a representation of bytecode is created, which acts as a superset of stack-based machine languages, facilitating straightforward bytecode manipulation. Furthermore, the paper demonstrates a cross-compilation example using XSL stylesheets to translate CLR bytecode instructions to the JVM. This approach allows for a declarative methodology for performing the transformation.

Ultimately, the paper serves as a showcase for the effectiveness of XML technologies and declarative programming in a complex application. The paper is structured as follows: Section 2 presents XMLVM, an XML-based representation of bytecode instructions. Section 3 provides an overview of the JVM and the CLR, emphasizing their differences. Based on XMLVM, Section 4 illustrates how to cross-compile bytecode instructions using XSL stylesheets. Finally, Section 5 offers conclusions and outlines directions for future work.

The main aspect of the XMLVM program is the implementation of the "main" method, which resides within the <code> tags. With the bytecode instructions belonging to the CLR, corresponding XMLVM instructions are placed in the XML namespace denoted by the prefix "clr". The <clr:var> tag declares a variable with a specific type, which can be referenced by a given index. The <clr:ldc> instruction loads a constant referred to by the attribute value onto the stack.

In contrast to the JVM, the CLR introduces the concept of value types in addition to classes, with instances of value types being allocated on the stack. In contrast, instances of classes are typically allocated on the heap and are garbage collected when no longer in use. Given that the CLR is a superset of the JVM, supporting additional primitive types and bytecode instructions, it is relatively straightforward to map a JVM program to the CLR.

To achieve a comprehensive cross-compilation, it is crucial to provide support for unsigned integers, utilize appropriate bytecode instructions for different data types, and address overflow scenarios by throwing a runtime exception. Additionally, in the absence of native support for value types in the JVM, a simulation approach is necessary to retain CLR semantics, such as mapping value types to objects and performing deep copies.

API mapping and wrapping play a crucial role in achieving functional equivalence between the cross-compiled Java application and its original CLR version. This process involves changing class and method names as well as handling references to external libraries. The declarative XPath expressions are shown to filter out the desired API, showcasing their potential in this context.