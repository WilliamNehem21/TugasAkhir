Both the functional and logic programming paradigms offer attractive features for programming, and various efforts have been made to integrate these paradigms in order to leverage their most interesting capabilities. This integrative approach is evident in functional-logic languages such as Curry and Toy, which draw significant influence from Haskell in terms of syntax, higher order capabilities, and type inference systems. Moreover, these languages incorporate lazy evaluation, similar to Haskell, as a fundamental feature. In addition to this, they also incorporate non-deterministic functions and logic variables from logic programming, along with a generalization of unification and non-deterministic computations. However, the introduction of delayed computations in these languages can sometimes disrupt the intended semantics of programs, especially when overlooking the impact of non-deterministic functions. Therefore, it becomes necessary to introduce a sharing structure, as seen in Toy and Curry, to address these issues.

When it comes to the interpretation of rules in functional-logic languages, the order of computation involves unification for parameter passing, followed by the satisfaction of conditions, and finally the evaluation of the rule body to obtain the result. However, an alternative approach could involve evaluating the body of the function prior to satisfying the conditions, offering a different translation perspective.

For higher order functions, a common technique implemented in languages like Toy involves translating them into first order using a specific mechanism. In the proposed approach, functions are generally strict by default, but the introduction of explicit annotations allows for lazy evaluation, a concept similar to the lazy annotations proposed for functions in the functional extension of Prolog. Moreover, certain strict functional languages like OCaml provide features for suspending the evaluation of expressions and forcing their evaluation when necessary, opening up new possibilities for exploration.

The proposed approach allows for the introduction of laziness annotations for data type constructors, enabling the translator to incorporate appropriate suspensions and their corresponding manipulations, and an extension is presented to capture sharing.

However, it's important to consider the implications of incorporating laziness in the translation of functional-logic languages, especially when dealing with non-deterministic computations. For instance, scenarios where non-deterministic functions are involved can lead to unexpected behavior, as illustrated in the example of implementing the classical Prolog generate and test algorithm for sorting a list.

The proposed model of laziness is compared to similar approaches, particularly the extension proposed for CIAO Prolog. The comparison highlights the similarities and differences in both approaches, emphasizing the importance of optional laziness and its implications for program efficiency.

In summary, the proposed functional Prolog model expands the capabilities of the language, offering the potential for improved program efficiency through fine control over laziness and providing sophisticated resources for exploring the search space through the combination of meta-predicates from Prolog and the functional extension.