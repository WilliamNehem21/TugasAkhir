The current Java verifiers use iterative data-flow analysis to determine the precise type of values stored on the stack or in registers. Our new verification algorithm employs abstract interpretation to gather definition/use information for each register and stack location in the program. This information is then utilized to convert the program into static single assignment (SSA) form. In this form, verification is simplified to checking type compatibility between the definition type of each SSA variable and the type of each use. Additionally, this integrated approach is more efficient than traditional bytecode verification, while maintaining the same level of safety, as the overall correctness of the program can be guaranteed when the data flow from each definition to its uses is known to be type-safe.

This research was supported in part by the National Science Foundation (NSF) under grants TC-0209163 and ITR-0205712, and by the Office of Naval Research (ONR) under agreement N00014-01-1-0854. The U.S. government has the right to reproduce and distribute reprints for governmental purposes despite any copyright annotation. The opinions and conclusions expressed in the paper are those of the authors and do not necessarily represent the official policies or endorsements of the NSF, ONR, or any other U.S. government agency.

Verification in SSA significantly reduces the number of program points that need to undergo type-checking, as only producers and consumers of values are verified. Inter-adjacent transitions of a value through stack and registers are no longer explicitly verified using this approach. It is more efficient than traditional bytecode verification but still ensures program safety by guaranteeing type-safety as long as the data flow from each definition to its associated uses is known to be type-safe.

Values in the program are created by core instructions and can be utilized by other core instructions, residing on the operand stack or in variables during their lifetime. The verification process ensures that these locations are consistently used and that intermediate values are always read back with the same types they were originally written as.

Control-flow safety is comparatively straightforward to verify, but ensuring the type safety of data flow is more complex. The Java bytecode verifier checks that stack locations and local variables are used in a type-safe manner by determining the types of all stack locations and variables for each instruction.

In the JVM, there is no direct connection between the definition of a value and its uses. Even if definition-use chains were available in a JVM program, it would still be impossible to verify a Java program in a single pass by comparing the type of each definition with its uses. The approach of the research is to replace the stack and local variables with a register file and redefine the dynamic semantics of instructions to operate on these registers. This allows a transformation of the stack-based code into SSA and facilitates type checking only between the definitions of values and their actual uses.

Following the annotation phase, the verification algorithm computes the iterative dominance frontier for all value definitions, and resolves all references of core instructions to stack cells and local variables to SSA-names. Data-flow instructions, which do not produce or consume values, are eliminated through copy propagation.

In summary, the proposed approach provides a more efficient method of verification by transforming the program into SSA form and simplifying verification to type compatibility checking, while maintaining the safety of traditional verification methods.