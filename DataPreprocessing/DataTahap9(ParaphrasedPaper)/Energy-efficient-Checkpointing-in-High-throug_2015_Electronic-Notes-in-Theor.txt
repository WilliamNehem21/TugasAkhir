The remainder of the paper is structured as follows: Section 2 provides an overview of related work, while Section 3 introduces our experimental approach and trace-driven simulation of checkpointing in a high-throughput computing environment using real-world datasets. In Section 4, we describe existing checkpointing strategies and propose novel energy- and failure-aware checkpoint strategies. Section 5 demonstrates the negative impact of the proposed checkpointing policies on energy consumption, emphasizing the need for a better understanding of checkpointing strategies in HTC clusters. We discuss key considerations for adopting checkpointing in HTC clusters in Section 6 and conclude in Section 7.

Unsal et al. evaluate the energy characteristics of an application-level fault tolerance (ALFT) scheme, which incorporates redundancy and recovery logic at the application level, and propose a task scheduling heuristic that can reduce energy consumption by up to 40%. In contrast, our high-throughput computing (HTC) environment does not face the same budgetary constraints as real-time systems. HTC systems prioritize overall system throughput over the completion time for individual tasks and typically do not consider deadline constraints during resource allocation.

Several grid and cluster level simulators, such as SimGrid, GridSim, and OptorSim, focus on resource selection processes within and between clusters but do not model energy consumption. More recent cloud simulators, including CloudSim, GreenCloud, and MDCSim, can model the tradeoff between cost, quality of service, and energy consumption. However, these simulators do not support multi-use clusters with interactive user workloads or checkpointing.

We extend our simulation environment to model the checkpoint model introduced in Section 3.3 and evaluate the impact of various checkpointing policies outlined in Section 4. Although our primary focus is on energy consumption and average task makespan, our simulation records numerous additional performance measures, allowing us to evaluate the impact of policies on all areas of the system.

In this section, we introduce the checkpointing policies investigated in this work, which include policies for determining checkpoint evaluation event intervals and policies for deciding whether a checkpoint operation should occur for a given evaluation event. Additionally, we propose a class of migration policies that proactively checkpoint in anticipation of failure events and migrate tasks to resources less susceptible to failure.