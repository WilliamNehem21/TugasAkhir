The C programming language does not have a dedicated boolean type; instead, boolean values are represented using integers. This representation also applies to enumerated types, which can be freely and covertly converted to and from integers. Verification tools that aim to infer the possible values of variables at different points within a program could benefit from knowing that certain integer variables are being used exclusively as boolean or enumerated type variables, or more generally as finite type variables with a limited domain. Specialized and efficient symbolic representations, such as Binary Decision Diagrams (BDDs), can be employed to represent properties related to such variables, while approximated representations like intervals and octagons are better suited for larger domain integers and floating-point variables.

Our primary motivation is to integrate the "concurinterproc" verification tool and its extension to pointers "pinterproc." These tools are capable of treating integer variables in C programs as numerical variables, representing their potential values using, for example, octagons. However, they can handle integer variables that are manipulated as boolean or enumerated variables more precisely, in a disjunctive manner, using BDDs.

In this section, we expanded the proposal from Section 3 to cover a broader subset of C. However, this extension was made based on certain assumptions (e.g., absence of casts and pointer arithmetic) and should be viewed as a demonstration of how value analysis and points-to analysis interact. These assumptions can be relaxed by applying well-established points-to analysis techniques, such as the Steensgaard method.

It's important to note that this work would not be necessary if the abstract domains utilized by the analyzers were capable of dynamically adjusting the types of the variables they handle when the variables exceed their capabilities. However, the abstract domains proposed in the literature tend to be highly specialized (e.g., for floating points, numerical arrays), and accommodating more general cases would increase their complexity.