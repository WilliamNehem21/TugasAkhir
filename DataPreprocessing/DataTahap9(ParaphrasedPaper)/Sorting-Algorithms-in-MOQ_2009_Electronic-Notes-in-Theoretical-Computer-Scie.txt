The purpose of this paper is to provide an overview of the current state of the moqa implementation in Section 4, and to discuss the overhead of two algorithms implemented in moqa in Section 5 -- specifically, insertion-sort and quicksort. Section 5 will demonstrate that the implementation's emphasis on data in its structures, rather than on the algorithms themselves, leads to a higher space cost and an increase in constant values for the average-case time of quicksort. The paper will conclude with a summary in Section 6 and outline future work in this area in Section 7.

Upon comparing the pseudo-code for insertion-sort with the moqa-java implementation, it is evident that moqa introduces an additional level of abstraction. In moqa-java, there is no explicit reference to the position of the next element to be inserted within the already sorted elements, unlike in the pseudo-code where the variable 'j' serves as the index of the next item to be inserted. Instead, moqa-java employs an iterator over the ordered collection to return the next element for insertion. This iterator retrieves the first two elements which become parameters for the first product. The product then removes these elements from the specified ordered collection ('oc') and links the greater element above the lesser element in a new 'orderedcollectionsubset' that is added to 'oc' before being returned. Subsequently, for each product, a 'nodeinfo' in 'oc' is removed and linked above the specified 'orderedcollectionsubset' to create a new 'orderedcollectionsubset' that replaces the previously added one. The 'nodeinfo' is then placed in its correct position in the newly created 'orderedcollectionsubset' before being returned by the product.

The traversal and manipulation of moqa's data structures are more complex than those of an array. The current implementation represents one approach to managing this additional complexity. Consequently, the paper aims to investigate the impact of this extra information on the average-case time of an algorithm in this implementation. This inquiry will likely be better addressed using a sorting algorithm that is more sophisticated in its approach.

Future work will involve refactoring moqa-java, improving the flexibility of the current API, and extending moqa-java to include more specific partial order types alongside the encapsulation of the partial order data structure within the 'orderedcollection' class.