However, the local strategies may fail to compute normal forms if certain indices are absent. For example, when evaluating the expression s(0) + s(0) in accordance with example 1.1 using Maude 3, the following result is obtained:

We have introduced two new commands (norm and eval) in order to enable the execution of Maude programs using techniques i and ii. In this paper, we demonstrate how on-demand strategies have been incorporated into Maude. Before delving into the specifics, we illustrate how negative indices can enhance Maude strategy annotations.

As demonstrated below, on-demand strategy annotations can address this issue. Specifically, employing the strategy (-1 0) for the symbol s, where the first argument is declared as evaluable only on-demand, allows us to achieve the desired behavior while ensuring program termination (refer to examples 4.1 and 4.2 below).

This paper furnishes Maude with the capability to handle on-demand strategy annotations. The reflective capabilities of Maude play a crucial role in implementing these language extensions, which are made simpler to use thanks to the infrastructure provided by full Maude. Full Maude, an extension of Maude written in Maude itself, equips Maude with object-oriented module notation and a robust and adaptable module algebra. Its design and level of abstraction make it an excellent metalevel tool for testing and experimenting with features and capabilities not present in core Maude. We leverage the extensibility and flexibility of full Maude to enable the use of both red (the usual evaluation command of Maude) and norm (introduced in this paper) with Maude programs utilizing on-demand strategy annotations.

In this paper, we aim to reduce a subterm at positions with consumed or present negative indices. All consumed indices (both positive and negative) are associated with each symbol in the term using an extra strategy list, enabling the search for demanded positions. For a formal description of the procedure and details regarding the necessity of the memory list as compared to other frameworks for negative annotations such as Obj3 and CafeOBJ, please refer to the paper. We do not consider AC symbols or rules with non-linear left-hand sides in this paper. Furthermore, strategy annotations are explicitly prohibited for AC symbols, and the completeness of evaluation with strategy annotations is only guaranteed for linear left-hand sides and constructor-based terms.

These functionalities are highly advantageous for metaprogramming, particularly in the development of formal tools. Moreover, full Maude offers a powerful environment with additional facilities, making the addition of new commands or the redefinition of existing ones, as demonstrated in this paper, more straightforward. The specification of full Maude and its execution environment can serve as the foundation for building new features.

Similar to other commands in full Maude, new commands can be defined by specifying the actions to take when these commands are used, accomplished by defining their corresponding meta-function. For example, the execution of a red command involves appropriately calling the metalevel metareduce function. In order to equip Maude with on-demand evaluation, we provide a new metalevel operation, metareduceondemand, which extends the reflective and metalevel capabilities of Maude, as explained in Section 3. The operation metareduceondemand takes arguments of sorts module, opdeclset, and term, and returns a term of sort resultpair. Its arguments represent the module on which the reduction takes place, the operation declarations in that module, and the term to be reduced. The result returned is as the one given by metareduce (as discussed in Section 3). It is important to note that core Maude cannot handle negative annotations; therefore, the function requires a valid module (i.e., a module without negative annotations) and the set of operation declarations with any type of annotation. The redefined command red must then select between metareduce and metareduceondemand based on the presence of negative annotations.

When an index 0 is encountered, the function procstrat attempts to match the term against the left-hand sides of the rules using the metalevel function metaapply. If a match is found, the rule is applied. If no match is obtained, we determine if any demanded position exists using the function procstratod, which performs a matching algorithm to detect which positions under negative annotations are actually demanded by some rule. If a demanded position exists, the evaluation of such a position is initiated, and then the matching against the left-hand sides of the rules is retried after the evaluation is completed. If no demanded position exists, the current index 0 is removed from the strategy list, and the rest of the strategy list is considered.

During the execution of the function procstratod (i.e., when a demanded position is being searched), the computational model specifies that the search order defined by the position order in the strategy must be followed. For instance, if (-1-2 0) is the strategy for a symbol, then any demanded subterm under the first argument would be selected first, disregarding any demanded subterm under the second argument.

Once the function metareduceondemand is implemented, it is necessary to redefine parts of full Maude so that the command red can execute metareduce or metareduceondemand. There is no need to define a new command or extend full Maude to accept that command, as was done for the norm and eval commands. Instead, we only need to modify the way the red command is processed.

In the current version of Maude, input/output is achieved through the predefined loop-mode module, which facilitates a generic read-eval-print loop. In the context of full Maude, the persistent state of the loop is maintained by a single object of class database, which houses the system's database. This class has attributes including db (to store the actual database), default (to retain the identifier of the current module by default), and input and output (to facilitate the communication of the read-eval-print loop with the database). By utilizing the notation for classes in object-oriented modules, it is possible to declare such a class.

The module database-handling defines the behavior of the database with new entries. The behavior associated with commands is managed by rules describing transitions that call the function proccommand. For instance, the rule defining the behavior when the red command is received is as follows.

Upon entering a red command, the parsing of the input results in a term of the form red_.[t], where t represents a bubble. The result of the parsing is placed in the input attribute of the database object. The function proccommand specifies the actions to take upon receiving the term red_.[t], with mn and db variables representing the name of the current default module and the state of the database, respectively. In the original case of the red command, proccommand calls the function procred with appropriate arguments, such as the name of the default module, the flatten module itself, the bubble representing the argument of the command, the variables in the default module, and the database. Depending on whether the default module is a built-in or not, and whether it is compiled or not, proccommand will take different actions to obtain the arguments for procred. In the redefinition for the command red, proccommand calls a new function procreduceondemand, which redefines procred.

As explained throughout the paper, our objective is to provide appropriate normal forms to programs with strategy annotations. However, the redefinition of the red command falls short in providing the normal form 0.1 for the program in example 1.2, since the annotation 2 is missing in the strategy list for the symbol (as seen in the output of the red command in example 4.1). Nevertheless, as explained in Section 1, this specific issue can be addressed using either a layered normalization or a transformation. In this section, we redefine the norm command to perform a layered normalization of the output produced by the on-demand evaluation presented earlier.

These features have been integrated into full Maude, making them accessible within its programming environment. The high-level nature of the full Maude specification and implementation makes this approach particularly appealing when compared to conventional implementations. The flexibility and extensibility provided by full Maude have made the extension relatively simple and quick to accomplish.