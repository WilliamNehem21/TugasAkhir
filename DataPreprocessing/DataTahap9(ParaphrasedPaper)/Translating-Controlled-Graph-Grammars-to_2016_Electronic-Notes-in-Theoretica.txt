Software and hardware systems are now prevalent, and they are becoming increasingly complex and sophisticated. Development of reliable systems has proven to be challenging, requiring comprehensive and error-free specifications. As systems grow in scale and complexity, the potential for errors also increases, which can lead to significant losses in time, money, and safety. Therefore, there is a growing need for techniques to improve the development of dependable and accurate systems. Formal methods, which are based on mathematical formalisms, can provide rigorous and effective means to design, model, and analyze computer systems. These methods require specifications to be precise, concise, and unambiguous, using a language with well-defined syntax and semantics based on mathematical concepts to verify if a computational system exhibits certain properties or meets its specifications.

In the last decade, numerous case studies and industrial applications have demonstrated the substantial impact of formal methods in enhancing the quality of both hardware and software systems. However, the high cost associated with formal methods has limited their widespread use, and they are primarily applied in the development of high-integrity systems where errors could lead to significant consequences. Well-defined specifications, verified for critical properties, have served as a foundation for the correct and efficient generation of source code. A notable example is the Paris metro system, which had its crucial safety components developed using the B method by Matra Transport International.

Instead of using basic graphs with only vertices and edges, graph typing mechanisms involving labels, attributes, or type graphs are typically employed. In this paper, a type graph is used to characterize all the types of vertices and edges allowed in the system, with all graphs in the grammar constrained to these types. This restriction is defined by a graph morphism that maps each graph in the type graph.

The behavior of a graph transformation system is determined by the application of rewriting rules, also known as graph productions, following the double pushout approach (DPO). A rule comprises three graphs: the left-hand side (L), the right-hand side (R), and the interface (K), which represents the elements common to L and R. This specification dictates that once an occurrence of the graph L is found in the current state, it can be replaced by the graph R while preserving K.

In general, a graph grammar describes a system consisting of a type graph that characterizes the permissible types of vertices and edges, an initial graph representing the system's initial state, and a set of rules describing potential state changes. These rules can have associated names, and a set of rule names is defined, with each name associated with a rule via a function.

The behavior of a system specified using a graph grammar can be described by applying the graph grammar rules to graphs representing the system states, yielding a set of graphs derived from the initial graph. Application of a rule to a graph (derivation step) is possible as long as there exists an occurrence of the left-hand side of a rule in the present state graph, i.e., if there is a total graph morphism mapping the left-hand side of the rule into the state graph.

The construction of the diagram above relies on the existence of a "pushout complement" called D, for which the match M must satisfy the gluing condition with respect to L. This condition consists of two parts: the dangling condition, which stipulates that if a vertex is deleted, there can be no edges arriving or leaving from this vertex; and the identification condition, which dictates that two vertices can only be identified by M if they are preserved.

If a rule creates an item needed by another rule, it can be considered the cause of this second rule, emphasizing that a cause provides the necessary condition for an action. Furthermore, for rules that can be applied simultaneously (in parallel), it is essential to ensure that these rules do not conflict, i.e., one rule must not delete an item used by other rules. The following definition reviews causal dependency and conflict relations.

The restrictions imposed by the "res" (presumably "graph grammars with rule restrictions") cannot be directly translated to a control structure of Event-B, so the control structures imposed by the "res" are transferred to the data. This involves a translation of controlled graph grammars to graph grammars by adding dependencies and conflicts in the grammar rules, ensuring that the order of rule applications defined by the "res" is maintained. To introduce dependencies and conflicts, the left- and right-hand sides of the rules and the initial graph are modified by adding new vertices. Each added vertex must be new and must not cause side effects beyond the expected ones. All new vertices must also be added to the type graph of the new grammar. Since a rule can appear multiple times in a "res" and have different order restrictions, several instances of the same rule can be created, each with different added dependencies and conflicts.

The functions "right" and "left" differ from "right" and "left" by using the functions "upfinalnames" and "upinitialnames," respectively, instead of the originals. These new functions change the name of an old rule by a non-deterministic choice between the old and the new rule names, allowing the original rule to be retained (necessary to start and finish the iteration cycle).

New vertices are added to the type and initial graphs, as well as to the left- and right-hand sides of the rules. All new vertices used to create the dependencies and conflicts are added to the type graph, while only one vertex is added to the initial graph, as there is only one start rule in the initial rules of the "res." Given that the new vertex is only on the left-hand side of the start.1 rule, this rule does not conflict with any others. Note that there are two versions of the start rule, due to the closure operation. One version (start.1) is applied.

Graph grammar is a visual and intuitive language that enables the specification and formal verification of systems with complex characteristics. However, there are currently no tools available to formally verify properties for controlled graph grammars, despite the usefulness of techniques and tools that allow the use of model checking and theorem provers for other graph grammar verification.