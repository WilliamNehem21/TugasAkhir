In any standard abstract interpretation framework, it is conceivable to view it as a probabilistic abstract interpretation by lifting the traditional domains into probabilistic domains, such as Hilbert spaces. Another strategy for analyzing probabilistic programs involves applying traditional abstract interpretation techniques to probabilistic semantics. This approach corresponds to a specific case of traditional abstract interpretation, resulting in safe worst-case analyses. Additionally, the more general probabilistic abstract interpretation approach allows for the construction of statistical information more in line with an average-case analysis.

One example of an analysis based on the loss of probability while concerns the parity of variables. While it can be debated whether this analysis is practically useful on its own, it serves as a useful example for illustrating the basic methodology. The purpose of the parity analysis is to determine at each program point whether a variable is even or odd. This is a simple forward analysis, where the concrete and abstract implementations are almost identical, with the exception of a few operators and the fact that the identities have reduced dimension. The control-flow steps remain unchanged, as the focus here is solely on data-flow analysis. Each operator is constructed using the parity.

It is relatively simple to implement finite approximations of both the concrete and abstract semantics using a numerical program like Octave. As expected, the size, even with sparse matrix representations, becomes prohibitively large. While things still work for n= 5, it is effectively impossible to handle the case of n= 10. The abstract semantics do not encounter this issue.

An example of a more interesting static program analysis is the classical live variable (LV) analysis. This represents a backward analysis, meaning that the control flow must be reversed. To achieve this, the transposes of the original control-transfer matrices are used.

The information recorded about each variable simply indicates whether it is alive or not, requiring consideration of an abstract state for each variable in the set v({live, dead}). The update can be specified in a manner similar to the classical analysis. The local transfer function is usually defined by means of the control flows coming together, as seen in a test in an if or while statement. Additional information about the branching probabilities is required to accomplish this, which could be obtained experimentally from profiling or from the concrete semantics by not abstracting at least those variables which determine.

Similar to other probabilistic variants of traditional analyses, the classical result can be reconstructed from the probabilistic version by recording the possibilities instead of probabilities. For this, a forgetful map from v(x) to p(x) is defined, considering only the support of a probability distribution, i.e., those elements in x which are associated with a non-zero probability.

A formal estimation of the branching probabilities for if statements (and similarly for while loops) follows a specific scheme: perform a first-phase analysis (e.g. a parity analysis) to determine the branching probabilities, then use these estimates for the actual analysis. This effectively involves replacing tests with ways to construct abstractions of control variables in order to obtain optimal estimates for these branching probabilities. Alternatively, for sub-optimal abstractions, determining the error margins of these estimates is also of interest. Finally, there are plans to extend this approach to higher order languages, such as functional languages, and to implement a prototype of an automatic analyzer.