The completion of the use case involves specifying the use case extensions, which depict alternative scenarios that may or may not lead to achieving the use case goal. These extensions represent different or exceptional behaviors compared to the main success scenario and are crucial for capturing the full system behavior. Each extension begins with a condition related to one or more steps of the use case.

User task modeling is a well-established technique that supports user-centered UI design. In most UI development approaches, the task set serves as the primary input to the UI design stage. User task models describe the tasks performed by users using the application and their relationships. These task modeling approaches are rooted in activity theory, where human operators carry out activities to change part of the environment (artifacts) to achieve a specific goal.

Tasks are represented as a directed graph and are hierarchically decomposed into sub-tasks and atomic actions. Leaf tasks, also known as actions, are the tasks actually carried out by the user or the system. Temporal operators determine the execution order of tasks, including enabling (>>), choice ([]), concurrency (||), and disabling ([>).

Alur et al. propose a semantics for a subset of message sequence charts (MSCs) that only allow message events as possible event types. Katoen and Lambertâ€™s semantics for MSCs is more comprehensive and maps them to a set of partial order multi-sets (Pomsets). Pomsets contain all objects that can be derived by a bijective projection from a base lposet. Approaches based on pomsets are similar to those based on lposets.

Mizouni et al. propose use case graphs as an intermediate notation for use cases, where the edges represent use case actions and the nodes represent system states. They also describe an algorithm for transforming a set of related use case graphs into an extended finite state machine (EFSM) for integrating several use cases into a single specification.

In use case modeling, state conditions often constrain the execution of use case steps. For example, the pre-condition attribute of a use case denotes the set of states where the use case can be executed, and each use case extension is triggered by a condition that must hold before the extension steps are executed.

In the following section, we present an approach to semantics in which we show how task models and use cases in ConcurTaskTrees (CTT) can be mapped to sets of partially ordered sets (posets). We define some operators over posets and describe semantic functions that map use cases and task models into sets of posets.

To derive a task expression from the task model, we first create a corresponding expression tree, where the operands are actions (leaf-level tasks) and the operators are the temporal relations defined in CTT. We then map the task expression into a corresponding set of posets, where action tasks correspond to elements of the poset, and composite tasks are represented by sets of posets composed using defined operators.

We discuss how use cases can be transformed into sets of posets, involving the transformation of textual use cases into an intermediate graph form called a use case graph, from which a corresponding set of posets is constructed iteratively. The construction process involves assigning a set of posets to each transition in the use case graph and then iteratively transforming the use case graph into a labeled transition system.

The resulting set of posets is a composition of use case steps, which requires special consideration when handling self-loops or pre-existing transitions.