The practical utility of coding rules should not depend on who formulates the rule set or enforces its usage. Several commercial compilers and quality assurance tools, such as those from IAR Systems and Parasoft, purport to verify code compliance with certain standards like HICPP or MISRA-C. However, the lack of formal and concise rule definitions makes it challenging to ascertain what these tools are precisely examining, leading to potential discrepancies in code validity assessment across different tools.

Notably, our coding rule checking tool has been integrated into the GNU Compiler Collection (GCC) development tool-chain, aiming to make the checker easily accessible to a large developer community and thereby promote the adoption of coding rules in various projects. Additionally, by utilizing a unified parser and semantic analysis engine within GCC for both compilation and code checking, we mitigate possible discrepancies in code interpretation that could arise from using different parsers or analyzers. Furthermore, existing static analysis information within GCC can be leveraged to implement rules requiring such data.

Currently, our rule definition language is a subset of Prolog with additional syntax extensions, though we plan to simplify rule formalization by employing a completely declarative logic language in the future. As an example, the Prolog formalization of rule 3.2.4 detects a violation in which an abstract class contains a public constructor. Our goal is to empower developers, even those unfamiliar with Prolog, to formalize coding rules.

In our enhanced version of GCC, which encompasses around 2.8 thousand lines of new code, we have integrated both the middle-end and the C++ front-end for the purpose of rule checking. Most of the analysis is conducted in a new middle-end pass, offering advantages such as simplicity in adding new passes, minimal overhead when a pass is disabled, and potential reusability for other GCC languages.

For every pertinent entity in the code, a Prolog term of the form "entity(global key)" is generated, where "entity" could represent an enum, enum value, union, record, function, global variable, method, field, or bit field. Additionally, the naming scheme for local entities is based on the scope in which they are defined, and numerical identifiers are generated for anonymous entities.

We have also established a rule checking procedure that quantifies the number of rule violations and user time consumed during various steps. While enabling structural data gathering during compilation increases project build time, the observed performance for project-wide static analysis is reasonable, demonstrating the tool's feasibility for widespread use.

Furthermore, we found a notable number of violations for many rules, though certain rules, such as HICPP 3.3.14 and 3.3.15, were not violated. This discrepancy is attributed to the infrequent usage of the specific language features addressed by these rules.

In summary, our tool for structural coding rule validation, which utilizes a declarative rule definition language for formalizing C++ rules, is seamlessly integrated into developers' workflow, receiving basic program information from the GCC compiler, thereby ensuring consistency in analysis.