We will first provide an overview of Protocol Composition Logic (PCL) to assist readers who may not be familiar with it, followed by a discussion of the Transport Layer Security (TLS) protocol, which will be used as a recurring example throughout this paper. Readers already knowledgeable about PCL and the analysis of TLS using PCL may proceed to Section 3.

The proof system we present expands first-order logic by incorporating axioms and proof rules for protocol actions, temporal reasoning, properties of cryptographic primitives, and a specialized version of the program invariance rule called the honesty rule, as detailed in Section 2.3. The axioms utilized in this paper are listed below. To delve into the soundness proof of the axioms and rules, we direct the reader to [6, 11, 7].

Next, we delve into the Transport Layer Security (TLS) protocol, which involves two main entities known as the TLS client and the TLS server. TLS ensures mutual authentication and establishes a shared secret between these entities. Our focus lies in proving the authentication property and identifying the program invariant required for it. Furthermore, we establish various other security properties of TLS as part of a comprehensive investigation into IEEE 802.11i.

We commence by outlining our representation of PCL programs. As a reminder from Section 2.3, we are required to demonstrate that the invariants hold at the conclusion of each initial segment of any protocol executable by an honest principal. We elucidate the process of invariant verification for one such initial segment; the general scenario merely comprises a conjunction of these steps.

PCL programs are depicted as a collection of facts involving the action predicate. The action predicate is structured as action(thread, actionnumber, output, actionname, input). For instance, the initial segment of the TLS client role (TLS: client0 from Section 2.4) is denoted by the following set of facts. The second fact action('x', 1.1, t1, cat, [nx, vx]) affirms that thread x concatenates the terms nx and vx to yield the term t1. The actionnumber field serves to ascertain the ordering of actions within a thread.

The action executed on the network is considered as a side effect, referred to as "output." In general, the number of inputs to an action hinges on its type. A key disparity between the PCL program listing and the logical program encoding is the explicit representation of concatenation actions. While an alternative encoding could have utilized the list construct, we discovered that this approach results in computational inefficiencies in practice.

Subsequently, we delve into the proof of the principal theorem. We demonstrate that the verification of invariants is sound when employing a standard decision procedure on logic programs. As stated in Section 2.3, the invariant must be deemed true for every initial segment of every protocol executed by an honest principal. We elucidate the process for one such initial segment and establish that if our decision procedure outputs failure on the query...

In the subsequent proofs, we attest that a decision procedure utilizing SLD-resolution in a left-to-right, depth-first manner is sound for invariant verification. We also leverage the fact that SLD-resolution attempts every rule in the logic program before encountering failure. Most Prolog interpreters implement SLD-resolution in a left-to-right, depth-first fashion, enabling us to employ standard tools for realizing the decision procedure. Specifically, we utilized SWI-Prolog as our prototype tool.