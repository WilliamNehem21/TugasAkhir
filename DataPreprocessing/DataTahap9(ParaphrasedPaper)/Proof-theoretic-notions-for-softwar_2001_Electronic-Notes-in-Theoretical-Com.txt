One important concept in a proof-theoretic context is the concept of usage. We propose formal definitions of this concept depending on the underlying calculus, allowing explicit control of the parts of a program that are essential for a specific property. This control provides a form of locality, which is crucial for the potential reuse of proofs or parts of proofs when a program undergoes changes.

For our purposes, we treat computer programs as syntactic objects, distinct from the algorithm or mathematical function they implement. Software maintenance is understood as the modification of program text.

The formal analysis of programs in theoretical computer science involves associating a programming language S with a formal framework F. Using a translation T, programs in S can be interpreted within F. These frameworks exist for almost all modern programming languages, and there are competing frameworks with varying complexity, expressivity, and practical usage, even differing in their focus on denotational or operational semantics. However, these differences do not impact our approach, which is applicable to theories axiomatizing both denotational and operational semantics. This is important, as operational semantics is often more closely related to proof-theoretic views, while denotational semantics is linked to model-theoretic perspectives.

Additionally, we suggest referring to the second volume of the handbook of theoretical computer science as a general resource. It is worth noting that the formal approach to programming languages pioneered by Hoare is extensively documented, containing over 400 references.

The defined concepts are highly general and applicable in diverse contexts, provided an appropriate formal framework is available. However, for many computer programs, the computation and management of used formulas may be excessively time and space consuming. Nevertheless, given the conceptual clarity offered by our approach, there are numerous areas where it can be directly applicable.

Within this framework, the concept of pruning embodies some of our objectives. For instance, if we extract a program from a given proof utilizing case distinctions, newly acquired information may decrease the number of possible cases. Systematically leveraging this information allows for the pruning of distinctions, resulting in a more efficient program.