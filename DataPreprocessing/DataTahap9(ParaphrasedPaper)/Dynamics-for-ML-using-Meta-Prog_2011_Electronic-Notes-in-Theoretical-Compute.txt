One of the significant benefits of programming languages that leverage the Hindley-Milner type system, such as OCaml or Haskell, is the brevity and expressiveness of their type language. For instance, these languages make it very natural to express and utilize sum types when combined with pattern-matching. While these concepts can be translated to C or Java, doing so comes at the cost of a laborious and unnatural encoding. Additionally, parameterized types and mutually recursive types can be employed in OCaml or Haskell to empower users to define intricate data types. A crucial aspect of programming in these languages involves encoding the problem's invariants into the types, allowing the compiler to statically ensure the fulfillment of these invariants throughout the program's execution.

Efficient code generation with compact runtime support can be achieved through these languages. However, the absence of runtime type introspection makes certain tasks more challenging compared to more dynamically-typed languages like Python or Java. Operations such as pretty-printing, type conversions, and value persistence require manual effort in ML-like languages and can be tedious and error-prone. Haskell addresses these issues by utilizing type classes, which, while a natural solution, are challenging to implement. This approach leads to a more complex type-inference algorithm and imposes performance penalties on the runtime implementation. The paper focuses on dynamic types while being influenced by concepts derived from type classes.

Although these constructs are powerful, implementing them correctly within a rich type environment is difficult and intrusive in the compiler source code. Modern versions of OCaml have discontinued support for dynamics as a result of this complexity.

The paper presents a simplified implementation of dynamics in OCaml, based on staged programming to generate and execute code fragments as part of the compilation process. It describes a two-stage transformer that is adequate for producing information about dynamic types and illustrates the usage of this information in building a storage layer that can conveniently persist ML values. An advantage of this approach is that it does not require modification of the core OCaml compiler but instead utilizes the Camlp4 AST transformer to generate additional code at compilation time. The implementation accomplishes the following: (i) parsing a large subset of OCaml types into a more concise and expressive form than the syntax tree provided by Camlp4, (ii) implementing an object-relational mapping (ORM) defining an efficient conversion to and from SQL, and (iii) providing a syntax extension to enhance type.

In this implementation, the type `t` is a standard OCaml type adorned with an annotation to designate it as a storage type. Variables of type `t` can be saved and queried using the `t_open`, `t_save`, and `t_get` functions. The backend leverages the SQLite database library, and SQL is automatically generated from the application's data types and is not directly used by the programmer.

In this context, the type of `x` must be defined beforehand for the program to compile. This definition may have been automatically generated using the `type-of` library or defined by the user. The latter option makes the `type-of` library easily extensible, especially for abstract types.

The only constructs in use are unbounded product and sum constructors. Values corresponding to named sum types are constructed by retaining the tag's name and the corresponding value. Functional values have no explicit runtime representation and are depicted by the symbol `t`.