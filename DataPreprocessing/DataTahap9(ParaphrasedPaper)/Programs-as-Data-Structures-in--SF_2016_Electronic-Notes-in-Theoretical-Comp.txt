The expressive power mentioned can be utilized to facilitate arbitrary queries of closed normal forms. In this context, the data structures can be equated with the closed normal forms, raising the question of how programs fit into this framework. The standard interpretation of programs does not produce normal forms, as recursion is represented by a fixpoint function which lacks a normal form. Nevertheless, conventional combinators can be employed to match programs, including recursive ones, with closed normal forms. Consequently, programs can be associated with closed normal forms. 

In an untyped setting, the identification of programs with (closed) normal forms is rather atypical. It is important to note that isolating the terminating computations is not feasible, as this would effectively solve the halting problem. Moreover, if any computation, even one that takes no inputs, could be viewed as a program, then the reasoning would be circular. However, by separating the program from its inputs, combinatory techniques can be employed to prevent any problematic reductions in the program until the input is provided. This approach enables programs to attain strong normalization and thus be linked with (closed) normal forms.

All the named lemmas and theorems in the paper have been verified using the Coq proof assistant, and further details can be found in the source files. This section will recapitulate some of the key definitions and theorems to gain an understanding of the harmony between the manual and automated approaches.

Users of domain-specific languages are motivated to create their own languages tailored to their specific needs, as general-purpose languages often prove to be suboptimal. One approach involves evolving a language from a small core, which becomes more feasible once program analysis and evaluation strategies are definable.