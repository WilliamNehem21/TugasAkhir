The use of definitions by iteration and coiteration has been effectively applied to implement secure type systems that extend the second-order polymorphic lambda calculus, system f. Therefore, it is natural to consider defining and implementing fold operators corresponding to course-of-value recursion as well. This paper introduces some new such extensions and discusses important observations that emerged while verifying the correctness and safety properties of their operational semantics, drawing from both the categorical and logical approaches based on fixed-point operators. The paper's findings should be viewed as a starting point for further exploration of the relationship between these two approaches.

This paper focuses on another valuable concept known as course-of-value recursion, captured by a construction called histomorphism. However, the emphasis is not on the categorical concepts, but rather on their implementation as type systems, which has been successfully achieved for other schemes. The ultimate goal is to implement recursion principles within the framework of typed lambda calculus, leveraging both the categorical approach discussed earlier and a fixed-point approach commonly found in logics with inductive definitions as a foundation. While the formalisms presented in this paper may not be strictly new, the contribution lies in presenting them within the framework of curry-style type systems, generalizing them with full monotonicity instead of positivity, and discussing important remarks about their static and dynamic semantics. Additionally, this work aims to serve as a starting point for a deeper comparison of two distinct approaches to modeling course-of-value recursion.

In the context of different implementations of the course-of-value fold operator, the paper presents a case study involving natural numbers. After briefly discussing termination (strong normalization) and its associated challenges, the paper adopts a viewpoint that continues to pursue this property through an alternative system for course-of-value iteration presented in section 6, which is shown to be terminating. The paper also identifies operational problems with natural numbers and proposes full course-of-value primitive recursion as a definitive solution in section 7. Finally, in section 8, some closing remarks and suggestions for future work are provided.

An interesting future avenue would be to model course-of-value recursive types in Kleisli categories or compare histomorphisms with Kleisli or Eilenberg-Moore constructions. However, the primary goal of this paper is not to further develop the work on category theory, but rather to implement recursion principles within the setting of typed lambda calculi, using the categorical approach as a foundation. The paper outlines the general idea to later model the principle of course-of-value iteration.

The overall aim is to implement the course-of-value iteration scheme as defined by histomorphisms, as this categorical approach is interesting and useful for obtaining recursion combinators in typed lambda calculus. It is noted that while untyped lambda calculus has general recursion, the simple typed lambda calculus lacks recursion, making fixed-point operators like 'y' untypable. Although simple iteration principles can be modeled in the second-order lambda calculus (system f), the encodings are impredicative and challenging to handle practically.

As demonstrated in the previous section, the principle of course-of-value iteration can be faithfully modeled within a type system. However, an important question arises when proposing a new language - whether the new constructors can be defined as syntactic sugar in a base language, which typically already possesses important properties like safety or termination. It is revealed that this holds true in the presented case. An alternative reduction rule for course-of-value iteration is considered, with a proof similar to the ones for the systems in, based on the one for system f given in. It is noted that the property is non-trivial due to the systems being presented in curry-style, resulting in the rules for polymorphic typing not being syntax-directed.

The termination of these new systems is accomplished by a type-respecting and reduction-preserving embedding into a terminal system developed in, which includes the above operational rules for inversion. The essential part of this embedding can be derived from the definition of histomorphisms by catamorphisms (simple iteration) of proposition 3.6.

It is well known that the inefficiency of an iterative predecessor disappears by using primitive recursion instead of simple iteration to define it. Therefore, it is believed that the needed well-behaved predecessor for course-of-value natural numbers can be obtained using primitive course-of-value recursion, which would also solve the problem for the destructor of any course-of-value monotone inductive type.