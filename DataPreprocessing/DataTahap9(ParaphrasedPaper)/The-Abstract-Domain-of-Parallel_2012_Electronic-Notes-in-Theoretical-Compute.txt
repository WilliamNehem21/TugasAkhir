When defining the abstract operators, the primary challenge is that many specific operations do not preserve the properties of parallelotopes. Additionally, in numerous instances, there is no single optimal parallelotope that accurately approximates the outcome of the specific operation. As a result, it is crucial to carefully select, possibly using appropriate heuristics, an approximating parallelotope that provides precision in the overall analysis.

If ci ≠ 0, the operation assign(i, c, b) is reversible and, importantly, transforms a parallelotope into another parallelotope. In this particular scenario, it is feasible to implement the abstract operator in a manner similar to the concept of assign(i, c, b), which corresponds to the assignment xj = ctx + b, where xj represents the value of xi after the assignment.

Therefore, it becomes necessary to explicitly state the constraints embedded in p that do not involve the variable xi to be eliminated. The issue lies in the fact that, generally, there are more implied constraints than can be represented with a parallelotope. Hence, a method for selecting among competing constraints is required.

To address the aforementioned issues, we suggest a new operator. Initially, we may disregard the rows in p that are unbounded (i.e., with infinite lower and upper bounds) or whose i-th entry is zero: the former remain unbounded, while the latter are unaffected by the assignment. Subsequently, we will focus solely on the remaining rows, identified by the set j={j| aji ≠ 0, lj ≠ 0}.

We now propose a more intricate version of the abstract union, influenced by the recently developed inversion join operator. The fundamental idea of the algorithm is to generate several potential linear forms. The corresponding constraints are derived from these linear forms by calculating the lower and upper bounds on pa and pb. Subsequently, each constraint is assigned a priority.

Apparent candidates for the generated linear forms are the rows of the matrices a and b. Furthermore, new linear forms are also generated using (a part of) the inversion join algorithm. Given two constraints in pa and/or pb, the inversion join computes a novel linear form obtained as a linear combination of the two constraints, under the condition that they constitute an inversion. The complete procedure is illustrated in algorithm 5.