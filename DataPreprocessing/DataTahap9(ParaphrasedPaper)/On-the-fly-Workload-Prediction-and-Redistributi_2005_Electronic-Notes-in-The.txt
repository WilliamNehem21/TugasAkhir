The utilization of timed cases gives rise to distinct parallelization strategies and obstacles. Time model checkers typically rely on difference bound matrices (DBM), which serve as symbolic representations of state space. However, they differ conceptually from binary decision diagrams (BDD), which are the fundamental data structure for a wide range of untimed model checking tools and their distributed counterparts. As a result, the strategies and concepts employed in distributing BDD-based model checking algorithms, such as slicing large BDDs, do not appear to be directly applicable to the timed setting.

This paper delineates the challenges encountered in both asynchronous and synchronous versions of architecture, as discussed in section 3, and subsequently introduces the techniques employed to address these challenges. Section 5 presents several case studies demonstrating the efficacy of these methods in improving verification times. Finally, the future research directions are outlined.

For readers familiar with low-level system coding, it is apparent that the actual cost of a malloc() call relies on memory fragmentation at the time of the call. This is often the case across various platforms, rendering the value of 'k' no more than an estimate. Moreover, as detailed later, other uncertainties also necessitate estimation.

When the actual value needs to be estimated, its rounded estimated parameter sizes are cross-referenced in the compiled information. In the absence of a match, a default value is utilized, representing the worst-case scenario of estimation. It is important to note that while this approach represents a simplistic form of best-fit matching, more sophisticated algorithms could be implemented. However, this method carries the advantage of minimal overhead in terms of both space and time, and demonstrates excellent performance.

Timed automata is a formalism that integrates positive real valued clocks into automata notation. Clocks record the time elapsed between events and are synchronized to advance at the same pace. Each control location (automata node) is associated with an invariant (a clock constraint), and transitions allow clocks to be reset to zero. Additionally, each transition possesses a guard (a predicate over the clocks defining its enabling condition) and a label to name the executed event.

The state at any given time is determined by the control location and the values of clocks, which must satisfy the location invariant. The system can evolve in one of two ways: either an enabled transition is taken, changing the control location and resetting some clocks while leaving others unaltered, or time elapses, causing clocks to increase according to the elapsed time while still satisfying the location invariant, with the system remaining in the same location.

Models can express properties in terms of TCTL formulae. In practice, most properties can be articulated in terms of reachability (sometimes adding a virtual observer automaton), which determines whether a given set of states is reachable from the initial state by executing the model. These target states are labelled by propositions denoting the locations.

The structure known as difference bound matrices (DBM) is frequently utilized to manipulate this type of information. Non-convex sets are represented as a union of convex sets. ZeuS conducts reachability queries through a backward propagation of non-convex sets over the graph of control locations. This propagation constitutes a fixed-point calculation that can be informally described as follows: it starts with determining whether the initial states belong to the computed fixed point (i.e., ascertaining whether the target states can be reached from the initial states or not). When the target states are unreachable, the entire state space must be explored, which is typically considered a worst-case scenario.