The use of formal methods in the design of computing systems often leads to the generation of verification conditions that must be proved to ensure the correctness of the outcome. These conditions express properties of models or relations between models and can be articulated using various logics, including propositional logic, high-order logic, process algebra, and temporal logic. Consequently, the degree of automation for verification in a specific formalism heavily relies on the availability of tools to support reasoning in these logics.

The following section provides an overview of notations and the fundamentals of SMT-solvers. In Section 3, we introduce an abstract framework for describing SMT-solvers, focusing on the soundness and completeness of the combination framework outlined in this paper. This framework is less detailed than the DPLL(T) framework, as its purpose is not to provide a precise description of solvers. In contrast to the DPLL(T) framework, and for the sake of simplicity, our schema emphasizes the differentiation between boolean reasoning and theory reasoning. It is easy to view DPLL(T) as a refinement of our schema.

Given that the bottleneck in the collaboration between proof assistants and SMT-solvers does not lie in the efficiency of the SMT-solvers, our efforts have not been primarily directed towards optimizing the efficiency of our implementation. Specifically, we do not integrate theory propagation into our implementation. However, we have observed that for specific QF UFIDL benchmarks, our implementation performs as efficiently as Z3.

Future work involves applying this technique to other decidable fragments, such as full linear arithmetic on integers and reals. Additionally, our implementation incorporates a comprehensive first-order theorem prover that handles user theories. We aim to investigate the advantages of our framework in the presence of such user-defined theories.