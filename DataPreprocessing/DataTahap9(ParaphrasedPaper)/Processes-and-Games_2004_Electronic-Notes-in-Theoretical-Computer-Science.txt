The field of computing in the contemporary era is characterized by its diversity and rapid rate of change. In a manner similar to other scientific disciplines, computing encompasses a wide array of activities and theories that pertain to various subject matters and utilize different approaches. Consequently, there is significant value in the pursuit of a comprehensive theory of computing, which can provide a shared mathematical foundation for unifying and integrating the diverse scientific theories and engineering disciplines within the field. Such a general theory is anticipated to have a transformative impact on the science and engineering of computing, analogous to the influence exerted by fundamental physical theories on the natural sciences and engineering. The development of a general theory of computing is expected to yield numerous benefits, notwithstanding the inherent disparities between computing and physical phenomena, with the complexity method being particularly promising in this regard. The theory of domains and denotational semantics, pioneered by Scott and Strachey, represents a precursor to this approach. The coexistence of these disparate approaches serves to complement one another: while an understanding of specific structures would be restricted without overarching general algebraic theories, a general algebraic theory may achieve its maximum efficacy when combined with a robust concrete structure. Diverse presentations of a core theory can be extended to a general algebraic universe, thereby enhancing both its depth and applicability; conversely, these variations can also suggest alternative, valuable presentations of a general algebraic universe, thereby facilitating a more profound comprehension of the subject matter. It is noteworthy that any general theory, regardless of its potency, can only offer one method of abstracting computational phenomena; alternative forms of abstraction remain conceivable, and the interaction among different mathematical abstractions serves to enrich our scientific understanding. Consequently, distinct avenues of inquiry may lead to new insights and advancements in the field. 

In a similar vein, channel types are expanded to accommodate finite or infinite vectors and finite or countably infinite type heights, subject to the same well-formedness conditions as before. A sum type may possess an infinite domain, as can an action type in general. By incorporating infinitary processes and types, the typing rules remain consistent with the previous framework, with each rule effectively serving as a constraint on each full subtree of a process.

Furthermore, the concept of well-bracketing correlates to the proper matching of parentheses when expressed using the notations [, (, ), and ], while also considering the justification for each closure (e.g., [ can only be closed by ] which it justifies). Additionally, an innocent strategy can be defined within this framework.

By virtue of innocence and contingency completeness, an innocent strategy can be precisely characterized as a partial function from odd-length legal player views to next actions (if any), with such functions being designated as innocent functions. Consequently, an innocent function uniquely defines an innocent strategy, and vice versa. In essence, contingency completeness stipulates that a strategy is consistently prepared to receive any legal input, whereas innocence ensures that a strategy consistently responds in the same manner within the same context (with the concept of sameness being applicable in both instances).

For instance, in Example 4.2, let 1 represent the empty arena. An innocent strategy from 1 to b is one that returns true after the initial move (the latter justifies the former); another strategy returns false, and a third one returns nothing. These respective strategies correspond to the three constants - truth, falsity, and undefined - which collectively constitute the only inhabitants of the boolean type. An innocent function from b to b commences from the root of the co-domain and immediately returns true at the co-domain, thereby representing a constant function with a value of true. Another innocent function of the same type would, following the initial action at the co-domain, inquire at the domain, receive true (or false), and subsequently output false (or true) at the co-domain, thereby defining the negation.