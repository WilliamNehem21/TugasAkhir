The widespread availability of a large number of documents on the internet has made plagiarism a tempting and straightforward practice. This issue encompasses various types of content, including natural language texts and structured information such as programs. To address this problem, numerous tools and algorithms have been proposed to identify similarities. In this paper, we introduce a novel algorithm designed specifically for detecting similarities in source codes. Unlike existing methods, this algorithm is based on the concept of function and focuses on obfuscation through inlining and outlining of functions. It is also effective against insertions, deletions, and permutations of instruction blocks, utilizing code factorization and adapted pattern matching algorithms and structures such as suffix arrays.

The technique involves breaking down each original function into sub-functions, with an aim to maximize the sharing of sub-functions across original functions. The entire source code is then represented by a call graph, where the vertices represent the functions and the edges represent the function calls. As a result, similar functions should lead to identical or comparable sets of sub-functions, i.e., leaves of the call graph. Depending on the measurement used to assess function similarities, this technique may be insensitive to common obfuscation methods, such as insertion, deletion, inversion, inlining, or outlining of source code.

The remainder of this paper is structured as follows: Section 2 provides an overview of the entire detection process, while Sections 3 and 4 detail the key steps of the factorization algorithm and call graph analysis. Related work and benchmarks are discussed in Sections 5 and 6, followed by the paper's conclusion and an outline of potential future work.

Our research focuses on identifying similarities in source code written in procedural languages at the function level. We aim to experiment with a similarity detection technique based on function transformations in order to be robust against outlining, inlining, and source block displacements. This involves manipulating abstractions of the programs using call graphs. By enriching the call graph with new synthetic sub-functions that represent the granularity of similarities, we aim to create a call graph that can be used to define and measure metrics or scores relative to function similarity.

Several research efforts have concentrated on detecting similarities in source code. This section specifically focuses on research works that seek similarities in source code, and these efforts can be categorized into two main groups based on their objectives.

The first group concentrates on software engineering and aims to identify exact matches to eliminate redundant cut-and-paste code or to track evolution between different versions of a project. Typically, these methods do not address the problem of obfuscation. Exact pattern matching methods and complex algorithms on abstract syntax trees or dependency graphs are commonly utilized in this context. Various tools, such as ccfinder or clonedr, are employed to implement these approaches.

Our factorization method for identifying similarities in source code has shown promising results in preliminary tests. Its primary advantage lies in its resistance against obfuscation methods such as inlining, outlining, or code block shifts. However, we acknowledge the limitations of our approach and explore potential future developments.

Excessive outlining across the set of functions in projects could result in a few short leaf functions, potentially leading to reduced precision and false positives. Therefore, setting an upper threshold for the lengths of the leaf functions is necessary. Additionally, considering new metrics for function comparison that take into account the order of function calls may be considered. Furthermore, conducting data-flow analysis on specific parts of the code could help reduce false positives.

Our current method does not handle function calls with one or more function calls as arguments, a situation that is not uncommon in source code and poses interesting challenges for obfuscation. One approach to address this could involve adding temporary local variables to unfold the composed calls into intermediate assignments.

At present, the results of outlining processes are presented as partial outlining graphs, and similarity between functions or clusters is utilized to identify similarities. Creating a more user-friendly tool for rendering the results is an area for future consideration.