When utilizing embedded domain-specific languages, a critical concern is the extent to which embedded programs can be analyzed and transformed, particularly in the context of strongly typed host languages where the host type system is utilized to type the embedded language. In this paper, we outline the utilization of a library designed for constructing transformations of typed abstract syntax to eliminate left recursion from a typed grammar description. The algorithm we present, known as the left-corner transform, is sufficiently compact to be fully elucidated, sufficiently intricate to be engaging, and comprehensive enough to serve as a guide for addressing similar scenarios. This transformation has been effectively used to devise a compositional and efficient alternative to the standard Haskell read function.

Furthermore, we elaborate on the process of using a template Haskell library to generate type grammar values and combining these values at run-time to form a complete grammar. The resulting composite value is then employed to construct the desired read function for the composed data type using Haskell code within the library. This approach not only improves efficiency (with a complexity of O(n^2), where n is the number of terminals and nonterminals in the grammar), but has also been substantiated through extensive testing with large grammars and data type descriptions, showcasing its strong practical performance.

The left-corner transform (LCT) algorithm operates by sequentially applying the transformation to each non-terminal of the original grammar, employing a depth-first search for left-corner symbols and introducing new non-terminals and corresponding definitions as necessary. The transformation is achieved through a combination of functions rules1, rule2, and insert, with rules1 being defined by induction over the original grammar.

This work has demonstrated the execution of complex transformations at run-time while ensuring partial verification by the type system. It has leveraged a diverse array of type system concepts, such as generalized algebraic data types (GADTs), existential and polymorphic types, as well as lazy evaluation, which are uniquely available in Haskell. Importantly, this work represents the first description of run-time typed transformations that modify references within an abstract syntax represented as a graph, as opposed to a tree, thus addressing a previously unexplored complexity in typeful transformations of embedded domain-specific languages.