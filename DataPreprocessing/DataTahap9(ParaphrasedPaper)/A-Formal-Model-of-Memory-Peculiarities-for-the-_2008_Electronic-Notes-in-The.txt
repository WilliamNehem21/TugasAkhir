The paper discusses how certain practices that may appear unreasonable from an application programming perspective are actually quite common in kernel programming. It delves into the different ways in which kernel programming differs, such as the use of casts and pointer arithmetic, and also discusses the types of states and data in the context of PVS formalization. Additionally, it explains the composition of state transformers and the formalization of memory models in the hardware system, emphasizing the need to model cache effects on cachable devices. The paper also highlights the challenges in defining correct semantics for non-volatile data in C++ programs and presents an approach to maintain the correctness of memory access at blessed addresses. Furthermore, it covers the specification of well-behaved plain memory and the modeling of memory-mapped devices and reserved bit restrictions, and provides examples of the formalization of a random number generator and the verification of a simple C++ code fragment.