Aspect-oriented approaches have often emphasized the need to separate concerns. Some of these approaches, such as Hyper/J, have implemented separation in a symmetrical manner, while others, like AspectJ, have relied on an asymmetrical separation. The main difference lies in the symmetrical role that various concerns play in the former approach, while the latter explicitly includes a conventional implementation onto which other concerns are added as aspects. This raises the question of how the concerns of the conventional implementation are special in the latter approach, and whether the opportunity to use symmetrical separation leads to a fundamentally different decomposition. This paper explores the dominance in decompositions in specifications and corresponding aspect-oriented implementations. It uses the specification method Disco, which allows the modeling of concerns in a manner that separates them into specification branches. Hyper/J and AspectJ are used as examples of aspect-oriented implementations that can be composed for Disco specifications. The paper concludes by proposing that any aspect-oriented approach targeting the system at the level of program code necessarily involves some concerns that are more dominant than others due to the control flow of programs.

The term "tyranny of dominant decompositions" is introduced to address issues related to the inability to address all concerns of a software system using the same facilities. This has led to the introduction of a paradigm where all concerns can be treated in a similar fashion, with a practical programming-level implementation in Hyper/J. This allows for the symmetrical treatment of all concerns, enabling the creation of systems where both conventional modularity and cross-cutting properties are enabled using hypermodules.

In contrast to symmetric approaches, asymmetric approaches have also been introduced, such as AspectJ, which introduces facilities for augmenting a baseline implementation with additions referred to as aspects. This allows an existing system, given as a conventional program, to serve as the starting point, with new behaviors woven into the system using aspects. Developers can anticipate the injection of aspects and overlook such parts of the system in the baseline implementation.

The paper is structured as follows: Section 2 introduces the specification and modeling method used as the starting point, while Sections 3 and 4 outline implementations for Disco specifications using Hyper/J and AspectJ, offering symmetric and asymmetric decompositions of concerns. The dominance of decompositions in the described systems is also discussed, with the paper concluding in Section 5.

Disco specifications are composed in terms of layers containing classes and actions. Classes act as containers of data, while actions can be understood as multi-object methods that can modify variable values. The use of layers allows modeling of systems using several levels of abstraction, with each layer focusing on a specific concern the modeler wants to address separately.

Layered specifications in Disco allow for the addressing of individual concerns, and the refinement relationship between layers preserves the safety properties of all component layers, with refinements only introducing more restrictions. Furthermore, layers are complete in that they only describe behaviors in terms of the variables included in them, creating a new universe when composed, where the rules of behavior of all component layers are satisfied. Recently, aspect-oriented techniques have been considered to preserve the structure created with layers, applying the same design methodology in aspect-oriented system design.

When composing a Hyper/J system, independent subsystems are defined initially, with the goal of creating all necessary operations in isolation. However, the branch defining the control flow plays a dominant role in the semantic sense, as only declarative goals can be achieved before its inclusion. In contrast, in AspectJ, a baseline implementation is given using conventional Java and is then extended with aspects woven into the code.

The paper concludes that any aspect-oriented approach targeting the system at the level of program code necessarily involves some concerns that are more dominant than others due to the control flow of programs, and offers insights into approaches such as Hyper/J and AspectJ in addressing these concerns.