The translation of Handel-C programs into net-list descriptions of hardware components has been widely used in commercial tools but has not been formally verified. In this paper, we introduce a modified semantic model for Handel-C compilation that is suitable for mechanical proofs and detailed enough to analyze properties of the generated hardware. Using this model, we prove the correctness of the wiring schema used to interconnect hardware components and propagate control signals among them. We also discuss the mechanization of the model and the correctness proofs in the HOL theorem prover.

Given that our hardware model captures the semantics of circuits with loop-back connections by replicating the appropriate behavior through successive syntactic approximations, we must also consider the possibility of having an infinite set of traces. This feature precludes explicit description of the semantic set, particularly as we aim to mechanically verify our approach.

For the remainder of the paper, we will use "and" and "as" as short-hand notations for the mixed and combin constructors, respectively. In these terms, the semantics of the delay construct state that its combinatoric prelude only includes a verification for the start wire, while its combinatoric prologue simply sets its finish wire to the high value. The behavioral part of the circuit specifies that it delays its execution for a single clock cycle (definition 3.2).

The semantics for the while construct need to provide rules for handling the two possible outcomes of the evaluation of the condition. The first rule accounts for the case when the condition is false, and the while terminates immediately (definition 3.7).

Finally, the base case for the output construct is similar to that for input, but it inverts the roles in the combinatoric prelude (it establishes the writer's presence and asserts the reader's readiness). Its behavioral part is also different as it must assign the transmitted value to the appropriate channel (definition 3.12).

As we are dealing with sets of actions and assertions on each node of our sequences, we need to define the collective effect of this heterogeneous set of actions over the environment. The first difficulty we face when defining how a set of actions is going to be executed is that the initial order between actions and conditions has been lost. However, this is not a problem considering that assertions and control flow conditions refer only to the present value of the memory, and all variables preserve their values during the whole clock cycle. This fact makes the evaluation of assertions and control flow decisions independent of the combinatoric actions performed in parallel, and they can be evaluated at any time.