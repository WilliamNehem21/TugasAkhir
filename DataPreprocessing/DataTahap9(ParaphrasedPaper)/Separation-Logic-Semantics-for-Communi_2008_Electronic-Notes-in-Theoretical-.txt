The utilization of sets of primitive events, particularly in the depiction of completed communications, has been selected due to its propensity for yielding a straightforward notion of event composition through the use of set union. The sets of primitive events also represent concurrent actions, such as multiple offered communications on different channels, e.g., [c!3, d!4], or simultaneous consummated communications, e.g., [c!3, c?3, d!4, d?4].

In our approach, we have opted to only record communication events in the traces, excluding allocation and deallocation as events, as they are represented solely by changes in the alphabet. For instance, in t(c), the introduction of new extends the alphabet with both ends of a channel c (also binding c to x in the environment), while dispose removes those channels from the alphabet. The successful execution of dispose x necessitates both ends of the channel denoted by x in its pre-alphabet.

Not all sets of primitive events are meaningful. For example, a set [d!3, d!4] denotes two concurrent sends on d with different values. Another example, [c!(d!), d!3], involves the concurrent sending of 3 on channel d and the send permission for d on channel c, conflicting with the point-to-point notion that two processes cannot simultaneously possess the send permission on a channel.

Consistency of events occurring concurrently can be formalized through the notion of pre(e), which describes the required resources for event e to occur. Consistency between events e and e' signifies that their pre(e) and pre(e') do not overlap, enabling them to occur concurrently.

The semantics traces(p) of a process is a predicate denoting a set of traces, functioning as a mapping from environments to trace sets. We leverage logical notation in a semi-formal manner to represent these predicates, relying on predicate calculus for environment manipulation.

The synchronization property postulates that when a process possesses a resource, it has exclusive control over it. This property is illustrated through an example involving the sending and copying of messages between channels.

Additionally, we discuss a limitation of the trace model in addressing errors, highlighting the challenges in distinguishing and avoiding different types of errors represented using the stop symbol in the basic trace semantics.

In the subsequent section, we explore theoretical properties and conditions, such as healthiness conditions, which identify conditions on predicates preserved by the semantics of process terms. We also formulate a result on footprints, formalizing our intuitions about resources.

We provide reasoning to support the reasonability of the unity restriction. Furthermore, we establish the lattice structure of trace sets satisfying the healthiness conditions, and we discuss the scott-continuous nature of the trace semantics of each construct in its process arguments.

The exploration of recursion using least and greatest fixed-points is discussed, presenting their respective applications and relevant ordering considerations.

Our utilization of partial alphabet composition bears similarities to substructural typing in limiting channel access for processes. We also discuss potential complementarity between the techniques developed in this work and those in the field of types for pi-calculus.

We draw attention to the use of substructural logics in reasoning about process calculi, contrasting our approach with prior work in terms of the order of setting down models and defining semantical features using separation conjunctions.

By integrating concepts from csl and csp, we have delineated the semantics of a message-passing language featuring dynamic channel allocation and deallocation. The trace semantics of parallel composition entails a composition operation on traces that partitions channel ends between processes, and we also present results concerning the footprint of a process, reflecting how the model accounts for resources locally.