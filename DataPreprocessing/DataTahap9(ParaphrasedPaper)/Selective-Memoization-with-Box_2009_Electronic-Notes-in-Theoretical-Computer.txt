However, it is not possible to assign a new value to the same box, and when a value v is encapsulated by a box, it signifies that v should be examined to reveal its control and data dependencies. In practice, memoized functions often involve a box type in their domains.

The paper is structured as follows: following this introduction, we introduce a system called sm of selective memoization with box types in section 2. We then present an auxiliary system s, which retains the selectivity mechanism but without effects (storages), in section 3 and prove its type safety. In section 4, we demonstrate the type safety of sm through a faithful translation to s. In section 5, we provide a translation of s to pcf, indirectly proving the soundness of the original effectful evaluation semantics of sm with respect to the purely functional semantics of pcf. Finally, in section 6, we offer closing remarks and discuss future work.

Here, box t represents the constructor of box typed terms, and mfunl(f.a.e) defines a memoized, usually recursive, function with the name f, where the metavariable l belongs to a set l of label locations disjoint from ordinary variables and resources. The dot notation on abstractions, case analysis, and function declarations denotes variable contexts corresponding to the validity context, resource context corresponding to truth contexts, and a third context for labels to keep an exact track of the labels occurring in a term or expression. This context is used to statically ensure that location labels of different functions in the same program will be different.

In the case of rule(eletbox), we have e' = let box(t, x.e1), e = e1[x:=

Although system s does not have explicit effects, it still maintains a distinction between types and expressions as well as the selectivity feature, making it impure in a strict sense. To address this issue, we provide a translation of s to the purely functional language pcf.

The framework mfl of selective memoization explicitly captures the performance effects of memoization by documenting control and data dependences between the input and the result of a memoized function. Furthermore, it yields programs whose running times can be analyzed by standard techniques and has been implemented as an sml library. An essential feature of the system is the use of a modal type to reveal dependences. In this paper, we present a framework similar to the one developed previously, with improvements from a theoretical point of view. Instead of the bang modality, we use the box type corresponding to the necessitation modality, deeply discussed from a logical point of view. We provide our system with a static semantics that keeps an exact track of the location labels occurring in a term or expression, ensuring the uniqueness of the label assignment for memoized functions. Type safety for sm is proven by its translation to an effect-free system, which is later translated.

Memoization becomes more complex when the language includes composite value types like records, and in such cases, the data dependencies should be as fine-grained as possible. Therefore, it is interesting to explore the modeling of such dependencies in our framework. Additionally, regarding the inclusion of recursive types, we recall that memoization is most effective when applied to the kind of programs used in dynamic programming, which usually are neither simple iterative nor primitive-recursive, but course-of-value recursive. This fact leads us to investigate an extension with inductive types modeling the latter principle, motivated by our previous work.