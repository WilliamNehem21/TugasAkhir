The well-known approach to security, including several methods highlighted by G. Lowe, has been the subject of scrutiny. An advantageous aspect of this approach is the development of numerous automated verification techniques and tools [21, 8, 7, 2].

In the realm of computational approach, cryptographic primitives function on bit strings, and their security is defined by high complexity and the low likelihood of attacker success (e.g., in encryption). Protocols and attackers are modeled as randomized polynomial-time Turing machines. While this computational approach is seen as more realistic than the formal approach, its complexity makes it challenging to design automated verification tools.

In recent years, efforts have centered on bridging the gap between these two approaches. For instance, Abadi and Rogaway demonstrated that the notion of message indistinguishability in the symbolic model aligns with the computational model, provided that the encryption scheme employed for messages satisfies semantic security. This indicates that if two messages are indistinguishable in the symbolic model, then their computational implementations cannot be distinguished by a Turing machine in polynomial time. This pertains specifically to passive attackers that can eavesdrop but not alter or block messages.

The soundness of symbolic analysis has been established in the black-box reactive simulatability (BRSIM) framework by Backes, Pfitzmann, and Waidner. This result has been extended to encompass hash functions in the random oracle model, but it has been shown that such an extension is not feasible in the standard model. Despite the strength of the BRSIM model, this impossibility result does not automatically extend to the Dolev-Yao model used in [citation needed].

In this section, we analyze protocols enabling parties to exchange messages constructed from identities and randomly generated numbers using public key encryption and a hash function. These protocols are specified using terms in an algebra and typed variables. We utilize terms in this algebra and typed variables to describe protocols, where a term is termed atomic if it is a key, a nonce, or a variable, and ground terms (those without variables) are referred to as messages. Three types of instructions can be executed in protocol execution: receiving a message, sending a message, or testing a hash.

Two distinct protocol semantics are considered: symbolic and computational. Both delineate the behavior of the protocol when faced with an adversary. In the symbolic case, the protocol and the adversary exchange symbolic messages, and deductions are defined by a deduction relation. In the computational case, they exchange bit strings, and the adversary is a polynomial-random Turing machine capable of performing any operation.

Another property related to the strong secrecy of nonces, termed secnonce, is defined. This property asserts the difficulty for an adversary to distinguish the nonce used in protocol execution from a random nonce. In an experiment labeled secnonceb, after protocol execution, the adversary is presented with two nonce values and must determine which was used in the execution.

An alternative approach to ensuring hash function security involves employing probabilistic hash functions. While the security notion outlined ensures that any hash preserves partial information over the hashed message, it does not ensure the impossibility of forging a new hash containing the secret nonce. Additionally, the considered hash functions are probabilistic.

As a result, a new criterion for hash functions is formulated, aiming to ensure that hash functions satisfy a form of semantic security. Nevertheless, it is not feasible to directly adapt classical definitions as hash functions are deterministic, and the adversary cannot have full access to a left-right hash oracle. Thus, a new security game is introduced where challenge nonces are randomly sampled, and the adversary has access to a left-right oracle, with the queries being modified by inserting the challenge nonces before applying the hash function.

The main contributions of this paper encompass the formal definition of a correctness criterion for hash functions (that is easily fulfilled in the random oracle model), a proof of correctness for the Dolev-Yao model for protocols combining an asymmetric scheme and a hash function, as well as a discussion on potential future work, including investigating weaker assumptions on cryptographic primitives and extending the results to other security properties.