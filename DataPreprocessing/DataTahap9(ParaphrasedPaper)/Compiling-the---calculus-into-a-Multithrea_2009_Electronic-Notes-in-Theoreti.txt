The type system proposed for MIL closely aligns with the conventions of typed assembly languages, taking inspiration from previous works on typed assembly languages [20,21,22] and incorporating support for threads and locks in line with the work of Flanagan and Abadi. However, our approach operates at a lower level of abstraction in comparison to these previous works and encounters distinct challenges inherent to non-lexically scoped languages. While discussions on lock primitives have been prevalent in the context of concurrent object calculi, JVM [9,10,16,17], C, and C--, they have not been explored within the framework of typed assembly (or intermediate) languages. In a typed environment where programs are assured not to encounter race conditions, we handle tuple creation in registers. When initializing read-only tuples, they are directly established in registers. As long as the tuple remains confined to the (single-threaded) processor, there is no necessity to safeguard it with a lock or request permission to manipulate it. If the tuple is intended for sharing, the share instruction reserves memory in the heap and transfers the tuple from the register to the heap, while safeguarding it with a lock or marking it as read-only. We also elaborate on the introduction of universal and existential types in the system. Here, we encompass both forms of polymorphism, specifically introducing existential types over locks. The incorporation of universal and existential types over locks enables a lock variable to extend beyond the static scope in which it was declared. In situations where the buffer is empty, as in the monitor's initial state, the operation that removes the first element from the queue is undefined. We ensure that the consumer waits until the producer has filled the queue. It is presumed that the queue is infinitely large, ensuring space for producers to append new elements at all times. Due to this, and in contrast to removing from the buffer, appending does not cause a block.