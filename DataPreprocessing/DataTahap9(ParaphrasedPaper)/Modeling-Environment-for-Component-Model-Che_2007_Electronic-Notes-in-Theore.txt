The process of checking if a property is fulfilled in a model involves exhaustively traversing the state space defined by the model. While this method allows model checking to identify concurrency issues like deadlocks, which are difficult to uncover through traditional approaches like testing, its reliance on the complete traversal of the state space is also its primary limitation. Particularly in the case of complex software systems, the state space may be too extensive for model checking to be feasible, a well-recognized challenge known as the state explosion problem.

Additionally, when considering only primitive components, the issue with model checking lies in the fact that these components are not complete programs (i.e., they do not have a main method), and model checkers typically analyze only complete programs, thereby leading to the problem of missing environment. To address this, creating an environment for each primitive component subject to model checking could offer a feasible solution. Subsequently, the complete programs, each composed of a primitive component and its environment, can be separately checked.

The paper introduces an algorithm based on syntactical expansion and substitution of behavior protocols. Its input consists of the frame protocols of all the components in the architecture (excluding the target one) and the graph of the bindings between the components, and its output is the environment protocol of the target component. The algorithm comprises three steps, as detailed below.

The problem of model checking isolated software components within a component-based application can be viewed as a variant of compositional model checking. This approach involves decomposing a target system into multiple components, verifying the local properties of the components using model checking, and deducing global properties of the entire system from the local properties of the components. The crucial aspect of this approach is to check properties of a composition of a selected component with a model of its environment, ensuring that the local properties are maintained at the global level. Unlike compositional model checking, this approach focuses on verifying specific properties of individual components, such as adherence to a frame protocol.

In the verification of software component properties, the assume-guarantee approach is commonly employed. This approach involves checking a component only in environments that satisfy certain assumptions, typically provided by the user. By modeling valid component environments using assumptions, the need to check the component in all possible environments, which is often infeasible, is circumvented. Notably, temporal logic (LTL) is widely used for both specifying properties and expressing assumptions.