One example to consider is XML, which serves as a meta-model allowing for the expression of schemas tailored to specific roles. Both srcML and JavaML define XML-compliant schemas to represent the syntactic structure of code. However, srcML treats the source code as the foundation and adds markup to the code, whereas JavaML considers the model as the foundation and adds the code as attributes to the representation. This illustrates XML being used in different ways to achieve the same purpose, catering to different higher-level requirements. SrcML is designed to aid programmers working with the source code, while JavaML is designed to be easily manipulated by other XML tools.

GXL, an XML schema, is used to express graph-based software structures, showcasing little relation to srcML or JavaML. In this case, there is pressure from lower levels, driven by the desire to express unrelated concepts.

To address these challenges, the paper proposes supporting multiple schemas and representation models, emphasizing a multi-layered approach. Each layer is designed to minimize the constraints it imposes on higher layers and decouple higher layers from the constraints imposed by lower layers. The paper explores a three-layered implementation and its components in detail.

The storage layer is implemented using a database or repository system, and the storage model is database-specific. Modern databases are expected to handle large data sets without significant scalability issues.

It's also possible to consider the storage layer as providing an additional schema. However, directly storing information using the storage model interface is not desirable as it often lacks robust features for manipulating information. In response to this limitation, an algebraic query language specifically designed for manipulating source code has been developed.

While it's possible to store multiple XML schemas in the same database, there is a lack of documented research on the implications of normalization to remove redundancy and the efficiency of using a relational database to store source code when code is decomposed into grammatical units.

In the context of the Jupiter project, a multi-level markup approach is explored. Traditional markup is used for conceptual modeling, while a simplified second level of markup is tailored for the multitext structured text database system. The similarity of the conceptual and storage models allows for easy mapping of conceptual models to the storage model.

The paper suggests that extending the three-layered approach may involve splitting the conceptual layer into layers focused on specific concepts, potentially leading to a four-layered implementation.

While multi-layered approaches offer improved flexibility, they are more complex to implement and require further research. It is necessary to investigate how well a storage model, such as the relational model, will integrate multiple conceptual models, as well as develop techniques to map abstract graphical languages to database retrieval languages such as SQL.

There is a need to develop a consensus on the most appropriate storage models for representing conceptual models, as existing repository systems utilize various database systems.

The multi-layered approach unifies the work being done in the development of reverse engineering tools, recognizing that research on information extraction and representation is linked to the schema layer, while research on repository systems usually examines the storage layer. These aspects should not be viewed as separate entities but as integral components of a more comprehensive layered implementation approach.