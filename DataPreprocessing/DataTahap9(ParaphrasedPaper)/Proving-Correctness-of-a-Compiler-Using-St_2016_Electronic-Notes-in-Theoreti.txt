In this paper, we demonstrate the soundness of a compiler for a call-by-name language using step-indexed logical relations and biorthogonality. The source language is an extension of the simply typed lambda-calculus with recursion, and the target language is an extension of the Krivine abstract machine. We have formalized the proof in the Coq proof assistant.

Since the initial proofs of compiler correctness several years ago, significant progress has been made in this area. Notably, the CompCert project has developed a certified compiler for a substantial subset of the C programming language. In the realm of functional languages, the CertiCoq project has produced a certified compiler for the simply-typed lambda calculus, wherein the source language is a call-by-value functional language and the target is a variant of the SECD machine.

In our discussion, we utilize the notation f e t to specify both the set defined by the grammar and our naming convention for meta-variables ranging over it. The first three constructors correspond to the lambda calculus with de Bruijn indices. The language also encompasses a fixed-point operator, integer constants, strict arithmetic operators, pairs, and projections. The final constructor is a conditional projection. While we have chosen this form of conditional for convenience, a more familiar constructor of the form ifz t then t1 else t2 can be expressed as ifz t.(t1, t2). Furthermore, we write gn to represent any strict arithmetic operator with arity n > 0; operators are written in prefix position and cannot be partially applied.

Lemma 5.7 demonstrates our ability to make a nested induction when considering the case for rec t. If the source language were strongly normalizing (i.e., by setting aside the fixed-point operator), there would be no need to introduce the semantic chain, and correctness would directly relate the compiled code with the semantics of the term.

All the results presented in this paper have been rigorously formalized in the Coq proof assistant (version 8.4pl6 with ssreflect 1.5). This formalization is constructive, as we do not assume any classical axiom. We encourage interested readers to download and explore the formalization as it complements the content of this article.

As for our future work, we plan to enhance the source language by enriching the type system and adding new constructors. For instance, we previously demonstrated the correctness of a compiler for a higher-order imperative language with respect to the big-step operational semantics of the source language; it would be intriguing to obtain a relational proof of compiler correctness. Additionally, we intend to investigate the application of this technique to lazy functional languages targeting the Sestoft abstract machine or the STG machine. Moreover, we are interested in applying the method to other models of execution closer to real assembly code.
