We demonstrate how five refinement relations, drawn from the refinement literature, are specific examples of our general model. We refer to these instances as special models, as they are specializations of the general model. These theories of refinement are shown to be special models by fixing the sets of contexts and observations in appropriate ways.

In section 2 (and in a related paper), we define our general model without stipulating a particular operational semantics, allowing for a wide range of special models to emerge from our general model. Notable operational semantics that can be accommodated by our general approach include state-based relational semantics and event-based labeled transition semantics. Each of these particular incorporations can be further specialized. For instance, CSP interprets events in its labeled transition system semantics as handshake events, while CBS interprets the events in the same labeled transition system as broadcast events.

Due to the diverse variety of examples we seek to address, our general theory must be fairly abstract. Specifically, we aim to avoid fixing the operational semantics of its components at the general level. What we focus on in the general model is the nature of the interfaces between the components and the system.

Readers familiar with definitions of refinement may wonder why we need both contexts and users, as these roles are typically performed by a single system. The reason for introducing both contexts and users is that in certain situations, two interfaces with distinct properties are necessary. Further details will be presented in section 2.3.1.

It is important to note that when formalizing refinement, we should be cautious not to overlook or discard the contexts and observations that are involved, as the informal notion of refinement also encompasses the observations a user can make of the entities. To observe entities, users presumably use these entities within certain contexts, such as programs calling the operations provided by the entities.

An example of an interactive entity is a coffee machine. To obtain two cups of coffee, the user first inserts a coin, then presses the appropriate button, and obtains the first cup of coffee. However, if after inserting a second coin the vending machine fails to terminate, the previous successful interactions mean that what has been observed cannot be represented by noting non-termination alone (as the first cup of coffee has already been obtained).

This section delves into specific approaches to handling determinism in various contexts. It will become evident that determinism plays a crucial role in our later discussions on the refinement of processes. Given that moving towards more deterministic processes is a substantial aspect of process refinement, this emphasis on determinism is not surprising. Additionally, by establishing a general model that allows us to compare determinism from different viewpoints, we gain a comprehensive understanding of determinism.

In this work, we categorize processes, as found in the literature, into two types. Handshake processes, such as those in CSP, CCS, and ACP, treat all events in the same manner, whereas broadcast processes involve two types of events, with active output events causing passive input events. Broadcast output events differ from other observable events in that they are under local control and cannot be blocked by a context.

As we are no longer dealing with transactional interfaces, it is not necessary to distinguish between context and user. Furthermore, in the context of this work, there is no longer any fundamental difference between entities and contexts, as both are considered simply as processes.

We encounter a mismatch between our intuitions and the deterministic finite automaton (DFA) characterization, prompting us to turn to the deterministic (DET) characterization. While we cannot formalize DET as a definition due to entities and contexts being of the same type, the set of deterministic broadcast processes that we have defined can be verified to satisfy the DET-cond condition.

In the literature on handshake events, it is common to treat synchronous events in the same manner, without differentiating between events. However, our intuition suggests that the events of a vending machine are passive, while those of a robot are active and cause the passive events of the vending machine to occur. We view the active events as subsequent to the passive events, similar to how a program leads to the execution of a method of an ADT. Although similar to broadcast events, we do not have local control of the active events, and they can be blocked by a context.

The active events of an interactive program-user interface are modeled as committing, meaning that once started, the caller cannot retract the action but will be blocked if the passive event cannot be executed.

We can easily convert the relations above into state-to-state (partial) relations by simply removing the redundant pre-state from the observation. This operational semantics, utilized in ISO Z, is agnostic as to whether the operation terminates or not.