In the context of system modeling and simulation, performance typically improves as one moves towards more abstract models. In contrast, in software development, abstract models may suffer from an abstraction penalty, resulting in degraded performance as the level of abstraction increases. One of the objectives is to mitigate this abstraction penalty.

A comprehensive overview of pipelining, hardware implementation techniques, and taxonomies can be found in the works of [17, 15]. The compiler research community has developed high-level notations for pipelines to generate instruction schedulers [5, 20], which have served as an inspiration for the notation described in this paper. Other works [1, 13, 14] have also described notations for specifying pipelines for downstream tools. Mishra and Dutt have detailed how to validate a pipeline specification using the architectural description language. Additionally, Petri nets and process algebra [11, 12] have been utilized for modeling and simulating pipelines.

SystemC is a discrete event modeling and simulation language tailored for designing hardware/software systems [22, 19]. SystemC modules feature ports connected through channels, with predefined channels for hardware, such as wires (SC signal), and higher-level channels like blocking FIFOs. Users can also define their own channel types. A SystemC module is essentially a class that inherits SC module, and it can contain threads (SC thread) or methods that respond to event changes (SC method). SystemC also offers a vast library of hardware data types, including bit vectors and fixed-point types.

A pipeline expression delineates the path a transaction follows through a pipeline. In a static pipeline, this route remains fixed, whereas in a multi-function static pipeline, there may be different transaction types, each with their own distinct route. The paper also discusses the hard-coded performance model of a one nanosecond delay, proposing ways to make this model more general and to support untimed models without incurring a simulation performance penalty. Two timing policies, timedpolicy and untimedpolicy, are introduced to provide flexibility for modelers to design more sophisticated policies.

The research paper "Expression: A Language for Architecture Exploration through Compiler/Simulator Retargetability" by Ashok Halambi, Peter Grun, Vijay Ganesh, Asheesh Khare, Nikil Dutt, and Alex Nicolau (published in the proceedings of the European Conference on Design, Automation and Test, March 1999) explores these concepts in depth.