We have created a parallel implementation of coalgebraic logic programming (coalp) using the Go programming language. Initially, coalp was designed to represent the coalgebraic semantics of logic programming and featured a corecursive and parallel derivation algorithm. Here, we explore how the coalgebraic semantics influenced our parallel implementation of logic programming.

It has been observed that if a logic program can be modeled by a coalgebra of the endofunctor pf pf, then the SLD-derivations can be modeled by a comonad c(pf pf) on this coalgebra. Moreover, the main result established that if c(pf pf) is the cofree comonad on pf pf, then, given a ground (variable-free) logic program p, the induced c(pf pf)-coalgebra structure characterizes the parallel and-or derivation trees.

Initially, an empty list of references is present in the and-nodes. However, after the transformation pass, each and-node corresponding to a clause body atom is revisited, and its open list is populated with references to the unifiable clause-tree root nodes. This is a one-time process at the initialization stage and does not need to be repeated for different queries.

It is worth noting that implementing the above restricted (ground) logic programs can have practical value in itself. Logic programs containing variables but no function symbols of arity n>0 can all be soundly translated into finitely-presented ground logic programs. An example of such a language is datalog, which offers easier implementations and greater potential for parallelization. From a model theory perspective, datalog programs always have finite models.

Aside from the size, there is another reason hindering the speedup when increasing the number of expand threads for the uta programs. In principle, keeping every expansion thread busy by expanding a concrete part of a tree instead of directing it to work on different parts of the tree results in the best speedup. However, in unbalanced trees, it cannot be determined in advance if part of the tree is large enough to offset the setup costs of dedicating a new thread to it, rather than executing the work in the current thread. Consequently, when a new thread is dedicated to expand a part of a tree that is not sufficiently large, the expansion process is slowed down, and execution time increases.

We further extend our coalgebraic approach to the general first-order case. Unification and sld-resolution algorithms are p-complete in the general case. Practically, p-completeness of an algorithm implies that its parallel implementation would not yield effective speedup.

We have employed an optimization technique to minimize the work for constructing go-coinductive trees. When checking a referenced root node for term-matching, we also check whether it can be unified. If it is not unifiable, then term-matching is impossible, even if substitutions will be applied later when processing the tree. Thus, non-unifiable references to clause-tree roots can be immediately removed from the open lists. This process of filtering open lists and copying or-nodes and their child nodes during tree expansion can be done in parallel as no variable sub-organization of the work queue.

The work queue is sufficient to keep track of all trees that have derivation steps needing evaluation. This list of coinductive trees can be managed either as a first-in-first-out queue or alternatively as a last-in-first-out stack. This determines the search strategy employed to find success trees in the possible derivation chains: depth-first in the case of last-in-first-out stack (as in Prolog), and breadth-first in the case of first-in-first-out queue (as in coalp).

We have implemented buffering success trees in a priority queue. If it is determined that the work queue and all workers only hold derivation trees with the same or higher number of derivation steps, the solutions up to that number are returned from the solution queue. If the work queue is empty and all worker threads are idling, then all the solutions in the queue are returned, and the program exits. Note that the program may continue (co)recursively indefinitely.

A Prolog-like system with deterministic depth-search would produce solutions such as btree(empty), btree(tree(empty, 0, empty)), and btree(tree(empty, 0, tree(empty, 0, empty))), but not, for example, btree(tree(empty, 1, empty). Thus, it does not generate the same set of solutions even if run indefinitely and does not discover some of the solutions that coalp does for the binarytree program.