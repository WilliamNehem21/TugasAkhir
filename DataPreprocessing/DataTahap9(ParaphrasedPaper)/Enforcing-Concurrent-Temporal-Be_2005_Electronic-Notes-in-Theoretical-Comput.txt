The focus of our interest lies in inducing the verified or tested code to exhibit a specific suspicious behavior, which may result from a validation or testing process. Our goal is to reconstruct and analyze this behavior within the context of the tested or verified code. Due to the inherent nondeterminism associated with the concurrent execution of events, we cannot guarantee the recovery of the given execution without making some modifications to the verified software. Therefore, our emphasis is on minimizing the impact of the changes to the original code. We propose a straightforward and automated transformation that can be applied to the code to replicate the suspicious behavior. Our approach provides verification engineers or testers with a tool to check and demonstrate the presence of errors in the code. We impose the following constraints on the suggested software transformation:

In this context, both processes proceed to indicate their intent to enter their critical sections by setting c1 and c2 to 0 (lines 7 and 8) respectively. Since turn = 1 (checked in lines 11 and 12), process p1 takes precedence over process p2. Consequently, process p2 relinquishes its attempt by setting c2 to 1 (line 13), while process p1 perseveres, waiting for c2 to become 1 (checked in line 14) and then enters its critical section (line 15).

A (global) state of a program is a function that assigns values to the program variables, including the program counters. We assume that the program can be translated into a set of atomic actions. Each atomic action consists of a condition and a multiple assignment that alters the values of some program variables, including program counters. Some of the conditions are implicit in the program text, such as a check that a program counter has a particular value. Similarly, part of the multiple assignment is not included.

To perform the transformation, we prepare the code by translating it into a set of actions, while keeping track of the text location corresponding to the beginning and end of actions. In most cases, the transformation entails adding code at these locations, either before or after an action. For simplicity, we initially present the transformation under the unrealistic assumption that we can add code for the existing actions in a way that maintains the atomicity of the actions. Since this would result in rather large actions that cannot realistically be executed atomically, we split them in a detailed and explained manner.

An important point to note is that in order to avoid introducing unnecessary delays or deadlocks, we must ensure that the implementation of waitji does not block the process pi. Specifically, if vij is 0 and process pj is waiting for it to become 1, process pi needs to be able to progress, eventually allowing it to increment vij. Blocking of this nature could occur, for example, in a single-processor multitasking environment where waitji performs busy waiting for vij to become 1, causing the scheduler to be unfair to process pi. It is interesting to observe that

In the case of programs with shared variables, we only need to add code to activate the additional checks when enforcing a suspicious execution, i.e., when checki = true. Similarly, we include the last action in every process in the counting, in order to halt the execution. It's worth noting that with no shared variables and under handshake communication, the code added in the transformation is entirely local to the processes.