The expression x.oclIsKindOf(t) in the Loca language can be represented as x : t for class names t. Similarly, the expression x.oclInState(s), where s is a state of the state machine attached to the class and att is an attribute identifying the current state, can be expressed as x.att = s. The expression c.allInstances() can be represented simply as the name c.

In the context of this paper, a comparator operator op2 can take the form of =, /=, <, >, <=, >=, :, <:, /:, or /<:, while a logical operator op3 can be either & or or. A temporal operator can be ax (applicable to all next states), ex (applicable to some next state), af (applicable to some future state on all paths), ef (applicable to some future state in some path), ag (applicable to all future states on all paths), or eg (applicable to all future states on some path). Identifiers refer to class names, function names, class features (such as attributes, operations, or role names), elements of enumerated types, or represent variables or constants if in upper case. Variables are implicitly universally quantified over the entire formula. Operations can also be written with parameters as op(p1, ..., pn), etc.

Declarative constraints specify the invariant properties of the system in a manner independent of specific algorithms for maintaining them, thereby forming a Computation-Independent Model (CIM) in the context of Model-Driven Architecture (MDA). From such CIMs, a more explicit operational model can be systematically derived, as outlined in this section.

UML models can be methodically transformed to refine them into forms closer to implementation on specific platforms. For instance, transformations may involve the elimination of association classes (which are not expressible in mainstream object-oriented programming languages), or the elimination of many-many associations for refinement to a relational data model. These transformative processes can be seen as patterns.