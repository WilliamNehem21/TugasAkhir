This paper extends the study of concurrent refinement notions to the context of automata-based specification. The authors provide definitions and background in Section 2 and then introduce automata and IO automata, along with their refinement notions, in Section 3. They also derive the relational simulation rules for these notions and conclude in Section 4.

Traditionally, the standard refinement theory of Z has received the most attention. However, later publications by He and Hoare removed the restriction to total relations and proved the soundness and joint completeness of the same set of simulation rules in the more general case. De Roever and Engelhardt also present the theory of partial relations without emphasizing this aspect.

The paper demonstrates how different process algebraic preorders can be embedded into the relational model and how this embedding is achieved for the trace preorder, which defines refinement as trace inclusion. The authors then provide this type of characterization for each notion of automata refinement in the following section.

Based on these results, the paper extracts the simulation rules corresponding to this notion of refinement from the partial relation simulations, applied to this embedding without totalization in between. These rules correspond to standard Z refinement but omit the applicability of operations, as also used in event-B. The conditions for a downward simulation in the partial relational model are also outlined.

Automata offer an alternative perspective on refinement compared to those given by a process algebra or state-based context. Lynch and Vaandrager provide a comprehensive treatment of refinement for automata, defining several simulation definitions and results relating to them. The paper then describes the relationship between automata-based refinement and their relational characterization, addressing a raised question regarding their connection.

IO automata are a class of automata that explicitly distinguish between the input and output of a system, sharing characteristics with both standard automata and state-based languages such as Z and B. In this model, the set of actions is partitioned into input and output actions. The computational interpretation is that output actions are initiated by the system, while input actions are controlled by the environment. The system cannot refuse to perform its input actions, and its output actions cannot be blocked by the environment.