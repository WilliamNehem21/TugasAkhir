Spartacus solves the satisfiability problem for h(e,@), a basic hybrid logic incorporating global modalities. Our specification of h(e,@) is denoted notationally. We make a distinction between variables for states (x, y), properties (p, q), and relations (r). The expressions of h(e,@) can be derived from these variables based on the following grammar:

Each time we apply r to a formula sx, we must verify if pxs is expanded. Instead of computing this information from the branch, we use a specialized data structure, known as the pattern store, to record and query which patterns are expanded. The pattern store encompasses all patterns that are recognized to be expanded due to previous diamond rule applications. When r is applied to a formula sx, the pattern pxs is included in the pattern store. When checking if r is applicable to a formula sx, we must verify if the pattern store contains a superset of pxs. The efficiency of this operation, termed subset matching following, is essential for the performance of pbb.

The implementation of pbb in Spartacus draws inspiration from modal caching techniques, particularly the one outlined by Giunchiglia and Tacchella. The sets of expressions considered in pbb are essentially patterns, and the satisfiability cache of pbb provides the necessary storage and lookup operations. However, pbb differs from satisfiability caching in that it encompasses satisfiability caching, but the inverse is not true. In particular, the system of pbb does not terminate in the presence of transitivity or global modalities, and therefore requires supplementation with a blocking technique. To maintain completeness in the presence of blocking, satisfiability caching must be considerably refined.

Comparing lazy unfolding (lb) with pbb, lb is more versatile as it is applicable in a wider range of cases. However, in situations where both techniques are applicable, lazy unfolding is likely to be more effective, since it does not generate restricted disjunctions in the first place, rather than restricting the processing of delayed disjunctions.

The lb for propositional literals and boxes is implemented as an additional layer on top of the rule application queue. While conventional rule application heuristics influence the position of a pending rule application in the queue, lb prevents disjunctions from being added to the queue as long as they are delayed. This enables lb to operate independently of the traditional rule application strategy.

All provers are compiled and run using default settings. Unfortunately, we were unable to include the prover DLP in the comparison, which is reportedly one of the fastest provers for K, as DLP relies on an outdated version of the SML/NJ compiler that was not available for installation on our test machine. To gauge the performance of DLP, please refer to [28,7].